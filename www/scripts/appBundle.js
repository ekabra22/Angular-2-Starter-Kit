(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.0.2
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}),global.ng.core));
}(this, function (exports,_angular_core) { 'use strict';

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This class should not be used directly by an application developer. Instead, use
     * {@link Location}.
     *
     * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
     * agnostic.
     * This means that we can have different implementation of `PlatformLocation` for the different
     * platforms
     * that angular supports. For example, the default `PlatformLocation` is {@link
     * BrowserPlatformLocation},
     * however when you run your app in a WebWorker you use {@link WebWorkerPlatformLocation}.
     *
     * The `PlatformLocation` class is used directly by all implementations of {@link LocationStrategy}
     * when
     * they need to interact with the DOM apis like pushState, popState, etc...
     *
     * {@link LocationStrategy} in turn is used by the {@link Location} service which is used directly
     * by
     * the {@link Router} in order to navigate between routes. Since all interactions between {@link
     * Router} /
     * {@link Location} / {@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
     * class
     * they are all platform independent.
     *
     * @stable
     */
    var PlatformLocation = (function () {
        function PlatformLocation() {
        }
        Object.defineProperty(PlatformLocation.prototype, "pathname", {
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlatformLocation.prototype, "search", {
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlatformLocation.prototype, "hash", {
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        return PlatformLocation;
    }());

    /**
     * `LocationStrategy` is responsible for representing and reading route state
     * from the browser's URL. Angular provides two strategies:
     * {@link HashLocationStrategy} and {@link PathLocationStrategy} (default).
     *
     * This is used under the hood of the {@link Location} service.
     *
     * Applications should use the {@link Router} or {@link Location} services to
     * interact with application route state.
     *
     * For instance, {@link HashLocationStrategy} produces URLs like
     * `http://example.com#/foo`, and {@link PathLocationStrategy} produces
     * `http://example.com/foo` as an equivalent URL.
     *
     * See these two classes for more.
     *
     * @stable
     */
    var LocationStrategy = (function () {
        function LocationStrategy() {
        }
        return LocationStrategy;
    }());
    /**
     * The `APP_BASE_HREF` token represents the base href to be used with the
     * {@link PathLocationStrategy}.
     *
     * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
     * representing the URL prefix that should be preserved when generating and recognizing
     * URLs.
     *
     * ### Example
     *
     * ```typescript
     * import {Component, NgModule} from '@angular/core';
     * import {APP_BASE_HREF} from '@angular/common';
     *
     * @NgModule({
     *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]
     * })
     * class AppModule {}
     * ```
     *
     * @stable
     */
    var APP_BASE_HREF = new _angular_core.OpaqueToken('appBaseHref');

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = self;
        }
        else {
            globalScope = global;
        }
    }
    else {
        globalScope = window;
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var _global = globalScope;
    function getTypeNameForDebugging(type) {
        return type['name'] || typeof type;
    }
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    _global.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }
    function isStringMap(obj) {
        return typeof obj === 'object' && obj !== null;
    }
    function isArray(obj) {
        return Array.isArray(obj);
    }
    function isDate(obj) {
        return obj instanceof Date && !isNaN(obj.valueOf());
    }
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return token.overriddenName;
        }
        if (token.name) {
            return token.name;
        }
        var res = token.toString();
        var newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    var NumberWrapper = (function () {
        function NumberWrapper() {
        }
        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
        NumberWrapper.equal = function (a, b) { return a === b; };
        NumberWrapper.parseIntAutoRadix = function (text) {
            var result = parseInt(text);
            if (isNaN(result)) {
                throw new Error('Invalid integer literal when parsing ' + text);
            }
            return result;
        };
        NumberWrapper.parseInt = function (text, radix) {
            if (radix == 10) {
                if (/^(\-|\+)?[0-9]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else if (radix == 16) {
                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else {
                var result = parseInt(text, radix);
                if (!isNaN(result)) {
                    return result;
                }
            }
            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
        };
        Object.defineProperty(NumberWrapper, "NaN", {
            get: function () { return NaN; },
            enumerable: true,
            configurable: true
        });
        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
        NumberWrapper.isNaN = function (value) { return isNaN(value); };
        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
        return NumberWrapper;
    }());
    function isJsObject(o) {
        return o !== null && (typeof o === 'function' || typeof o === 'object');
    }
    // Can't be all uppercase as our transpiler would think it is a special directive...
    var Json = (function () {
        function Json() {
        }
        Json.parse = function (s) { return _global.JSON.parse(s); };
        Json.stringify = function (data) {
            // Dart doesn't take 3 arguments
            return _global.JSON.stringify(data, null, 2);
        };
        return Json;
    }());
    var _symbolIterator = null;
    function getSymbolIterator() {
        if (isBlank(_symbolIterator)) {
            if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
                _symbolIterator = Symbol.iterator;
            }
            else {
                // es6-shim specific logic
                var keys = Object.getOwnPropertyNames(Map.prototype);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (key !== 'entries' && key !== 'size' &&
                        Map.prototype[key] === Map.prototype['entries']) {
                        _symbolIterator = key;
                    }
                }
            }
        }
        return _symbolIterator;
    }

    /**
     * `Location` is a service that applications can use to interact with a browser's URL.
     * Depending on which {@link LocationStrategy} is used, `Location` will either persist
     * to the URL's path or the URL's hash segment.
     *
     * Note: it's better to use {@link Router#navigate} service to trigger route changes. Use
     * `Location` only if you need to interact with or create normalized URLs outside of
     * routing.
     *
     * `Location` is responsible for normalizing the URL against the application's base href.
     * A normalized URL is absolute from the URL host, includes the application's base href, and has no
     * trailing slash:
     * - `/my/app/user/123` is normalized
     * - `my/app/user/123` **is not** normalized
     * - `/my/app/user/123/` **is not** normalized
     *
     * ### Example
     *
     * ```
     * import {Component} from '@angular/core';
     * import {Location} from '@angular/common';
     *
     * @Component({selector: 'app-component'})
     * class AppCmp {
     *   constructor(location: Location) {
     *     location.go('/foo');
     *   }
     * }
     * ```
     *
     * @stable
     */
    var Location = (function () {
        function Location(platformStrategy) {
            var _this = this;
            /** @internal */
            this._subject = new _angular_core.EventEmitter();
            this._platformStrategy = platformStrategy;
            var browserBaseHref = this._platformStrategy.getBaseHref();
            this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
            this._platformStrategy.onPopState(function (ev) {
                _this._subject.emit({
                    'url': _this.path(true),
                    'pop': true,
                    'type': ev.type,
                });
            });
        }
        /**
         * Returns the normalized URL path.
         */
        // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is
        // removed.
        Location.prototype.path = function (includeHash) {
            if (includeHash === void 0) { includeHash = false; }
            return this.normalize(this._platformStrategy.path(includeHash));
        };
        /**
         * Normalizes the given path and compares to the current normalized path.
         */
        Location.prototype.isCurrentPathEqualTo = function (path, query) {
            if (query === void 0) { query = ''; }
            return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
        };
        /**
         * Given a string representing a URL, returns the normalized URL path without leading or
         * trailing slashes.
         */
        Location.prototype.normalize = function (url) {
            return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
        };
        /**
         * Given a string representing a URL, returns the platform-specific external URL path.
         * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
         * before normalizing. This method will also add a hash if `HashLocationStrategy` is
         * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
         */
        Location.prototype.prepareExternalUrl = function (url) {
            if (url.length > 0 && !url.startsWith('/')) {
                url = '/' + url;
            }
            return this._platformStrategy.prepareExternalUrl(url);
        };
        // TODO: rename this method to pushState
        /**
         * Changes the browsers URL to the normalized version of the given URL, and pushes a
         * new item onto the platform's history.
         */
        Location.prototype.go = function (path, query) {
            if (query === void 0) { query = ''; }
            this._platformStrategy.pushState(null, '', path, query);
        };
        /**
         * Changes the browsers URL to the normalized version of the given URL, and replaces
         * the top item on the platform's history stack.
         */
        Location.prototype.replaceState = function (path, query) {
            if (query === void 0) { query = ''; }
            this._platformStrategy.replaceState(null, '', path, query);
        };
        /**
         * Navigates forward in the platform's history.
         */
        Location.prototype.forward = function () { this._platformStrategy.forward(); };
        /**
         * Navigates back in the platform's history.
         */
        Location.prototype.back = function () { this._platformStrategy.back(); };
        /**
         * Subscribe to the platform's `popState` events.
         */
        Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
            if (onThrow === void 0) { onThrow = null; }
            if (onReturn === void 0) { onReturn = null; }
            return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
        };
        /**
         * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
         * is.
         */
        Location.normalizeQueryParams = function (params) {
            return (params.length > 0 && params.substring(0, 1) != '?') ? ('?' + params) : params;
        };
        /**
         * Given 2 parts of a url, join them with a slash if needed.
         */
        Location.joinWithSlash = function (start, end) {
            if (start.length == 0) {
                return end;
            }
            if (end.length == 0) {
                return start;
            }
            var slashes = 0;
            if (start.endsWith('/')) {
                slashes++;
            }
            if (end.startsWith('/')) {
                slashes++;
            }
            if (slashes == 2) {
                return start + end.substring(1);
            }
            if (slashes == 1) {
                return start + end;
            }
            return start + '/' + end;
        };
        /**
         * If url has a trailing slash, remove it, otherwise return url as is.
         */
        Location.stripTrailingSlash = function (url) {
            if (/\/$/g.test(url)) {
                url = url.substring(0, url.length - 1);
            }
            return url;
        };
        Location.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        Location.ctorParameters = [
            { type: LocationStrategy, },
        ];
        return Location;
    }());
    function _stripBaseHref(baseHref, url) {
        if (baseHref.length > 0 && url.startsWith(baseHref)) {
            return url.substring(baseHref.length);
        }
        return url;
    }
    function _stripIndexHtml(url) {
        if (/\/index.html$/g.test(url)) {
            // '/index.html'.length == 11
            return url.substring(0, url.length - 11);
        }
        return url;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * `HashLocationStrategy` is a {@link LocationStrategy} used to configure the
     * {@link Location} service to represent its state in the
     * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
     * of the browser's URL.
     *
     * For instance, if you call `location.go('/foo')`, the browser's URL will become
     * `example.com#/foo`.
     *
     * ### Example
     *
     * ```
     * import {Component, NgModule} from '@angular/core';
     * import {
     *   LocationStrategy,
     *   HashLocationStrategy
     * } from '@angular/common';
     *
     * @NgModule({
     *   providers: [{provide: LocationStrategy, useClass: HashLocationStrategy}]
     * })
     * class AppModule {}
     * ```
     *
     * @stable
     */
    var HashLocationStrategy = (function (_super) {
        __extends(HashLocationStrategy, _super);
        function HashLocationStrategy(_platformLocation, _baseHref) {
            _super.call(this);
            this._platformLocation = _platformLocation;
            this._baseHref = '';
            if (isPresent(_baseHref)) {
                this._baseHref = _baseHref;
            }
        }
        HashLocationStrategy.prototype.onPopState = function (fn) {
            this._platformLocation.onPopState(fn);
            this._platformLocation.onHashChange(fn);
        };
        HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
        HashLocationStrategy.prototype.path = function (includeHash) {
            if (includeHash === void 0) { includeHash = false; }
            // the hash value is always prefixed with a `#`
            // and if it is empty then it will stay empty
            var path = this._platformLocation.hash;
            if (!isPresent(path))
                path = '#';
            return path.length > 0 ? path.substring(1) : path;
        };
        HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {
            var url = Location.joinWithSlash(this._baseHref, internal);
            return url.length > 0 ? ('#' + url) : url;
        };
        HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
            if (url.length == 0) {
                url = this._platformLocation.pathname;
            }
            this._platformLocation.pushState(state, title, url);
        };
        HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {
            var url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
            if (url.length == 0) {
                url = this._platformLocation.pathname;
            }
            this._platformLocation.replaceState(state, title, url);
        };
        HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
        HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
        HashLocationStrategy.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        HashLocationStrategy.ctorParameters = [
            { type: PlatformLocation, },
            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
        ];
        return HashLocationStrategy;
    }(LocationStrategy));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * `PathLocationStrategy` is a {@link LocationStrategy} used to configure the
     * {@link Location} service to represent its state in the
     * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
     * browser's URL.
     *
     * `PathLocationStrategy` is the default binding for {@link LocationStrategy}
     * provided in {@link ROUTER_PROVIDERS}.
     *
     * If you're using `PathLocationStrategy`, you must provide a {@link APP_BASE_HREF}
     * or add a base element to the document. This URL prefix that will be preserved
     * when generating and recognizing URLs.
     *
     * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
     * `location.go('/foo')`, the browser's URL will become
     * `example.com/my/app/foo`.
     *
     * Similarly, if you add `<base href='/my/app'/>` to the document and call
     * `location.go('/foo')`, the browser's URL will become
     * `example.com/my/app/foo`.
     *
     * @stable
     */
    var PathLocationStrategy = (function (_super) {
        __extends$1(PathLocationStrategy, _super);
        function PathLocationStrategy(_platformLocation, href) {
            _super.call(this);
            this._platformLocation = _platformLocation;
            if (isBlank(href)) {
                href = this._platformLocation.getBaseHrefFromDOM();
            }
            if (isBlank(href)) {
                throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
            }
            this._baseHref = href;
        }
        PathLocationStrategy.prototype.onPopState = function (fn) {
            this._platformLocation.onPopState(fn);
            this._platformLocation.onHashChange(fn);
        };
        PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
        PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {
            return Location.joinWithSlash(this._baseHref, internal);
        };
        PathLocationStrategy.prototype.path = function (includeHash) {
            if (includeHash === void 0) { includeHash = false; }
            var pathname = this._platformLocation.pathname +
                Location.normalizeQueryParams(this._platformLocation.search);
            var hash = this._platformLocation.hash;
            return hash && includeHash ? "" + pathname + hash : pathname;
        };
        PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
            this._platformLocation.pushState(state, title, externalUrl);
        };
        PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
            var externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
            this._platformLocation.replaceState(state, title, externalUrl);
        };
        PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
        PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
        PathLocationStrategy.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        PathLocationStrategy.ctorParameters = [
            { type: PlatformLocation, },
            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
        ];
        return PathLocationStrategy;
    }(LocationStrategy));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$2 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @experimental
     */
    var NgLocalization = (function () {
        function NgLocalization() {
        }
        return NgLocalization;
    }());
    /**
     * Returns the plural category for a given value.
     * - "=value" when the case exists,
     * - the plural category otherwise
     *
     * @internal
     */
    function getPluralCategory(value, cases, ngLocalization) {
        var nbCase = "=" + value;
        return cases.indexOf(nbCase) > -1 ? nbCase : ngLocalization.getPluralCategory(value);
    }
    /**
     * Returns the plural case based on the locale
     *
     * @experimental
     */
    var NgLocaleLocalization = (function (_super) {
        __extends$2(NgLocaleLocalization, _super);
        function NgLocaleLocalization(_locale) {
            _super.call(this);
            this._locale = _locale;
        }
        NgLocaleLocalization.prototype.getPluralCategory = function (value) {
            var plural = getPluralCase(this._locale, value);
            switch (plural) {
                case Plural.Zero:
                    return 'zero';
                case Plural.One:
                    return 'one';
                case Plural.Two:
                    return 'two';
                case Plural.Few:
                    return 'few';
                case Plural.Many:
                    return 'many';
                default:
                    return 'other';
            }
        };
        NgLocaleLocalization.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        NgLocaleLocalization.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return NgLocaleLocalization;
    }(NgLocalization));
    // This is generated code DO NOT MODIFY
    // see angular2/script/cldr/gen_plural_rules.js
    /** @experimental */
    var Plural;
    (function (Plural) {
        Plural[Plural["Zero"] = 0] = "Zero";
        Plural[Plural["One"] = 1] = "One";
        Plural[Plural["Two"] = 2] = "Two";
        Plural[Plural["Few"] = 3] = "Few";
        Plural[Plural["Many"] = 4] = "Many";
        Plural[Plural["Other"] = 5] = "Other";
    })(Plural || (Plural = {}));
    /**
     * Returns the plural case based on the locale
     *
     * @experimental
     */
    function getPluralCase(locale, nLike) {
        // TODO(vicb): lazy compute
        if (typeof nLike === 'string') {
            nLike = parseInt(nLike, 10);
        }
        var n = nLike;
        var nDecimal = n.toString().replace(/^[^.]*\.?/, '');
        var i = Math.floor(Math.abs(n));
        var v = nDecimal.length;
        var f = parseInt(nDecimal, 10);
        var t = parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
        var lang = locale.split('-')[0].toLowerCase();
        switch (lang) {
            case 'af':
            case 'asa':
            case 'az':
            case 'bem':
            case 'bez':
            case 'bg':
            case 'brx':
            case 'ce':
            case 'cgg':
            case 'chr':
            case 'ckb':
            case 'ee':
            case 'el':
            case 'eo':
            case 'es':
            case 'eu':
            case 'fo':
            case 'fur':
            case 'gsw':
            case 'ha':
            case 'haw':
            case 'hu':
            case 'jgo':
            case 'jmc':
            case 'ka':
            case 'kk':
            case 'kkj':
            case 'kl':
            case 'ks':
            case 'ksb':
            case 'ky':
            case 'lb':
            case 'lg':
            case 'mas':
            case 'mgo':
            case 'ml':
            case 'mn':
            case 'nb':
            case 'nd':
            case 'ne':
            case 'nn':
            case 'nnh':
            case 'nyn':
            case 'om':
            case 'or':
            case 'os':
            case 'ps':
            case 'rm':
            case 'rof':
            case 'rwk':
            case 'saq':
            case 'seh':
            case 'sn':
            case 'so':
            case 'sq':
            case 'ta':
            case 'te':
            case 'teo':
            case 'tk':
            case 'tr':
            case 'ug':
            case 'uz':
            case 'vo':
            case 'vun':
            case 'wae':
            case 'xog':
                if (n === 1)
                    return Plural.One;
                return Plural.Other;
            case 'agq':
            case 'bas':
            case 'cu':
            case 'dav':
            case 'dje':
            case 'dua':
            case 'dyo':
            case 'ebu':
            case 'ewo':
            case 'guz':
            case 'kam':
            case 'khq':
            case 'ki':
            case 'kln':
            case 'kok':
            case 'ksf':
            case 'lrc':
            case 'lu':
            case 'luo':
            case 'luy':
            case 'mer':
            case 'mfe':
            case 'mgh':
            case 'mua':
            case 'mzn':
            case 'nmg':
            case 'nus':
            case 'qu':
            case 'rn':
            case 'rw':
            case 'sbp':
            case 'twq':
            case 'vai':
            case 'yav':
            case 'yue':
            case 'zgh':
            case 'ak':
            case 'ln':
            case 'mg':
            case 'pa':
            case 'ti':
                if (n === Math.floor(n) && n >= 0 && n <= 1)
                    return Plural.One;
                return Plural.Other;
            case 'am':
            case 'as':
            case 'bn':
            case 'fa':
            case 'gu':
            case 'hi':
            case 'kn':
            case 'mr':
            case 'zu':
                if (i === 0 || n === 1)
                    return Plural.One;
                return Plural.Other;
            case 'ar':
                if (n === 0)
                    return Plural.Zero;
                if (n === 1)
                    return Plural.One;
                if (n === 2)
                    return Plural.Two;
                if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)
                    return Plural.Few;
                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)
                    return Plural.Many;
                return Plural.Other;
            case 'ast':
            case 'ca':
            case 'de':
            case 'en':
            case 'et':
            case 'fi':
            case 'fy':
            case 'gl':
            case 'it':
            case 'nl':
            case 'sv':
            case 'sw':
            case 'ur':
            case 'yi':
                if (i === 1 && v === 0)
                    return Plural.One;
                return Plural.Other;
            case 'be':
                if (n % 10 === 1 && !(n % 100 === 11))
                    return Plural.One;
                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&
                    !(n % 100 >= 12 && n % 100 <= 14))
                    return Plural.Few;
                if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||
                    n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)
                    return Plural.Many;
                return Plural.Other;
            case 'br':
                if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))
                    return Plural.One;
                if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))
                    return Plural.Two;
                if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&
                    !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||
                        n % 100 >= 90 && n % 100 <= 99))
                    return Plural.Few;
                if (!(n === 0) && n % 1e6 === 0)
                    return Plural.Many;
                return Plural.Other;
            case 'bs':
            case 'hr':
            case 'sr':
                if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))
                    return Plural.One;
                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
                    !(i % 100 >= 12 && i % 100 <= 14) ||
                    f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&
                        !(f % 100 >= 12 && f % 100 <= 14))
                    return Plural.Few;
                return Plural.Other;
            case 'cs':
            case 'sk':
                if (i === 1 && v === 0)
                    return Plural.One;
                if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)
                    return Plural.Few;
                if (!(v === 0))
                    return Plural.Many;
                return Plural.Other;
            case 'cy':
                if (n === 0)
                    return Plural.Zero;
                if (n === 1)
                    return Plural.One;
                if (n === 2)
                    return Plural.Two;
                if (n === 3)
                    return Plural.Few;
                if (n === 6)
                    return Plural.Many;
                return Plural.Other;
            case 'da':
                if (n === 1 || !(t === 0) && (i === 0 || i === 1))
                    return Plural.One;
                return Plural.Other;
            case 'dsb':
            case 'hsb':
                if (v === 0 && i % 100 === 1 || f % 100 === 1)
                    return Plural.One;
                if (v === 0 && i % 100 === 2 || f % 100 === 2)
                    return Plural.Two;
                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||
                    f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)
                    return Plural.Few;
                return Plural.Other;
            case 'ff':
            case 'fr':
            case 'hy':
            case 'kab':
                if (i === 0 || i === 1)
                    return Plural.One;
                return Plural.Other;
            case 'fil':
                if (v === 0 && (i === 1 || i === 2 || i === 3) ||
                    v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||
                    !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))
                    return Plural.One;
                return Plural.Other;
            case 'ga':
                if (n === 1)
                    return Plural.One;
                if (n === 2)
                    return Plural.Two;
                if (n === Math.floor(n) && n >= 3 && n <= 6)
                    return Plural.Few;
                if (n === Math.floor(n) && n >= 7 && n <= 10)
                    return Plural.Many;
                return Plural.Other;
            case 'gd':
                if (n === 1 || n === 11)
                    return Plural.One;
                if (n === 2 || n === 12)
                    return Plural.Two;
                if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))
                    return Plural.Few;
                return Plural.Other;
            case 'gv':
                if (v === 0 && i % 10 === 1)
                    return Plural.One;
                if (v === 0 && i % 10 === 2)
                    return Plural.Two;
                if (v === 0 &&
                    (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))
                    return Plural.Few;
                if (!(v === 0))
                    return Plural.Many;
                return Plural.Other;
            case 'he':
                if (i === 1 && v === 0)
                    return Plural.One;
                if (i === 2 && v === 0)
                    return Plural.Two;
                if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)
                    return Plural.Many;
                return Plural.Other;
            case 'is':
                if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))
                    return Plural.One;
                return Plural.Other;
            case 'ksh':
                if (n === 0)
                    return Plural.Zero;
                if (n === 1)
                    return Plural.One;
                return Plural.Other;
            case 'kw':
            case 'naq':
            case 'se':
            case 'smn':
                if (n === 1)
                    return Plural.One;
                if (n === 2)
                    return Plural.Two;
                return Plural.Other;
            case 'lag':
                if (n === 0)
                    return Plural.Zero;
                if ((i === 0 || i === 1) && !(n === 0))
                    return Plural.One;
                return Plural.Other;
            case 'lt':
                if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))
                    return Plural.One;
                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&
                    !(n % 100 >= 11 && n % 100 <= 19))
                    return Plural.Few;
                if (!(f === 0))
                    return Plural.Many;
                return Plural.Other;
            case 'lv':
            case 'prg':
                if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||
                    v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)
                    return Plural.Zero;
                if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||
                    !(v === 2) && f % 10 === 1)
                    return Plural.One;
                return Plural.Other;
            case 'mk':
                if (v === 0 && i % 10 === 1 || f % 10 === 1)
                    return Plural.One;
                return Plural.Other;
            case 'mt':
                if (n === 1)
                    return Plural.One;
                if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)
                    return Plural.Few;
                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)
                    return Plural.Many;
                return Plural.Other;
            case 'pl':
                if (i === 1 && v === 0)
                    return Plural.One;
                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
                    !(i % 100 >= 12 && i % 100 <= 14))
                    return Plural.Few;
                if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||
                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)
                    return Plural.Many;
                return Plural.Other;
            case 'pt':
                if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))
                    return Plural.One;
                return Plural.Other;
            case 'ro':
                if (i === 1 && v === 0)
                    return Plural.One;
                if (!(v === 0) || n === 0 ||
                    !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)
                    return Plural.Few;
                return Plural.Other;
            case 'ru':
            case 'uk':
                if (v === 0 && i % 10 === 1 && !(i % 100 === 11))
                    return Plural.One;
                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
                    !(i % 100 >= 12 && i % 100 <= 14))
                    return Plural.Few;
                if (v === 0 && i % 10 === 0 ||
                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)
                    return Plural.Many;
                return Plural.Other;
            case 'shi':
                if (i === 0 || n === 1)
                    return Plural.One;
                if (n === Math.floor(n) && n >= 2 && n <= 10)
                    return Plural.Few;
                return Plural.Other;
            case 'si':
                if (n === 0 || n === 1 || i === 0 && f === 1)
                    return Plural.One;
                return Plural.Other;
            case 'sl':
                if (v === 0 && i % 100 === 1)
                    return Plural.One;
                if (v === 0 && i % 100 === 2)
                    return Plural.Two;
                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))
                    return Plural.Few;
                return Plural.Other;
            case 'tzm':
                if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)
                    return Plural.One;
                return Plural.Other;
            default:
                return Plural.Other;
        }
    }

    var _clearValues = (function () {
        if ((new Map()).keys().next) {
            return function _clearValues(m) {
                var keyIterator = m.keys();
                var k;
                while (!((k = keyIterator.next()).done)) {
                    m.set(k.value, null);
                }
            };
        }
        else {
            return function _clearValuesWithForeEach(m) {
                m.forEach(function (v, k) { m.set(k, null); });
            };
        }
    })();
    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
    var _arrayFromMap = (function () {
        try {
            if ((new Map()).values().next) {
                return function createArrayFromMap(m, getValues) {
                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
                };
            }
        }
        catch (e) {
        }
        return function createArrayFromMapWithForeach(m, getValues) {
            var res = new Array(m.size), i = 0;
            m.forEach(function (v, k) {
                res[i] = getValues ? v : k;
                i++;
            });
            return res;
        };
    })();
    var ListWrapper = (function () {
        function ListWrapper() {
        }
        // JS has no way to express a statically fixed size list, but dart does so we
        // keep both methods.
        ListWrapper.createFixedSize = function (size) { return new Array(size); };
        ListWrapper.createGrowableSize = function (size) { return new Array(size); };
        ListWrapper.clone = function (array) { return array.slice(0); };
        ListWrapper.forEachWithIndex = function (array, fn) {
            for (var i = 0; i < array.length; i++) {
                fn(array[i], i);
            }
        };
        ListWrapper.first = function (array) {
            if (!array)
                return null;
            return array[0];
        };
        ListWrapper.last = function (array) {
            if (!array || array.length == 0)
                return null;
            return array[array.length - 1];
        };
        ListWrapper.indexOf = function (array, value, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            return array.indexOf(value, startIndex);
        };
        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
        ListWrapper.reversed = function (array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
        };
        ListWrapper.concat = function (a, b) { return a.concat(b); };
        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
        ListWrapper.removeAt = function (list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
        };
        ListWrapper.removeAll = function (list, items) {
            for (var i = 0; i < items.length; ++i) {
                var index = list.indexOf(items[i]);
                list.splice(index, 1);
            }
        };
        ListWrapper.remove = function (list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
                return true;
            }
            return false;
        };
        ListWrapper.clear = function (list) { list.length = 0; };
        ListWrapper.isEmpty = function (list) { return list.length == 0; };
        ListWrapper.fill = function (list, value, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = null; }
            list.fill(value, start, end === null ? list.length : end);
        };
        ListWrapper.equals = function (a, b) {
            if (a.length != b.length)
                return false;
            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        };
        ListWrapper.slice = function (l, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return l.slice(from, to === null ? undefined : to);
        };
        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
        ListWrapper.sort = function (l, compareFn) {
            if (isPresent(compareFn)) {
                l.sort(compareFn);
            }
            else {
                l.sort();
            }
        };
        ListWrapper.toString = function (l) { return l.toString(); };
        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
        ListWrapper.maximum = function (list, predicate) {
            if (list.length == 0) {
                return null;
            }
            var solution = null;
            var maxValue = -Infinity;
            for (var index = 0; index < list.length; index++) {
                var candidate = list[index];
                if (isBlank(candidate)) {
                    continue;
                }
                var candidateValue = predicate(candidate);
                if (candidateValue > maxValue) {
                    solution = candidate;
                    maxValue = candidateValue;
                }
            }
            return solution;
        };
        ListWrapper.flatten = function (list) {
            var target = [];
            _flattenArray(list, target);
            return target;
        };
        ListWrapper.addAll = function (list, source) {
            for (var i = 0; i < source.length; i++) {
                list.push(source[i]);
            }
        };
        return ListWrapper;
    }());
    function _flattenArray(source, target) {
        if (isPresent(source)) {
            for (var i = 0; i < source.length; i++) {
                var item = source[i];
                if (isArray(item)) {
                    _flattenArray(item, target);
                }
                else {
                    target.push(item);
                }
            }
        }
        return target;
    }
    function isListLikeIterable(obj) {
        if (!isJsObject(obj))
            return false;
        return isArray(obj) ||
            (!(obj instanceof Map) &&
                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
    }

    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Adds and removes CSS classes on an HTML element.
     *
     * @howToUse
     * ```
     *     <some-element [ngClass]="'first second'">...</some-element>
     *
     *     <some-element [ngClass]="['first', 'second']">...</some-element>
     *
     *     <some-element [ngClass]="{'first': true, 'second': true, 'third': false}">...</some-element>
     *
     *     <some-element [ngClass]="stringExp|arrayExp|objExp">...</some-element>
     * ```
     *
     * @description
     *
     * The CSS classes are updated as follow depending on the type of the expression evaluation:
     * - `string` - the CSS classes listed in a string (space delimited) are added,
     * - `Array` - the CSS classes (Array elements) are added,
     * - `Object` - keys are CSS class names that get added when the expression given in the value
     *              evaluates to a truthy value, otherwise class are removed.
     *
     * @stable
     */
    var NgClass = (function () {
        function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
            this._iterableDiffers = _iterableDiffers;
            this._keyValueDiffers = _keyValueDiffers;
            this._ngEl = _ngEl;
            this._renderer = _renderer;
            this._initialClasses = [];
        }
        Object.defineProperty(NgClass.prototype, "klass", {
            set: function (v) {
                this._applyInitialClasses(true);
                this._initialClasses = typeof v === 'string' ? v.split(/\s+/) : [];
                this._applyInitialClasses(false);
                this._applyClasses(this._rawClass, false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgClass.prototype, "ngClass", {
            set: function (v) {
                this._cleanupClasses(this._rawClass);
                this._iterableDiffer = null;
                this._keyValueDiffer = null;
                this._rawClass = typeof v === 'string' ? v.split(/\s+/) : v;
                if (this._rawClass) {
                    if (isListLikeIterable(this._rawClass)) {
                        this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create(null);
                    }
                    else {
                        this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create(null);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        NgClass.prototype.ngDoCheck = function () {
            if (this._iterableDiffer) {
                var changes = this._iterableDiffer.diff(this._rawClass);
                if (changes) {
                    this._applyIterableChanges(changes);
                }
            }
            else if (this._keyValueDiffer) {
                var changes = this._keyValueDiffer.diff(this._rawClass);
                if (changes) {
                    this._applyKeyValueChanges(changes);
                }
            }
        };
        NgClass.prototype._cleanupClasses = function (rawClassVal) {
            this._applyClasses(rawClassVal, true);
            this._applyInitialClasses(false);
        };
        NgClass.prototype._applyKeyValueChanges = function (changes) {
            var _this = this;
            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
            changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
            changes.forEachRemovedItem(function (record) {
                if (record.previousValue) {
                    _this._toggleClass(record.key, false);
                }
            });
        };
        NgClass.prototype._applyIterableChanges = function (changes) {
            var _this = this;
            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.item, true); });
            changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });
        };
        NgClass.prototype._applyInitialClasses = function (isCleanup) {
            var _this = this;
            this._initialClasses.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
        };
        NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
            var _this = this;
            if (rawClassVal) {
                if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                    rawClassVal.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
                }
                else {
                    Object.keys(rawClassVal).forEach(function (klass) {
                        if (isPresent(rawClassVal[klass]))
                            _this._toggleClass(klass, !isCleanup);
                    });
                }
            }
        };
        NgClass.prototype._toggleClass = function (klass, enabled) {
            var _this = this;
            klass = klass.trim();
            if (klass) {
                klass.split(/\s+/g).forEach(function (klass) { _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, enabled); });
            }
        };
        NgClass.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngClass]' },] },
        ];
        /** @nocollapse */
        NgClass.ctorParameters = [
            { type: _angular_core.IterableDiffers, },
            { type: _angular_core.KeyValueDiffers, },
            { type: _angular_core.ElementRef, },
            { type: _angular_core.Renderer, },
        ];
        NgClass.propDecorators = {
            'klass': [{ type: _angular_core.Input, args: ['class',] },],
            'ngClass': [{ type: _angular_core.Input },],
        };
        return NgClass;
    }());

    var NgForRow = (function () {
        function NgForRow($implicit, index, count) {
            this.$implicit = $implicit;
            this.index = index;
            this.count = count;
        }
        Object.defineProperty(NgForRow.prototype, "first", {
            get: function () { return this.index === 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForRow.prototype, "last", {
            get: function () { return this.index === this.count - 1; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForRow.prototype, "even", {
            get: function () { return this.index % 2 === 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgForRow.prototype, "odd", {
            get: function () { return !this.even; },
            enumerable: true,
            configurable: true
        });
        return NgForRow;
    }());
    /**
     * The `NgFor` directive instantiates a template once per item from an iterable. The context for
     * each instantiated template inherits from the outer context with the given loop variable set
     * to the current item from the iterable.
     *
     * ### Local Variables
     *
     * `NgFor` provides several exported values that can be aliased to local variables:
     *
     * * `index` will be set to the current loop iteration for each template context.
     * * `first` will be set to a boolean value indicating whether the item is the first one in the
     *   iteration.
     * * `last` will be set to a boolean value indicating whether the item is the last one in the
     *   iteration.
     * * `even` will be set to a boolean value indicating whether this item has an even index.
     * * `odd` will be set to a boolean value indicating whether this item has an odd index.
     *
     * ### Change Propagation
     *
     * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
     *
     * * When an item is added, a new instance of the template is added to the DOM.
     * * When an item is removed, its template instance is removed from the DOM.
     * * When items are reordered, their respective templates are reordered in the DOM.
     * * Otherwise, the DOM element for that item will remain the same.
     *
     * Angular uses object identity to track insertions and deletions within the iterator and reproduce
     * those changes in the DOM. This has important implications for animations and any stateful
     * controls
     * (such as `<input>` elements which accept user input) that are present. Inserted rows can be
     * animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such
     * as user input.
     *
     * It is possible for the identities of elements in the iterator to change while the data does not.
     * This can happen, for example, if the iterator produced from an RPC to the server, and that
     * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with
     * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old
     * elements were deleted and all new elements inserted). This is an expensive operation and should
     * be avoided if possible.
     *
     * To customize the default tracking algorithm, `NgFor` supports `trackBy` option.
     * `trackBy` takes a function which has two arguments: `index` and `item`.
     * If `trackBy` is given, Angular tracks changes by the return value of the function.
     *
     * ### Syntax
     *
     * - `<li *ngFor="let item of items; let i = index; trackBy: trackByFn">...</li>`
     * - `<li template="ngFor let item of items; let i = index; trackBy: trackByFn">...</li>`
     *
     * With `<template>` element:
     *
     * ```
     * <template ngFor let-item [ngForOf]="items" let-i="index" [ngForTrackBy]="trackByFn">
     *   <li>...</li>
     * </template>
     * ```
     *
     * ### Example
     *
     * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed
     * example.
     *
     * @stable
     */
    var NgFor = (function () {
        function NgFor(_viewContainer, _template, _differs, _cdr) {
            this._viewContainer = _viewContainer;
            this._template = _template;
            this._differs = _differs;
            this._cdr = _cdr;
            this._differ = null;
        }
        Object.defineProperty(NgFor.prototype, "ngForTemplate", {
            set: function (value) {
                if (value) {
                    this._template = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        NgFor.prototype.ngOnChanges = function (changes) {
            if ('ngForOf' in changes) {
                // React on ngForOf changes only once all inputs have been initialized
                var value = changes['ngForOf'].currentValue;
                if (!this._differ && value) {
                    try {
                        this._differ = this._differs.find(value).create(this._cdr, this.ngForTrackBy);
                    }
                    catch (e) {
                        throw new Error("Cannot find a differ supporting object '" + value + "' of type '" + getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
                    }
                }
            }
        };
        NgFor.prototype.ngDoCheck = function () {
            if (this._differ) {
                var changes = this._differ.diff(this.ngForOf);
                if (changes)
                    this._applyChanges(changes);
            }
        };
        NgFor.prototype._applyChanges = function (changes) {
            var _this = this;
            var insertTuples = [];
            changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {
                if (item.previousIndex == null) {
                    var view = _this._viewContainer.createEmbeddedView(_this._template, new NgForRow(null, null, null), currentIndex);
                    var tuple = new RecordViewTuple(item, view);
                    insertTuples.push(tuple);
                }
                else if (currentIndex == null) {
                    _this._viewContainer.remove(adjustedPreviousIndex);
                }
                else {
                    var view = _this._viewContainer.get(adjustedPreviousIndex);
                    _this._viewContainer.move(view, currentIndex);
                    var tuple = new RecordViewTuple(item, view);
                    insertTuples.push(tuple);
                }
            });
            for (var i = 0; i < insertTuples.length; i++) {
                this._perViewChange(insertTuples[i].view, insertTuples[i].record);
            }
            for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
                var viewRef = this._viewContainer.get(i);
                viewRef.context.index = i;
                viewRef.context.count = ilen;
            }
            changes.forEachIdentityChange(function (record) {
                var viewRef = _this._viewContainer.get(record.currentIndex);
                viewRef.context.$implicit = record.item;
            });
        };
        NgFor.prototype._perViewChange = function (view, record) {
            view.context.$implicit = record.item;
        };
        NgFor.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngFor][ngForOf]' },] },
        ];
        /** @nocollapse */
        NgFor.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
            { type: _angular_core.TemplateRef, },
            { type: _angular_core.IterableDiffers, },
            { type: _angular_core.ChangeDetectorRef, },
        ];
        NgFor.propDecorators = {
            'ngForOf': [{ type: _angular_core.Input },],
            'ngForTrackBy': [{ type: _angular_core.Input },],
            'ngForTemplate': [{ type: _angular_core.Input },],
        };
        return NgFor;
    }());
    var RecordViewTuple = (function () {
        function RecordViewTuple(record, view) {
            this.record = record;
            this.view = view;
        }
        return RecordViewTuple;
    }());

    /**
     * Removes or recreates a portion of the DOM tree based on an {expression}.
     *
     * If the expression assigned to `ngIf` evaluates to a false value then the element
     * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
     *
     * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):
     *
     * ```
     * <div *ngIf="errorCount > 0" class="error">
     *   <!-- Error message displayed when the errorCount property on the current context is greater
     * than 0. -->
     *   {{errorCount}} errors detected
     * </div>
     * ```
     *
     * ### Syntax
     *
     * - `<div *ngIf="condition">...</div>`
     * - `<div template="ngIf condition">...</div>`
     * - `<template [ngIf]="condition"><div>...</div></template>`
     *
     * @stable
     */
    var NgIf = (function () {
        function NgIf(_viewContainer, _template) {
            this._viewContainer = _viewContainer;
            this._template = _template;
            this._hasView = false;
        }
        Object.defineProperty(NgIf.prototype, "ngIf", {
            set: function (condition) {
                if (condition && !this._hasView) {
                    this._hasView = true;
                    this._viewContainer.createEmbeddedView(this._template);
                }
                else if (!condition && this._hasView) {
                    this._hasView = false;
                    this._viewContainer.clear();
                }
            },
            enumerable: true,
            configurable: true
        });
        NgIf.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngIf]' },] },
        ];
        /** @nocollapse */
        NgIf.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
            { type: _angular_core.TemplateRef, },
        ];
        NgIf.propDecorators = {
            'ngIf': [{ type: _angular_core.Input },],
        };
        return NgIf;
    }());

    var _CASE_DEFAULT = new Object();
    var SwitchView = (function () {
        function SwitchView(_viewContainerRef, _templateRef) {
            this._viewContainerRef = _viewContainerRef;
            this._templateRef = _templateRef;
        }
        SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };
        SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };
        return SwitchView;
    }());
    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Adds / removes DOM sub-trees when the nest match expressions matches the switch
     *             expression.
     *
     * @howToUse
     * ```
     *     <container-element [ngSwitch]="switch_expression">
     *       <some-element *ngSwitchCase="match_expression_1">...</some-element>
     *       <some-element *ngSwitchCase="match_expression_2">...</some-element>
     *       <some-other-element *ngSwitchCase="match_expression_3">...</some-other-element>
     *       <ng-container *ngSwitchCase="match_expression_3">
     *         <!-- use a ng-container to group multiple root nodes -->
     *         <inner-element></inner-element>
     *         <inner-other-element></inner-other-element>
     *       </ng-container>
     *       <some-element *ngSwitchDefault>...</p>
     *     </container-element>
     * ```
     * @description
     *
     * `NgSwitch` stamps out nested views when their match expression value matches the value of the
     * switch expression.
     *
     * In other words:
     * - you define a container element (where you place the directive with a switch expression on the
     * `[ngSwitch]="..."` attribute)
     * - you define inner views inside the `NgSwitch` and place a `*ngSwitchCase` attribute on the view
     * root elements.
     *
     * Elements within `NgSwitch` but outside of a `NgSwitchCase` or `NgSwitchDefault` directives will
     * be
     * preserved at the location.
     *
     * The `ngSwitchCase` directive informs the parent `NgSwitch` of which view to display when the
     * expression is evaluated.
     * When no matching expression is found on a `ngSwitchCase` view, the `ngSwitchDefault` view is
     * stamped out.
     *
     * @stable
     */
    var NgSwitch = (function () {
        function NgSwitch() {
            this._useDefault = false;
            this._valueViews = new Map();
            this._activeViews = [];
        }
        Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
            set: function (value) {
                // Empty the currently active ViewContainers
                this._emptyAllActiveViews();
                // Add the ViewContainers matching the value (with a fallback to default)
                this._useDefault = false;
                var views = this._valueViews.get(value);
                if (!views) {
                    this._useDefault = true;
                    views = this._valueViews.get(_CASE_DEFAULT) || null;
                }
                this._activateViews(views);
                this._switchValue = value;
            },
            enumerable: true,
            configurable: true
        });
        /** @internal */
        NgSwitch.prototype._onCaseValueChanged = function (oldCase, newCase, view) {
            this._deregisterView(oldCase, view);
            this._registerView(newCase, view);
            if (oldCase === this._switchValue) {
                view.destroy();
                ListWrapper.remove(this._activeViews, view);
            }
            else if (newCase === this._switchValue) {
                if (this._useDefault) {
                    this._useDefault = false;
                    this._emptyAllActiveViews();
                }
                view.create();
                this._activeViews.push(view);
            }
            // Switch to default when there is no more active ViewContainers
            if (this._activeViews.length === 0 && !this._useDefault) {
                this._useDefault = true;
                this._activateViews(this._valueViews.get(_CASE_DEFAULT));
            }
        };
        NgSwitch.prototype._emptyAllActiveViews = function () {
            var activeContainers = this._activeViews;
            for (var i = 0; i < activeContainers.length; i++) {
                activeContainers[i].destroy();
            }
            this._activeViews = [];
        };
        NgSwitch.prototype._activateViews = function (views) {
            if (views) {
                for (var i = 0; i < views.length; i++) {
                    views[i].create();
                }
                this._activeViews = views;
            }
        };
        /** @internal */
        NgSwitch.prototype._registerView = function (value, view) {
            var views = this._valueViews.get(value);
            if (!views) {
                views = [];
                this._valueViews.set(value, views);
            }
            views.push(view);
        };
        NgSwitch.prototype._deregisterView = function (value, view) {
            // `_CASE_DEFAULT` is used a marker for non-registered cases
            if (value === _CASE_DEFAULT)
                return;
            var views = this._valueViews.get(value);
            if (views.length == 1) {
                this._valueViews.delete(value);
            }
            else {
                ListWrapper.remove(views, view);
            }
        };
        NgSwitch.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngSwitch]' },] },
        ];
        /** @nocollapse */
        NgSwitch.ctorParameters = [];
        NgSwitch.propDecorators = {
            'ngSwitch': [{ type: _angular_core.Input },],
        };
        return NgSwitch;
    }());
    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgSwitch} when the
     *             given expression evaluate to respectively the same/different value as the switch
     *             expression.
     *
     * @howToUse
     * ```
     * <container-element [ngSwitch]="switch_expression">
     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
     * </container-element>
     *```
     * @description
     *
     * Insert the sub-tree when the expression evaluates to the same value as the enclosing switch
     * expression.
     *
     * If multiple match expressions match the switch expression value, all of them are displayed.
     *
     * See {@link NgSwitch} for more details and example.
     *
     * @stable
     */
    var NgSwitchCase = (function () {
        function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
            // `_CASE_DEFAULT` is used as a marker for a not yet initialized value
            this._value = _CASE_DEFAULT;
            this._switch = ngSwitch;
            this._view = new SwitchView(viewContainer, templateRef);
        }
        Object.defineProperty(NgSwitchCase.prototype, "ngSwitchCase", {
            set: function (value) {
                this._switch._onCaseValueChanged(this._value, value, this._view);
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        NgSwitchCase.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchCase]' },] },
        ];
        /** @nocollapse */
        NgSwitchCase.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
            { type: _angular_core.TemplateRef, },
            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
        ];
        NgSwitchCase.propDecorators = {
            'ngSwitchCase': [{ type: _angular_core.Input },],
        };
        return NgSwitchCase;
    }());
    /**
     * @ngModule CommonModule
     * @whatItDoes Creates a view that is added to the parent {@link NgSwitch} when no case expressions
     * match the
     *             switch expression.
     *
     * @howToUse
     * ```
     * <container-element [ngSwitch]="switch_expression">
     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
     *   <some-other-element *ngSwitchDefault>...</some-other-element>
     * </container-element>
     * ```
     *
     * @description
     *
     * Insert the sub-tree when no case expressions evaluate to the same value as the enclosing switch
     * expression.
     *
     * See {@link NgSwitch} for more details and example.
     *
     * @stable
     */
    var NgSwitchDefault = (function () {
        function NgSwitchDefault(viewContainer, templateRef, sswitch) {
            sswitch._registerView(_CASE_DEFAULT, new SwitchView(viewContainer, templateRef));
        }
        NgSwitchDefault.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchDefault]' },] },
        ];
        /** @nocollapse */
        NgSwitchDefault.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
            { type: _angular_core.TemplateRef, },
            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
        ];
        return NgSwitchDefault;
    }());

    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.
     *
     * @howToUse
     * ```
     * <some-element [ngPlural]="value">
     *   <ng-container *ngPluralCase="'=0'">there is nothing</ng-container>
     *   <ng-container *ngPluralCase="'=1'">there is one</ng-container>
     *   <ng-container *ngPluralCase="'few'">there are a few</ng-container>
     *   <ng-container *ngPluralCase="'other'">there are exactly #</ng-container>
     * </some-element>
     * ```
     *
     * @description
     *
     * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees
     * that match the switch expression's pluralization category.
     *
     * To use this directive you must provide a container element that sets the `[ngPlural]` attribute
     * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their
     * expression:
     * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value
     *   matches the switch expression exactly,
     * - otherwise, the view will be treated as a "category match", and will only display if exact
     *   value matches aren't found and the value maps to its category for the defined locale.
     *
     * See http://cldr.unicode.org/index/cldr-spec/plural-rules
     *
     * @experimental
     */
    var NgPlural = (function () {
        function NgPlural(_localization) {
            this._localization = _localization;
            this._caseViews = {};
        }
        Object.defineProperty(NgPlural.prototype, "ngPlural", {
            set: function (value) {
                this._switchValue = value;
                this._updateView();
            },
            enumerable: true,
            configurable: true
        });
        NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };
        NgPlural.prototype._updateView = function () {
            this._clearViews();
            var cases = Object.keys(this._caseViews);
            var key = getPluralCategory(this._switchValue, cases, this._localization);
            this._activateView(this._caseViews[key]);
        };
        NgPlural.prototype._clearViews = function () {
            if (this._activeView)
                this._activeView.destroy();
        };
        NgPlural.prototype._activateView = function (view) {
            if (view) {
                this._activeView = view;
                this._activeView.create();
            }
        };
        NgPlural.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngPlural]' },] },
        ];
        /** @nocollapse */
        NgPlural.ctorParameters = [
            { type: NgLocalization, },
        ];
        NgPlural.propDecorators = {
            'ngPlural': [{ type: _angular_core.Input },],
        };
        return NgPlural;
    }());
    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Creates a view that will be added/removed from the parent {@link NgPlural} when the
     *             given expression matches the plural expression according to CLDR rules.
     *
     * @howToUse
     * ```
     * <some-element [ngPlural]="value">
     *   <ng-container *ngPluralCase="'=0'">...</ng-container>
     *   <ng-container *ngPluralCase="'other'">...</ng-container>
     * </some-element>
     *```
     *
     * See {@link NgPlural} for more details and example.
     *
     * @experimental
     */
    var NgPluralCase = (function () {
        function NgPluralCase(value, template, viewContainer, ngPlural) {
            this.value = value;
            ngPlural.addCase(value, new SwitchView(viewContainer, template));
        }
        NgPluralCase.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngPluralCase]' },] },
        ];
        /** @nocollapse */
        NgPluralCase.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['ngPluralCase',] },] },
            { type: _angular_core.TemplateRef, },
            { type: _angular_core.ViewContainerRef, },
            { type: NgPlural, decorators: [{ type: _angular_core.Host },] },
        ];
        return NgPluralCase;
    }());

    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Update an HTML element styles.
     *
     * @howToUse
     * ```
     * <some-element [ngStyle]="{'font-style': styleExp}">...</some-element>
     *
     * <some-element [ngStyle]="{'max-width.px': widthExp}">...</some-element>
     *
     * <some-element [ngStyle]="objExp">...</some-element>
     * ```
     *
     * @description
     *
     * The styles are updated according to the value of the expression evaluation:
     * - keys are style names with an option `.<unit>` suffix (ie 'top.px', 'font-style.em'),
     * - values are the values assigned to those properties (expressed in the given unit).
     *
     * @stable
     */
    var NgStyle = (function () {
        function NgStyle(_differs, _ngEl, _renderer) {
            this._differs = _differs;
            this._ngEl = _ngEl;
            this._renderer = _renderer;
        }
        Object.defineProperty(NgStyle.prototype, "ngStyle", {
            set: function (v) {
                this._ngStyle = v;
                if (!this._differ && v) {
                    this._differ = this._differs.find(v).create(null);
                }
            },
            enumerable: true,
            configurable: true
        });
        NgStyle.prototype.ngDoCheck = function () {
            if (this._differ) {
                var changes = this._differ.diff(this._ngStyle);
                if (changes) {
                    this._applyChanges(changes);
                }
            }
        };
        NgStyle.prototype._applyChanges = function (changes) {
            var _this = this;
            changes.forEachRemovedItem(function (record) { return _this._setStyle(record.key, null); });
            changes.forEachAddedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
            changes.forEachChangedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
        };
        NgStyle.prototype._setStyle = function (nameAndUnit, value) {
            var _a = nameAndUnit.split('.'), name = _a[0], unit = _a[1];
            value = value && unit ? "" + value + unit : value;
            this._renderer.setElementStyle(this._ngEl.nativeElement, name, value);
        };
        NgStyle.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngStyle]' },] },
        ];
        /** @nocollapse */
        NgStyle.ctorParameters = [
            { type: _angular_core.KeyValueDiffers, },
            { type: _angular_core.ElementRef, },
            { type: _angular_core.Renderer, },
        ];
        NgStyle.propDecorators = {
            'ngStyle': [{ type: _angular_core.Input },],
        };
        return NgStyle;
    }());

    /**
     * @ngModule CommonModule
     *
     * @whatItDoes Inserts an embedded view from a prepared `TemplateRef`
     *
     * @howToUse
     * ```
     * <template [ngTemplateOutlet]="templateRefExpression"
     *           [ngOutletContext]="objectExpression">
     * </template>
     * ```
     *
     * @description
     *
     * You can attach a context object to the `EmbeddedViewRef` by setting `[ngOutletContext]`.
     * `[ngOutletContext]` should be an object, the object's keys will be the local template variables
     * available within the `TemplateRef`.
     *
     * Note: using the key `$implicit` in the context object will set it's value as default.
     *
     * @experimental
     */
    var NgTemplateOutlet = (function () {
        function NgTemplateOutlet(_viewContainerRef) {
            this._viewContainerRef = _viewContainerRef;
        }
        Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
            set: function (context) { this._context = context; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgTemplateOutlet.prototype, "ngTemplateOutlet", {
            set: function (templateRef) { this._templateRef = templateRef; },
            enumerable: true,
            configurable: true
        });
        NgTemplateOutlet.prototype.ngOnChanges = function (changes) {
            if (this._viewRef) {
                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
            }
            if (this._templateRef) {
                this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);
            }
        };
        NgTemplateOutlet.decorators = [
            { type: _angular_core.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },
        ];
        /** @nocollapse */
        NgTemplateOutlet.ctorParameters = [
            { type: _angular_core.ViewContainerRef, },
        ];
        NgTemplateOutlet.propDecorators = {
            'ngOutletContext': [{ type: _angular_core.Input },],
            'ngTemplateOutlet': [{ type: _angular_core.Input },],
        };
        return NgTemplateOutlet;
    }());

    /**
     * A collection of Angular directives that are likely to be used in each and every Angular
     * application.
     */
    var COMMON_DIRECTIVES = [
        NgClass,
        NgFor,
        NgIf,
        NgTemplateOutlet,
        NgStyle,
        NgSwitch,
        NgSwitchCase,
        NgSwitchDefault,
        NgPlural,
        NgPluralCase,
    ];

    var isPromise = _angular_core.__core_private__.isPromise;

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$4 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @stable
     */
    var BaseError = (function (_super) {
        __extends$4(BaseError, _super);
        function BaseError(message) {
            // Errors don't use current this, instead they create a new instance.
            // We have to do forward all of our api to the nativeInstance.
            var nativeError = _super.call(this, message);
            this._nativeError = nativeError;
        }
        Object.defineProperty(BaseError.prototype, "message", {
            get: function () { return this._nativeError.message; },
            set: function (message) { this._nativeError.message = message; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "name", {
            get: function () { return this._nativeError.name; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "stack", {
            get: function () { return this._nativeError.stack; },
            set: function (value) { this._nativeError.stack = value; },
            enumerable: true,
            configurable: true
        });
        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
        return BaseError;
    }(Error));
    /**
     * @stable
     */
    var WrappedError = (function (_super) {
        __extends$4(WrappedError, _super);
        function WrappedError(message, error) {
            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
            this.originalError = error;
        }
        Object.defineProperty(WrappedError.prototype, "stack", {
            get: function () {
                return (this.originalError instanceof Error ? this.originalError : this._nativeError)
                    .stack;
            },
            enumerable: true,
            configurable: true
        });
        return WrappedError;
    }(BaseError));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$3 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var InvalidPipeArgumentError = (function (_super) {
        __extends$3(InvalidPipeArgumentError, _super);
        function InvalidPipeArgumentError(type, value) {
            _super.call(this, "Invalid argument '" + value + "' for pipe '" + stringify(type) + "'");
        }
        return InvalidPipeArgumentError;
    }(BaseError));

    var ObservableStrategy = (function () {
        function ObservableStrategy() {
        }
        ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
            return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });
        };
        ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };
        ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };
        return ObservableStrategy;
    }());
    var PromiseStrategy = (function () {
        function PromiseStrategy() {
        }
        PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
            return async.then(updateLatestValue, function (e) { throw e; });
        };
        PromiseStrategy.prototype.dispose = function (subscription) { };
        PromiseStrategy.prototype.onDestroy = function (subscription) { };
        return PromiseStrategy;
    }());
    var _promiseStrategy = new PromiseStrategy();
    var _observableStrategy = new ObservableStrategy();
    /**
     * @ngModule CommonModule
     * @whatItDoes Unwraps a value from an asynchronous primitive.
     * @howToUse `observable_or_promise_expression | async`
     * @description
     * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
     * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
     * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
     * potential memory leaks.
     *
     *
     * ## Examples
     *
     * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
     * promise.
     *
     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
     *
     * It's also possible to use `async` with Observables. The example below binds the `time` Observable
     * to the view. The Observable continuesly updates the view with the current time.
     *
     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
     *
     * @stable
     */
    var AsyncPipe = (function () {
        function AsyncPipe(_ref) {
            this._ref = _ref;
            this._latestValue = null;
            this._latestReturnedValue = null;
            this._subscription = null;
            this._obj = null;
            this._strategy = null;
        }
        AsyncPipe.prototype.ngOnDestroy = function () {
            if (this._subscription) {
                this._dispose();
            }
        };
        AsyncPipe.prototype.transform = function (obj) {
            if (!this._obj) {
                if (obj) {
                    this._subscribe(obj);
                }
                this._latestReturnedValue = this._latestValue;
                return this._latestValue;
            }
            if (obj !== this._obj) {
                this._dispose();
                return this.transform(obj);
            }
            if (this._latestValue === this._latestReturnedValue) {
                return this._latestReturnedValue;
            }
            this._latestReturnedValue = this._latestValue;
            return _angular_core.WrappedValue.wrap(this._latestValue);
        };
        AsyncPipe.prototype._subscribe = function (obj) {
            var _this = this;
            this._obj = obj;
            this._strategy = this._selectStrategy(obj);
            this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
        };
        AsyncPipe.prototype._selectStrategy = function (obj) {
            if (isPromise(obj)) {
                return _promiseStrategy;
            }
            if (obj.subscribe) {
                return _observableStrategy;
            }
            throw new InvalidPipeArgumentError(AsyncPipe, obj);
        };
        AsyncPipe.prototype._dispose = function () {
            this._strategy.dispose(this._subscription);
            this._latestValue = null;
            this._latestReturnedValue = null;
            this._subscription = null;
            this._obj = null;
        };
        AsyncPipe.prototype._updateLatestValue = function (async, value) {
            if (async === this._obj) {
                this._latestValue = value;
                this._ref.markForCheck();
            }
        };
        AsyncPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'async', pure: false },] },
        ];
        /** @nocollapse */
        AsyncPipe.ctorParameters = [
            { type: _angular_core.ChangeDetectorRef, },
        ];
        return AsyncPipe;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var NumberFormatStyle;
    (function (NumberFormatStyle) {
        NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
        NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
        NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
    })(NumberFormatStyle || (NumberFormatStyle = {}));
    var NumberFormatter = (function () {
        function NumberFormatter() {
        }
        NumberFormatter.format = function (num, locale, style, _a) {
            var _b = _a === void 0 ? {} : _a, minimumIntegerDigits = _b.minimumIntegerDigits, minimumFractionDigits = _b.minimumFractionDigits, maximumFractionDigits = _b.maximumFractionDigits, currency = _b.currency, _c = _b.currencyAsSymbol, currencyAsSymbol = _c === void 0 ? false : _c;
            var options = {
                minimumIntegerDigits: minimumIntegerDigits,
                minimumFractionDigits: minimumFractionDigits,
                maximumFractionDigits: maximumFractionDigits,
                style: NumberFormatStyle[style].toLowerCase()
            };
            if (style == NumberFormatStyle.Currency) {
                options.currency = currency;
                options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
            }
            return new Intl.NumberFormat(locale, options).format(num);
        };
        return NumberFormatter;
    }());
    var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
    var PATTERN_ALIASES = {
        yMMMdjms: datePartGetterFactory(combine([
            digitCondition('year', 1),
            nameCondition('month', 3),
            digitCondition('day', 1),
            digitCondition('hour', 1),
            digitCondition('minute', 1),
            digitCondition('second', 1),
        ])),
        yMdjm: datePartGetterFactory(combine([
            digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
            digitCondition('hour', 1), digitCondition('minute', 1)
        ])),
        yMMMMEEEEd: datePartGetterFactory(combine([
            digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
            digitCondition('day', 1)
        ])),
        yMMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
        yMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
        yMd: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
        jms: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
        jm: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
    };
    var DATE_FORMATS = {
        yyyy: datePartGetterFactory(digitCondition('year', 4)),
        yy: datePartGetterFactory(digitCondition('year', 2)),
        y: datePartGetterFactory(digitCondition('year', 1)),
        MMMM: datePartGetterFactory(nameCondition('month', 4)),
        MMM: datePartGetterFactory(nameCondition('month', 3)),
        MM: datePartGetterFactory(digitCondition('month', 2)),
        M: datePartGetterFactory(digitCondition('month', 1)),
        LLLL: datePartGetterFactory(nameCondition('month', 4)),
        dd: datePartGetterFactory(digitCondition('day', 2)),
        d: datePartGetterFactory(digitCondition('day', 1)),
        HH: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
        H: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
        hh: digitModifier(hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
        h: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
        jj: datePartGetterFactory(digitCondition('hour', 2)),
        j: datePartGetterFactory(digitCondition('hour', 1)),
        mm: digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
        m: datePartGetterFactory(digitCondition('minute', 1)),
        ss: digitModifier(datePartGetterFactory(digitCondition('second', 2))),
        s: datePartGetterFactory(digitCondition('second', 1)),
        // while ISO 8601 requires fractions to be prefixed with `.` or `,`
        // we can be just safely rely on using `sss` since we currently don't support single or two digit
        // fractions
        sss: datePartGetterFactory(digitCondition('second', 3)),
        EEEE: datePartGetterFactory(nameCondition('weekday', 4)),
        EEE: datePartGetterFactory(nameCondition('weekday', 3)),
        EE: datePartGetterFactory(nameCondition('weekday', 2)),
        E: datePartGetterFactory(nameCondition('weekday', 1)),
        a: hourClockExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
        Z: timeZoneGetter('short'),
        z: timeZoneGetter('long'),
        ww: datePartGetterFactory({}),
        // first Thursday of the year. not support ?
        w: datePartGetterFactory({}),
        // of the year not support ?
        G: datePartGetterFactory(nameCondition('era', 1)),
        GG: datePartGetterFactory(nameCondition('era', 2)),
        GGG: datePartGetterFactory(nameCondition('era', 3)),
        GGGG: datePartGetterFactory(nameCondition('era', 4))
    };
    function digitModifier(inner) {
        return function (date, locale) {
            var result = inner(date, locale);
            return result.length == 1 ? '0' + result : result;
        };
    }
    function hourClockExtracter(inner) {
        return function (date, locale) {
            var result = inner(date, locale);
            return result.split(' ')[1];
        };
    }
    function hourExtracter(inner) {
        return function (date, locale) {
            var result = inner(date, locale);
            return result.split(' ')[0];
        };
    }
    function intlDateFormat(date, locale, options) {
        return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\u200e\u200f]/g, '');
    }
    function timeZoneGetter(timezone) {
        // To workaround `Intl` API restriction for single timezone let format with 24 hours
        var options = { hour: '2-digit', hour12: false, timeZoneName: timezone };
        return function (date, locale) {
            var result = intlDateFormat(date, locale, options);
            // Then extract first 3 letters that related to hours
            return result ? result.substring(3) : '';
        };
    }
    function hour12Modify(options, value) {
        options.hour12 = value;
        return options;
    }
    function digitCondition(prop, len) {
        var result = {};
        result[prop] = len == 2 ? '2-digit' : 'numeric';
        return result;
    }
    function nameCondition(prop, len) {
        var result = {};
        result[prop] = len < 4 ? 'short' : 'long';
        return result;
    }
    function combine(options) {
        var result = {};
        options.forEach(function (option) { Object.assign(result, option); });
        return result;
    }
    function datePartGetterFactory(ret) {
        return function (date, locale) { return intlDateFormat(date, locale, ret); };
    }
    var datePartsFormatterCache = new Map();
    function dateFormatter(format, date, locale) {
        var text = '';
        var match;
        var fn;
        var parts = [];
        if (PATTERN_ALIASES[format]) {
            return PATTERN_ALIASES[format](date, locale);
        }
        if (datePartsFormatterCache.has(format)) {
            parts = datePartsFormatterCache.get(format);
        }
        else {
            var matches = DATE_FORMATS_SPLIT.exec(format);
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                }
                else {
                    parts.push(format);
                    format = null;
                }
            }
            datePartsFormatterCache.set(format, parts);
        }
        parts.forEach(function (part) {
            fn = DATE_FORMATS[part];
            text += fn ? fn(date, locale) :
                part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
        });
        return text;
    }
    var slice = [].slice;
    function concat(array1 /** TODO #9100 */, array2 /** TODO #9100 */, index /** TODO #9100 */) {
        return array1.concat(slice.call(array2, index));
    }
    var DateFormatter = (function () {
        function DateFormatter() {
        }
        DateFormatter.format = function (date, locale, pattern) {
            return dateFormatter(pattern, date, locale);
        };
        return DateFormatter;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Formats a date according to locale rules.
     * @howToUse `date_expression | date[:format]`
     * @description
     *
     * Where:
     * - `expression` is a date object or a number (milliseconds since UTC epoch) or an ISO string
     * (https://www.w3.org/TR/NOTE-datetime).
     * - `format` indicates which date/time components to include. The format can be predifined as
     *   shown below or custom as shown in the table.
     *   - `'medium'`: equivalent to `'yMMMdjms'` (e.g. `Sep 3, 2010, 12:05:08 PM` for `en-US`)
     *   - `'short'`: equivalent to `'yMdjm'` (e.g. `9/3/2010, 12:05 PM` for `en-US`)
     *   - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. `Friday, September 3, 2010` for `en-US`)
     *   - `'longDate'`: equivalent to `'yMMMMd'` (e.g. `September 3, 2010` for `en-US`)
     *   - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. `Sep 3, 2010` for `en-US`)
     *   - `'shortDate'`: equivalent to `'yMd'` (e.g. `9/3/2010` for `en-US`)
     *   - `'mediumTime'`: equivalent to `'jms'` (e.g. `12:05:08 PM` for `en-US`)
     *   - `'shortTime'`: equivalent to `'jm'` (e.g. `12:05 PM` for `en-US`)
     *
     *
     *  | Component | Symbol | Short Form   | Long Form         | Numeric   | 2-digit   |
     *  |-----------|:------:|--------------|-------------------|-----------|-----------|
     *  | era       |   G    | G (AD)       | GGGG (Anno Domini)| -         | -         |
     *  | year      |   y    | -            | -                 | y (2015)  | yy (15)   |
     *  | month     |   M    | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
     *  | day       |   d    | -            | -                 | d (3)     | dd (03)   |
     *  | weekday   |   E    | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
     *  | hour      |   j    | -            | -                 | j (13)    | jj (13)   |
     *  | hour12    |   h    | -            | -                 | h (1 PM)  | hh (01 PM)|
     *  | hour24    |   H    | -            | -                 | H (13)    | HH (13)   |
     *  | minute    |   m    | -            | -                 | m (5)     | mm (05)   |
     *  | second    |   s    | -            | -                 | s (9)     | ss (09)   |
     *  | timezone  |   z    | -            | z (Pacific Standard Time)| -  | -         |
     *  | timezone  |   Z    | Z (GMT-8:00) | -                 | -         | -         |
     *  | timezone  |   a    | a (PM)       | -                 | -         | -         |
     *
     * In javascript, only the components specified will be respected (not the ordering,
     * punctuations, ...) and details of the formatting will be dependent on the locale.
     *
     * Timezone of the formatted text will be the local system timezone of the end-user's machine.
     *
     * WARNINGS:
     * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.
     *   Instead users should treat the date as an immutable object and change the reference when the
     *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run
     *   which would be an expensive operation).
     * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera
     *   browsers.
     *
     * ### Examples
     *
     * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
     * in the _local_ time and locale is 'en-US':
     *
     * ```
     *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
     *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
     *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
     *     {{ dateObj | date:'mmss' }}        // output is '43:11'
     * ```
     *
     * {@example common/pipes/ts/date_pipe.ts region='DatePipe'}
     *
     * @stable
     */
    var DatePipe = (function () {
        function DatePipe(_locale) {
            this._locale = _locale;
        }
        DatePipe.prototype.transform = function (value, pattern) {
            if (pattern === void 0) { pattern = 'mediumDate'; }
            if (isBlank(value))
                return null;
            if (!this.supports(value)) {
                throw new InvalidPipeArgumentError(DatePipe, value);
            }
            if (NumberWrapper.isNumeric(value)) {
                value = parseFloat(value);
            }
            return DateFormatter.format(new Date(value), this._locale, DatePipe._ALIASES[pattern] || pattern);
        };
        DatePipe.prototype.supports = function (obj) {
            return isDate(obj) || NumberWrapper.isNumeric(obj) ||
                (typeof obj === 'string' && isDate(new Date(obj)));
        };
        /** @internal */
        DatePipe._ALIASES = {
            'medium': 'yMMMdjms',
            'short': 'yMdjm',
            'fullDate': 'yMMMMEEEEd',
            'longDate': 'yMMMMd',
            'mediumDate': 'yMMMd',
            'shortDate': 'yMd',
            'mediumTime': 'jms',
            'shortTime': 'jm'
        };
        DatePipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'date', pure: true },] },
        ];
        /** @nocollapse */
        DatePipe.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return DatePipe;
    }());

    var _INTERPOLATION_REGEXP = /#/g;
    /**
     * @ngModule CommonModule
     * @whatItDoes Maps a value to a string that pluralizes the value according to locale rules.
     * @howToUse `expression | i18nPlural:mapping`
     * @description
     *
     *  Where:
     *  - `expression` is a number.
     *  - `mapping` is an object that mimics the ICU format, see
     *    http://userguide.icu-project.org/formatparse/messages
     *
     *  ## Example
     *
     * {@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}
     *
     * @experimental
     */
    var I18nPluralPipe = (function () {
        function I18nPluralPipe(_localization) {
            this._localization = _localization;
        }
        I18nPluralPipe.prototype.transform = function (value, pluralMap) {
            if (isBlank(value))
                return '';
            if (!isStringMap(pluralMap)) {
                throw new InvalidPipeArgumentError(I18nPluralPipe, pluralMap);
            }
            var key = getPluralCategory(value, Object.keys(pluralMap), this._localization);
            return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
        };
        I18nPluralPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'i18nPlural', pure: true },] },
        ];
        /** @nocollapse */
        I18nPluralPipe.ctorParameters = [
            { type: NgLocalization, },
        ];
        return I18nPluralPipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Generic selector that displays the string that matches the current value.
     * @howToUse `expression | i18nSelect:mapping`
     * @description
     *
     *  Where:
     *  - `mapping`: is an object that indicates the text that should be displayed
     *  for different values of the provided `expression`.
     *
     *  ## Example
     *
     * {@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}
     *
     *  @experimental
     */
    var I18nSelectPipe = (function () {
        function I18nSelectPipe() {
        }
        I18nSelectPipe.prototype.transform = function (value, mapping) {
            if (isBlank(value))
                return '';
            if (!isStringMap(mapping)) {
                throw new InvalidPipeArgumentError(I18nSelectPipe, mapping);
            }
            return mapping.hasOwnProperty(value) ? mapping[value] : '';
        };
        I18nSelectPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'i18nSelect', pure: true },] },
        ];
        /** @nocollapse */
        I18nSelectPipe.ctorParameters = [];
        return I18nSelectPipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Converts value into JSON string.
     * @howToUse `expression | json`
     * @description
     *
     * Converts value into string using `JSON.stringify`. Useful for debugging.
     *
     * ### Example
     * {@example common/pipes/ts/json_pipe.ts region='JsonPipe'}
     *
     * @stable
     */
    var JsonPipe = (function () {
        function JsonPipe() {
        }
        JsonPipe.prototype.transform = function (value) { return Json.stringify(value); };
        JsonPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'json', pure: false },] },
        ];
        /** @nocollapse */
        JsonPipe.ctorParameters = [];
        return JsonPipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Transforms string to lowercase.
     * @howToUse `expression | lowercase`
     * @description
     *
     * Converts value into lowercase string using `String.prototype.toLowerCase()`.
     *
     * ### Example
     *
     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
     *
     * @stable
     */
    var LowerCasePipe = (function () {
        function LowerCasePipe() {
        }
        LowerCasePipe.prototype.transform = function (value) {
            if (isBlank(value))
                return value;
            if (typeof value !== 'string') {
                throw new InvalidPipeArgumentError(LowerCasePipe, value);
            }
            return value.toLowerCase();
        };
        LowerCasePipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'lowercase' },] },
        ];
        /** @nocollapse */
        LowerCasePipe.ctorParameters = [];
        return LowerCasePipe;
    }());

    var _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
    function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {
        if (currency === void 0) { currency = null; }
        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
        if (isBlank(value))
            return null;
        // Convert strings to numbers
        value = typeof value === 'string' && NumberWrapper.isNumeric(value) ? +value : value;
        if (typeof value !== 'number') {
            throw new InvalidPipeArgumentError(pipe, value);
        }
        var minInt;
        var minFraction;
        var maxFraction;
        if (style !== NumberFormatStyle.Currency) {
            // rely on Intl default for currency
            minInt = 1;
            minFraction = 0;
            maxFraction = 3;
        }
        if (digits) {
            var parts = digits.match(_NUMBER_FORMAT_REGEXP);
            if (parts === null) {
                throw new Error(digits + " is not a valid digit info for number pipes");
            }
            if (isPresent(parts[1])) {
                minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
            }
            if (isPresent(parts[3])) {
                minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
            }
            if (isPresent(parts[5])) {
                maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
            }
        }
        return NumberFormatter.format(value, locale, style, {
            minimumIntegerDigits: minInt,
            minimumFractionDigits: minFraction,
            maximumFractionDigits: maxFraction,
            currency: currency,
            currencyAsSymbol: currencyAsSymbol,
        });
    }
    /**
     * @ngModule CommonModule
     * @whatItDoes Formats a number according to locale rules.
     * @howToUse `number_expression | number[:digitInfo]`
     *
     * Formats a number as text. Group sizing and separator and other locale-specific
     * configurations are based on the active locale.
     *
     * where `expression` is a number:
     *  - `digitInfo` is a `string` which has a following format: <br>
     *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>
     *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.
     *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.
     *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.
     *
     * For more information on the acceptable range for each of these numbers and other
     * details see your native internationalization library.
     *
     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.
     *
     * ### Example
     *
     * {@example common/pipes/ts/number_pipe.ts region='NumberPipe'}
     *
     * @stable
     */
    var DecimalPipe = (function () {
        function DecimalPipe(_locale) {
            this._locale = _locale;
        }
        DecimalPipe.prototype.transform = function (value, digits) {
            if (digits === void 0) { digits = null; }
            return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);
        };
        DecimalPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'number' },] },
        ];
        /** @nocollapse */
        DecimalPipe.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return DecimalPipe;
    }());
    /**
     * @ngModule CommonModule
     * @whatItDoes Formats a number as a percentage according to locale rules.
     * @howToUse `number_expression | percent[:digitInfo]`
     *
     * @description
     *
     * Formats a number as percentage.
     *
     * - `digitInfo` See {@link DecimalPipe} for detailed description.
     *
     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.
     *
     * ### Example
     *
     * {@example common/pipes/ts/number_pipe.ts region='PercentPipe'}
     *
     * @stable
     */
    var PercentPipe = (function () {
        function PercentPipe(_locale) {
            this._locale = _locale;
        }
        PercentPipe.prototype.transform = function (value, digits) {
            if (digits === void 0) { digits = null; }
            return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);
        };
        PercentPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'percent' },] },
        ];
        /** @nocollapse */
        PercentPipe.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return PercentPipe;
    }());
    /**
     * @ngModule CommonModule
     * @whatItDoes Formats a number as currency using locale rules.
     * @howToUse `number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]`
     * @description
     *
     * Use `currency` to format a number as currency.
     *
     * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such
     *    as `USD` for the US dollar and `EUR` for the euro.
     * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.
     *   - `true`: use symbol (e.g. `$`).
     *   - `false`(default): use code (e.g. `USD`).
     * - `digitInfo` See {@link DecimalPipe} for detailed description.
     *
     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
     * and may require a polyfill. See {@linkDocs guide/browser-support} for details.
     *
     * ### Example
     *
     * {@example common/pipes/ts/number_pipe.ts region='CurrencyPipe'}
     *
     * @stable
     */
    var CurrencyPipe = (function () {
        function CurrencyPipe(_locale) {
            this._locale = _locale;
        }
        CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
            if (currencyCode === void 0) { currencyCode = 'USD'; }
            if (symbolDisplay === void 0) { symbolDisplay = false; }
            if (digits === void 0) { digits = null; }
            return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
        };
        CurrencyPipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'currency' },] },
        ];
        /** @nocollapse */
        CurrencyPipe.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
        ];
        return CurrencyPipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Creates a new List or String containing a subset (slice) of the elements.
     * @howToUse `array_or_string_expression | slice:start[:end]`
     * @description
     *
     * Where the input expression is a `List` or `String`, and:
     * - `start`: The starting index of the subset to return.
     *   - **a positive integer**: return the item at `start` index and all items after
     *     in the list or string expression.
     *   - **a negative integer**: return the item at `start` index from the end and all items after
     *     in the list or string expression.
     *   - **if positive and greater than the size of the expression**: return an empty list or string.
     *   - **if negative and greater than the size of the expression**: return entire list or string.
     * - `end`: The ending index of the subset to return.
     *   - **omitted**: return all items until the end.
     *   - **if positive**: return all items before `end` index of the list or string.
     *   - **if negative**: return all items before `end` index from the end of the list or string.
     *
     * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`
     * and `String.prototype.slice()`.
     *
     * When operating on a [List], the returned list is always a copy even when all
     * the elements are being returned.
     *
     * When operating on a blank value, the pipe returns the blank value.
     *
     * ## List Example
     *
     * This `ngFor` example:
     *
     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}
     *
     * produces the following:
     *
     *     <li>b</li>
     *     <li>c</li>
     *
     * ## String Examples
     *
     * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}
     *
     * @stable
     */
    var SlicePipe = (function () {
        function SlicePipe() {
        }
        SlicePipe.prototype.transform = function (value, start, end) {
            if (isBlank(value))
                return value;
            if (!this.supports(value)) {
                throw new InvalidPipeArgumentError(SlicePipe, value);
            }
            return value.slice(start, end);
        };
        SlicePipe.prototype.supports = function (obj) { return typeof obj === 'string' || Array.isArray(obj); };
        SlicePipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'slice', pure: false },] },
        ];
        /** @nocollapse */
        SlicePipe.ctorParameters = [];
        return SlicePipe;
    }());

    /**
     * @ngModule CommonModule
     * @whatItDoes Transforms string to uppercase.
     * @howToUse `expression | uppercase`
     * @description
     *
     * Converts value into lowercase string using `String.prototype.toUpperCase()`.
     *
     * ### Example
     *
     * {@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
     *
     * @stable
     */
    var UpperCasePipe = (function () {
        function UpperCasePipe() {
        }
        UpperCasePipe.prototype.transform = function (value) {
            if (isBlank(value))
                return value;
            if (typeof value !== 'string') {
                throw new InvalidPipeArgumentError(UpperCasePipe, value);
            }
            return value.toUpperCase();
        };
        UpperCasePipe.decorators = [
            { type: _angular_core.Pipe, args: [{ name: 'uppercase' },] },
        ];
        /** @nocollapse */
        UpperCasePipe.ctorParameters = [];
        return UpperCasePipe;
    }());

    /**
     * A collection of Angular pipes that are likely to be used in each and every application.
     */
    var COMMON_PIPES = [
        AsyncPipe,
        UpperCasePipe,
        LowerCasePipe,
        JsonPipe,
        SlicePipe,
        DecimalPipe,
        PercentPipe,
        CurrencyPipe,
        DatePipe,
        I18nPluralPipe,
        I18nSelectPipe,
    ];

    // Note: This does not contain the location providers,
    // as they need some platform specific implementations to work.
    /**
     * The module that includes all the basic Angular directives like {@link NgIf}, {@link NgFor}, ...
     *
     * @stable
     */
    var CommonModule = (function () {
        function CommonModule() {
        }
        CommonModule.decorators = [
            { type: _angular_core.NgModule, args: [{
                        declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
                        exports: [COMMON_DIRECTIVES, COMMON_PIPES],
                        providers: [
                            { provide: NgLocalization, useClass: NgLocaleLocalization },
                        ],
                    },] },
        ];
        /** @nocollapse */
        CommonModule.ctorParameters = [];
        return CommonModule;
    }());

    exports.NgLocalization = NgLocalization;
    exports.CommonModule = CommonModule;
    exports.NgClass = NgClass;
    exports.NgFor = NgFor;
    exports.NgIf = NgIf;
    exports.NgPlural = NgPlural;
    exports.NgPluralCase = NgPluralCase;
    exports.NgStyle = NgStyle;
    exports.NgSwitch = NgSwitch;
    exports.NgSwitchCase = NgSwitchCase;
    exports.NgSwitchDefault = NgSwitchDefault;
    exports.NgTemplateOutlet = NgTemplateOutlet;
    exports.AsyncPipe = AsyncPipe;
    exports.DatePipe = DatePipe;
    exports.I18nPluralPipe = I18nPluralPipe;
    exports.I18nSelectPipe = I18nSelectPipe;
    exports.JsonPipe = JsonPipe;
    exports.LowerCasePipe = LowerCasePipe;
    exports.CurrencyPipe = CurrencyPipe;
    exports.DecimalPipe = DecimalPipe;
    exports.PercentPipe = PercentPipe;
    exports.SlicePipe = SlicePipe;
    exports.UpperCasePipe = UpperCasePipe;
    exports.PlatformLocation = PlatformLocation;
    exports.LocationStrategy = LocationStrategy;
    exports.APP_BASE_HREF = APP_BASE_HREF;
    exports.HashLocationStrategy = HashLocationStrategy;
    exports.PathLocationStrategy = PathLocationStrategy;
    exports.Location = Location;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@angular/core":3}],2:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.0.2
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
  typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
  (factory((global.ng = global.ng || {}, global.ng.compiler = global.ng.compiler || {}),global.ng.core));
}(this, function (exports,_angular_core) { 'use strict';

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var globalScope;
  if (typeof window === 'undefined') {
      if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
          // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
          globalScope = self;
      }
      else {
          globalScope = global;
      }
  }
  else {
      globalScope = window;
  }
  // Need to declare a new variable for global here since TypeScript
  // exports the original value of the symbol.
  var global$1 = globalScope;
  // TODO: remove calls to assert in production environment
  // Note: Can't just export this and import in in other files
  // as `assert` is a reserved keyword in Dart
  global$1.assert = function assert(condition) {
      // TODO: to be fixed properly via #2830, noop for now
  };
  function isPresent(obj) {
      return obj !== undefined && obj !== null;
  }
  function isBlank(obj) {
      return obj === undefined || obj === null;
  }
  function isString(obj) {
      return typeof obj === 'string';
  }
  function isStringMap(obj) {
      return typeof obj === 'object' && obj !== null;
  }
  var STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
      return isStringMap(obj) && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  function isArray(obj) {
      return Array.isArray(obj);
  }
  function stringify(token) {
      if (typeof token === 'string') {
          return token;
      }
      if (token === undefined || token === null) {
          return '' + token;
      }
      if (token.overriddenName) {
          return token.overriddenName;
      }
      if (token.name) {
          return token.name;
      }
      var res = token.toString();
      var newLineIndex = res.indexOf('\n');
      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }
  var StringWrapper = (function () {
      function StringWrapper() {
      }
      StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
      StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
      StringWrapper.split = function (s, regExp) { return s.split(regExp); };
      StringWrapper.equals = function (s, s2) { return s === s2; };
      StringWrapper.stripLeft = function (s, charVal) {
          if (s && s.length) {
              var pos = 0;
              for (var i = 0; i < s.length; i++) {
                  if (s[i] != charVal)
                      break;
                  pos++;
              }
              s = s.substring(pos);
          }
          return s;
      };
      StringWrapper.stripRight = function (s, charVal) {
          if (s && s.length) {
              var pos = s.length;
              for (var i = s.length - 1; i >= 0; i--) {
                  if (s[i] != charVal)
                      break;
                  pos--;
              }
              s = s.substring(0, pos);
          }
          return s;
      };
      StringWrapper.replace = function (s, from, replace) {
          return s.replace(from, replace);
      };
      StringWrapper.replaceAll = function (s, from, replace) {
          return s.replace(from, replace);
      };
      StringWrapper.slice = function (s, from, to) {
          if (from === void 0) { from = 0; }
          if (to === void 0) { to = null; }
          return s.slice(from, to === null ? undefined : to);
      };
      StringWrapper.replaceAllMapped = function (s, from, cb) {
          return s.replace(from, function () {
              var matches = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  matches[_i - 0] = arguments[_i];
              }
              // Remove offset & string from the result array
              matches.splice(-2, 2);
              // The callback receives match, p1, ..., pn
              return cb(matches);
          });
      };
      StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
      StringWrapper.compare = function (a, b) {
          if (a < b) {
              return -1;
          }
          else if (a > b) {
              return 1;
          }
          else {
              return 0;
          }
      };
      return StringWrapper;
  }());
  var StringJoiner = (function () {
      function StringJoiner(parts) {
          if (parts === void 0) { parts = []; }
          this.parts = parts;
      }
      StringJoiner.prototype.add = function (part) { this.parts.push(part); };
      StringJoiner.prototype.toString = function () { return this.parts.join(''); };
      return StringJoiner;
  }());
  var NumberWrapper = (function () {
      function NumberWrapper() {
      }
      NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
      NumberWrapper.equal = function (a, b) { return a === b; };
      NumberWrapper.parseIntAutoRadix = function (text) {
          var result = parseInt(text);
          if (isNaN(result)) {
              throw new Error('Invalid integer literal when parsing ' + text);
          }
          return result;
      };
      NumberWrapper.parseInt = function (text, radix) {
          if (radix == 10) {
              if (/^(\-|\+)?[0-9]+$/.test(text)) {
                  return parseInt(text, radix);
              }
          }
          else if (radix == 16) {
              if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                  return parseInt(text, radix);
              }
          }
          else {
              var result = parseInt(text, radix);
              if (!isNaN(result)) {
                  return result;
              }
          }
          throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
      };
      Object.defineProperty(NumberWrapper, "NaN", {
          get: function () { return NaN; },
          enumerable: true,
          configurable: true
      });
      NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
      NumberWrapper.isNaN = function (value) { return isNaN(value); };
      NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
      return NumberWrapper;
  }());
  function normalizeBlank(obj) {
      return isBlank(obj) ? null : obj;
  }
  function normalizeBool(obj) {
      return isBlank(obj) ? false : obj;
  }
  function isJsObject(o) {
      return o !== null && (typeof o === 'function' || typeof o === 'object');
  }
  function evalExpression(sourceUrl, expr, declarations, vars) {
      var fnBody = declarations + "\nreturn " + expr + "\n//# sourceURL=" + sourceUrl;
      var fnArgNames = [];
      var fnArgValues = [];
      for (var argName in vars) {
          fnArgNames.push(argName);
          fnArgValues.push(vars[argName]);
      }
      return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);
  }
  function isPrimitive(obj) {
      return !isJsObject(obj);
  }
  function escapeRegExp(s) {
      return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }

  /**
   * A segment of text within the template.
   */
  var TextAst = (function () {
      function TextAst(value, ngContentIndex, sourceSpan) {
          this.value = value;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
      return TextAst;
  }());
  /**
   * A bound expression within the text of a template.
   */
  var BoundTextAst = (function () {
      function BoundTextAst(value, ngContentIndex, sourceSpan) {
          this.value = value;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      BoundTextAst.prototype.visit = function (visitor, context) {
          return visitor.visitBoundText(this, context);
      };
      return BoundTextAst;
  }());
  /**
   * A plain attribute on an element.
   */
  var AttrAst = (function () {
      function AttrAst(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };
      return AttrAst;
  }());
  /**
   * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
   * `[@trigger]="stateExp"`)
   */
  var BoundElementPropertyAst = (function () {
      function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {
          this.name = name;
          this.type = type;
          this.securityContext = securityContext;
          this.value = value;
          this.unit = unit;
          this.sourceSpan = sourceSpan;
      }
      BoundElementPropertyAst.prototype.visit = function (visitor, context) {
          return visitor.visitElementProperty(this, context);
      };
      Object.defineProperty(BoundElementPropertyAst.prototype, "isAnimation", {
          get: function () { return this.type === exports.PropertyBindingType.Animation; },
          enumerable: true,
          configurable: true
      });
      return BoundElementPropertyAst;
  }());
  /**
   * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
   * `(@trigger.phase)="callback($event)"`).
   */
  var BoundEventAst = (function () {
      function BoundEventAst(name, target, phase, handler, sourceSpan) {
          this.name = name;
          this.target = target;
          this.phase = phase;
          this.handler = handler;
          this.sourceSpan = sourceSpan;
      }
      BoundEventAst.prototype.visit = function (visitor, context) {
          return visitor.visitEvent(this, context);
      };
      Object.defineProperty(BoundEventAst.prototype, "fullName", {
          get: function () {
              if (isPresent(this.target)) {
                  return this.target + ":" + this.name;
              }
              else {
                  return this.name;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(BoundEventAst.prototype, "isAnimation", {
          get: function () { return !!this.phase; },
          enumerable: true,
          configurable: true
      });
      return BoundEventAst;
  }());
  /**
   * A reference declaration on an element (e.g. `let someName="expression"`).
   */
  var ReferenceAst = (function () {
      function ReferenceAst(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      ReferenceAst.prototype.visit = function (visitor, context) {
          return visitor.visitReference(this, context);
      };
      return ReferenceAst;
  }());
  /**
   * A variable declaration on a <template> (e.g. `var-someName="someLocalName"`).
   */
  var VariableAst = (function () {
      function VariableAst(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      VariableAst.prototype.visit = function (visitor, context) {
          return visitor.visitVariable(this, context);
      };
      return VariableAst;
  }());
  /**
   * An element declaration in a template.
   */
  var ElementAst = (function () {
      function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
          this.name = name;
          this.attrs = attrs;
          this.inputs = inputs;
          this.outputs = outputs;
          this.references = references;
          this.directives = directives;
          this.providers = providers;
          this.hasViewContainer = hasViewContainer;
          this.children = children;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      ElementAst.prototype.visit = function (visitor, context) {
          return visitor.visitElement(this, context);
      };
      return ElementAst;
  }());
  /**
   * A `<template>` element included in an Angular template.
   */
  var EmbeddedTemplateAst = (function () {
      function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, children, ngContentIndex, sourceSpan) {
          this.attrs = attrs;
          this.outputs = outputs;
          this.references = references;
          this.variables = variables;
          this.directives = directives;
          this.providers = providers;
          this.hasViewContainer = hasViewContainer;
          this.children = children;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      EmbeddedTemplateAst.prototype.visit = function (visitor, context) {
          return visitor.visitEmbeddedTemplate(this, context);
      };
      return EmbeddedTemplateAst;
  }());
  /**
   * A directive property with a bound value (e.g. `*ngIf="condition").
   */
  var BoundDirectivePropertyAst = (function () {
      function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {
          this.directiveName = directiveName;
          this.templateName = templateName;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {
          return visitor.visitDirectiveProperty(this, context);
      };
      return BoundDirectivePropertyAst;
  }());
  /**
   * A directive declared on an element.
   */
  var DirectiveAst = (function () {
      function DirectiveAst(directive, inputs, hostProperties, hostEvents, sourceSpan) {
          this.directive = directive;
          this.inputs = inputs;
          this.hostProperties = hostProperties;
          this.hostEvents = hostEvents;
          this.sourceSpan = sourceSpan;
      }
      DirectiveAst.prototype.visit = function (visitor, context) {
          return visitor.visitDirective(this, context);
      };
      return DirectiveAst;
  }());
  /**
   * A provider declared on an element
   */
  var ProviderAst = (function () {
      function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {
          this.token = token;
          this.multiProvider = multiProvider;
          this.eager = eager;
          this.providers = providers;
          this.providerType = providerType;
          this.lifecycleHooks = lifecycleHooks;
          this.sourceSpan = sourceSpan;
      }
      ProviderAst.prototype.visit = function (visitor, context) {
          // No visit method in the visitor for now...
          return null;
      };
      return ProviderAst;
  }());
  exports.ProviderAstType;
  (function (ProviderAstType) {
      ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
      ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
      ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
      ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
      ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
  })(exports.ProviderAstType || (exports.ProviderAstType = {}));
  /**
   * Position where content is to be projected (instance of `<ng-content>` in a template).
   */
  var NgContentAst = (function () {
      function NgContentAst(index, ngContentIndex, sourceSpan) {
          this.index = index;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      NgContentAst.prototype.visit = function (visitor, context) {
          return visitor.visitNgContent(this, context);
      };
      return NgContentAst;
  }());
  /**
   * Enumeration of types of property bindings.
   */
  exports.PropertyBindingType;
  (function (PropertyBindingType) {
      /**
       * A normal binding to a property (e.g. `[property]="expression"`).
       */
      PropertyBindingType[PropertyBindingType["Property"] = 0] = "Property";
      /**
       * A binding to an element attribute (e.g. `[attr.name]="expression"`).
       */
      PropertyBindingType[PropertyBindingType["Attribute"] = 1] = "Attribute";
      /**
       * A binding to a CSS class (e.g. `[class.name]="condition"`).
       */
      PropertyBindingType[PropertyBindingType["Class"] = 2] = "Class";
      /**
       * A binding to a style rule (e.g. `[style.rule]="expression"`).
       */
      PropertyBindingType[PropertyBindingType["Style"] = 3] = "Style";
      /**
       * A binding to an animation reference (e.g. `[animate.key]="expression"`).
       */
      PropertyBindingType[PropertyBindingType["Animation"] = 4] = "Animation";
  })(exports.PropertyBindingType || (exports.PropertyBindingType = {}));
  /**
   * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
   */
  function templateVisitAll(visitor, asts, context) {
      if (context === void 0) { context = null; }
      var result = [];
      asts.forEach(function (ast) {
          var astResult = ast.visit(visitor, context);
          if (isPresent(astResult)) {
              result.push(astResult);
          }
      });
      return result;
  }

  // Safari and Internet Explorer do not support the iterable parameter to the
  // Map constructor.  We work around that by manually adding the items.
  var createMapFromPairs = (function () {
      try {
          if (new Map([[1, 2]]).size === 1) {
              return function createMapFromPairs(pairs) { return new Map(pairs); };
          }
      }
      catch (e) {
      }
      return function createMapAndPopulateFromPairs(pairs) {
          var map = new Map();
          for (var i = 0; i < pairs.length; i++) {
              var pair = pairs[i];
              map.set(pair[0], pair[1]);
          }
          return map;
      };
  })();
  var _clearValues = (function () {
      if ((new Map()).keys().next) {
          return function _clearValues(m) {
              var keyIterator = m.keys();
              var k;
              while (!((k = keyIterator.next()).done)) {
                  m.set(k.value, null);
              }
          };
      }
      else {
          return function _clearValuesWithForeEach(m) {
              m.forEach(function (v, k) { m.set(k, null); });
          };
      }
  })();
  // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
  // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
  var _arrayFromMap = (function () {
      try {
          if ((new Map()).values().next) {
              return function createArrayFromMap(m, getValues) {
                  return getValues ? Array.from(m.values()) : Array.from(m.keys());
              };
          }
      }
      catch (e) {
      }
      return function createArrayFromMapWithForeach(m, getValues) {
          var res = new Array(m.size), i = 0;
          m.forEach(function (v, k) {
              res[i] = getValues ? v : k;
              i++;
          });
          return res;
      };
  })();
  var MapWrapper = (function () {
      function MapWrapper() {
      }
      MapWrapper.createFromStringMap = function (stringMap) {
          var result = new Map();
          for (var prop in stringMap) {
              result.set(prop, stringMap[prop]);
          }
          return result;
      };
      MapWrapper.toStringMap = function (m) {
          var r = {};
          m.forEach(function (v, k) { return r[k] = v; });
          return r;
      };
      MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };
      MapWrapper.iterable = function (m) { return m; };
      MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
      MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
      return MapWrapper;
  }());
  /**
   * Wraps Javascript Objects
   */
  var StringMapWrapper = (function () {
      function StringMapWrapper() {
      }
      StringMapWrapper.merge = function (m1, m2) {
          var m = {};
          for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
              var k = _a[_i];
              m[k] = m1[k];
          }
          for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
              var k = _c[_b];
              m[k] = m2[k];
          }
          return m;
      };
      StringMapWrapper.equals = function (m1, m2) {
          var k1 = Object.keys(m1);
          var k2 = Object.keys(m2);
          if (k1.length != k2.length) {
              return false;
          }
          for (var i = 0; i < k1.length; i++) {
              var key = k1[i];
              if (m1[key] !== m2[key]) {
                  return false;
              }
          }
          return true;
      };
      return StringMapWrapper;
  }());
  var ListWrapper = (function () {
      function ListWrapper() {
      }
      // JS has no way to express a statically fixed size list, but dart does so we
      // keep both methods.
      ListWrapper.createFixedSize = function (size) { return new Array(size); };
      ListWrapper.createGrowableSize = function (size) { return new Array(size); };
      ListWrapper.clone = function (array) { return array.slice(0); };
      ListWrapper.forEachWithIndex = function (array, fn) {
          for (var i = 0; i < array.length; i++) {
              fn(array[i], i);
          }
      };
      ListWrapper.first = function (array) {
          if (!array)
              return null;
          return array[0];
      };
      ListWrapper.last = function (array) {
          if (!array || array.length == 0)
              return null;
          return array[array.length - 1];
      };
      ListWrapper.indexOf = function (array, value, startIndex) {
          if (startIndex === void 0) { startIndex = 0; }
          return array.indexOf(value, startIndex);
      };
      ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
      ListWrapper.reversed = function (array) {
          var a = ListWrapper.clone(array);
          return a.reverse();
      };
      ListWrapper.concat = function (a, b) { return a.concat(b); };
      ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
      ListWrapper.removeAt = function (list, index) {
          var res = list[index];
          list.splice(index, 1);
          return res;
      };
      ListWrapper.removeAll = function (list, items) {
          for (var i = 0; i < items.length; ++i) {
              var index = list.indexOf(items[i]);
              list.splice(index, 1);
          }
      };
      ListWrapper.remove = function (list, el) {
          var index = list.indexOf(el);
          if (index > -1) {
              list.splice(index, 1);
              return true;
          }
          return false;
      };
      ListWrapper.clear = function (list) { list.length = 0; };
      ListWrapper.isEmpty = function (list) { return list.length == 0; };
      ListWrapper.fill = function (list, value, start, end) {
          if (start === void 0) { start = 0; }
          if (end === void 0) { end = null; }
          list.fill(value, start, end === null ? list.length : end);
      };
      ListWrapper.equals = function (a, b) {
          if (a.length != b.length)
              return false;
          for (var i = 0; i < a.length; ++i) {
              if (a[i] !== b[i])
                  return false;
          }
          return true;
      };
      ListWrapper.slice = function (l, from, to) {
          if (from === void 0) { from = 0; }
          if (to === void 0) { to = null; }
          return l.slice(from, to === null ? undefined : to);
      };
      ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
      ListWrapper.sort = function (l, compareFn) {
          if (isPresent(compareFn)) {
              l.sort(compareFn);
          }
          else {
              l.sort();
          }
      };
      ListWrapper.toString = function (l) { return l.toString(); };
      ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
      ListWrapper.maximum = function (list, predicate) {
          if (list.length == 0) {
              return null;
          }
          var solution = null;
          var maxValue = -Infinity;
          for (var index = 0; index < list.length; index++) {
              var candidate = list[index];
              if (isBlank(candidate)) {
                  continue;
              }
              var candidateValue = predicate(candidate);
              if (candidateValue > maxValue) {
                  solution = candidate;
                  maxValue = candidateValue;
              }
          }
          return solution;
      };
      ListWrapper.flatten = function (list) {
          var target = [];
          _flattenArray(list, target);
          return target;
      };
      ListWrapper.addAll = function (list, source) {
          for (var i = 0; i < source.length; i++) {
              list.push(source[i]);
          }
      };
      return ListWrapper;
  }());
  function _flattenArray(source, target) {
      if (isPresent(source)) {
          for (var i = 0; i < source.length; i++) {
              var item = source[i];
              if (isArray(item)) {
                  _flattenArray(item, target);
              }
              else {
                  target.push(item);
              }
          }
      }
      return target;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TagContentType;
  (function (TagContentType) {
      TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
      TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
      TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
  })(TagContentType || (TagContentType = {}));
  function splitNsName(elementName) {
      if (elementName[0] != ':') {
          return [null, elementName];
      }
      var colonIndex = elementName.indexOf(':', 1);
      if (colonIndex == -1) {
          throw new Error("Unsupported format \"" + elementName + "\" expecting \":namespace:name\"");
      }
      return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
  }
  function getNsPrefix(fullName) {
      return fullName === null ? null : splitNsName(fullName)[0];
  }
  function mergeNsAndName(prefix, localName) {
      return prefix ? ":" + prefix + ":" + localName : localName;
  }
  // see http://www.w3.org/TR/html51/syntax.html#named-character-references
  // see https://html.spec.whatwg.org/multipage/entities.json
  // This list is not exhaustive to keep the compiler footprint low.
  // The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.
  var NAMED_ENTITIES = {
      'Aacute': '\u00C1',
      'aacute': '\u00E1',
      'Acirc': '\u00C2',
      'acirc': '\u00E2',
      'acute': '\u00B4',
      'AElig': '\u00C6',
      'aelig': '\u00E6',
      'Agrave': '\u00C0',
      'agrave': '\u00E0',
      'alefsym': '\u2135',
      'Alpha': '\u0391',
      'alpha': '\u03B1',
      'amp': '&',
      'and': '\u2227',
      'ang': '\u2220',
      'apos': '\u0027',
      'Aring': '\u00C5',
      'aring': '\u00E5',
      'asymp': '\u2248',
      'Atilde': '\u00C3',
      'atilde': '\u00E3',
      'Auml': '\u00C4',
      'auml': '\u00E4',
      'bdquo': '\u201E',
      'Beta': '\u0392',
      'beta': '\u03B2',
      'brvbar': '\u00A6',
      'bull': '\u2022',
      'cap': '\u2229',
      'Ccedil': '\u00C7',
      'ccedil': '\u00E7',
      'cedil': '\u00B8',
      'cent': '\u00A2',
      'Chi': '\u03A7',
      'chi': '\u03C7',
      'circ': '\u02C6',
      'clubs': '\u2663',
      'cong': '\u2245',
      'copy': '\u00A9',
      'crarr': '\u21B5',
      'cup': '\u222A',
      'curren': '\u00A4',
      'dagger': '\u2020',
      'Dagger': '\u2021',
      'darr': '\u2193',
      'dArr': '\u21D3',
      'deg': '\u00B0',
      'Delta': '\u0394',
      'delta': '\u03B4',
      'diams': '\u2666',
      'divide': '\u00F7',
      'Eacute': '\u00C9',
      'eacute': '\u00E9',
      'Ecirc': '\u00CA',
      'ecirc': '\u00EA',
      'Egrave': '\u00C8',
      'egrave': '\u00E8',
      'empty': '\u2205',
      'emsp': '\u2003',
      'ensp': '\u2002',
      'Epsilon': '\u0395',
      'epsilon': '\u03B5',
      'equiv': '\u2261',
      'Eta': '\u0397',
      'eta': '\u03B7',
      'ETH': '\u00D0',
      'eth': '\u00F0',
      'Euml': '\u00CB',
      'euml': '\u00EB',
      'euro': '\u20AC',
      'exist': '\u2203',
      'fnof': '\u0192',
      'forall': '\u2200',
      'frac12': '\u00BD',
      'frac14': '\u00BC',
      'frac34': '\u00BE',
      'frasl': '\u2044',
      'Gamma': '\u0393',
      'gamma': '\u03B3',
      'ge': '\u2265',
      'gt': '>',
      'harr': '\u2194',
      'hArr': '\u21D4',
      'hearts': '\u2665',
      'hellip': '\u2026',
      'Iacute': '\u00CD',
      'iacute': '\u00ED',
      'Icirc': '\u00CE',
      'icirc': '\u00EE',
      'iexcl': '\u00A1',
      'Igrave': '\u00CC',
      'igrave': '\u00EC',
      'image': '\u2111',
      'infin': '\u221E',
      'int': '\u222B',
      'Iota': '\u0399',
      'iota': '\u03B9',
      'iquest': '\u00BF',
      'isin': '\u2208',
      'Iuml': '\u00CF',
      'iuml': '\u00EF',
      'Kappa': '\u039A',
      'kappa': '\u03BA',
      'Lambda': '\u039B',
      'lambda': '\u03BB',
      'lang': '\u27E8',
      'laquo': '\u00AB',
      'larr': '\u2190',
      'lArr': '\u21D0',
      'lceil': '\u2308',
      'ldquo': '\u201C',
      'le': '\u2264',
      'lfloor': '\u230A',
      'lowast': '\u2217',
      'loz': '\u25CA',
      'lrm': '\u200E',
      'lsaquo': '\u2039',
      'lsquo': '\u2018',
      'lt': '<',
      'macr': '\u00AF',
      'mdash': '\u2014',
      'micro': '\u00B5',
      'middot': '\u00B7',
      'minus': '\u2212',
      'Mu': '\u039C',
      'mu': '\u03BC',
      'nabla': '\u2207',
      'nbsp': '\u00A0',
      'ndash': '\u2013',
      'ne': '\u2260',
      'ni': '\u220B',
      'not': '\u00AC',
      'notin': '\u2209',
      'nsub': '\u2284',
      'Ntilde': '\u00D1',
      'ntilde': '\u00F1',
      'Nu': '\u039D',
      'nu': '\u03BD',
      'Oacute': '\u00D3',
      'oacute': '\u00F3',
      'Ocirc': '\u00D4',
      'ocirc': '\u00F4',
      'OElig': '\u0152',
      'oelig': '\u0153',
      'Ograve': '\u00D2',
      'ograve': '\u00F2',
      'oline': '\u203E',
      'Omega': '\u03A9',
      'omega': '\u03C9',
      'Omicron': '\u039F',
      'omicron': '\u03BF',
      'oplus': '\u2295',
      'or': '\u2228',
      'ordf': '\u00AA',
      'ordm': '\u00BA',
      'Oslash': '\u00D8',
      'oslash': '\u00F8',
      'Otilde': '\u00D5',
      'otilde': '\u00F5',
      'otimes': '\u2297',
      'Ouml': '\u00D6',
      'ouml': '\u00F6',
      'para': '\u00B6',
      'permil': '\u2030',
      'perp': '\u22A5',
      'Phi': '\u03A6',
      'phi': '\u03C6',
      'Pi': '\u03A0',
      'pi': '\u03C0',
      'piv': '\u03D6',
      'plusmn': '\u00B1',
      'pound': '\u00A3',
      'prime': '\u2032',
      'Prime': '\u2033',
      'prod': '\u220F',
      'prop': '\u221D',
      'Psi': '\u03A8',
      'psi': '\u03C8',
      'quot': '\u0022',
      'radic': '\u221A',
      'rang': '\u27E9',
      'raquo': '\u00BB',
      'rarr': '\u2192',
      'rArr': '\u21D2',
      'rceil': '\u2309',
      'rdquo': '\u201D',
      'real': '\u211C',
      'reg': '\u00AE',
      'rfloor': '\u230B',
      'Rho': '\u03A1',
      'rho': '\u03C1',
      'rlm': '\u200F',
      'rsaquo': '\u203A',
      'rsquo': '\u2019',
      'sbquo': '\u201A',
      'Scaron': '\u0160',
      'scaron': '\u0161',
      'sdot': '\u22C5',
      'sect': '\u00A7',
      'shy': '\u00AD',
      'Sigma': '\u03A3',
      'sigma': '\u03C3',
      'sigmaf': '\u03C2',
      'sim': '\u223C',
      'spades': '\u2660',
      'sub': '\u2282',
      'sube': '\u2286',
      'sum': '\u2211',
      'sup': '\u2283',
      'sup1': '\u00B9',
      'sup2': '\u00B2',
      'sup3': '\u00B3',
      'supe': '\u2287',
      'szlig': '\u00DF',
      'Tau': '\u03A4',
      'tau': '\u03C4',
      'there4': '\u2234',
      'Theta': '\u0398',
      'theta': '\u03B8',
      'thetasym': '\u03D1',
      'thinsp': '\u2009',
      'THORN': '\u00DE',
      'thorn': '\u00FE',
      'tilde': '\u02DC',
      'times': '\u00D7',
      'trade': '\u2122',
      'Uacute': '\u00DA',
      'uacute': '\u00FA',
      'uarr': '\u2191',
      'uArr': '\u21D1',
      'Ucirc': '\u00DB',
      'ucirc': '\u00FB',
      'Ugrave': '\u00D9',
      'ugrave': '\u00F9',
      'uml': '\u00A8',
      'upsih': '\u03D2',
      'Upsilon': '\u03A5',
      'upsilon': '\u03C5',
      'Uuml': '\u00DC',
      'uuml': '\u00FC',
      'weierp': '\u2118',
      'Xi': '\u039E',
      'xi': '\u03BE',
      'Yacute': '\u00DD',
      'yacute': '\u00FD',
      'yen': '\u00A5',
      'yuml': '\u00FF',
      'Yuml': '\u0178',
      'Zeta': '\u0396',
      'zeta': '\u03B6',
      'zwj': '\u200D',
      'zwnj': '\u200C',
  };

  var HtmlTagDefinition = (function () {
      function HtmlTagDefinition(_a) {
          var _this = this;
          var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;
          this.closedByChildren = {};
          this.closedByParent = false;
          this.canSelfClose = false;
          if (closedByChildren && closedByChildren.length > 0) {
              closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });
          }
          this.isVoid = isVoid;
          this.closedByParent = closedByParent || isVoid;
          if (requiredParents && requiredParents.length > 0) {
              this.requiredParents = {};
              // The first parent is the list is automatically when none of the listed parents are present
              this.parentToAdd = requiredParents[0];
              requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });
          }
          this.implicitNamespacePrefix = implicitNamespacePrefix;
          this.contentType = contentType;
          this.ignoreFirstLf = ignoreFirstLf;
      }
      HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {
          if (!this.requiredParents) {
              return false;
          }
          if (!currentParent) {
              return true;
          }
          var lcParent = currentParent.toLowerCase();
          return this.requiredParents[lcParent] != true && lcParent != 'template';
      };
      HtmlTagDefinition.prototype.isClosedByChild = function (name) {
          return this.isVoid || name.toLowerCase() in this.closedByChildren;
      };
      return HtmlTagDefinition;
  }());
  // see http://www.w3.org/TR/html51/syntax.html#optional-tags
  // This implementation does not fully conform to the HTML5 spec.
  var TAG_DEFINITIONS = {
      'base': new HtmlTagDefinition({ isVoid: true }),
      'meta': new HtmlTagDefinition({ isVoid: true }),
      'area': new HtmlTagDefinition({ isVoid: true }),
      'embed': new HtmlTagDefinition({ isVoid: true }),
      'link': new HtmlTagDefinition({ isVoid: true }),
      'img': new HtmlTagDefinition({ isVoid: true }),
      'input': new HtmlTagDefinition({ isVoid: true }),
      'param': new HtmlTagDefinition({ isVoid: true }),
      'hr': new HtmlTagDefinition({ isVoid: true }),
      'br': new HtmlTagDefinition({ isVoid: true }),
      'source': new HtmlTagDefinition({ isVoid: true }),
      'track': new HtmlTagDefinition({ isVoid: true }),
      'wbr': new HtmlTagDefinition({ isVoid: true }),
      'p': new HtmlTagDefinition({
          closedByChildren: [
              'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',
              'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',
              'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'
          ],
          closedByParent: true
      }),
      'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
      'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
      'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
      'tr': new HtmlTagDefinition({
          closedByChildren: ['tr'],
          requiredParents: ['tbody', 'tfoot', 'thead'],
          closedByParent: true
      }),
      'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
      'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
      'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),
      'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
      'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
      'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
      'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
      'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
      'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
      'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
      'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
      'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
      'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
      'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
      'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
      'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
      'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
      'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
      'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),
      'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),
  };
  var _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
  function getHtmlTagDefinition(tagName) {
      return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;
  }

  var _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' +
      '([-\\w]+)|' +
      '(?:\\.([-\\w]+))|' +
      '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' +
      '(\\))|' +
      '(\\s*,\\s*)', // ","
  'g');
  /**
   * A css selector contains an element name,
   * css classes and attribute/value pairs with the purpose
   * of selecting subsets out of them.
   */
  var CssSelector = (function () {
      function CssSelector() {
          this.element = null;
          this.classNames = [];
          this.attrs = [];
          this.notSelectors = [];
      }
      CssSelector.parse = function (selector) {
          var results = [];
          var _addResult = function (res, cssSel) {
              if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&
                  cssSel.attrs.length == 0) {
                  cssSel.element = '*';
              }
              res.push(cssSel);
          };
          var cssSelector = new CssSelector();
          var match;
          var current = cssSelector;
          var inNot = false;
          _SELECTOR_REGEXP.lastIndex = 0;
          while (match = _SELECTOR_REGEXP.exec(selector)) {
              if (match[1]) {
                  if (inNot) {
                      throw new Error('Nesting :not is not allowed in a selector');
                  }
                  inNot = true;
                  current = new CssSelector();
                  cssSelector.notSelectors.push(current);
              }
              if (match[2]) {
                  current.setElement(match[2]);
              }
              if (match[3]) {
                  current.addClassName(match[3]);
              }
              if (match[4]) {
                  current.addAttribute(match[4], match[5]);
              }
              if (match[6]) {
                  inNot = false;
                  current = cssSelector;
              }
              if (match[7]) {
                  if (inNot) {
                      throw new Error('Multiple selectors in :not are not supported');
                  }
                  _addResult(results, cssSelector);
                  cssSelector = current = new CssSelector();
              }
          }
          _addResult(results, cssSelector);
          return results;
      };
      CssSelector.prototype.isElementSelector = function () {
          return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&
              this.notSelectors.length === 0;
      };
      CssSelector.prototype.hasElementSelector = function () { return !!this.element; };
      CssSelector.prototype.setElement = function (element) {
          if (element === void 0) { element = null; }
          this.element = element;
      };
      /** Gets a template string for an element that matches the selector. */
      CssSelector.prototype.getMatchingElementTemplate = function () {
          var tagName = this.element || 'div';
          var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
          var attrs = '';
          for (var i = 0; i < this.attrs.length; i += 2) {
              var attrName = this.attrs[i];
              var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
              attrs += " " + attrName + attrValue;
          }
          return getHtmlTagDefinition(tagName).isVoid ? "<" + tagName + classAttr + attrs + "/>" :
              "<" + tagName + classAttr + attrs + "></" + tagName + ">";
      };
      CssSelector.prototype.addAttribute = function (name, value) {
          if (value === void 0) { value = ''; }
          this.attrs.push(name, value && value.toLowerCase() || '');
      };
      CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };
      CssSelector.prototype.toString = function () {
          var res = this.element || '';
          if (this.classNames) {
              this.classNames.forEach(function (klass) { return res += "." + klass; });
          }
          if (this.attrs) {
              for (var i = 0; i < this.attrs.length; i += 2) {
                  var name_1 = this.attrs[i];
                  var value = this.attrs[i + 1];
                  res += "[" + name_1 + (value ? '=' + value : '') + "]";
              }
          }
          this.notSelectors.forEach(function (notSelector) { return res += ":not(" + notSelector + ")"; });
          return res;
      };
      return CssSelector;
  }());
  /**
   * Reads a list of CssSelectors and allows to calculate which ones
   * are contained in a given CssSelector.
   */
  var SelectorMatcher = (function () {
      function SelectorMatcher() {
          this._elementMap = {};
          this._elementPartialMap = {};
          this._classMap = {};
          this._classPartialMap = {};
          this._attrValueMap = {};
          this._attrValuePartialMap = {};
          this._listContexts = [];
      }
      SelectorMatcher.createNotMatcher = function (notSelectors) {
          var notMatcher = new SelectorMatcher();
          notMatcher.addSelectables(notSelectors, null);
          return notMatcher;
      };
      SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {
          var listContext = null;
          if (cssSelectors.length > 1) {
              listContext = new SelectorListContext(cssSelectors);
              this._listContexts.push(listContext);
          }
          for (var i = 0; i < cssSelectors.length; i++) {
              this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
          }
      };
      /**
       * Add an object that can be found later on by calling `match`.
       * @param cssSelector A css selector
       * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
       */
      SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {
          var matcher = this;
          var element = cssSelector.element;
          var classNames = cssSelector.classNames;
          var attrs = cssSelector.attrs;
          var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
          if (element) {
              var isTerminal = attrs.length === 0 && classNames.length === 0;
              if (isTerminal) {
                  this._addTerminal(matcher._elementMap, element, selectable);
              }
              else {
                  matcher = this._addPartial(matcher._elementPartialMap, element);
              }
          }
          if (classNames) {
              for (var i = 0; i < classNames.length; i++) {
                  var isTerminal = attrs.length === 0 && i === classNames.length - 1;
                  var className = classNames[i];
                  if (isTerminal) {
                      this._addTerminal(matcher._classMap, className, selectable);
                  }
                  else {
                      matcher = this._addPartial(matcher._classPartialMap, className);
                  }
              }
          }
          if (attrs) {
              for (var i = 0; i < attrs.length; i += 2) {
                  var isTerminal = i === attrs.length - 2;
                  var name_2 = attrs[i];
                  var value = attrs[i + 1];
                  if (isTerminal) {
                      var terminalMap = matcher._attrValueMap;
                      var terminalValuesMap = terminalMap[name_2];
                      if (!terminalValuesMap) {
                          terminalValuesMap = {};
                          terminalMap[name_2] = terminalValuesMap;
                      }
                      this._addTerminal(terminalValuesMap, value, selectable);
                  }
                  else {
                      var partialMap = matcher._attrValuePartialMap;
                      var partialValuesMap = partialMap[name_2];
                      if (!partialValuesMap) {
                          partialValuesMap = {};
                          partialMap[name_2] = partialValuesMap;
                      }
                      matcher = this._addPartial(partialValuesMap, value);
                  }
              }
          }
      };
      SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {
          var terminalList = map[name];
          if (!terminalList) {
              terminalList = [];
              map[name] = terminalList;
          }
          terminalList.push(selectable);
      };
      SelectorMatcher.prototype._addPartial = function (map, name) {
          var matcher = map[name];
          if (!matcher) {
              matcher = new SelectorMatcher();
              map[name] = matcher;
          }
          return matcher;
      };
      /**
       * Find the objects that have been added via `addSelectable`
       * whose css selector is contained in the given css selector.
       * @param cssSelector A css selector
       * @param matchedCallback This callback will be called with the object handed into `addSelectable`
       * @return boolean true if a match was found
      */
      SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {
          var result = false;
          var element = cssSelector.element;
          var classNames = cssSelector.classNames;
          var attrs = cssSelector.attrs;
          for (var i = 0; i < this._listContexts.length; i++) {
              this._listContexts[i].alreadyMatched = false;
          }
          result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
          result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
              result;
          if (classNames) {
              for (var i = 0; i < classNames.length; i++) {
                  var className = classNames[i];
                  result =
                      this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                  result =
                      this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
                          result;
              }
          }
          if (attrs) {
              for (var i = 0; i < attrs.length; i += 2) {
                  var name_3 = attrs[i];
                  var value = attrs[i + 1];
                  var terminalValuesMap = this._attrValueMap[name_3];
                  if (value) {
                      result =
                          this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
                  }
                  result =
                      this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
                  var partialValuesMap = this._attrValuePartialMap[name_3];
                  if (value) {
                      result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
                  }
                  result =
                      this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
              }
          }
          return result;
      };
      /** @internal */
      SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {
          if (!map || typeof name !== 'string') {
              return false;
          }
          var selectables = map[name];
          var starSelectables = map['*'];
          if (starSelectables) {
              selectables = selectables.concat(starSelectables);
          }
          if (!selectables) {
              return false;
          }
          var selectable;
          var result = false;
          for (var i = 0; i < selectables.length; i++) {
              selectable = selectables[i];
              result = selectable.finalize(cssSelector, matchedCallback) || result;
          }
          return result;
      };
      /** @internal */
      SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {
          if (!map || typeof name !== 'string') {
              return false;
          }
          var nestedSelector = map[name];
          if (!nestedSelector) {
              return false;
          }
          // TODO(perf): get rid of recursion and measure again
          // TODO(perf): don't pass the whole selector into the recursion,
          // but only the not processed parts
          return nestedSelector.match(cssSelector, matchedCallback);
      };
      return SelectorMatcher;
  }());
  var SelectorListContext = (function () {
      function SelectorListContext(selectors) {
          this.selectors = selectors;
          this.alreadyMatched = false;
      }
      return SelectorListContext;
  }());
  // Store context to pass back selector and context when a selector is matched
  var SelectorContext = (function () {
      function SelectorContext(selector, cbContext, listContext) {
          this.selector = selector;
          this.cbContext = cbContext;
          this.listContext = listContext;
          this.notSelectors = selector.notSelectors;
      }
      SelectorContext.prototype.finalize = function (cssSelector, callback) {
          var result = true;
          if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
              var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
              result = !notMatcher.match(cssSelector, null);
          }
          if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
              if (this.listContext) {
                  this.listContext.alreadyMatched = true;
              }
              callback(this.selector, this.cbContext);
          }
          return result;
      };
      return SelectorContext;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$2 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  //// Types
  var TypeModifier;
  (function (TypeModifier) {
      TypeModifier[TypeModifier["Const"] = 0] = "Const";
  })(TypeModifier || (TypeModifier = {}));
  var Type$1 = (function () {
      function Type(modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          this.modifiers = modifiers;
          if (!modifiers) {
              this.modifiers = [];
          }
      }
      Type.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
      return Type;
  }());
  var BuiltinTypeName;
  (function (BuiltinTypeName) {
      BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
      BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
      BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
      BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
      BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
      BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
  })(BuiltinTypeName || (BuiltinTypeName = {}));
  var BuiltinType = (function (_super) {
      __extends$2(BuiltinType, _super);
      function BuiltinType(name, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.name = name;
      }
      BuiltinType.prototype.visitType = function (visitor, context) {
          return visitor.visitBuiltintType(this, context);
      };
      return BuiltinType;
  }(Type$1));
  var ExternalType = (function (_super) {
      __extends$2(ExternalType, _super);
      function ExternalType(value, typeParams, modifiers) {
          if (typeParams === void 0) { typeParams = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.value = value;
          this.typeParams = typeParams;
      }
      ExternalType.prototype.visitType = function (visitor, context) {
          return visitor.visitExternalType(this, context);
      };
      return ExternalType;
  }(Type$1));
  var ArrayType = (function (_super) {
      __extends$2(ArrayType, _super);
      function ArrayType(of, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.of = of;
      }
      ArrayType.prototype.visitType = function (visitor, context) {
          return visitor.visitArrayType(this, context);
      };
      return ArrayType;
  }(Type$1));
  var MapType = (function (_super) {
      __extends$2(MapType, _super);
      function MapType(valueType, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.valueType = valueType;
      }
      MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };
      return MapType;
  }(Type$1));
  var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
  var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
  var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
  var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
  var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
  var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
  ///// Expressions
  var BinaryOperator;
  (function (BinaryOperator) {
      BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
      BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
      BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
      BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
      BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
      BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
      BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
      BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
      BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
      BinaryOperator[BinaryOperator["And"] = 9] = "And";
      BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
      BinaryOperator[BinaryOperator["Lower"] = 11] = "Lower";
      BinaryOperator[BinaryOperator["LowerEquals"] = 12] = "LowerEquals";
      BinaryOperator[BinaryOperator["Bigger"] = 13] = "Bigger";
      BinaryOperator[BinaryOperator["BiggerEquals"] = 14] = "BiggerEquals";
  })(BinaryOperator || (BinaryOperator = {}));
  var Expression = (function () {
      function Expression(type) {
          this.type = type;
      }
      Expression.prototype.prop = function (name) { return new ReadPropExpr(this, name); };
      Expression.prototype.key = function (index, type) {
          if (type === void 0) { type = null; }
          return new ReadKeyExpr(this, index, type);
      };
      Expression.prototype.callMethod = function (name, params) {
          return new InvokeMethodExpr(this, name, params);
      };
      Expression.prototype.callFn = function (params) { return new InvokeFunctionExpr(this, params); };
      Expression.prototype.instantiate = function (params, type) {
          if (type === void 0) { type = null; }
          return new InstantiateExpr(this, params, type);
      };
      Expression.prototype.conditional = function (trueCase, falseCase) {
          if (falseCase === void 0) { falseCase = null; }
          return new ConditionalExpr(this, trueCase, falseCase);
      };
      Expression.prototype.equals = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs);
      };
      Expression.prototype.notEquals = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs);
      };
      Expression.prototype.identical = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs);
      };
      Expression.prototype.notIdentical = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs);
      };
      Expression.prototype.minus = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs);
      };
      Expression.prototype.plus = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs);
      };
      Expression.prototype.divide = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs);
      };
      Expression.prototype.multiply = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs);
      };
      Expression.prototype.modulo = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs);
      };
      Expression.prototype.and = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.And, this, rhs);
      };
      Expression.prototype.or = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs);
      };
      Expression.prototype.lower = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs);
      };
      Expression.prototype.lowerEquals = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs);
      };
      Expression.prototype.bigger = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs);
      };
      Expression.prototype.biggerEquals = function (rhs) {
          return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs);
      };
      Expression.prototype.isBlank = function () {
          // Note: We use equals by purpose here to compare to null and undefined in JS.
          return this.equals(NULL_EXPR);
      };
      Expression.prototype.cast = function (type) { return new CastExpr(this, type); };
      Expression.prototype.toStmt = function () { return new ExpressionStatement(this); };
      return Expression;
  }());
  var BuiltinVar;
  (function (BuiltinVar) {
      BuiltinVar[BuiltinVar["This"] = 0] = "This";
      BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
      BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
      BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
  })(BuiltinVar || (BuiltinVar = {}));
  var ReadVarExpr = (function (_super) {
      __extends$2(ReadVarExpr, _super);
      function ReadVarExpr(name, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          if (isString(name)) {
              this.name = name;
              this.builtin = null;
          }
          else {
              this.name = null;
              this.builtin = name;
          }
      }
      ReadVarExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitReadVarExpr(this, context);
      };
      ReadVarExpr.prototype.set = function (value) { return new WriteVarExpr(this.name, value); };
      return ReadVarExpr;
  }(Expression));
  var WriteVarExpr = (function (_super) {
      __extends$2(WriteVarExpr, _super);
      function WriteVarExpr(name, value, type) {
          if (type === void 0) { type = null; }
          _super.call(this, isPresent(type) ? type : value.type);
          this.name = name;
          this.value = value;
      }
      WriteVarExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitWriteVarExpr(this, context);
      };
      WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          return new DeclareVarStmt(this.name, this.value, type, modifiers);
      };
      return WriteVarExpr;
  }(Expression));
  var WriteKeyExpr = (function (_super) {
      __extends$2(WriteKeyExpr, _super);
      function WriteKeyExpr(receiver, index, value, type) {
          if (type === void 0) { type = null; }
          _super.call(this, isPresent(type) ? type : value.type);
          this.receiver = receiver;
          this.index = index;
          this.value = value;
      }
      WriteKeyExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitWriteKeyExpr(this, context);
      };
      return WriteKeyExpr;
  }(Expression));
  var WritePropExpr = (function (_super) {
      __extends$2(WritePropExpr, _super);
      function WritePropExpr(receiver, name, value, type) {
          if (type === void 0) { type = null; }
          _super.call(this, isPresent(type) ? type : value.type);
          this.receiver = receiver;
          this.name = name;
          this.value = value;
      }
      WritePropExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitWritePropExpr(this, context);
      };
      return WritePropExpr;
  }(Expression));
  var BuiltinMethod;
  (function (BuiltinMethod) {
      BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
      BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
      BuiltinMethod[BuiltinMethod["Bind"] = 2] = "Bind";
  })(BuiltinMethod || (BuiltinMethod = {}));
  var InvokeMethodExpr = (function (_super) {
      __extends$2(InvokeMethodExpr, _super);
      function InvokeMethodExpr(receiver, method, args, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.receiver = receiver;
          this.args = args;
          if (isString(method)) {
              this.name = method;
              this.builtin = null;
          }
          else {
              this.name = null;
              this.builtin = method;
          }
      }
      InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitInvokeMethodExpr(this, context);
      };
      return InvokeMethodExpr;
  }(Expression));
  var InvokeFunctionExpr = (function (_super) {
      __extends$2(InvokeFunctionExpr, _super);
      function InvokeFunctionExpr(fn, args, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.fn = fn;
          this.args = args;
      }
      InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitInvokeFunctionExpr(this, context);
      };
      return InvokeFunctionExpr;
  }(Expression));
  var InstantiateExpr = (function (_super) {
      __extends$2(InstantiateExpr, _super);
      function InstantiateExpr(classExpr, args, type) {
          _super.call(this, type);
          this.classExpr = classExpr;
          this.args = args;
      }
      InstantiateExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitInstantiateExpr(this, context);
      };
      return InstantiateExpr;
  }(Expression));
  var LiteralExpr = (function (_super) {
      __extends$2(LiteralExpr, _super);
      function LiteralExpr(value, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.value = value;
      }
      LiteralExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitLiteralExpr(this, context);
      };
      return LiteralExpr;
  }(Expression));
  var ExternalExpr = (function (_super) {
      __extends$2(ExternalExpr, _super);
      function ExternalExpr(value, type, typeParams) {
          if (type === void 0) { type = null; }
          if (typeParams === void 0) { typeParams = null; }
          _super.call(this, type);
          this.value = value;
          this.typeParams = typeParams;
      }
      ExternalExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitExternalExpr(this, context);
      };
      return ExternalExpr;
  }(Expression));
  var ConditionalExpr = (function (_super) {
      __extends$2(ConditionalExpr, _super);
      function ConditionalExpr(condition, trueCase, falseCase, type) {
          if (falseCase === void 0) { falseCase = null; }
          if (type === void 0) { type = null; }
          _super.call(this, isPresent(type) ? type : trueCase.type);
          this.condition = condition;
          this.falseCase = falseCase;
          this.trueCase = trueCase;
      }
      ConditionalExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitConditionalExpr(this, context);
      };
      return ConditionalExpr;
  }(Expression));
  var NotExpr = (function (_super) {
      __extends$2(NotExpr, _super);
      function NotExpr(condition) {
          _super.call(this, BOOL_TYPE);
          this.condition = condition;
      }
      NotExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitNotExpr(this, context);
      };
      return NotExpr;
  }(Expression));
  var CastExpr = (function (_super) {
      __extends$2(CastExpr, _super);
      function CastExpr(value, type) {
          _super.call(this, type);
          this.value = value;
      }
      CastExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitCastExpr(this, context);
      };
      return CastExpr;
  }(Expression));
  var FnParam = (function () {
      function FnParam(name, type) {
          if (type === void 0) { type = null; }
          this.name = name;
          this.type = type;
      }
      return FnParam;
  }());
  var FunctionExpr = (function (_super) {
      __extends$2(FunctionExpr, _super);
      function FunctionExpr(params, statements, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.params = params;
          this.statements = statements;
      }
      FunctionExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitFunctionExpr(this, context);
      };
      FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers);
      };
      return FunctionExpr;
  }(Expression));
  var BinaryOperatorExpr = (function (_super) {
      __extends$2(BinaryOperatorExpr, _super);
      function BinaryOperatorExpr(operator, lhs, rhs, type) {
          if (type === void 0) { type = null; }
          _super.call(this, isPresent(type) ? type : lhs.type);
          this.operator = operator;
          this.rhs = rhs;
          this.lhs = lhs;
      }
      BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitBinaryOperatorExpr(this, context);
      };
      return BinaryOperatorExpr;
  }(Expression));
  var ReadPropExpr = (function (_super) {
      __extends$2(ReadPropExpr, _super);
      function ReadPropExpr(receiver, name, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.receiver = receiver;
          this.name = name;
      }
      ReadPropExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitReadPropExpr(this, context);
      };
      ReadPropExpr.prototype.set = function (value) {
          return new WritePropExpr(this.receiver, this.name, value);
      };
      return ReadPropExpr;
  }(Expression));
  var ReadKeyExpr = (function (_super) {
      __extends$2(ReadKeyExpr, _super);
      function ReadKeyExpr(receiver, index, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.receiver = receiver;
          this.index = index;
      }
      ReadKeyExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitReadKeyExpr(this, context);
      };
      ReadKeyExpr.prototype.set = function (value) {
          return new WriteKeyExpr(this.receiver, this.index, value);
      };
      return ReadKeyExpr;
  }(Expression));
  var LiteralArrayExpr = (function (_super) {
      __extends$2(LiteralArrayExpr, _super);
      function LiteralArrayExpr(entries, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.entries = entries;
      }
      LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitLiteralArrayExpr(this, context);
      };
      return LiteralArrayExpr;
  }(Expression));
  var LiteralMapExpr = (function (_super) {
      __extends$2(LiteralMapExpr, _super);
      function LiteralMapExpr(entries, type) {
          if (type === void 0) { type = null; }
          _super.call(this, type);
          this.entries = entries;
          this.valueType = null;
          if (isPresent(type)) {
              this.valueType = type.valueType;
          }
      }
      LiteralMapExpr.prototype.visitExpression = function (visitor, context) {
          return visitor.visitLiteralMapExpr(this, context);
      };
      return LiteralMapExpr;
  }(Expression));
  var THIS_EXPR = new ReadVarExpr(BuiltinVar.This);
  var SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);
  var CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);
  var CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);
  var NULL_EXPR = new LiteralExpr(null, null);
  //// Statements
  var StmtModifier;
  (function (StmtModifier) {
      StmtModifier[StmtModifier["Final"] = 0] = "Final";
      StmtModifier[StmtModifier["Private"] = 1] = "Private";
  })(StmtModifier || (StmtModifier = {}));
  var Statement = (function () {
      function Statement(modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          this.modifiers = modifiers;
          if (!modifiers) {
              this.modifiers = [];
          }
      }
      Statement.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
      return Statement;
  }());
  var DeclareVarStmt = (function (_super) {
      __extends$2(DeclareVarStmt, _super);
      function DeclareVarStmt(name, value, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.name = name;
          this.value = value;
          this.type = isPresent(type) ? type : value.type;
      }
      DeclareVarStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitDeclareVarStmt(this, context);
      };
      return DeclareVarStmt;
  }(Statement));
  var DeclareFunctionStmt = (function (_super) {
      __extends$2(DeclareFunctionStmt, _super);
      function DeclareFunctionStmt(name, params, statements, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.name = name;
          this.params = params;
          this.statements = statements;
          this.type = type;
      }
      DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitDeclareFunctionStmt(this, context);
      };
      return DeclareFunctionStmt;
  }(Statement));
  var ExpressionStatement = (function (_super) {
      __extends$2(ExpressionStatement, _super);
      function ExpressionStatement(expr) {
          _super.call(this);
          this.expr = expr;
      }
      ExpressionStatement.prototype.visitStatement = function (visitor, context) {
          return visitor.visitExpressionStmt(this, context);
      };
      return ExpressionStatement;
  }(Statement));
  var ReturnStatement = (function (_super) {
      __extends$2(ReturnStatement, _super);
      function ReturnStatement(value) {
          _super.call(this);
          this.value = value;
      }
      ReturnStatement.prototype.visitStatement = function (visitor, context) {
          return visitor.visitReturnStmt(this, context);
      };
      return ReturnStatement;
  }(Statement));
  var AbstractClassPart = (function () {
      function AbstractClassPart(type, modifiers) {
          if (type === void 0) { type = null; }
          this.type = type;
          this.modifiers = modifiers;
          if (!modifiers) {
              this.modifiers = [];
          }
      }
      AbstractClassPart.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };
      return AbstractClassPart;
  }());
  var ClassField = (function (_super) {
      __extends$2(ClassField, _super);
      function ClassField(name, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, type, modifiers);
          this.name = name;
      }
      return ClassField;
  }(AbstractClassPart));
  var ClassMethod = (function (_super) {
      __extends$2(ClassMethod, _super);
      function ClassMethod(name, params, body, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, type, modifiers);
          this.name = name;
          this.params = params;
          this.body = body;
      }
      return ClassMethod;
  }(AbstractClassPart));
  var ClassGetter = (function (_super) {
      __extends$2(ClassGetter, _super);
      function ClassGetter(name, body, type, modifiers) {
          if (type === void 0) { type = null; }
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, type, modifiers);
          this.name = name;
          this.body = body;
      }
      return ClassGetter;
  }(AbstractClassPart));
  var ClassStmt = (function (_super) {
      __extends$2(ClassStmt, _super);
      function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers) {
          if (modifiers === void 0) { modifiers = null; }
          _super.call(this, modifiers);
          this.name = name;
          this.parent = parent;
          this.fields = fields;
          this.getters = getters;
          this.constructorMethod = constructorMethod;
          this.methods = methods;
      }
      ClassStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitDeclareClassStmt(this, context);
      };
      return ClassStmt;
  }(Statement));
  var IfStmt = (function (_super) {
      __extends$2(IfStmt, _super);
      function IfStmt(condition, trueCase, falseCase) {
          if (falseCase === void 0) { falseCase = []; }
          _super.call(this);
          this.condition = condition;
          this.trueCase = trueCase;
          this.falseCase = falseCase;
      }
      IfStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitIfStmt(this, context);
      };
      return IfStmt;
  }(Statement));
  var CommentStmt = (function (_super) {
      __extends$2(CommentStmt, _super);
      function CommentStmt(comment) {
          _super.call(this);
          this.comment = comment;
      }
      CommentStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitCommentStmt(this, context);
      };
      return CommentStmt;
  }(Statement));
  var TryCatchStmt = (function (_super) {
      __extends$2(TryCatchStmt, _super);
      function TryCatchStmt(bodyStmts, catchStmts) {
          _super.call(this);
          this.bodyStmts = bodyStmts;
          this.catchStmts = catchStmts;
      }
      TryCatchStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitTryCatchStmt(this, context);
      };
      return TryCatchStmt;
  }(Statement));
  var ThrowStmt = (function (_super) {
      __extends$2(ThrowStmt, _super);
      function ThrowStmt(error) {
          _super.call(this);
          this.error = error;
      }
      ThrowStmt.prototype.visitStatement = function (visitor, context) {
          return visitor.visitThrowStmt(this, context);
      };
      return ThrowStmt;
  }(Statement));
  var ExpressionTransformer = (function () {
      function ExpressionTransformer() {
      }
      ExpressionTransformer.prototype.visitReadVarExpr = function (ast, context) { return ast; };
      ExpressionTransformer.prototype.visitWriteVarExpr = function (expr, context) {
          return new WriteVarExpr(expr.name, expr.value.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitWriteKeyExpr = function (expr, context) {
          return new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitWritePropExpr = function (expr, context) {
          return new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitInvokeMethodExpr = function (ast, context) {
          var method = isPresent(ast.builtin) ? ast.builtin : ast.name;
          return new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type);
      };
      ExpressionTransformer.prototype.visitInvokeFunctionExpr = function (ast, context) {
          return new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
      };
      ExpressionTransformer.prototype.visitInstantiateExpr = function (ast, context) {
          return new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type);
      };
      ExpressionTransformer.prototype.visitLiteralExpr = function (ast, context) { return ast; };
      ExpressionTransformer.prototype.visitExternalExpr = function (ast, context) { return ast; };
      ExpressionTransformer.prototype.visitConditionalExpr = function (ast, context) {
          return new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitNotExpr = function (ast, context) {
          return new NotExpr(ast.condition.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitCastExpr = function (ast, context) {
          return new CastExpr(ast.value.visitExpression(this, context), context);
      };
      ExpressionTransformer.prototype.visitFunctionExpr = function (ast, context) {
          // Don't descend into nested functions
          return ast;
      };
      ExpressionTransformer.prototype.visitBinaryOperatorExpr = function (ast, context) {
          return new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type);
      };
      ExpressionTransformer.prototype.visitReadPropExpr = function (ast, context) {
          return new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type);
      };
      ExpressionTransformer.prototype.visitReadKeyExpr = function (ast, context) {
          return new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type);
      };
      ExpressionTransformer.prototype.visitLiteralArrayExpr = function (ast, context) {
          return new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context));
      };
      ExpressionTransformer.prototype.visitLiteralMapExpr = function (ast, context) {
          var _this = this;
          return new LiteralMapExpr(ast.entries.map(function (entry) { return [entry[0], entry[1].visitExpression(_this, context)]; }));
      };
      ExpressionTransformer.prototype.visitAllExpressions = function (exprs, context) {
          var _this = this;
          return exprs.map(function (expr) { return expr.visitExpression(_this, context); });
      };
      ExpressionTransformer.prototype.visitDeclareVarStmt = function (stmt, context) {
          return new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers);
      };
      ExpressionTransformer.prototype.visitDeclareFunctionStmt = function (stmt, context) {
          // Don't descend into nested functions
          return stmt;
      };
      ExpressionTransformer.prototype.visitExpressionStmt = function (stmt, context) {
          return new ExpressionStatement(stmt.expr.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitReturnStmt = function (stmt, context) {
          return new ReturnStatement(stmt.value.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitDeclareClassStmt = function (stmt, context) {
          // Don't descend into nested functions
          return stmt;
      };
      ExpressionTransformer.prototype.visitIfStmt = function (stmt, context) {
          return new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context));
      };
      ExpressionTransformer.prototype.visitTryCatchStmt = function (stmt, context) {
          return new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context));
      };
      ExpressionTransformer.prototype.visitThrowStmt = function (stmt, context) {
          return new ThrowStmt(stmt.error.visitExpression(this, context));
      };
      ExpressionTransformer.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
      ExpressionTransformer.prototype.visitAllStatements = function (stmts, context) {
          var _this = this;
          return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });
      };
      return ExpressionTransformer;
  }());
  var RecursiveExpressionVisitor = (function () {
      function RecursiveExpressionVisitor() {
      }
      RecursiveExpressionVisitor.prototype.visitReadVarExpr = function (ast, context) { return ast; };
      RecursiveExpressionVisitor.prototype.visitWriteVarExpr = function (expr, context) {
          expr.value.visitExpression(this, context);
          return expr;
      };
      RecursiveExpressionVisitor.prototype.visitWriteKeyExpr = function (expr, context) {
          expr.receiver.visitExpression(this, context);
          expr.index.visitExpression(this, context);
          expr.value.visitExpression(this, context);
          return expr;
      };
      RecursiveExpressionVisitor.prototype.visitWritePropExpr = function (expr, context) {
          expr.receiver.visitExpression(this, context);
          expr.value.visitExpression(this, context);
          return expr;
      };
      RecursiveExpressionVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {
          ast.receiver.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {
          ast.fn.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitInstantiateExpr = function (ast, context) {
          ast.classExpr.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitLiteralExpr = function (ast, context) { return ast; };
      RecursiveExpressionVisitor.prototype.visitExternalExpr = function (ast, context) { return ast; };
      RecursiveExpressionVisitor.prototype.visitConditionalExpr = function (ast, context) {
          ast.condition.visitExpression(this, context);
          ast.trueCase.visitExpression(this, context);
          ast.falseCase.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitNotExpr = function (ast, context) {
          ast.condition.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitCastExpr = function (ast, context) {
          ast.value.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitFunctionExpr = function (ast, context) { return ast; };
      RecursiveExpressionVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {
          ast.lhs.visitExpression(this, context);
          ast.rhs.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitReadPropExpr = function (ast, context) {
          ast.receiver.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitReadKeyExpr = function (ast, context) {
          ast.receiver.visitExpression(this, context);
          ast.index.visitExpression(this, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {
          this.visitAllExpressions(ast.entries, context);
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitLiteralMapExpr = function (ast, context) {
          var _this = this;
          ast.entries.forEach(function (entry) { return entry[1].visitExpression(_this, context); });
          return ast;
      };
      RecursiveExpressionVisitor.prototype.visitAllExpressions = function (exprs, context) {
          var _this = this;
          exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });
      };
      RecursiveExpressionVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {
          stmt.value.visitExpression(this, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {
          // Don't descend into nested functions
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitExpressionStmt = function (stmt, context) {
          stmt.expr.visitExpression(this, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitReturnStmt = function (stmt, context) {
          stmt.value.visitExpression(this, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {
          // Don't descend into nested functions
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitIfStmt = function (stmt, context) {
          stmt.condition.visitExpression(this, context);
          this.visitAllStatements(stmt.trueCase, context);
          this.visitAllStatements(stmt.falseCase, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitTryCatchStmt = function (stmt, context) {
          this.visitAllStatements(stmt.bodyStmts, context);
          this.visitAllStatements(stmt.catchStmts, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitThrowStmt = function (stmt, context) {
          stmt.error.visitExpression(this, context);
          return stmt;
      };
      RecursiveExpressionVisitor.prototype.visitCommentStmt = function (stmt, context) { return stmt; };
      RecursiveExpressionVisitor.prototype.visitAllStatements = function (stmts, context) {
          var _this = this;
          stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });
      };
      return RecursiveExpressionVisitor;
  }());
  function replaceVarInExpression(varName, newValue, expression) {
      var transformer = new _ReplaceVariableTransformer(varName, newValue);
      return expression.visitExpression(transformer, null);
  }
  var _ReplaceVariableTransformer = (function (_super) {
      __extends$2(_ReplaceVariableTransformer, _super);
      function _ReplaceVariableTransformer(_varName, _newValue) {
          _super.call(this);
          this._varName = _varName;
          this._newValue = _newValue;
      }
      _ReplaceVariableTransformer.prototype.visitReadVarExpr = function (ast, context) {
          return ast.name == this._varName ? this._newValue : ast;
      };
      return _ReplaceVariableTransformer;
  }(ExpressionTransformer));
  function findReadVarNames(stmts) {
      var finder = new _VariableFinder();
      finder.visitAllStatements(stmts, null);
      return finder.varNames;
  }
  var _VariableFinder = (function (_super) {
      __extends$2(_VariableFinder, _super);
      function _VariableFinder() {
          _super.apply(this, arguments);
          this.varNames = new Set();
      }
      _VariableFinder.prototype.visitReadVarExpr = function (ast, context) {
          this.varNames.add(ast.name);
          return null;
      };
      return _VariableFinder;
  }(RecursiveExpressionVisitor));
  function variable(name, type) {
      if (type === void 0) { type = null; }
      return new ReadVarExpr(name, type);
  }
  function importExpr(id, typeParams) {
      if (typeParams === void 0) { typeParams = null; }
      return new ExternalExpr(id, null, typeParams);
  }
  function importType(id, typeParams, typeModifiers) {
      if (typeParams === void 0) { typeParams = null; }
      if (typeModifiers === void 0) { typeModifiers = null; }
      return isPresent(id) ? new ExternalType(id, typeParams, typeModifiers) : null;
  }
  function literalArr(values, type) {
      if (type === void 0) { type = null; }
      return new LiteralArrayExpr(values, type);
  }
  function literalMap(values, type) {
      if (type === void 0) { type = null; }
      return new LiteralMapExpr(values, type);
  }
  function not(expr) {
      return new NotExpr(expr);
  }
  function fn(params, body, type) {
      if (type === void 0) { type = null; }
      return new FunctionExpr(params, body, type);
  }
  function literal(value, type) {
      if (type === void 0) { type = null; }
      return new LiteralExpr(value, type);
  }

  var MODULE_SUFFIX = '';
  var CAMEL_CASE_REGEXP = /([A-Z])/g;
  function camelCaseToDashCase(input) {
      return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });
  }
  function splitAtColon(input, defaultValues) {
      return _splitAt(input, ':', defaultValues);
  }
  function splitAtPeriod(input, defaultValues) {
      return _splitAt(input, '.', defaultValues);
  }
  function _splitAt(input, character, defaultValues) {
      var characterIndex = input.indexOf(character);
      if (characterIndex == -1)
          return defaultValues;
      return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
  }
  function sanitizeIdentifier(name) {
      return StringWrapper.replaceAll(name, /\W/g, '_');
  }
  function visitValue(value, visitor, context) {
      if (isArray(value)) {
          return visitor.visitArray(value, context);
      }
      else if (isStrictStringMap(value)) {
          return visitor.visitStringMap(value, context);
      }
      else if (isBlank(value) || isPrimitive(value)) {
          return visitor.visitPrimitive(value, context);
      }
      else {
          return visitor.visitOther(value, context);
      }
  }
  var ValueTransformer = (function () {
      function ValueTransformer() {
      }
      ValueTransformer.prototype.visitArray = function (arr, context) {
          var _this = this;
          return arr.map(function (value) { return visitValue(value, _this, context); });
      };
      ValueTransformer.prototype.visitStringMap = function (map, context) {
          var _this = this;
          var result = {};
          Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });
          return result;
      };
      ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };
      ValueTransformer.prototype.visitOther = function (value, context) { return value; };
      return ValueTransformer;
  }());
  function assetUrl(pkg, path, type) {
      if (path === void 0) { path = null; }
      if (type === void 0) { type = 'src'; }
      if (path == null) {
          return "asset:@angular/lib/" + pkg + "/index";
      }
      else {
          return "asset:@angular/lib/" + pkg + "/src/" + path;
      }
  }
  function createDiTokenExpression(token) {
      if (isPresent(token.value)) {
          return literal(token.value);
      }
      else if (token.identifierIsInstance) {
          return importExpr(token.identifier)
              .instantiate([], importType(token.identifier, [], [TypeModifier.Const]));
      }
      else {
          return importExpr(token.identifier);
      }
  }
  var SyncAsyncResult = (function () {
      function SyncAsyncResult(syncResult, asyncResult) {
          if (asyncResult === void 0) { asyncResult = null; }
          this.syncResult = syncResult;
          this.asyncResult = asyncResult;
          if (!asyncResult) {
              this.asyncResult = Promise.resolve(syncResult);
          }
      }
      return SyncAsyncResult;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$1 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  function unimplemented() {
      throw new Error('unimplemented');
  }
  // group 0: "[prop] or (event) or @trigger"
  // group 1: "prop" from "[prop]"
  // group 2: "event" from "(event)"
  // group 3: "@trigger" from "@trigger"
  var HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  var CompileMetadataWithIdentifier = (function () {
      function CompileMetadataWithIdentifier() {
      }
      Object.defineProperty(CompileMetadataWithIdentifier.prototype, "identifier", {
          get: function () { return unimplemented(); },
          enumerable: true,
          configurable: true
      });
      return CompileMetadataWithIdentifier;
  }());
  var CompileAnimationEntryMetadata = (function () {
      function CompileAnimationEntryMetadata(name, definitions) {
          if (name === void 0) { name = null; }
          if (definitions === void 0) { definitions = null; }
          this.name = name;
          this.definitions = definitions;
      }
      return CompileAnimationEntryMetadata;
  }());
  var CompileAnimationStateMetadata = (function () {
      function CompileAnimationStateMetadata() {
      }
      return CompileAnimationStateMetadata;
  }());
  var CompileAnimationStateDeclarationMetadata = (function (_super) {
      __extends$1(CompileAnimationStateDeclarationMetadata, _super);
      function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {
          _super.call(this);
          this.stateNameExpr = stateNameExpr;
          this.styles = styles;
      }
      return CompileAnimationStateDeclarationMetadata;
  }(CompileAnimationStateMetadata));
  var CompileAnimationStateTransitionMetadata = (function (_super) {
      __extends$1(CompileAnimationStateTransitionMetadata, _super);
      function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {
          _super.call(this);
          this.stateChangeExpr = stateChangeExpr;
          this.steps = steps;
      }
      return CompileAnimationStateTransitionMetadata;
  }(CompileAnimationStateMetadata));
  var CompileAnimationMetadata = (function () {
      function CompileAnimationMetadata() {
      }
      return CompileAnimationMetadata;
  }());
  var CompileAnimationKeyframesSequenceMetadata = (function (_super) {
      __extends$1(CompileAnimationKeyframesSequenceMetadata, _super);
      function CompileAnimationKeyframesSequenceMetadata(steps) {
          if (steps === void 0) { steps = []; }
          _super.call(this);
          this.steps = steps;
      }
      return CompileAnimationKeyframesSequenceMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationStyleMetadata = (function (_super) {
      __extends$1(CompileAnimationStyleMetadata, _super);
      function CompileAnimationStyleMetadata(offset, styles) {
          if (styles === void 0) { styles = null; }
          _super.call(this);
          this.offset = offset;
          this.styles = styles;
      }
      return CompileAnimationStyleMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationAnimateMetadata = (function (_super) {
      __extends$1(CompileAnimationAnimateMetadata, _super);
      function CompileAnimationAnimateMetadata(timings, styles) {
          if (timings === void 0) { timings = 0; }
          if (styles === void 0) { styles = null; }
          _super.call(this);
          this.timings = timings;
          this.styles = styles;
      }
      return CompileAnimationAnimateMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationWithStepsMetadata = (function (_super) {
      __extends$1(CompileAnimationWithStepsMetadata, _super);
      function CompileAnimationWithStepsMetadata(steps) {
          if (steps === void 0) { steps = null; }
          _super.call(this);
          this.steps = steps;
      }
      return CompileAnimationWithStepsMetadata;
  }(CompileAnimationMetadata));
  var CompileAnimationSequenceMetadata = (function (_super) {
      __extends$1(CompileAnimationSequenceMetadata, _super);
      function CompileAnimationSequenceMetadata(steps) {
          if (steps === void 0) { steps = null; }
          _super.call(this, steps);
      }
      return CompileAnimationSequenceMetadata;
  }(CompileAnimationWithStepsMetadata));
  var CompileAnimationGroupMetadata = (function (_super) {
      __extends$1(CompileAnimationGroupMetadata, _super);
      function CompileAnimationGroupMetadata(steps) {
          if (steps === void 0) { steps = null; }
          _super.call(this, steps);
      }
      return CompileAnimationGroupMetadata;
  }(CompileAnimationWithStepsMetadata));
  var CompileIdentifierMetadata = (function () {
      function CompileIdentifierMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, reference = _b.reference, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, value = _b.value;
          this.reference = reference;
          this.name = name;
          this.prefix = prefix;
          this.moduleUrl = moduleUrl;
          this.value = value;
      }
      Object.defineProperty(CompileIdentifierMetadata.prototype, "identifier", {
          get: function () { return this; },
          enumerable: true,
          configurable: true
      });
      return CompileIdentifierMetadata;
  }());
  var CompileDiDependencyMetadata = (function () {
      function CompileDiDependencyMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, isAttribute = _b.isAttribute, isSelf = _b.isSelf, isHost = _b.isHost, isSkipSelf = _b.isSkipSelf, isOptional = _b.isOptional, isValue = _b.isValue, query = _b.query, viewQuery = _b.viewQuery, token = _b.token, value = _b.value;
          this.isAttribute = normalizeBool(isAttribute);
          this.isSelf = normalizeBool(isSelf);
          this.isHost = normalizeBool(isHost);
          this.isSkipSelf = normalizeBool(isSkipSelf);
          this.isOptional = normalizeBool(isOptional);
          this.isValue = normalizeBool(isValue);
          this.query = query;
          this.viewQuery = viewQuery;
          this.token = token;
          this.value = value;
      }
      return CompileDiDependencyMetadata;
  }());
  var CompileProviderMetadata = (function () {
      function CompileProviderMetadata(_a) {
          var token = _a.token, useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
          this.token = token;
          this.useClass = useClass;
          this.useValue = useValue;
          this.useExisting = useExisting;
          this.useFactory = useFactory;
          this.deps = normalizeBlank(deps);
          this.multi = normalizeBool(multi);
      }
      return CompileProviderMetadata;
  }());
  var CompileFactoryMetadata = (function (_super) {
      __extends$1(CompileFactoryMetadata, _super);
      function CompileFactoryMetadata(_a) {
          var reference = _a.reference, name = _a.name, moduleUrl = _a.moduleUrl, prefix = _a.prefix, diDeps = _a.diDeps, value = _a.value;
          _super.call(this, { reference: reference, name: name, prefix: prefix, moduleUrl: moduleUrl, value: value });
          this.diDeps = _normalizeArray(diDeps);
      }
      return CompileFactoryMetadata;
  }(CompileIdentifierMetadata));
  var CompileTokenMetadata = (function () {
      function CompileTokenMetadata(_a) {
          var value = _a.value, identifier = _a.identifier, identifierIsInstance = _a.identifierIsInstance;
          this.value = value;
          this.identifier = identifier;
          this.identifierIsInstance = normalizeBool(identifierIsInstance);
      }
      Object.defineProperty(CompileTokenMetadata.prototype, "reference", {
          get: function () {
              if (isPresent(this.identifier)) {
                  return this.identifier.reference;
              }
              else {
                  return this.value;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CompileTokenMetadata.prototype, "name", {
          get: function () {
              return isPresent(this.value) ? sanitizeIdentifier(this.value) : this.identifier.name;
          },
          enumerable: true,
          configurable: true
      });
      return CompileTokenMetadata;
  }());
  /**
   * Metadata regarding compilation of a type.
   */
  var CompileTypeMetadata = (function (_super) {
      __extends$1(CompileTypeMetadata, _super);
      function CompileTypeMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, reference = _b.reference, name = _b.name, moduleUrl = _b.moduleUrl, prefix = _b.prefix, isHost = _b.isHost, value = _b.value, diDeps = _b.diDeps, lifecycleHooks = _b.lifecycleHooks;
          _super.call(this, { reference: reference, name: name, moduleUrl: moduleUrl, prefix: prefix, value: value });
          this.isHost = normalizeBool(isHost);
          this.diDeps = _normalizeArray(diDeps);
          this.lifecycleHooks = _normalizeArray(lifecycleHooks);
      }
      return CompileTypeMetadata;
  }(CompileIdentifierMetadata));
  var CompileQueryMetadata = (function () {
      function CompileQueryMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, selectors = _b.selectors, descendants = _b.descendants, first = _b.first, propertyName = _b.propertyName, read = _b.read;
          this.selectors = selectors;
          this.descendants = normalizeBool(descendants);
          this.first = normalizeBool(first);
          this.propertyName = propertyName;
          this.read = read;
      }
      return CompileQueryMetadata;
  }());
  /**
   * Metadata about a stylesheet
   */
  var CompileStylesheetMetadata = (function () {
      function CompileStylesheetMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;
          this.moduleUrl = moduleUrl;
          this.styles = _normalizeArray(styles);
          this.styleUrls = _normalizeArray(styleUrls);
      }
      return CompileStylesheetMetadata;
  }());
  /**
   * Metadata regarding compilation of a template.
   */
  var CompileTemplateMetadata = (function () {
      function CompileTemplateMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, externalStylesheets = _b.externalStylesheets, animations = _b.animations, ngContentSelectors = _b.ngContentSelectors, interpolation = _b.interpolation;
          this.encapsulation = encapsulation;
          this.template = template;
          this.templateUrl = templateUrl;
          this.styles = _normalizeArray(styles);
          this.styleUrls = _normalizeArray(styleUrls);
          this.externalStylesheets = _normalizeArray(externalStylesheets);
          this.animations = isPresent(animations) ? ListWrapper.flatten(animations) : [];
          this.ngContentSelectors = isPresent(ngContentSelectors) ? ngContentSelectors : [];
          if (isPresent(interpolation) && interpolation.length != 2) {
              throw new Error("'interpolation' should have a start and an end symbol.");
          }
          this.interpolation = interpolation;
      }
      return CompileTemplateMetadata;
  }());
  /**
   * Metadata regarding compilation of a directive.
   */
  var CompileDirectiveMetadata = (function () {
      function CompileDirectiveMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;
          this.type = type;
          this.isComponent = isComponent;
          this.selector = selector;
          this.exportAs = exportAs;
          this.changeDetection = changeDetection;
          this.inputs = inputs;
          this.outputs = outputs;
          this.hostListeners = hostListeners;
          this.hostProperties = hostProperties;
          this.hostAttributes = hostAttributes;
          this.providers = _normalizeArray(providers);
          this.viewProviders = _normalizeArray(viewProviders);
          this.queries = _normalizeArray(queries);
          this.viewQueries = _normalizeArray(viewQueries);
          this.entryComponents = _normalizeArray(entryComponents);
          this.template = template;
      }
      CompileDirectiveMetadata.create = function (_a) {
          var _b = _a === void 0 ? {} : _a, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template;
          var hostListeners = {};
          var hostProperties = {};
          var hostAttributes = {};
          if (isPresent(host)) {
              Object.keys(host).forEach(function (key) {
                  var value = host[key];
                  var matches = key.match(HOST_REG_EXP);
                  if (matches === null) {
                      hostAttributes[key] = value;
                  }
                  else if (isPresent(matches[1])) {
                      hostProperties[matches[1]] = value;
                  }
                  else if (isPresent(matches[2])) {
                      hostListeners[matches[2]] = value;
                  }
              });
          }
          var inputsMap = {};
          if (isPresent(inputs)) {
              inputs.forEach(function (bindConfig) {
                  // canonical syntax: `dirProp: elProp`
                  // if there is no `:`, use dirProp = elProp
                  var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
                  inputsMap[parts[0]] = parts[1];
              });
          }
          var outputsMap = {};
          if (isPresent(outputs)) {
              outputs.forEach(function (bindConfig) {
                  // canonical syntax: `dirProp: elProp`
                  // if there is no `:`, use dirProp = elProp
                  var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
                  outputsMap[parts[0]] = parts[1];
              });
          }
          return new CompileDirectiveMetadata({
              type: type,
              isComponent: normalizeBool(isComponent), selector: selector, exportAs: exportAs, changeDetection: changeDetection,
              inputs: inputsMap,
              outputs: outputsMap,
              hostListeners: hostListeners,
              hostProperties: hostProperties,
              hostAttributes: hostAttributes,
              providers: providers,
              viewProviders: viewProviders,
              queries: queries,
              viewQueries: viewQueries,
              entryComponents: entryComponents,
              template: template,
          });
      };
      Object.defineProperty(CompileDirectiveMetadata.prototype, "identifier", {
          get: function () { return this.type; },
          enumerable: true,
          configurable: true
      });
      return CompileDirectiveMetadata;
  }());
  /**
   * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.
   */
  function createHostComponentMeta(compMeta) {
      var template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();
      return CompileDirectiveMetadata.create({
          type: new CompileTypeMetadata({
              reference: Object,
              name: compMeta.type.name + "_Host",
              moduleUrl: compMeta.type.moduleUrl,
              isHost: true
          }),
          template: new CompileTemplateMetadata({
              encapsulation: _angular_core.ViewEncapsulation.None,
              template: template,
              templateUrl: '',
              styles: [],
              styleUrls: [],
              ngContentSelectors: [],
              animations: []
          }),
          changeDetection: _angular_core.ChangeDetectionStrategy.Default,
          inputs: [],
          outputs: [],
          host: {},
          isComponent: true,
          selector: '*',
          providers: [],
          viewProviders: [],
          queries: [],
          viewQueries: []
      });
  }
  var CompilePipeMetadata = (function () {
      function CompilePipeMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, type = _b.type, name = _b.name, pure = _b.pure;
          this.type = type;
          this.name = name;
          this.pure = normalizeBool(pure);
      }
      Object.defineProperty(CompilePipeMetadata.prototype, "identifier", {
          get: function () { return this.type; },
          enumerable: true,
          configurable: true
      });
      return CompilePipeMetadata;
  }());
  /**
   * Metadata regarding compilation of a directive.
   */
  var CompileNgModuleMetadata = (function () {
      function CompileNgModuleMetadata(_a) {
          var _b = _a === void 0 ? {} : _a, type = _b.type, providers = _b.providers, declaredDirectives = _b.declaredDirectives, exportedDirectives = _b.exportedDirectives, declaredPipes = _b.declaredPipes, exportedPipes = _b.exportedPipes, entryComponents = _b.entryComponents, bootstrapComponents = _b.bootstrapComponents, importedModules = _b.importedModules, exportedModules = _b.exportedModules, schemas = _b.schemas, transitiveModule = _b.transitiveModule, id = _b.id;
          this.type = type;
          this.declaredDirectives = _normalizeArray(declaredDirectives);
          this.exportedDirectives = _normalizeArray(exportedDirectives);
          this.declaredPipes = _normalizeArray(declaredPipes);
          this.exportedPipes = _normalizeArray(exportedPipes);
          this.providers = _normalizeArray(providers);
          this.entryComponents = _normalizeArray(entryComponents);
          this.bootstrapComponents = _normalizeArray(bootstrapComponents);
          this.importedModules = _normalizeArray(importedModules);
          this.exportedModules = _normalizeArray(exportedModules);
          this.schemas = _normalizeArray(schemas);
          this.id = id;
          this.transitiveModule = transitiveModule;
      }
      Object.defineProperty(CompileNgModuleMetadata.prototype, "identifier", {
          get: function () { return this.type; },
          enumerable: true,
          configurable: true
      });
      return CompileNgModuleMetadata;
  }());
  var TransitiveCompileNgModuleMetadata = (function () {
      function TransitiveCompileNgModuleMetadata(modules, providers, entryComponents, directives, pipes) {
          var _this = this;
          this.modules = modules;
          this.providers = providers;
          this.entryComponents = entryComponents;
          this.directives = directives;
          this.pipes = pipes;
          this.directivesSet = new Set();
          this.pipesSet = new Set();
          directives.forEach(function (dir) { return _this.directivesSet.add(dir.type.reference); });
          pipes.forEach(function (pipe) { return _this.pipesSet.add(pipe.type.reference); });
      }
      return TransitiveCompileNgModuleMetadata;
  }());
  function removeIdentifierDuplicates(items) {
      var map = new Map();
      items.forEach(function (item) {
          if (!map.get(item.identifier.reference)) {
              map.set(item.identifier.reference, item);
          }
      });
      return MapWrapper.values(map);
  }
  function _normalizeArray(obj) {
      return isPresent(obj) ? obj : [];
  }
  function isStaticSymbol(value) {
      return isStringMap(value) && isPresent(value['name']) && isPresent(value['filePath']);
  }
  var ProviderMeta = (function () {
      function ProviderMeta(token, _a) {
          var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;
          this.token = token;
          this.useClass = useClass;
          this.useValue = useValue;
          this.useExisting = useExisting;
          this.useFactory = useFactory;
          this.dependencies = deps;
          this.multi = !!multi;
      }
      return ProviderMeta;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$3 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var ParserError = (function () {
      function ParserError(message, input, errLocation, ctxLocation) {
          this.input = input;
          this.errLocation = errLocation;
          this.ctxLocation = ctxLocation;
          this.message = "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation;
      }
      return ParserError;
  }());
  var ParseSpan = (function () {
      function ParseSpan(start, end) {
          this.start = start;
          this.end = end;
      }
      return ParseSpan;
  }());
  var AST = (function () {
      function AST(span) {
          this.span = span;
      }
      AST.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return null;
      };
      AST.prototype.toString = function () { return 'AST'; };
      return AST;
  }());
  /**
   * Represents a quoted expression of the form:
   *
   * quote = prefix `:` uninterpretedExpression
   * prefix = identifier
   * uninterpretedExpression = arbitrary string
   *
   * A quoted expression is meant to be pre-processed by an AST transformer that
   * converts it into another AST that no longer contains quoted expressions.
   * It is meant to allow third-party developers to extend Angular template
   * expression language. The `uninterpretedExpression` part of the quote is
   * therefore not interpreted by the Angular's own expression parser.
   */
  var Quote = (function (_super) {
      __extends$3(Quote, _super);
      function Quote(span, prefix, uninterpretedExpression, location) {
          _super.call(this, span);
          this.prefix = prefix;
          this.uninterpretedExpression = uninterpretedExpression;
          this.location = location;
      }
      Quote.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitQuote(this, context);
      };
      Quote.prototype.toString = function () { return 'Quote'; };
      return Quote;
  }(AST));
  var EmptyExpr = (function (_super) {
      __extends$3(EmptyExpr, _super);
      function EmptyExpr() {
          _super.apply(this, arguments);
      }
      EmptyExpr.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          // do nothing
      };
      return EmptyExpr;
  }(AST));
  var ImplicitReceiver = (function (_super) {
      __extends$3(ImplicitReceiver, _super);
      function ImplicitReceiver() {
          _super.apply(this, arguments);
      }
      ImplicitReceiver.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitImplicitReceiver(this, context);
      };
      return ImplicitReceiver;
  }(AST));
  /**
   * Multiple expressions separated by a semicolon.
   */
  var Chain = (function (_super) {
      __extends$3(Chain, _super);
      function Chain(span, expressions) {
          _super.call(this, span);
          this.expressions = expressions;
      }
      Chain.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitChain(this, context);
      };
      return Chain;
  }(AST));
  var Conditional = (function (_super) {
      __extends$3(Conditional, _super);
      function Conditional(span, condition, trueExp, falseExp) {
          _super.call(this, span);
          this.condition = condition;
          this.trueExp = trueExp;
          this.falseExp = falseExp;
      }
      Conditional.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitConditional(this, context);
      };
      return Conditional;
  }(AST));
  var PropertyRead = (function (_super) {
      __extends$3(PropertyRead, _super);
      function PropertyRead(span, receiver, name) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
      }
      PropertyRead.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitPropertyRead(this, context);
      };
      return PropertyRead;
  }(AST));
  var PropertyWrite = (function (_super) {
      __extends$3(PropertyWrite, _super);
      function PropertyWrite(span, receiver, name, value) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
          this.value = value;
      }
      PropertyWrite.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitPropertyWrite(this, context);
      };
      return PropertyWrite;
  }(AST));
  var SafePropertyRead = (function (_super) {
      __extends$3(SafePropertyRead, _super);
      function SafePropertyRead(span, receiver, name) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
      }
      SafePropertyRead.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitSafePropertyRead(this, context);
      };
      return SafePropertyRead;
  }(AST));
  var KeyedRead = (function (_super) {
      __extends$3(KeyedRead, _super);
      function KeyedRead(span, obj, key) {
          _super.call(this, span);
          this.obj = obj;
          this.key = key;
      }
      KeyedRead.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitKeyedRead(this, context);
      };
      return KeyedRead;
  }(AST));
  var KeyedWrite = (function (_super) {
      __extends$3(KeyedWrite, _super);
      function KeyedWrite(span, obj, key, value) {
          _super.call(this, span);
          this.obj = obj;
          this.key = key;
          this.value = value;
      }
      KeyedWrite.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitKeyedWrite(this, context);
      };
      return KeyedWrite;
  }(AST));
  var BindingPipe = (function (_super) {
      __extends$3(BindingPipe, _super);
      function BindingPipe(span, exp, name, args) {
          _super.call(this, span);
          this.exp = exp;
          this.name = name;
          this.args = args;
      }
      BindingPipe.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitPipe(this, context);
      };
      return BindingPipe;
  }(AST));
  var LiteralPrimitive = (function (_super) {
      __extends$3(LiteralPrimitive, _super);
      function LiteralPrimitive(span, value) {
          _super.call(this, span);
          this.value = value;
      }
      LiteralPrimitive.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitLiteralPrimitive(this, context);
      };
      return LiteralPrimitive;
  }(AST));
  var LiteralArray = (function (_super) {
      __extends$3(LiteralArray, _super);
      function LiteralArray(span, expressions) {
          _super.call(this, span);
          this.expressions = expressions;
      }
      LiteralArray.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitLiteralArray(this, context);
      };
      return LiteralArray;
  }(AST));
  var LiteralMap = (function (_super) {
      __extends$3(LiteralMap, _super);
      function LiteralMap(span, keys, values) {
          _super.call(this, span);
          this.keys = keys;
          this.values = values;
      }
      LiteralMap.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitLiteralMap(this, context);
      };
      return LiteralMap;
  }(AST));
  var Interpolation = (function (_super) {
      __extends$3(Interpolation, _super);
      function Interpolation(span, strings, expressions) {
          _super.call(this, span);
          this.strings = strings;
          this.expressions = expressions;
      }
      Interpolation.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitInterpolation(this, context);
      };
      return Interpolation;
  }(AST));
  var Binary = (function (_super) {
      __extends$3(Binary, _super);
      function Binary(span, operation, left, right) {
          _super.call(this, span);
          this.operation = operation;
          this.left = left;
          this.right = right;
      }
      Binary.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitBinary(this, context);
      };
      return Binary;
  }(AST));
  var PrefixNot = (function (_super) {
      __extends$3(PrefixNot, _super);
      function PrefixNot(span, expression) {
          _super.call(this, span);
          this.expression = expression;
      }
      PrefixNot.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitPrefixNot(this, context);
      };
      return PrefixNot;
  }(AST));
  var MethodCall = (function (_super) {
      __extends$3(MethodCall, _super);
      function MethodCall(span, receiver, name, args) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
          this.args = args;
      }
      MethodCall.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitMethodCall(this, context);
      };
      return MethodCall;
  }(AST));
  var SafeMethodCall = (function (_super) {
      __extends$3(SafeMethodCall, _super);
      function SafeMethodCall(span, receiver, name, args) {
          _super.call(this, span);
          this.receiver = receiver;
          this.name = name;
          this.args = args;
      }
      SafeMethodCall.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitSafeMethodCall(this, context);
      };
      return SafeMethodCall;
  }(AST));
  var FunctionCall = (function (_super) {
      __extends$3(FunctionCall, _super);
      function FunctionCall(span, target, args) {
          _super.call(this, span);
          this.target = target;
          this.args = args;
      }
      FunctionCall.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return visitor.visitFunctionCall(this, context);
      };
      return FunctionCall;
  }(AST));
  var ASTWithSource = (function (_super) {
      __extends$3(ASTWithSource, _super);
      function ASTWithSource(ast, source, location, errors) {
          _super.call(this, new ParseSpan(0, isBlank(source) ? 0 : source.length));
          this.ast = ast;
          this.source = source;
          this.location = location;
          this.errors = errors;
      }
      ASTWithSource.prototype.visit = function (visitor, context) {
          if (context === void 0) { context = null; }
          return this.ast.visit(visitor, context);
      };
      ASTWithSource.prototype.toString = function () { return this.source + " in " + this.location; };
      return ASTWithSource;
  }(AST));
  var TemplateBinding = (function () {
      function TemplateBinding(key, keyIsVar, name, expression) {
          this.key = key;
          this.keyIsVar = keyIsVar;
          this.name = name;
          this.expression = expression;
      }
      return TemplateBinding;
  }());
  var RecursiveAstVisitor = (function () {
      function RecursiveAstVisitor() {
      }
      RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {
          ast.left.visit(this);
          ast.right.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };
      RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {
          ast.condition.visit(this);
          ast.trueExp.visit(this);
          ast.falseExp.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {
          ast.exp.visit(this);
          this.visitAll(ast.args, context);
          return null;
      };
      RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {
          ast.target.visit(this);
          this.visitAll(ast.args, context);
          return null;
      };
      RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };
      RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {
          return this.visitAll(ast.expressions, context);
      };
      RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {
          ast.obj.visit(this);
          ast.key.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {
          ast.obj.visit(this);
          ast.key.visit(this);
          ast.value.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {
          return this.visitAll(ast.expressions, context);
      };
      RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };
      RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };
      RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {
          ast.receiver.visit(this);
          return this.visitAll(ast.args, context);
      };
      RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {
          ast.expression.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {
          ast.receiver.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {
          ast.receiver.visit(this);
          ast.value.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {
          ast.receiver.visit(this);
          return null;
      };
      RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {
          ast.receiver.visit(this);
          return this.visitAll(ast.args, context);
      };
      RecursiveAstVisitor.prototype.visitAll = function (asts, context) {
          var _this = this;
          asts.forEach(function (ast) { return ast.visit(_this, context); });
          return null;
      };
      RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };
      return RecursiveAstVisitor;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var $EOF = 0;
  var $TAB = 9;
  var $LF = 10;
  var $VTAB = 11;
  var $FF = 12;
  var $CR = 13;
  var $SPACE = 32;
  var $BANG = 33;
  var $DQ = 34;
  var $HASH = 35;
  var $$ = 36;
  var $PERCENT = 37;
  var $AMPERSAND = 38;
  var $SQ = 39;
  var $LPAREN = 40;
  var $RPAREN = 41;
  var $STAR = 42;
  var $PLUS = 43;
  var $COMMA = 44;
  var $MINUS = 45;
  var $PERIOD = 46;
  var $SLASH = 47;
  var $COLON = 58;
  var $SEMICOLON = 59;
  var $LT = 60;
  var $EQ = 61;
  var $GT = 62;
  var $QUESTION = 63;
  var $0 = 48;
  var $9 = 57;
  var $A = 65;
  var $E = 69;
  var $F = 70;
  var $X = 88;
  var $Z = 90;
  var $LBRACKET = 91;
  var $BACKSLASH = 92;
  var $RBRACKET = 93;
  var $CARET = 94;
  var $_ = 95;
  var $a = 97;
  var $e = 101;
  var $f = 102;
  var $n = 110;
  var $r = 114;
  var $t = 116;
  var $u = 117;
  var $v = 118;
  var $x = 120;
  var $z = 122;
  var $LBRACE = 123;
  var $BAR = 124;
  var $RBRACE = 125;
  var $NBSP = 160;
  var $BT = 96;
  function isWhitespace(code) {
      return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
  }
  function isDigit(code) {
      return $0 <= code && code <= $9;
  }
  function isAsciiLetter(code) {
      return code >= $a && code <= $z || code >= $A && code <= $Z;
  }
  function isAsciiHexDigit(code) {
      return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
  }

  function assertArrayOfStrings(identifier, value) {
      if (!_angular_core.isDevMode() || isBlank(value)) {
          return;
      }
      if (!isArray(value)) {
          throw new Error("Expected '" + identifier + "' to be an array of strings.");
      }
      for (var i = 0; i < value.length; i += 1) {
          if (!isString(value[i])) {
              throw new Error("Expected '" + identifier + "' to be an array of strings.");
          }
      }
  }
  var INTERPOLATION_BLACKLIST_REGEXPS = [
      /^\s*$/,
      /[<>]/,
      /^[{}]$/,
      /&(#|[a-z])/i,
      /^\/\//,
  ];
  function assertInterpolationSymbols(identifier, value) {
      if (isPresent(value) && !(isArray(value) && value.length == 2)) {
          throw new Error("Expected '" + identifier + "' to be an array, [start, end].");
      }
      else if (_angular_core.isDevMode() && !isBlank(value)) {
          var start_1 = value[0];
          var end_1 = value[1];
          // black list checking
          INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {
              if (regexp.test(start_1) || regexp.test(end_1)) {
                  throw new Error("['" + start_1 + "', '" + end_1 + "'] contains unusable interpolation symbol.");
              }
          });
      }
  }

  var InterpolationConfig = (function () {
      function InterpolationConfig(start, end) {
          this.start = start;
          this.end = end;
      }
      InterpolationConfig.fromArray = function (markers) {
          if (!markers) {
              return DEFAULT_INTERPOLATION_CONFIG;
          }
          assertInterpolationSymbols('interpolation', markers);
          return new InterpolationConfig(markers[0], markers[1]);
      };
      ;
      return InterpolationConfig;
  }());
  var DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');

  var TokenType;
  (function (TokenType) {
      TokenType[TokenType["Character"] = 0] = "Character";
      TokenType[TokenType["Identifier"] = 1] = "Identifier";
      TokenType[TokenType["Keyword"] = 2] = "Keyword";
      TokenType[TokenType["String"] = 3] = "String";
      TokenType[TokenType["Operator"] = 4] = "Operator";
      TokenType[TokenType["Number"] = 5] = "Number";
      TokenType[TokenType["Error"] = 6] = "Error";
  })(TokenType || (TokenType = {}));
  var KEYWORDS = ['var', 'let', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
  var Lexer = (function () {
      function Lexer() {
      }
      Lexer.prototype.tokenize = function (text) {
          var scanner = new _Scanner(text);
          var tokens = [];
          var token = scanner.scanToken();
          while (token != null) {
              tokens.push(token);
              token = scanner.scanToken();
          }
          return tokens;
      };
      Lexer.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      Lexer.ctorParameters = [];
      return Lexer;
  }());
  var Token = (function () {
      function Token(index, type, numValue, strValue) {
          this.index = index;
          this.type = type;
          this.numValue = numValue;
          this.strValue = strValue;
      }
      Token.prototype.isCharacter = function (code) {
          return this.type == TokenType.Character && this.numValue == code;
      };
      Token.prototype.isNumber = function () { return this.type == TokenType.Number; };
      Token.prototype.isString = function () { return this.type == TokenType.String; };
      Token.prototype.isOperator = function (operater) {
          return this.type == TokenType.Operator && this.strValue == operater;
      };
      Token.prototype.isIdentifier = function () { return this.type == TokenType.Identifier; };
      Token.prototype.isKeyword = function () { return this.type == TokenType.Keyword; };
      Token.prototype.isKeywordLet = function () { return this.type == TokenType.Keyword && this.strValue == 'let'; };
      Token.prototype.isKeywordNull = function () { return this.type == TokenType.Keyword && this.strValue == 'null'; };
      Token.prototype.isKeywordUndefined = function () {
          return this.type == TokenType.Keyword && this.strValue == 'undefined';
      };
      Token.prototype.isKeywordTrue = function () { return this.type == TokenType.Keyword && this.strValue == 'true'; };
      Token.prototype.isKeywordFalse = function () { return this.type == TokenType.Keyword && this.strValue == 'false'; };
      Token.prototype.isKeywordThis = function () { return this.type == TokenType.Keyword && this.strValue == 'this'; };
      Token.prototype.isError = function () { return this.type == TokenType.Error; };
      Token.prototype.toNumber = function () { return this.type == TokenType.Number ? this.numValue : -1; };
      Token.prototype.toString = function () {
          switch (this.type) {
              case TokenType.Character:
              case TokenType.Identifier:
              case TokenType.Keyword:
              case TokenType.Operator:
              case TokenType.String:
              case TokenType.Error:
                  return this.strValue;
              case TokenType.Number:
                  return this.numValue.toString();
              default:
                  return null;
          }
      };
      return Token;
  }());
  function newCharacterToken(index, code) {
      return new Token(index, TokenType.Character, code, StringWrapper.fromCharCode(code));
  }
  function newIdentifierToken(index, text) {
      return new Token(index, TokenType.Identifier, 0, text);
  }
  function newKeywordToken(index, text) {
      return new Token(index, TokenType.Keyword, 0, text);
  }
  function newOperatorToken(index, text) {
      return new Token(index, TokenType.Operator, 0, text);
  }
  function newStringToken(index, text) {
      return new Token(index, TokenType.String, 0, text);
  }
  function newNumberToken(index, n) {
      return new Token(index, TokenType.Number, n, '');
  }
  function newErrorToken(index, message) {
      return new Token(index, TokenType.Error, 0, message);
  }
  var EOF = new Token(-1, TokenType.Character, 0, '');
  var _Scanner = (function () {
      function _Scanner(input) {
          this.input = input;
          this.peek = 0;
          this.index = -1;
          this.length = input.length;
          this.advance();
      }
      _Scanner.prototype.advance = function () {
          this.peek =
              ++this.index >= this.length ? $EOF : StringWrapper.charCodeAt(this.input, this.index);
      };
      _Scanner.prototype.scanToken = function () {
          var input = this.input, length = this.length, peek = this.peek, index = this.index;
          // Skip whitespace.
          while (peek <= $SPACE) {
              if (++index >= length) {
                  peek = $EOF;
                  break;
              }
              else {
                  peek = StringWrapper.charCodeAt(input, index);
              }
          }
          this.peek = peek;
          this.index = index;
          if (index >= length) {
              return null;
          }
          // Handle identifiers and numbers.
          if (isIdentifierStart(peek))
              return this.scanIdentifier();
          if (isDigit(peek))
              return this.scanNumber(index);
          var start = index;
          switch (peek) {
              case $PERIOD:
                  this.advance();
                  return isDigit(this.peek) ? this.scanNumber(start) :
                      newCharacterToken(start, $PERIOD);
              case $LPAREN:
              case $RPAREN:
              case $LBRACE:
              case $RBRACE:
              case $LBRACKET:
              case $RBRACKET:
              case $COMMA:
              case $COLON:
              case $SEMICOLON:
                  return this.scanCharacter(start, peek);
              case $SQ:
              case $DQ:
                  return this.scanString();
              case $HASH:
              case $PLUS:
              case $MINUS:
              case $STAR:
              case $SLASH:
              case $PERCENT:
              case $CARET:
                  return this.scanOperator(start, StringWrapper.fromCharCode(peek));
              case $QUESTION:
                  return this.scanComplexOperator(start, '?', $PERIOD, '.');
              case $LT:
              case $GT:
                  return this.scanComplexOperator(start, StringWrapper.fromCharCode(peek), $EQ, '=');
              case $BANG:
              case $EQ:
                  return this.scanComplexOperator(start, StringWrapper.fromCharCode(peek), $EQ, '=', $EQ, '=');
              case $AMPERSAND:
                  return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
              case $BAR:
                  return this.scanComplexOperator(start, '|', $BAR, '|');
              case $NBSP:
                  while (isWhitespace(this.peek))
                      this.advance();
                  return this.scanToken();
          }
          this.advance();
          return this.error("Unexpected character [" + StringWrapper.fromCharCode(peek) + "]", 0);
      };
      _Scanner.prototype.scanCharacter = function (start, code) {
          this.advance();
          return newCharacterToken(start, code);
      };
      _Scanner.prototype.scanOperator = function (start, str) {
          this.advance();
          return newOperatorToken(start, str);
      };
      /**
       * Tokenize a 2/3 char long operator
       *
       * @param start start index in the expression
       * @param one first symbol (always part of the operator)
       * @param twoCode code point for the second symbol
       * @param two second symbol (part of the operator when the second code point matches)
       * @param threeCode code point for the third symbol
       * @param three third symbol (part of the operator when provided and matches source expression)
       * @returns {Token}
       */
      _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {
          this.advance();
          var str = one;
          if (this.peek == twoCode) {
              this.advance();
              str += two;
          }
          if (isPresent(threeCode) && this.peek == threeCode) {
              this.advance();
              str += three;
          }
          return newOperatorToken(start, str);
      };
      _Scanner.prototype.scanIdentifier = function () {
          var start = this.index;
          this.advance();
          while (isIdentifierPart(this.peek))
              this.advance();
          var str = this.input.substring(start, this.index);
          return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :
              newIdentifierToken(start, str);
      };
      _Scanner.prototype.scanNumber = function (start) {
          var simple = (this.index === start);
          this.advance(); // Skip initial digit.
          while (true) {
              if (isDigit(this.peek)) {
              }
              else if (this.peek == $PERIOD) {
                  simple = false;
              }
              else if (isExponentStart(this.peek)) {
                  this.advance();
                  if (isExponentSign(this.peek))
                      this.advance();
                  if (!isDigit(this.peek))
                      return this.error('Invalid exponent', -1);
                  simple = false;
              }
              else {
                  break;
              }
              this.advance();
          }
          var str = this.input.substring(start, this.index);
          var value = simple ? NumberWrapper.parseIntAutoRadix(str) : parseFloat(str);
          return newNumberToken(start, value);
      };
      _Scanner.prototype.scanString = function () {
          var start = this.index;
          var quote = this.peek;
          this.advance(); // Skip initial quote.
          var buffer;
          var marker = this.index;
          var input = this.input;
          while (this.peek != quote) {
              if (this.peek == $BACKSLASH) {
                  if (buffer == null)
                      buffer = new StringJoiner();
                  buffer.add(input.substring(marker, this.index));
                  this.advance();
                  var unescapedCode;
                  if (this.peek == $u) {
                      // 4 character hex code for unicode character.
                      var hex = input.substring(this.index + 1, this.index + 5);
                      try {
                          unescapedCode = NumberWrapper.parseInt(hex, 16);
                      }
                      catch (e) {
                          return this.error("Invalid unicode escape [\\u" + hex + "]", 0);
                      }
                      for (var i = 0; i < 5; i++) {
                          this.advance();
                      }
                  }
                  else {
                      unescapedCode = unescape(this.peek);
                      this.advance();
                  }
                  buffer.add(StringWrapper.fromCharCode(unescapedCode));
                  marker = this.index;
              }
              else if (this.peek == $EOF) {
                  return this.error('Unterminated quote', 0);
              }
              else {
                  this.advance();
              }
          }
          var last = input.substring(marker, this.index);
          this.advance(); // Skip terminating quote.
          // Compute the unescaped string value.
          var unescaped = last;
          if (buffer != null) {
              buffer.add(last);
              unescaped = buffer.toString();
          }
          return newStringToken(start, unescaped);
      };
      _Scanner.prototype.error = function (message, offset) {
          var position = this.index + offset;
          return newErrorToken(position, "Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
      };
      return _Scanner;
  }());
  function isIdentifierStart(code) {
      return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
          (code == $_) || (code == $$);
  }
  function isIdentifier(input) {
      if (input.length == 0)
          return false;
      var scanner = new _Scanner(input);
      if (!isIdentifierStart(scanner.peek))
          return false;
      scanner.advance();
      while (scanner.peek !== $EOF) {
          if (!isIdentifierPart(scanner.peek))
              return false;
          scanner.advance();
      }
      return true;
  }
  function isIdentifierPart(code) {
      return isAsciiLetter(code) || isDigit(code) || (code == $_) ||
          (code == $$);
  }
  function isExponentStart(code) {
      return code == $e || code == $E;
  }
  function isExponentSign(code) {
      return code == $MINUS || code == $PLUS;
  }
  function isQuote(code) {
      return code === $SQ || code === $DQ || code === $BT;
  }
  function unescape(code) {
      switch (code) {
          case $n:
              return $LF;
          case $f:
              return $FF;
          case $r:
              return $CR;
          case $t:
              return $TAB;
          case $v:
              return $VTAB;
          default:
              return code;
      }
  }

  var SplitInterpolation = (function () {
      function SplitInterpolation(strings, expressions) {
          this.strings = strings;
          this.expressions = expressions;
      }
      return SplitInterpolation;
  }());
  var TemplateBindingParseResult = (function () {
      function TemplateBindingParseResult(templateBindings, warnings, errors) {
          this.templateBindings = templateBindings;
          this.warnings = warnings;
          this.errors = errors;
      }
      return TemplateBindingParseResult;
  }());
  function _createInterpolateRegExp(config) {
      var pattern = escapeRegExp(config.start) + '([\\s\\S]*?)' + escapeRegExp(config.end);
      return new RegExp(pattern, 'g');
  }
  var Parser = (function () {
      function Parser(_lexer) {
          this._lexer = _lexer;
          this.errors = [];
      }
      Parser.prototype.parseAction = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          this._checkNoInterpolation(input, location, interpolationConfig);
          var tokens = this._lexer.tokenize(this._stripComments(input));
          var ast = new _ParseAST(input, location, tokens, true, this.errors).parseChain();
          return new ASTWithSource(ast, input, location, this.errors);
      };
      Parser.prototype.parseBinding = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var ast = this._parseBindingAst(input, location, interpolationConfig);
          return new ASTWithSource(ast, input, location, this.errors);
      };
      Parser.prototype.parseSimpleBinding = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var ast = this._parseBindingAst(input, location, interpolationConfig);
          if (!SimpleExpressionChecker.check(ast)) {
              this._reportError('Host binding expression can only contain field access and constants', input, location);
          }
          return new ASTWithSource(ast, input, location, this.errors);
      };
      Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {
          this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
      };
      Parser.prototype._parseBindingAst = function (input, location, interpolationConfig) {
          // Quotes expressions use 3rd-party expression language. We don't want to use
          // our lexer or parser for that, so we check for that ahead of time.
          var quote = this._parseQuote(input, location);
          if (isPresent(quote)) {
              return quote;
          }
          this._checkNoInterpolation(input, location, interpolationConfig);
          var tokens = this._lexer.tokenize(this._stripComments(input));
          return new _ParseAST(input, location, tokens, false, this.errors).parseChain();
      };
      Parser.prototype._parseQuote = function (input, location) {
          if (isBlank(input))
              return null;
          var prefixSeparatorIndex = input.indexOf(':');
          if (prefixSeparatorIndex == -1)
              return null;
          var prefix = input.substring(0, prefixSeparatorIndex).trim();
          if (!isIdentifier(prefix))
              return null;
          var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
          return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);
      };
      Parser.prototype.parseTemplateBindings = function (input, location) {
          var tokens = this._lexer.tokenize(input);
          return new _ParseAST(input, location, tokens, false, this.errors).parseTemplateBindings();
      };
      Parser.prototype.parseInterpolation = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var split = this.splitInterpolation(input, location, interpolationConfig);
          if (split == null)
              return null;
          var expressions = [];
          for (var i = 0; i < split.expressions.length; ++i) {
              var tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));
              var ast = new _ParseAST(input, location, tokens, false, this.errors).parseChain();
              expressions.push(ast);
          }
          return new ASTWithSource(new Interpolation(new ParseSpan(0, isBlank(input) ? 0 : input.length), split.strings, expressions), input, location, this.errors);
      };
      Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var regexp = _createInterpolateRegExp(interpolationConfig);
          var parts = StringWrapper.split(input, regexp);
          if (parts.length <= 1) {
              return null;
          }
          var strings = [];
          var expressions = [];
          for (var i = 0; i < parts.length; i++) {
              var part = parts[i];
              if (i % 2 === 0) {
                  // fixed string
                  strings.push(part);
              }
              else if (part.trim().length > 0) {
                  expressions.push(part);
              }
              else {
                  this._reportError('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + " in", location);
              }
          }
          return new SplitInterpolation(strings, expressions);
      };
      Parser.prototype.wrapLiteralPrimitive = function (input, location) {
          return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, isBlank(input) ? 0 : input.length), input), input, location, this.errors);
      };
      Parser.prototype._stripComments = function (input) {
          var i = this._commentStart(input);
          return isPresent(i) ? input.substring(0, i).trim() : input;
      };
      Parser.prototype._commentStart = function (input) {
          var outerQuote = null;
          for (var i = 0; i < input.length - 1; i++) {
              var char = StringWrapper.charCodeAt(input, i);
              var nextChar = StringWrapper.charCodeAt(input, i + 1);
              if (char === $SLASH && nextChar == $SLASH && isBlank(outerQuote))
                  return i;
              if (outerQuote === char) {
                  outerQuote = null;
              }
              else if (isBlank(outerQuote) && isQuote(char)) {
                  outerQuote = char;
              }
          }
          return null;
      };
      Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {
          var regexp = _createInterpolateRegExp(interpolationConfig);
          var parts = StringWrapper.split(input, regexp);
          if (parts.length > 1) {
              this._reportError("Got interpolation (" + interpolationConfig.start + interpolationConfig.end + ") where expression was expected", input, "at column " + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + " in", location);
          }
      };
      Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {
          var errLocation = '';
          for (var j = 0; j < partInErrIdx; j++) {
              errLocation += j % 2 === 0 ?
                  parts[j] :
                  "" + interpolationConfig.start + parts[j] + interpolationConfig.end;
          }
          return errLocation.length;
      };
      Parser.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      Parser.ctorParameters = [
          { type: Lexer, },
      ];
      return Parser;
  }());
  var _ParseAST = (function () {
      function _ParseAST(input, location, tokens, parseAction, errors) {
          this.input = input;
          this.location = location;
          this.tokens = tokens;
          this.parseAction = parseAction;
          this.errors = errors;
          this.rparensExpected = 0;
          this.rbracketsExpected = 0;
          this.rbracesExpected = 0;
          this.index = 0;
      }
      _ParseAST.prototype.peek = function (offset) {
          var i = this.index + offset;
          return i < this.tokens.length ? this.tokens[i] : EOF;
      };
      Object.defineProperty(_ParseAST.prototype, "next", {
          get: function () { return this.peek(0); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(_ParseAST.prototype, "inputIndex", {
          get: function () {
              return (this.index < this.tokens.length) ? this.next.index : this.input.length;
          },
          enumerable: true,
          configurable: true
      });
      _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };
      _ParseAST.prototype.advance = function () { this.index++; };
      _ParseAST.prototype.optionalCharacter = function (code) {
          if (this.next.isCharacter(code)) {
              this.advance();
              return true;
          }
          else {
              return false;
          }
      };
      _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };
      _ParseAST.prototype.expectCharacter = function (code) {
          if (this.optionalCharacter(code))
              return;
          this.error("Missing expected " + StringWrapper.fromCharCode(code));
      };
      _ParseAST.prototype.optionalOperator = function (op) {
          if (this.next.isOperator(op)) {
              this.advance();
              return true;
          }
          else {
              return false;
          }
      };
      _ParseAST.prototype.expectOperator = function (operator) {
          if (this.optionalOperator(operator))
              return;
          this.error("Missing expected operator " + operator);
      };
      _ParseAST.prototype.expectIdentifierOrKeyword = function () {
          var n = this.next;
          if (!n.isIdentifier() && !n.isKeyword()) {
              this.error("Unexpected token " + n + ", expected identifier or keyword");
              return '';
          }
          this.advance();
          return n.toString();
      };
      _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {
          var n = this.next;
          if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
              this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
              return '';
          }
          this.advance();
          return n.toString();
      };
      _ParseAST.prototype.parseChain = function () {
          var exprs = [];
          var start = this.inputIndex;
          while (this.index < this.tokens.length) {
              var expr = this.parsePipe();
              exprs.push(expr);
              if (this.optionalCharacter($SEMICOLON)) {
                  if (!this.parseAction) {
                      this.error('Binding expression cannot contain chained expression');
                  }
                  while (this.optionalCharacter($SEMICOLON)) {
                  } // read all semicolons
              }
              else if (this.index < this.tokens.length) {
                  this.error("Unexpected token '" + this.next + "'");
              }
          }
          if (exprs.length == 0)
              return new EmptyExpr(this.span(start));
          if (exprs.length == 1)
              return exprs[0];
          return new Chain(this.span(start), exprs);
      };
      _ParseAST.prototype.parsePipe = function () {
          var result = this.parseExpression();
          if (this.optionalOperator('|')) {
              if (this.parseAction) {
                  this.error('Cannot have a pipe in an action expression');
              }
              do {
                  var name = this.expectIdentifierOrKeyword();
                  var args = [];
                  while (this.optionalCharacter($COLON)) {
                      args.push(this.parseExpression());
                  }
                  result = new BindingPipe(this.span(result.span.start), result, name, args);
              } while (this.optionalOperator('|'));
          }
          return result;
      };
      _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };
      _ParseAST.prototype.parseConditional = function () {
          var start = this.inputIndex;
          var result = this.parseLogicalOr();
          if (this.optionalOperator('?')) {
              var yes = this.parsePipe();
              var no = void 0;
              if (!this.optionalCharacter($COLON)) {
                  var end = this.inputIndex;
                  var expression = this.input.substring(start, end);
                  this.error("Conditional expression " + expression + " requires all 3 expressions");
                  no = new EmptyExpr(this.span(start));
              }
              else {
                  no = this.parsePipe();
              }
              return new Conditional(this.span(start), result, yes, no);
          }
          else {
              return result;
          }
      };
      _ParseAST.prototype.parseLogicalOr = function () {
          // '||'
          var result = this.parseLogicalAnd();
          while (this.optionalOperator('||')) {
              var right = this.parseLogicalAnd();
              result = new Binary(this.span(result.span.start), '||', result, right);
          }
          return result;
      };
      _ParseAST.prototype.parseLogicalAnd = function () {
          // '&&'
          var result = this.parseEquality();
          while (this.optionalOperator('&&')) {
              var right = this.parseEquality();
              result = new Binary(this.span(result.span.start), '&&', result, right);
          }
          return result;
      };
      _ParseAST.prototype.parseEquality = function () {
          // '==','!=','===','!=='
          var result = this.parseRelational();
          while (this.next.type == TokenType.Operator) {
              var operator = this.next.strValue;
              switch (operator) {
                  case '==':
                  case '===':
                  case '!=':
                  case '!==':
                      this.advance();
                      var right = this.parseRelational();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      };
      _ParseAST.prototype.parseRelational = function () {
          // '<', '>', '<=', '>='
          var result = this.parseAdditive();
          while (this.next.type == TokenType.Operator) {
              var operator = this.next.strValue;
              switch (operator) {
                  case '<':
                  case '>':
                  case '<=':
                  case '>=':
                      this.advance();
                      var right = this.parseAdditive();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      };
      _ParseAST.prototype.parseAdditive = function () {
          // '+', '-'
          var result = this.parseMultiplicative();
          while (this.next.type == TokenType.Operator) {
              var operator = this.next.strValue;
              switch (operator) {
                  case '+':
                  case '-':
                      this.advance();
                      var right = this.parseMultiplicative();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      };
      _ParseAST.prototype.parseMultiplicative = function () {
          // '*', '%', '/'
          var result = this.parsePrefix();
          while (this.next.type == TokenType.Operator) {
              var operator = this.next.strValue;
              switch (operator) {
                  case '*':
                  case '%':
                  case '/':
                      this.advance();
                      var right = this.parsePrefix();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      };
      _ParseAST.prototype.parsePrefix = function () {
          if (this.next.type == TokenType.Operator) {
              var start = this.inputIndex;
              var operator = this.next.strValue;
              var result = void 0;
              switch (operator) {
                  case '+':
                      this.advance();
                      return this.parsePrefix();
                  case '-':
                      this.advance();
                      result = this.parsePrefix();
                      return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);
                  case '!':
                      this.advance();
                      result = this.parsePrefix();
                      return new PrefixNot(this.span(start), result);
              }
          }
          return this.parseCallChain();
      };
      _ParseAST.prototype.parseCallChain = function () {
          var result = this.parsePrimary();
          while (true) {
              if (this.optionalCharacter($PERIOD)) {
                  result = this.parseAccessMemberOrMethodCall(result, false);
              }
              else if (this.optionalOperator('?.')) {
                  result = this.parseAccessMemberOrMethodCall(result, true);
              }
              else if (this.optionalCharacter($LBRACKET)) {
                  this.rbracketsExpected++;
                  var key = this.parsePipe();
                  this.rbracketsExpected--;
                  this.expectCharacter($RBRACKET);
                  if (this.optionalOperator('=')) {
                      var value = this.parseConditional();
                      result = new KeyedWrite(this.span(result.span.start), result, key, value);
                  }
                  else {
                      result = new KeyedRead(this.span(result.span.start), result, key);
                  }
              }
              else if (this.optionalCharacter($LPAREN)) {
                  this.rparensExpected++;
                  var args = this.parseCallArguments();
                  this.rparensExpected--;
                  this.expectCharacter($RPAREN);
                  result = new FunctionCall(this.span(result.span.start), result, args);
              }
              else {
                  return result;
              }
          }
      };
      _ParseAST.prototype.parsePrimary = function () {
          var start = this.inputIndex;
          if (this.optionalCharacter($LPAREN)) {
              this.rparensExpected++;
              var result = this.parsePipe();
              this.rparensExpected--;
              this.expectCharacter($RPAREN);
              return result;
          }
          else if (this.next.isKeywordNull()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), null);
          }
          else if (this.next.isKeywordUndefined()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), void 0);
          }
          else if (this.next.isKeywordTrue()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), true);
          }
          else if (this.next.isKeywordFalse()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), false);
          }
          else if (this.next.isKeywordThis()) {
              this.advance();
              return new ImplicitReceiver(this.span(start));
          }
          else if (this.optionalCharacter($LBRACKET)) {
              this.rbracketsExpected++;
              var elements = this.parseExpressionList($RBRACKET);
              this.rbracketsExpected--;
              this.expectCharacter($RBRACKET);
              return new LiteralArray(this.span(start), elements);
          }
          else if (this.next.isCharacter($LBRACE)) {
              return this.parseLiteralMap();
          }
          else if (this.next.isIdentifier()) {
              return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);
          }
          else if (this.next.isNumber()) {
              var value = this.next.toNumber();
              this.advance();
              return new LiteralPrimitive(this.span(start), value);
          }
          else if (this.next.isString()) {
              var literalValue = this.next.toString();
              this.advance();
              return new LiteralPrimitive(this.span(start), literalValue);
          }
          else if (this.index >= this.tokens.length) {
              this.error("Unexpected end of expression: " + this.input);
              return new EmptyExpr(this.span(start));
          }
          else {
              this.error("Unexpected token " + this.next);
              return new EmptyExpr(this.span(start));
          }
      };
      _ParseAST.prototype.parseExpressionList = function (terminator) {
          var result = [];
          if (!this.next.isCharacter(terminator)) {
              do {
                  result.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
          }
          return result;
      };
      _ParseAST.prototype.parseLiteralMap = function () {
          var keys = [];
          var values = [];
          var start = this.inputIndex;
          this.expectCharacter($LBRACE);
          if (!this.optionalCharacter($RBRACE)) {
              this.rbracesExpected++;
              do {
                  var key = this.expectIdentifierOrKeywordOrString();
                  keys.push(key);
                  this.expectCharacter($COLON);
                  values.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
              this.rbracesExpected--;
              this.expectCharacter($RBRACE);
          }
          return new LiteralMap(this.span(start), keys, values);
      };
      _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {
          if (isSafe === void 0) { isSafe = false; }
          var start = receiver.span.start;
          var id = this.expectIdentifierOrKeyword();
          if (this.optionalCharacter($LPAREN)) {
              this.rparensExpected++;
              var args = this.parseCallArguments();
              this.expectCharacter($RPAREN);
              this.rparensExpected--;
              var span = this.span(start);
              return isSafe ? new SafeMethodCall(span, receiver, id, args) :
                  new MethodCall(span, receiver, id, args);
          }
          else {
              if (isSafe) {
                  if (this.optionalOperator('=')) {
                      this.error('The \'?.\' operator cannot be used in the assignment');
                      return new EmptyExpr(this.span(start));
                  }
                  else {
                      return new SafePropertyRead(this.span(start), receiver, id);
                  }
              }
              else {
                  if (this.optionalOperator('=')) {
                      if (!this.parseAction) {
                          this.error('Bindings cannot contain assignments');
                          return new EmptyExpr(this.span(start));
                      }
                      var value = this.parseConditional();
                      return new PropertyWrite(this.span(start), receiver, id, value);
                  }
                  else {
                      return new PropertyRead(this.span(start), receiver, id);
                  }
              }
          }
      };
      _ParseAST.prototype.parseCallArguments = function () {
          if (this.next.isCharacter($RPAREN))
              return [];
          var positionals = [];
          do {
              positionals.push(this.parsePipe());
          } while (this.optionalCharacter($COMMA));
          return positionals;
      };
      /**
       * An identifier, a keyword, a string with an optional `-` inbetween.
       */
      _ParseAST.prototype.expectTemplateBindingKey = function () {
          var result = '';
          var operatorFound = false;
          do {
              result += this.expectIdentifierOrKeywordOrString();
              operatorFound = this.optionalOperator('-');
              if (operatorFound) {
                  result += '-';
              }
          } while (operatorFound);
          return result.toString();
      };
      _ParseAST.prototype.parseTemplateBindings = function () {
          var bindings = [];
          var prefix = null;
          var warnings = [];
          while (this.index < this.tokens.length) {
              var keyIsVar = this.peekKeywordLet();
              if (keyIsVar) {
                  this.advance();
              }
              var key = this.expectTemplateBindingKey();
              if (!keyIsVar) {
                  if (prefix == null) {
                      prefix = key;
                  }
                  else {
                      key = prefix + key[0].toUpperCase() + key.substring(1);
                  }
              }
              this.optionalCharacter($COLON);
              var name = null;
              var expression = null;
              if (keyIsVar) {
                  if (this.optionalOperator('=')) {
                      name = this.expectTemplateBindingKey();
                  }
                  else {
                      name = '\$implicit';
                  }
              }
              else if (this.next !== EOF && !this.peekKeywordLet()) {
                  var start = this.inputIndex;
                  var ast = this.parsePipe();
                  var source = this.input.substring(start, this.inputIndex);
                  expression = new ASTWithSource(ast, source, this.location, this.errors);
              }
              bindings.push(new TemplateBinding(key, keyIsVar, name, expression));
              if (!this.optionalCharacter($SEMICOLON)) {
                  this.optionalCharacter($COMMA);
              }
          }
          return new TemplateBindingParseResult(bindings, warnings, this.errors);
      };
      _ParseAST.prototype.error = function (message, index) {
          if (index === void 0) { index = null; }
          this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
          this.skip();
      };
      _ParseAST.prototype.locationText = function (index) {
          if (index === void 0) { index = null; }
          if (isBlank(index))
              index = this.index;
          return (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" :
              "at the end of the expression";
      };
      // Error recovery should skip tokens until it encounters a recovery point. skip() treats
      // the end of input and a ';' as unconditionally a recovery point. It also treats ')',
      // '}' and ']' as conditional recovery points if one of calling productions is expecting
      // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing
      // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because
      // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols
      // must be conditional as they must be skipped if none of the calling productions are not
      // expecting the closing token else we will never make progress in the case of an
      // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because
      // parseChain() is always the root production and it expects a ';'.
      // If a production expects one of these token it increments the corresponding nesting count,
      // and then decrements it just prior to checking if the token is in the input.
      _ParseAST.prototype.skip = function () {
          var n = this.next;
          while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&
              (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&
              (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&
              (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {
              if (this.next.isError()) {
                  this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
              }
              this.advance();
              n = this.next;
          }
      };
      return _ParseAST;
  }());
  var SimpleExpressionChecker = (function () {
      function SimpleExpressionChecker() {
          this.simple = true;
      }
      SimpleExpressionChecker.check = function (ast) {
          var s = new SimpleExpressionChecker();
          ast.visit(s);
          return s.simple;
      };
      SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };
      SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };
      SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };
      SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };
      SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };
      SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitAll = function (asts) {
          var _this = this;
          return asts.map(function (node) { return node.visit(_this); });
      };
      SimpleExpressionChecker.prototype.visitChain = function (ast, context) { this.simple = false; };
      SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { this.simple = false; };
      return SimpleExpressionChecker;
  }());

  var ParseLocation = (function () {
      function ParseLocation(file, offset, line, col) {
          this.file = file;
          this.offset = offset;
          this.line = line;
          this.col = col;
      }
      ParseLocation.prototype.toString = function () {
          return isPresent(this.offset) ? this.file.url + "@" + this.line + ":" + this.col : this.file.url;
      };
      return ParseLocation;
  }());
  var ParseSourceFile = (function () {
      function ParseSourceFile(content, url) {
          this.content = content;
          this.url = url;
      }
      return ParseSourceFile;
  }());
  var ParseSourceSpan = (function () {
      function ParseSourceSpan(start, end, details) {
          if (details === void 0) { details = null; }
          this.start = start;
          this.end = end;
          this.details = details;
      }
      ParseSourceSpan.prototype.toString = function () {
          return this.start.file.content.substring(this.start.offset, this.end.offset);
      };
      return ParseSourceSpan;
  }());
  var ParseErrorLevel;
  (function (ParseErrorLevel) {
      ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
      ParseErrorLevel[ParseErrorLevel["FATAL"] = 1] = "FATAL";
  })(ParseErrorLevel || (ParseErrorLevel = {}));
  var ParseError = (function () {
      function ParseError(span, msg, level) {
          if (level === void 0) { level = ParseErrorLevel.FATAL; }
          this.span = span;
          this.msg = msg;
          this.level = level;
      }
      ParseError.prototype.toString = function () {
          var source = this.span.start.file.content;
          var ctxStart = this.span.start.offset;
          var contextStr = '';
          var details = '';
          if (isPresent(ctxStart)) {
              if (ctxStart > source.length - 1) {
                  ctxStart = source.length - 1;
              }
              var ctxEnd = ctxStart;
              var ctxLen = 0;
              var ctxLines = 0;
              while (ctxLen < 100 && ctxStart > 0) {
                  ctxStart--;
                  ctxLen++;
                  if (source[ctxStart] == '\n') {
                      if (++ctxLines == 3) {
                          break;
                      }
                  }
              }
              ctxLen = 0;
              ctxLines = 0;
              while (ctxLen < 100 && ctxEnd < source.length - 1) {
                  ctxEnd++;
                  ctxLen++;
                  if (source[ctxEnd] == '\n') {
                      if (++ctxLines == 3) {
                          break;
                      }
                  }
              }
              var context = source.substring(ctxStart, this.span.start.offset) + '[ERROR ->]' +
                  source.substring(this.span.start.offset, ctxEnd + 1);
              contextStr = " (\"" + context + "\")";
          }
          if (this.span.details) {
              details = ", " + this.span.details;
          }
          return "" + this.msg + contextStr + ": " + this.span.start + details;
      };
      return ParseError;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Text = (function () {
      function Text(value, sourceSpan) {
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
      return Text;
  }());
  var Expansion = (function () {
      function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {
          this.switchValue = switchValue;
          this.type = type;
          this.cases = cases;
          this.sourceSpan = sourceSpan;
          this.switchValueSourceSpan = switchValueSourceSpan;
      }
      Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };
      return Expansion;
  }());
  var ExpansionCase = (function () {
      function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
          this.value = value;
          this.expression = expression;
          this.sourceSpan = sourceSpan;
          this.valueSourceSpan = valueSourceSpan;
          this.expSourceSpan = expSourceSpan;
      }
      ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };
      return ExpansionCase;
  }());
  var Attribute$1 = (function () {
      function Attribute(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      Attribute.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };
      return Attribute;
  }());
  var Element = (function () {
      function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {
          this.name = name;
          this.attrs = attrs;
          this.children = children;
          this.sourceSpan = sourceSpan;
          this.startSourceSpan = startSourceSpan;
          this.endSourceSpan = endSourceSpan;
      }
      Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };
      return Element;
  }());
  var Comment = (function () {
      function Comment(value, sourceSpan) {
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };
      return Comment;
  }());
  function visitAll(visitor, nodes, context) {
      if (context === void 0) { context = null; }
      var result = [];
      nodes.forEach(function (ast) {
          var astResult = ast.visit(visitor, context);
          if (astResult) {
              result.push(astResult);
          }
      });
      return result;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$5 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var TokenType$1;
  (function (TokenType) {
      TokenType[TokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
      TokenType[TokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
      TokenType[TokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
      TokenType[TokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
      TokenType[TokenType["TEXT"] = 4] = "TEXT";
      TokenType[TokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
      TokenType[TokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
      TokenType[TokenType["COMMENT_START"] = 7] = "COMMENT_START";
      TokenType[TokenType["COMMENT_END"] = 8] = "COMMENT_END";
      TokenType[TokenType["CDATA_START"] = 9] = "CDATA_START";
      TokenType[TokenType["CDATA_END"] = 10] = "CDATA_END";
      TokenType[TokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
      TokenType[TokenType["ATTR_VALUE"] = 12] = "ATTR_VALUE";
      TokenType[TokenType["DOC_TYPE"] = 13] = "DOC_TYPE";
      TokenType[TokenType["EXPANSION_FORM_START"] = 14] = "EXPANSION_FORM_START";
      TokenType[TokenType["EXPANSION_CASE_VALUE"] = 15] = "EXPANSION_CASE_VALUE";
      TokenType[TokenType["EXPANSION_CASE_EXP_START"] = 16] = "EXPANSION_CASE_EXP_START";
      TokenType[TokenType["EXPANSION_CASE_EXP_END"] = 17] = "EXPANSION_CASE_EXP_END";
      TokenType[TokenType["EXPANSION_FORM_END"] = 18] = "EXPANSION_FORM_END";
      TokenType[TokenType["EOF"] = 19] = "EOF";
  })(TokenType$1 || (TokenType$1 = {}));
  var Token$1 = (function () {
      function Token(type, parts, sourceSpan) {
          this.type = type;
          this.parts = parts;
          this.sourceSpan = sourceSpan;
      }
      return Token;
  }());
  var TokenError = (function (_super) {
      __extends$5(TokenError, _super);
      function TokenError(errorMsg, tokenType, span) {
          _super.call(this, span, errorMsg);
          this.tokenType = tokenType;
      }
      return TokenError;
  }(ParseError));
  var TokenizeResult = (function () {
      function TokenizeResult(tokens, errors) {
          this.tokens = tokens;
          this.errors = errors;
      }
      return TokenizeResult;
  }());
  function tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {
      if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }
      if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
      return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)
          .tokenize();
  }
  var _CR_OR_CRLF_REGEXP = /\r\n?/g;
  function _unexpectedCharacterErrorMsg(charCode) {
      var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
      return "Unexpected character \"" + char + "\"";
  }
  function _unknownEntityErrorMsg(entitySrc) {
      return "Unknown entity \"" + entitySrc + "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax";
  }
  var _ControlFlowError = (function () {
      function _ControlFlowError(error) {
          this.error = error;
      }
      return _ControlFlowError;
  }());
  // See http://www.w3.org/TR/html51/syntax.html#writing
  var _Tokenizer = (function () {
      /**
       * @param _file The html source
       * @param _getTagDefinition
       * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)
       * @param _interpolationConfig
       */
      function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {
          if (_interpolationConfig === void 0) { _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          this._file = _file;
          this._getTagDefinition = _getTagDefinition;
          this._tokenizeIcu = _tokenizeIcu;
          this._interpolationConfig = _interpolationConfig;
          // Note: this is always lowercase!
          this._peek = -1;
          this._nextPeek = -1;
          this._index = -1;
          this._line = 0;
          this._column = -1;
          this._expansionCaseStack = [];
          this._inInterpolation = false;
          this.tokens = [];
          this.errors = [];
          this._input = _file.content;
          this._length = _file.content.length;
          this._advance();
      }
      _Tokenizer.prototype._processCarriageReturns = function (content) {
          // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream
          // In order to keep the original position in the source, we can not
          // pre-process it.
          // Instead CRs are processed right before instantiating the tokens.
          return content.replace(_CR_OR_CRLF_REGEXP, '\n');
      };
      _Tokenizer.prototype.tokenize = function () {
          while (this._peek !== $EOF) {
              var start = this._getLocation();
              try {
                  if (this._attemptCharCode($LT)) {
                      if (this._attemptCharCode($BANG)) {
                          if (this._attemptCharCode($LBRACKET)) {
                              this._consumeCdata(start);
                          }
                          else if (this._attemptCharCode($MINUS)) {
                              this._consumeComment(start);
                          }
                          else {
                              this._consumeDocType(start);
                          }
                      }
                      else if (this._attemptCharCode($SLASH)) {
                          this._consumeTagClose(start);
                      }
                      else {
                          this._consumeTagOpen(start);
                      }
                  }
                  else if (!this._tokenizeIcu || !this._tokenizeExpansionForm()) {
                      this._consumeText();
                  }
              }
              catch (e) {
                  if (e instanceof _ControlFlowError) {
                      this.errors.push(e.error);
                  }
                  else {
                      throw e;
                  }
              }
          }
          this._beginToken(TokenType$1.EOF);
          this._endToken([]);
          return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);
      };
      /**
       * @returns {boolean} whether an ICU token has been created
       * @internal
       */
      _Tokenizer.prototype._tokenizeExpansionForm = function () {
          if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
              this._consumeExpansionFormStart();
              return true;
          }
          if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {
              this._consumeExpansionCaseStart();
              return true;
          }
          if (this._peek === $RBRACE) {
              if (this._isInExpansionCase()) {
                  this._consumeExpansionCaseEnd();
                  return true;
              }
              if (this._isInExpansionForm()) {
                  this._consumeExpansionFormEnd();
                  return true;
              }
          }
          return false;
      };
      _Tokenizer.prototype._getLocation = function () {
          return new ParseLocation(this._file, this._index, this._line, this._column);
      };
      _Tokenizer.prototype._getSpan = function (start, end) {
          if (start === void 0) { start = this._getLocation(); }
          if (end === void 0) { end = this._getLocation(); }
          return new ParseSourceSpan(start, end);
      };
      _Tokenizer.prototype._beginToken = function (type, start) {
          if (start === void 0) { start = this._getLocation(); }
          this._currentTokenStart = start;
          this._currentTokenType = type;
      };
      _Tokenizer.prototype._endToken = function (parts, end) {
          if (end === void 0) { end = this._getLocation(); }
          var token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));
          this.tokens.push(token);
          this._currentTokenStart = null;
          this._currentTokenType = null;
          return token;
      };
      _Tokenizer.prototype._createError = function (msg, span) {
          if (this._isInExpansionForm()) {
              msg += " (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)";
          }
          var error = new TokenError(msg, this._currentTokenType, span);
          this._currentTokenStart = null;
          this._currentTokenType = null;
          return new _ControlFlowError(error);
      };
      _Tokenizer.prototype._advance = function () {
          if (this._index >= this._length) {
              throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());
          }
          if (this._peek === $LF) {
              this._line++;
              this._column = 0;
          }
          else if (this._peek !== $LF && this._peek !== $CR) {
              this._column++;
          }
          this._index++;
          this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);
          this._nextPeek =
              this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);
      };
      _Tokenizer.prototype._attemptCharCode = function (charCode) {
          if (this._peek === charCode) {
              this._advance();
              return true;
          }
          return false;
      };
      _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {
          if (compareCharCodeCaseInsensitive(this._peek, charCode)) {
              this._advance();
              return true;
          }
          return false;
      };
      _Tokenizer.prototype._requireCharCode = function (charCode) {
          var location = this._getLocation();
          if (!this._attemptCharCode(charCode)) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));
          }
      };
      _Tokenizer.prototype._attemptStr = function (chars) {
          var len = chars.length;
          if (this._index + len > this._length) {
              return false;
          }
          var initialPosition = this._savePosition();
          for (var i = 0; i < len; i++) {
              if (!this._attemptCharCode(chars.charCodeAt(i))) {
                  // If attempting to parse the string fails, we want to reset the parser
                  // to where it was before the attempt
                  this._restorePosition(initialPosition);
                  return false;
              }
          }
          return true;
      };
      _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {
          for (var i = 0; i < chars.length; i++) {
              if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
                  return false;
              }
          }
          return true;
      };
      _Tokenizer.prototype._requireStr = function (chars) {
          var location = this._getLocation();
          if (!this._attemptStr(chars)) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));
          }
      };
      _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {
          while (!predicate(this._peek)) {
              this._advance();
          }
      };
      _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {
          var start = this._getLocation();
          this._attemptCharCodeUntilFn(predicate);
          if (this._index - start.offset < len) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));
          }
      };
      _Tokenizer.prototype._attemptUntilChar = function (char) {
          while (this._peek !== char) {
              this._advance();
          }
      };
      _Tokenizer.prototype._readChar = function (decodeEntities) {
          if (decodeEntities && this._peek === $AMPERSAND) {
              return this._decodeEntity();
          }
          else {
              var index = this._index;
              this._advance();
              return this._input[index];
          }
      };
      _Tokenizer.prototype._decodeEntity = function () {
          var start = this._getLocation();
          this._advance();
          if (this._attemptCharCode($HASH)) {
              var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
              var numberStart = this._getLocation().offset;
              this._attemptCharCodeUntilFn(isDigitEntityEnd);
              if (this._peek != $SEMICOLON) {
                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
              }
              this._advance();
              var strNum = this._input.substring(numberStart, this._index - 1);
              try {
                  var charCode = parseInt(strNum, isHex ? 16 : 10);
                  return String.fromCharCode(charCode);
              }
              catch (e) {
                  var entity = this._input.substring(start.offset + 1, this._index - 1);
                  throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));
              }
          }
          else {
              var startPosition = this._savePosition();
              this._attemptCharCodeUntilFn(isNamedEntityEnd);
              if (this._peek != $SEMICOLON) {
                  this._restorePosition(startPosition);
                  return '&';
              }
              this._advance();
              var name_1 = this._input.substring(start.offset + 1, this._index - 1);
              var char = NAMED_ENTITIES[name_1];
              if (!char) {
                  throw this._createError(_unknownEntityErrorMsg(name_1), this._getSpan(start));
              }
              return char;
          }
      };
      _Tokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {
          var tagCloseStart;
          var textStart = this._getLocation();
          this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);
          var parts = [];
          while (true) {
              tagCloseStart = this._getLocation();
              if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
                  break;
              }
              if (this._index > tagCloseStart.offset) {
                  // add the characters consumed by the previous if statement to the output
                  parts.push(this._input.substring(tagCloseStart.offset, this._index));
              }
              while (this._peek !== firstCharOfEnd) {
                  parts.push(this._readChar(decodeEntities));
              }
          }
          return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
      };
      _Tokenizer.prototype._consumeComment = function (start) {
          var _this = this;
          this._beginToken(TokenType$1.COMMENT_START, start);
          this._requireCharCode($MINUS);
          this._endToken([]);
          var textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });
          this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);
          this._endToken([]);
      };
      _Tokenizer.prototype._consumeCdata = function (start) {
          var _this = this;
          this._beginToken(TokenType$1.CDATA_START, start);
          this._requireStr('CDATA[');
          this._endToken([]);
          var textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });
          this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);
          this._endToken([]);
      };
      _Tokenizer.prototype._consumeDocType = function (start) {
          this._beginToken(TokenType$1.DOC_TYPE, start);
          this._attemptUntilChar($GT);
          this._advance();
          this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);
      };
      _Tokenizer.prototype._consumePrefixAndName = function () {
          var nameOrPrefixStart = this._index;
          var prefix = null;
          while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {
              this._advance();
          }
          var nameStart;
          if (this._peek === $COLON) {
              this._advance();
              prefix = this._input.substring(nameOrPrefixStart, this._index - 1);
              nameStart = this._index;
          }
          else {
              nameStart = nameOrPrefixStart;
          }
          this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);
          var name = this._input.substring(nameStart, this._index);
          return [prefix, name];
      };
      _Tokenizer.prototype._consumeTagOpen = function (start) {
          var savedPos = this._savePosition();
          var tagName;
          var lowercaseTagName;
          try {
              if (!isAsciiLetter(this._peek)) {
                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
              }
              var nameStart = this._index;
              this._consumeTagOpenStart(start);
              tagName = this._input.substring(nameStart, this._index);
              lowercaseTagName = tagName.toLowerCase();
              this._attemptCharCodeUntilFn(isNotWhitespace);
              while (this._peek !== $SLASH && this._peek !== $GT) {
                  this._consumeAttributeName();
                  this._attemptCharCodeUntilFn(isNotWhitespace);
                  if (this._attemptCharCode($EQ)) {
                      this._attemptCharCodeUntilFn(isNotWhitespace);
                      this._consumeAttributeValue();
                  }
                  this._attemptCharCodeUntilFn(isNotWhitespace);
              }
              this._consumeTagOpenEnd();
          }
          catch (e) {
              if (e instanceof _ControlFlowError) {
                  // When the start tag is invalid, assume we want a "<"
                  this._restorePosition(savedPos);
                  // Back to back text tokens are merged at the end
                  this._beginToken(TokenType$1.TEXT, start);
                  this._endToken(['<']);
                  return;
              }
              throw e;
          }
          var contentTokenType = this._getTagDefinition(tagName).contentType;
          if (contentTokenType === TagContentType.RAW_TEXT) {
              this._consumeRawTextWithTagClose(lowercaseTagName, false);
          }
          else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
              this._consumeRawTextWithTagClose(lowercaseTagName, true);
          }
      };
      _Tokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {
          var _this = this;
          var textToken = this._consumeRawText(decodeEntities, $LT, function () {
              if (!_this._attemptCharCode($SLASH))
                  return false;
              _this._attemptCharCodeUntilFn(isNotWhitespace);
              if (!_this._attemptStrCaseInsensitive(lowercaseTagName))
                  return false;
              _this._attemptCharCodeUntilFn(isNotWhitespace);
              return _this._attemptCharCode($GT);
          });
          this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);
          this._endToken([null, lowercaseTagName]);
      };
      _Tokenizer.prototype._consumeTagOpenStart = function (start) {
          this._beginToken(TokenType$1.TAG_OPEN_START, start);
          var parts = this._consumePrefixAndName();
          this._endToken(parts);
      };
      _Tokenizer.prototype._consumeAttributeName = function () {
          this._beginToken(TokenType$1.ATTR_NAME);
          var prefixAndName = this._consumePrefixAndName();
          this._endToken(prefixAndName);
      };
      _Tokenizer.prototype._consumeAttributeValue = function () {
          this._beginToken(TokenType$1.ATTR_VALUE);
          var value;
          if (this._peek === $SQ || this._peek === $DQ) {
              var quoteChar = this._peek;
              this._advance();
              var parts = [];
              while (this._peek !== quoteChar) {
                  parts.push(this._readChar(true));
              }
              value = parts.join('');
              this._advance();
          }
          else {
              var valueStart = this._index;
              this._requireCharCodeUntilFn(isNameEnd, 1);
              value = this._input.substring(valueStart, this._index);
          }
          this._endToken([this._processCarriageReturns(value)]);
      };
      _Tokenizer.prototype._consumeTagOpenEnd = function () {
          var tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;
          this._beginToken(tokenType);
          this._requireCharCode($GT);
          this._endToken([]);
      };
      _Tokenizer.prototype._consumeTagClose = function (start) {
          this._beginToken(TokenType$1.TAG_CLOSE, start);
          this._attemptCharCodeUntilFn(isNotWhitespace);
          var prefixAndName = this._consumePrefixAndName();
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._requireCharCode($GT);
          this._endToken(prefixAndName);
      };
      _Tokenizer.prototype._consumeExpansionFormStart = function () {
          this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());
          this._requireCharCode($LBRACE);
          this._endToken([]);
          this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);
          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
          var condition = this._readUntil($COMMA);
          this._endToken([condition], this._getLocation());
          this._requireCharCode($COMMA);
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
          var type = this._readUntil($COMMA);
          this._endToken([type], this._getLocation());
          this._requireCharCode($COMMA);
          this._attemptCharCodeUntilFn(isNotWhitespace);
      };
      _Tokenizer.prototype._consumeExpansionCaseStart = function () {
          this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());
          var value = this._readUntil($LBRACE).trim();
          this._endToken([value], this._getLocation());
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());
          this._requireCharCode($LBRACE);
          this._endToken([], this._getLocation());
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);
      };
      _Tokenizer.prototype._consumeExpansionCaseEnd = function () {
          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());
          this._requireCharCode($RBRACE);
          this._endToken([], this._getLocation());
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._expansionCaseStack.pop();
      };
      _Tokenizer.prototype._consumeExpansionFormEnd = function () {
          this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());
          this._requireCharCode($RBRACE);
          this._endToken([]);
          this._expansionCaseStack.pop();
      };
      _Tokenizer.prototype._consumeText = function () {
          var start = this._getLocation();
          this._beginToken(TokenType$1.TEXT, start);
          var parts = [];
          do {
              if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
                  parts.push(this._interpolationConfig.start);
                  this._inInterpolation = true;
              }
              else if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.end) &&
                  this._inInterpolation) {
                  parts.push(this._interpolationConfig.end);
                  this._inInterpolation = false;
              }
              else {
                  parts.push(this._readChar(true));
              }
          } while (!this._isTextEnd());
          this._endToken([this._processCarriageReturns(parts.join(''))]);
      };
      _Tokenizer.prototype._isTextEnd = function () {
          if (this._peek === $LT || this._peek === $EOF) {
              return true;
          }
          if (this._tokenizeIcu && !this._inInterpolation) {
              if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
                  // start of an expansion form
                  return true;
              }
              if (this._peek === $RBRACE && this._isInExpansionCase()) {
                  // end of and expansion case
                  return true;
              }
          }
          return false;
      };
      _Tokenizer.prototype._savePosition = function () {
          return [this._peek, this._index, this._column, this._line, this.tokens.length];
      };
      _Tokenizer.prototype._readUntil = function (char) {
          var start = this._index;
          this._attemptUntilChar(char);
          return this._input.substring(start, this._index);
      };
      _Tokenizer.prototype._restorePosition = function (position) {
          this._peek = position[0];
          this._index = position[1];
          this._column = position[2];
          this._line = position[3];
          var nbTokens = position[4];
          if (nbTokens < this.tokens.length) {
              // remove any extra tokens
              this.tokens = this.tokens.slice(0, nbTokens);
          }
      };
      _Tokenizer.prototype._isInExpansionCase = function () {
          return this._expansionCaseStack.length > 0 &&
              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                  TokenType$1.EXPANSION_CASE_EXP_START;
      };
      _Tokenizer.prototype._isInExpansionForm = function () {
          return this._expansionCaseStack.length > 0 &&
              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                  TokenType$1.EXPANSION_FORM_START;
      };
      return _Tokenizer;
  }());
  function isNotWhitespace(code) {
      return !isWhitespace(code) || code === $EOF;
  }
  function isNameEnd(code) {
      return isWhitespace(code) || code === $GT || code === $SLASH ||
          code === $SQ || code === $DQ || code === $EQ;
  }
  function isPrefixEnd(code) {
      return (code < $a || $z < code) && (code < $A || $Z < code) &&
          (code < $0 || code > $9);
  }
  function isDigitEntityEnd(code) {
      return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
  }
  function isNamedEntityEnd(code) {
      return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
  }
  function isExpansionFormStart(input, offset, interpolationConfig) {
      var isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;
      return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;
  }
  function isExpansionCaseStart(peek) {
      return peek === $EQ || isAsciiLetter(peek);
  }
  function compareCharCodeCaseInsensitive(code1, code2) {
      return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
  }
  function toUpperCaseCharCode(code) {
      return code >= $a && code <= $z ? code - $a + $A : code;
  }
  function mergeTextTokens(srcTokens) {
      var dstTokens = [];
      var lastDstToken;
      for (var i = 0; i < srcTokens.length; i++) {
          var token = srcTokens[i];
          if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {
              lastDstToken.parts[0] += token.parts[0];
              lastDstToken.sourceSpan.end = token.sourceSpan.end;
          }
          else {
              lastDstToken = token;
              dstTokens.push(lastDstToken);
          }
      }
      return dstTokens;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$4 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var TreeError = (function (_super) {
      __extends$4(TreeError, _super);
      function TreeError(elementName, span, msg) {
          _super.call(this, span, msg);
          this.elementName = elementName;
      }
      TreeError.create = function (elementName, span, msg) {
          return new TreeError(elementName, span, msg);
      };
      return TreeError;
  }(ParseError));
  var ParseTreeResult = (function () {
      function ParseTreeResult(rootNodes, errors) {
          this.rootNodes = rootNodes;
          this.errors = errors;
      }
      return ParseTreeResult;
  }());
  var Parser$1 = (function () {
      function Parser(getTagDefinition) {
          this.getTagDefinition = getTagDefinition;
      }
      Parser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);
          var treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();
          return new ParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));
      };
      return Parser;
  }());
  var _TreeBuilder = (function () {
      function _TreeBuilder(tokens, getTagDefinition) {
          this.tokens = tokens;
          this.getTagDefinition = getTagDefinition;
          this._index = -1;
          this._rootNodes = [];
          this._errors = [];
          this._elementStack = [];
          this._advance();
      }
      _TreeBuilder.prototype.build = function () {
          while (this._peek.type !== TokenType$1.EOF) {
              if (this._peek.type === TokenType$1.TAG_OPEN_START) {
                  this._consumeStartTag(this._advance());
              }
              else if (this._peek.type === TokenType$1.TAG_CLOSE) {
                  this._consumeEndTag(this._advance());
              }
              else if (this._peek.type === TokenType$1.CDATA_START) {
                  this._closeVoidElement();
                  this._consumeCdata(this._advance());
              }
              else if (this._peek.type === TokenType$1.COMMENT_START) {
                  this._closeVoidElement();
                  this._consumeComment(this._advance());
              }
              else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||
                  this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {
                  this._closeVoidElement();
                  this._consumeText(this._advance());
              }
              else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {
                  this._consumeExpansion(this._advance());
              }
              else {
                  // Skip all other tokens...
                  this._advance();
              }
          }
          return new ParseTreeResult(this._rootNodes, this._errors);
      };
      _TreeBuilder.prototype._advance = function () {
          var prev = this._peek;
          if (this._index < this.tokens.length - 1) {
              // Note: there is always an EOF token at the end
              this._index++;
          }
          this._peek = this.tokens[this._index];
          return prev;
      };
      _TreeBuilder.prototype._advanceIf = function (type) {
          if (this._peek.type === type) {
              return this._advance();
          }
          return null;
      };
      _TreeBuilder.prototype._consumeCdata = function (startToken) {
          this._consumeText(this._advance());
          this._advanceIf(TokenType$1.CDATA_END);
      };
      _TreeBuilder.prototype._consumeComment = function (token) {
          var text = this._advanceIf(TokenType$1.RAW_TEXT);
          this._advanceIf(TokenType$1.COMMENT_END);
          var value = isPresent(text) ? text.parts[0].trim() : null;
          this._addToParent(new Comment(value, token.sourceSpan));
      };
      _TreeBuilder.prototype._consumeExpansion = function (token) {
          var switchValue = this._advance();
          var type = this._advance();
          var cases = [];
          // read =
          while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {
              var expCase = this._parseExpansionCase();
              if (!expCase)
                  return; // error
              cases.push(expCase);
          }
          // read the final }
          if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {
              this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
              return;
          }
          var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);
          this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
          this._advance();
      };
      _TreeBuilder.prototype._parseExpansionCase = function () {
          var value = this._advance();
          // read {
          if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {
              this._errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'."));
              return null;
          }
          // read until }
          var start = this._advance();
          var exp = this._collectExpansionExpTokens(start);
          if (!exp)
              return null;
          var end = this._advance();
          exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));
          // parse everything in between { and }
          var parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();
          if (parsedExp.errors.length > 0) {
              this._errors = this._errors.concat(parsedExp.errors);
              return null;
          }
          var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
          var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
          return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
      };
      _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {
          var exp = [];
          var expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];
          while (true) {
              if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||
                  this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {
                  expansionFormStack.push(this._peek.type);
              }
              if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {
                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {
                      expansionFormStack.pop();
                      if (expansionFormStack.length == 0)
                          return exp;
                  }
                  else {
                      this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
                      return null;
                  }
              }
              if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {
                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {
                      expansionFormStack.pop();
                  }
                  else {
                      this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
                      return null;
                  }
              }
              if (this._peek.type === TokenType$1.EOF) {
                  this._errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
                  return null;
              }
              exp.push(this._advance());
          }
      };
      _TreeBuilder.prototype._consumeText = function (token) {
          var text = token.parts[0];
          if (text.length > 0 && text[0] == '\n') {
              var parent_1 = this._getParentElement();
              if (isPresent(parent_1) && parent_1.children.length == 0 &&
                  this.getTagDefinition(parent_1.name).ignoreFirstLf) {
                  text = text.substring(1);
              }
          }
          if (text.length > 0) {
              this._addToParent(new Text(text, token.sourceSpan));
          }
      };
      _TreeBuilder.prototype._closeVoidElement = function () {
          if (this._elementStack.length > 0) {
              var el = ListWrapper.last(this._elementStack);
              if (this.getTagDefinition(el.name).isVoid) {
                  this._elementStack.pop();
              }
          }
      };
      _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {
          var prefix = startTagToken.parts[0];
          var name = startTagToken.parts[1];
          var attrs = [];
          while (this._peek.type === TokenType$1.ATTR_NAME) {
              attrs.push(this._consumeAttr(this._advance()));
          }
          var fullName = this._getElementFullName(prefix, name, this._getParentElement());
          var selfClosing = false;
          // Note: There could have been a tokenizer error
          // so that we don't get a token for the end tag...
          if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {
              this._advance();
              selfClosing = true;
              var tagDef = this.getTagDefinition(fullName);
              if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
                  this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"" + startTagToken.parts[1] + "\""));
              }
          }
          else if (this._peek.type === TokenType$1.TAG_OPEN_END) {
              this._advance();
              selfClosing = false;
          }
          var end = this._peek.sourceSpan.start;
          var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
          var el = new Element(fullName, attrs, [], span, span, null);
          this._pushElement(el);
          if (selfClosing) {
              this._popElement(fullName);
              el.endSourceSpan = span;
          }
      };
      _TreeBuilder.prototype._pushElement = function (el) {
          if (this._elementStack.length > 0) {
              var parentEl = ListWrapper.last(this._elementStack);
              if (this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
                  this._elementStack.pop();
              }
          }
          var tagDef = this.getTagDefinition(el.name);
          var _a = this._getParentElementSkippingContainers(), parent = _a.parent, container = _a.container;
          if (isPresent(parent) && tagDef.requireExtraParent(parent.name)) {
              var newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
              this._insertBeforeContainer(parent, container, newParent);
          }
          this._addToParent(el);
          this._elementStack.push(el);
      };
      _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {
          var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
          if (this._getParentElement()) {
              this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
          }
          if (this.getTagDefinition(fullName).isVoid) {
              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"" + endTagToken.parts[1] + "\""));
          }
          else if (!this._popElement(fullName)) {
              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Unexpected closing tag \"" + endTagToken.parts[1] + "\""));
          }
      };
      _TreeBuilder.prototype._popElement = function (fullName) {
          for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
              var el = this._elementStack[stackIndex];
              if (el.name == fullName) {
                  ListWrapper.splice(this._elementStack, stackIndex, this._elementStack.length - stackIndex);
                  return true;
              }
              if (!this.getTagDefinition(el.name).closedByParent) {
                  return false;
              }
          }
          return false;
      };
      _TreeBuilder.prototype._consumeAttr = function (attrName) {
          var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
          var end = attrName.sourceSpan.end;
          var value = '';
          if (this._peek.type === TokenType$1.ATTR_VALUE) {
              var valueToken = this._advance();
              value = valueToken.parts[0];
              end = valueToken.sourceSpan.end;
          }
          return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end));
      };
      _TreeBuilder.prototype._getParentElement = function () {
          return this._elementStack.length > 0 ? ListWrapper.last(this._elementStack) : null;
      };
      /**
       * Returns the parent in the DOM and the container.
       *
       * `<ng-container>` elements are skipped as they are not rendered as DOM element.
       */
      _TreeBuilder.prototype._getParentElementSkippingContainers = function () {
          var container = null;
          for (var i = this._elementStack.length - 1; i >= 0; i--) {
              if (this._elementStack[i].name !== 'ng-container') {
                  return { parent: this._elementStack[i], container: container };
              }
              container = this._elementStack[i];
          }
          return { parent: ListWrapper.last(this._elementStack), container: container };
      };
      _TreeBuilder.prototype._addToParent = function (node) {
          var parent = this._getParentElement();
          if (isPresent(parent)) {
              parent.children.push(node);
          }
          else {
              this._rootNodes.push(node);
          }
      };
      /**
       * Insert a node between the parent and the container.
       * When no container is given, the node is appended as a child of the parent.
       * Also updates the element stack accordingly.
       *
       * @internal
       */
      _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {
          if (!container) {
              this._addToParent(node);
              this._elementStack.push(node);
          }
          else {
              if (parent) {
                  // replace the container with the new node in the children
                  var index = parent.children.indexOf(container);
                  parent.children[index] = node;
              }
              else {
                  this._rootNodes.push(node);
              }
              node.children.push(container);
              this._elementStack.splice(this._elementStack.indexOf(container), 0, node);
          }
      };
      _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {
          if (isBlank(prefix)) {
              prefix = this.getTagDefinition(localName).implicitNamespacePrefix;
              if (isBlank(prefix) && isPresent(parentElement)) {
                  prefix = getNsPrefix(parentElement.name);
              }
          }
          return mergeNsAndName(prefix, localName);
      };
      return _TreeBuilder;
  }());
  function lastOnStack(stack, element) {
      return stack.length > 0 && stack[stack.length - 1] === element;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function digestMessage(message) {
      return sha1(serializeNodes(message.nodes).join('') + ("[" + message.meaning + "]"));
  }
  /**
   * Serialize the i18n ast to something xml-like in order to generate an UID.
   *
   * The visitor is also used in the i18n parser tests
   *
   * @internal
   */
  var _SerializerVisitor = (function () {
      function _SerializerVisitor() {
      }
      _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };
      _SerializerVisitor.prototype.visitContainer = function (container, context) {
          var _this = this;
          return "[" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + "]";
      };
      _SerializerVisitor.prototype.visitIcu = function (icu, context) {
          var _this = this;
          var strCases = Object.keys(icu.cases).map(function (k) { return (k + " {" + icu.cases[k].visit(_this) + "}"); });
          return "{" + icu.expression + ", " + icu.type + ", " + strCases.join(', ') + "}";
      };
      _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {
          var _this = this;
          return ph.isVoid ?
              "<ph tag name=\"" + ph.startName + "\"/>" :
              "<ph tag name=\"" + ph.startName + "\">" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + "</ph name=\"" + ph.closeName + "\">";
      };
      _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {
          return "<ph name=\"" + ph.name + "\">" + ph.value + "</ph>";
      };
      _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {
          return "<ph icu name=\"" + ph.name + "\">" + ph.value.visit(this) + "</ph>";
      };
      return _SerializerVisitor;
  }());
  var serializerVisitor = new _SerializerVisitor();
  function serializeNodes(nodes) {
      return nodes.map(function (a) { return a.visit(serializerVisitor, null); });
  }
  /**
   * Compute the SHA1 of the given string
   *
   * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
   *
   * WARNING: this function has not been designed not tested with security in mind.
   *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
   */
  function sha1(str) {
      var utf8 = utf8Encode(str);
      var words32 = stringToWords32(utf8);
      var len = utf8.length * 8;
      var w = new Array(80);
      var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4];
      words32[len >> 5] |= 0x80 << (24 - len % 32);
      words32[((len + 64 >> 9) << 4) + 15] = len;
      for (var i = 0; i < words32.length; i += 16) {
          var _b = [a, b, c, d, e], h0 = _b[0], h1 = _b[1], h2 = _b[2], h3 = _b[3], h4 = _b[4];
          for (var j = 0; j < 80; j++) {
              if (j < 16) {
                  w[j] = words32[i + j];
              }
              else {
                  w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
              }
              var _c = fk(j, b, c, d), f = _c[0], k = _c[1];
              var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
              _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];
          }
          _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];
      }
      var sha1 = words32ToString([a, b, c, d, e]);
      var hex = '';
      for (var i = 0; i < sha1.length; i++) {
          var b_1 = sha1.charCodeAt(i);
          hex += (b_1 >>> 4 & 0x0f).toString(16) + (b_1 & 0x0f).toString(16);
      }
      return hex.toLowerCase();
      var _d, _e;
  }
  function utf8Encode(str) {
      var encoded = '';
      for (var index = 0; index < str.length; index++) {
          var codePoint = decodeSurrogatePairs(str, index);
          if (codePoint <= 0x7f) {
              encoded += String.fromCharCode(codePoint);
          }
          else if (codePoint <= 0x7ff) {
              encoded += String.fromCharCode(0xc0 | codePoint >>> 6, 0x80 | codePoint & 0x3f);
          }
          else if (codePoint <= 0xffff) {
              encoded += String.fromCharCode(0xe0 | codePoint >>> 12, 0x80 | codePoint >>> 6 & 0x3f, 0x80 | codePoint & 0x3f);
          }
          else if (codePoint <= 0x1fffff) {
              encoded += String.fromCharCode(0xf0 | codePoint >>> 18, 0x80 | codePoint >>> 12 & 0x3f, 0x80 | codePoint >>> 6 & 0x3f, 0x80 | codePoint & 0x3f);
          }
      }
      return encoded;
  }
  // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
  function decodeSurrogatePairs(str, index) {
      if (index < 0 || index >= str.length) {
          throw new Error("index=" + index + " is out of range in \"" + str + "\"");
      }
      var high = str.charCodeAt(index);
      var low;
      if (high >= 0xd800 && high <= 0xdfff && str.length > index + 1) {
          low = str.charCodeAt(index + 1);
          if (low >= 0xdc00 && low <= 0xdfff) {
              return (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;
          }
      }
      return high;
  }
  function stringToWords32(str) {
      var words32 = Array(str.length >>> 2);
      for (var i = 0; i < words32.length; i++) {
          words32[i] = 0;
      }
      for (var i = 0; i < str.length; i++) {
          words32[i >>> 2] |= (str.charCodeAt(i) & 0xff) << 8 * (3 - i & 0x3);
      }
      return words32;
  }
  function words32ToString(words32) {
      var str = '';
      for (var i = 0; i < words32.length * 4; i++) {
          str += String.fromCharCode((words32[i >>> 2] >>> 8 * (3 - i & 0x3)) & 0xff);
      }
      return str;
  }
  function fk(index, b, c, d) {
      if (index < 20) {
          return [(b & c) | (~b & d), 0x5a827999];
      }
      if (index < 40) {
          return [b ^ c ^ d, 0x6ed9eba1];
      }
      if (index < 60) {
          return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
      }
      return [b ^ c ^ d, 0xca62c1d6];
  }
  function add32(a, b) {
      var low = (a & 0xffff) + (b & 0xffff);
      var high = (a >> 16) + (b >> 16) + (low >> 16);
      return (high << 16) | (low & 0xffff);
  }
  function rol32(a, count) {
      return (a << count) | (a >>> (32 - count));
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var Message = (function () {
      /**
       * @param nodes message AST
       * @param placeholders maps placeholder names to static content
       * @param placeholderToMsgIds maps placeholder names to translatable message IDs (used for ICU
       *                            messages)
       * @param meaning
       * @param description
       */
      function Message(nodes, placeholders, placeholderToMsgIds, meaning, description) {
          this.nodes = nodes;
          this.placeholders = placeholders;
          this.placeholderToMsgIds = placeholderToMsgIds;
          this.meaning = meaning;
          this.description = description;
      }
      return Message;
  }());
  var Text$1 = (function () {
      function Text(value, sourceSpan) {
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };
      return Text;
  }());
  var Container = (function () {
      function Container(children, sourceSpan) {
          this.children = children;
          this.sourceSpan = sourceSpan;
      }
      Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };
      return Container;
  }());
  var Icu = (function () {
      function Icu(expression, type, cases, sourceSpan) {
          this.expression = expression;
          this.type = type;
          this.cases = cases;
          this.sourceSpan = sourceSpan;
      }
      Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };
      return Icu;
  }());
  var TagPlaceholder = (function () {
      function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {
          this.tag = tag;
          this.attrs = attrs;
          this.startName = startName;
          this.closeName = closeName;
          this.children = children;
          this.isVoid = isVoid;
          this.sourceSpan = sourceSpan;
      }
      TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };
      return TagPlaceholder;
  }());
  var Placeholder = (function () {
      function Placeholder(value, name, sourceSpan) {
          if (name === void 0) { name = ''; }
          this.value = value;
          this.name = name;
          this.sourceSpan = sourceSpan;
      }
      Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };
      return Placeholder;
  }());
  var IcuPlaceholder = (function () {
      function IcuPlaceholder(value, name, sourceSpan) {
          if (name === void 0) { name = ''; }
          this.value = value;
          this.name = name;
          this.sourceSpan = sourceSpan;
      }
      IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };
      return IcuPlaceholder;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TAG_TO_PLACEHOLDER_NAMES = {
      'A': 'LINK',
      'B': 'BOLD_TEXT',
      'BR': 'LINE_BREAK',
      'EM': 'EMPHASISED_TEXT',
      'H1': 'HEADING_LEVEL1',
      'H2': 'HEADING_LEVEL2',
      'H3': 'HEADING_LEVEL3',
      'H4': 'HEADING_LEVEL4',
      'H5': 'HEADING_LEVEL5',
      'H6': 'HEADING_LEVEL6',
      'HR': 'HORIZONTAL_RULE',
      'I': 'ITALIC_TEXT',
      'LI': 'LIST_ITEM',
      'LINK': 'MEDIA_LINK',
      'OL': 'ORDERED_LIST',
      'P': 'PARAGRAPH',
      'Q': 'QUOTATION',
      'S': 'STRIKETHROUGH_TEXT',
      'SMALL': 'SMALL_TEXT',
      'SUB': 'SUBSTRIPT',
      'SUP': 'SUPERSCRIPT',
      'TBODY': 'TABLE_BODY',
      'TD': 'TABLE_CELL',
      'TFOOT': 'TABLE_FOOTER',
      'TH': 'TABLE_HEADER_CELL',
      'THEAD': 'TABLE_HEADER',
      'TR': 'TABLE_ROW',
      'TT': 'MONOSPACED_TEXT',
      'U': 'UNDERLINED_TEXT',
      'UL': 'UNORDERED_LIST',
  };
  /**
   * Creates unique names for placeholder with different content
   *
   * @internal
   */
  var PlaceholderRegistry = (function () {
      function PlaceholderRegistry() {
          // Count the occurrence of the base name top generate a unique name
          this._placeHolderNameCounts = {};
          // Maps signature to placeholder names
          this._signatureToName = {};
      }
      PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {
          var signature = this._hashTag(tag, attrs, isVoid);
          if (this._signatureToName[signature]) {
              return this._signatureToName[signature];
          }
          var upperTag = tag.toUpperCase();
          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
          var name = this._generateUniqueName(isVoid ? baseName : "START_" + baseName);
          this._signatureToName[signature] = name;
          return name;
      };
      PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {
          var signature = this._hashClosingTag(tag);
          if (this._signatureToName[signature]) {
              return this._signatureToName[signature];
          }
          var upperTag = tag.toUpperCase();
          var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_" + upperTag;
          var name = this._generateUniqueName("CLOSE_" + baseName);
          this._signatureToName[signature] = name;
          return name;
      };
      PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {
          var upperName = name.toUpperCase();
          var signature = "PH: " + upperName + "=" + content;
          if (this._signatureToName[signature]) {
              return this._signatureToName[signature];
          }
          var uniqueName = this._generateUniqueName(upperName);
          this._signatureToName[signature] = uniqueName;
          return uniqueName;
      };
      // Generate a hash for a tag - does not take attribute order into account
      PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {
          var start = "<" + tag;
          var strAttrs = Object.keys(attrs).sort().map(function (name) { return (" " + name + "=" + attrs[name]); }).join('');
          var end = isVoid ? '/>' : "></" + tag + ">";
          return start + strAttrs + end;
      };
      PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag("/" + tag, {}, false); };
      PlaceholderRegistry.prototype._generateUniqueName = function (base) {
          var name = base;
          var next = this._placeHolderNameCounts[name];
          if (!next) {
              next = 1;
          }
          else {
              name += "_" + next;
              next++;
          }
          this._placeHolderNameCounts[base] = next;
          return name;
      };
      return PlaceholderRegistry;
  }());

  var _expParser = new Parser(new Lexer());
  /**
   * Returns a function converting html nodes to an i18n Message given an interpolationConfig
   */
  function createI18nMessageFactory(interpolationConfig) {
      var visitor = new _I18nVisitor(_expParser, interpolationConfig);
      return function (nodes, meaning, description) {
          return visitor.toI18nMessage(nodes, meaning, description);
      };
  }
  var _I18nVisitor = (function () {
      function _I18nVisitor(_expressionParser, _interpolationConfig) {
          this._expressionParser = _expressionParser;
          this._interpolationConfig = _interpolationConfig;
      }
      _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description) {
          this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;
          this._icuDepth = 0;
          this._placeholderRegistry = new PlaceholderRegistry();
          this._placeholderToContent = {};
          this._placeholderToIds = {};
          var i18nodes = visitAll(this, nodes, {});
          return new Message(i18nodes, this._placeholderToContent, this._placeholderToIds, meaning, description);
      };
      _I18nVisitor.prototype.visitElement = function (el, context) {
          var children = visitAll(this, el.children);
          var attrs = {};
          el.attrs.forEach(function (attr) {
              // Do not visit the attributes, translatable ones are top-level ASTs
              attrs[attr.name] = attr.value;
          });
          var isVoid = getHtmlTagDefinition(el.name).isVoid;
          var startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
          this._placeholderToContent[startPhName] = el.sourceSpan.toString();
          var closePhName = '';
          if (!isVoid) {
              closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);
              this._placeholderToContent[closePhName] = "</" + el.name + ">";
          }
          return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);
      };
      _I18nVisitor.prototype.visitAttribute = function (attribute, context) {
          return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);
      };
      _I18nVisitor.prototype.visitText = function (text, context) {
          return this._visitTextWithInterpolation(text.value, text.sourceSpan);
      };
      _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };
      _I18nVisitor.prototype.visitExpansion = function (icu, context) {
          var _this = this;
          this._icuDepth++;
          var i18nIcuCases = {};
          var i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
          icu.cases.forEach(function (caze) {
              i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);
          });
          this._icuDepth--;
          if (this._isIcu || this._icuDepth > 0) {
              // If the message (vs a part of the message) is an ICU message returns it
              return i18nIcu;
          }
          // Else returns a placeholder
          // ICU placeholders should not be replaced with their original content but with the their
          // translations. We need to create a new visitor (they are not re-entrant) to compute the
          // message id.
          // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg
          var phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
          var visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);
          this._placeholderToIds[phName] = digestMessage(visitor.toI18nMessage([icu], '', ''));
          return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
      };
      _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {
          throw new Error('Unreachable code');
      };
      _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {
          var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);
          if (!splitInterpolation) {
              // No expression, return a single text
              return new Text$1(text, sourceSpan);
          }
          // Return a group of text + expressions
          var nodes = [];
          var container = new Container(nodes, sourceSpan);
          var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;
          for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {
              var expression = splitInterpolation.expressions[i];
              var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';
              var phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);
              if (splitInterpolation.strings[i].length) {
                  // No need to add empty strings
                  nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));
              }
              nodes.push(new Placeholder(expression, phName, sourceSpan));
              this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;
          }
          // The last index contains no expression
          var lastStringIdx = splitInterpolation.strings.length - 1;
          if (splitInterpolation.strings[lastStringIdx].length) {
              nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));
          }
          return container;
      };
      return _I18nVisitor;
  }());
  var _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*"([\s\S]*?)"[\s\S]*\)/g;
  function _extractPlaceholderName(input) {
      return input.split(_CUSTOM_PH_EXP)[1];
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$6 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  /**
   * An i18n error.
   */
  var I18nError = (function (_super) {
      __extends$6(I18nError, _super);
      function I18nError(span, msg) {
          _super.call(this, span, msg);
      }
      return I18nError;
  }(ParseError));

  var _I18N_ATTR = 'i18n';
  var _I18N_ATTR_PREFIX = 'i18n-';
  var _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;
  /**
   * Extract translatable messages from an html AST
   */
  function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {
      var visitor = new _Visitor(implicitTags, implicitAttrs);
      return visitor.extract(nodes, interpolationConfig);
  }
  function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {
      var visitor = new _Visitor(implicitTags, implicitAttrs);
      return visitor.merge(nodes, translations, interpolationConfig);
  }
  var ExtractionResult = (function () {
      function ExtractionResult(messages, errors) {
          this.messages = messages;
          this.errors = errors;
      }
      return ExtractionResult;
  }());
  var _VisitorMode;
  (function (_VisitorMode) {
      _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
      _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
  })(_VisitorMode || (_VisitorMode = {}));
  /**
   * This Visitor is used:
   * 1. to extract all the translatable strings from an html AST (see `extract()`),
   * 2. to replace the translatable strings with the actual translations (see `merge()`)
   *
   * @internal
   */
  var _Visitor = (function () {
      function _Visitor(_implicitTags, _implicitAttrs) {
          this._implicitTags = _implicitTags;
          this._implicitAttrs = _implicitAttrs;
      }
      /**
       * Extracts the messages from the tree
       */
      _Visitor.prototype.extract = function (nodes, interpolationConfig) {
          var _this = this;
          this._init(_VisitorMode.Extract, interpolationConfig);
          nodes.forEach(function (node) { return node.visit(_this, null); });
          if (this._inI18nBlock) {
              this._reportError(nodes[nodes.length - 1], 'Unclosed block');
          }
          return new ExtractionResult(this._messages, this._errors);
      };
      /**
       * Returns a tree where all translatable nodes are translated
       */
      _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {
          this._init(_VisitorMode.Merge, interpolationConfig);
          this._translations = translations;
          // Construct a single fake root element
          var wrapper = new Element('wrapper', [], nodes, null, null, null);
          var translatedNode = wrapper.visit(this, null);
          if (this._inI18nBlock) {
              this._reportError(nodes[nodes.length - 1], 'Unclosed block');
          }
          return new ParseTreeResult(translatedNode.children, this._errors);
      };
      _Visitor.prototype.visitExpansionCase = function (icuCase, context) {
          // Parse cases for translatable html attributes
          var expression = visitAll(this, icuCase.expression, context);
          if (this._mode === _VisitorMode.Merge) {
              return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);
          }
      };
      _Visitor.prototype.visitExpansion = function (icu, context) {
          this._mayBeAddBlockChildren(icu);
          var wasInIcu = this._inIcu;
          if (!this._inIcu) {
              // nested ICU messages should not be extracted but top-level translated as a whole
              if (this._isInTranslatableSection) {
                  this._addMessage([icu]);
              }
              this._inIcu = true;
          }
          var cases = visitAll(this, icu.cases, context);
          if (this._mode === _VisitorMode.Merge) {
              icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);
          }
          this._inIcu = wasInIcu;
          return icu;
      };
      _Visitor.prototype.visitComment = function (comment, context) {
          var isOpening = _isOpeningComment(comment);
          if (isOpening && this._isInTranslatableSection) {
              this._reportError(comment, 'Could not start a block inside a translatable section');
              return;
          }
          var isClosing = _isClosingComment(comment);
          if (isClosing && !this._inI18nBlock) {
              this._reportError(comment, 'Trying to close an unopened block');
              return;
          }
          if (!this._inI18nNode && !this._inIcu) {
              if (!this._inI18nBlock) {
                  if (isOpening) {
                      this._inI18nBlock = true;
                      this._blockStartDepth = this._depth;
                      this._blockChildren = [];
                      this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();
                      this._openTranslatableSection(comment);
                  }
              }
              else {
                  if (isClosing) {
                      if (this._depth == this._blockStartDepth) {
                          this._closeTranslatableSection(comment, this._blockChildren);
                          this._inI18nBlock = false;
                          var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);
                          // merge attributes in sections
                          var nodes = this._translateMessage(comment, message);
                          return visitAll(this, nodes);
                      }
                      else {
                          this._reportError(comment, 'I18N blocks should not cross element boundaries');
                          return;
                      }
                  }
              }
          }
      };
      _Visitor.prototype.visitText = function (text, context) {
          if (this._isInTranslatableSection) {
              this._mayBeAddBlockChildren(text);
          }
          return text;
      };
      _Visitor.prototype.visitElement = function (el, context) {
          var _this = this;
          this._mayBeAddBlockChildren(el);
          this._depth++;
          var wasInI18nNode = this._inI18nNode;
          var wasInImplicitNode = this._inImplicitNode;
          var childNodes;
          // Extract only top level nodes with the (implicit) "i18n" attribute if not in a block or an ICU
          // message
          var i18nAttr = _getI18nAttr(el);
          var isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) &&
              !this._inIcu && !this._isInTranslatableSection;
          var isTopLevelImplicit = !wasInImplicitNode && isImplicit;
          this._inImplicitNode = this._inImplicitNode || isImplicit;
          if (!this._isInTranslatableSection && !this._inIcu) {
              if (i18nAttr) {
                  // explicit translation
                  this._inI18nNode = true;
                  var message = this._addMessage(el.children, i18nAttr.value);
                  childNodes = this._translateMessage(el, message);
              }
              else if (isTopLevelImplicit) {
                  // implicit translation
                  this._inI18nNode = true;
                  var message = this._addMessage(el.children);
                  childNodes = this._translateMessage(el, message);
              }
              if (this._mode == _VisitorMode.Extract) {
                  var isTranslatable = i18nAttr || isTopLevelImplicit;
                  if (isTranslatable) {
                      this._openTranslatableSection(el);
                  }
                  visitAll(this, el.children);
                  if (isTranslatable) {
                      this._closeTranslatableSection(el, el.children);
                  }
              }
              if (this._mode === _VisitorMode.Merge && !i18nAttr && !isTopLevelImplicit) {
                  childNodes = [];
                  el.children.forEach(function (child) {
                      var visited = child.visit(_this, context);
                      if (visited && !_this._isInTranslatableSection) {
                          // Do not add the children from translatable sections (= i18n blocks here)
                          // They will be added when the section is close (i.e. on `<!-- /i18n -->`)
                          childNodes = childNodes.concat(visited);
                      }
                  });
              }
          }
          else {
              if (i18nAttr || isTopLevelImplicit) {
                  this._reportError(el, 'Could not mark an element as translatable inside a translatable section');
              }
              if (this._mode == _VisitorMode.Extract) {
                  // Descend into child nodes for extraction
                  visitAll(this, el.children);
              }
              if (this._mode == _VisitorMode.Merge) {
                  // Translate attributes in ICU messages
                  childNodes = [];
                  el.children.forEach(function (child) {
                      var visited = child.visit(_this, context);
                      if (visited && !_this._isInTranslatableSection) {
                          // Do not add the children from translatable sections (= i18n blocks here)
                          // They will be added when the section is close (i.e. on `<!-- /i18n -->`)
                          childNodes = childNodes.concat(visited);
                      }
                  });
              }
          }
          this._visitAttributesOf(el);
          this._depth--;
          this._inI18nNode = wasInI18nNode;
          this._inImplicitNode = wasInImplicitNode;
          if (this._mode === _VisitorMode.Merge) {
              // There are no childNodes in translatable sections - those nodes will be replace anyway
              var translatedAttrs = this._translateAttributes(el);
              return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
          }
      };
      _Visitor.prototype.visitAttribute = function (attribute, context) {
          throw new Error('unreachable code');
      };
      _Visitor.prototype._init = function (mode, interpolationConfig) {
          this._mode = mode;
          this._inI18nBlock = false;
          this._inI18nNode = false;
          this._depth = 0;
          this._inIcu = false;
          this._msgCountAtSectionStart = void 0;
          this._errors = [];
          this._messages = [];
          this._inImplicitNode = false;
          this._createI18nMessage = createI18nMessageFactory(interpolationConfig);
      };
      // looks for translatable attributes
      _Visitor.prototype._visitAttributesOf = function (el) {
          var _this = this;
          var explicitAttrNameToValue = {};
          var implicitAttrNames = this._implicitAttrs[el.name] || [];
          el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })
              .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
              attr.value; });
          el.attrs.forEach(function (attr) {
              if (attr.name in explicitAttrNameToValue) {
                  _this._addMessage([attr], explicitAttrNameToValue[attr.name]);
              }
              else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {
                  _this._addMessage([attr]);
              }
          });
      };
      // add a translatable message
      _Visitor.prototype._addMessage = function (ast, meaningAndDesc) {
          if (ast.length == 0 ||
              ast.length == 1 && ast[0] instanceof Attribute$1 && !ast[0].value) {
              // Do not create empty messages
              return;
          }
          var _a = _splitMeaningAndDesc(meaningAndDesc), meaning = _a[0], description = _a[1];
          var message = this._createI18nMessage(ast, meaning, description);
          this._messages.push(message);
          return message;
      };
      // Translates the given message given the `TranslationBundle`
      // no-op when called in extraction mode (returns [])
      _Visitor.prototype._translateMessage = function (el, message) {
          if (message && this._mode === _VisitorMode.Merge) {
              var id = digestMessage(message);
              var nodes = this._translations.get(id);
              if (nodes) {
                  return nodes;
              }
              this._reportError(el, "Translation unavailable for message id=\"" + id + "\"");
          }
          return [];
      };
      // translate the attributes of an element and remove i18n specific attributes
      _Visitor.prototype._translateAttributes = function (el) {
          var _this = this;
          var attributes = el.attrs;
          var i18nAttributeMeanings = {};
          attributes.forEach(function (attr) {
              if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {
                  i18nAttributeMeanings[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
                      _splitMeaningAndDesc(attr.value)[0];
              }
          });
          var translatedAttributes = [];
          attributes.forEach(function (attr) {
              if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {
                  // strip i18n specific attributes
                  return;
              }
              if (attr.value && attr.value != '' && i18nAttributeMeanings.hasOwnProperty(attr.name)) {
                  var meaning = i18nAttributeMeanings[attr.name];
                  var message = _this._createI18nMessage([attr], meaning, '');
                  var id = digestMessage(message);
                  var nodes = _this._translations.get(id);
                  if (nodes) {
                      if (nodes[0] instanceof Text) {
                          var value = nodes[0].value;
                          translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));
                      }
                      else {
                          _this._reportError(el, "Unexpected translation for attribute \"" + attr.name + "\" (id=\"" + id + "\")");
                      }
                  }
                  else {
                      _this._reportError(el, "Translation unavailable for attribute \"" + attr.name + "\" (id=\"" + id + "\")");
                  }
              }
              else {
                  translatedAttributes.push(attr);
              }
          });
          return translatedAttributes;
      };
      /**
       * Add the node as a child of the block when:
       * - we are in a block,
       * - we are not inside a ICU message (those are handled separately),
       * - the node is a "direct child" of the block
       */
      _Visitor.prototype._mayBeAddBlockChildren = function (node) {
          if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {
              this._blockChildren.push(node);
          }
      };
      /**
       * Marks the start of a section, see `_endSection`
       */
      _Visitor.prototype._openTranslatableSection = function (node) {
          if (this._isInTranslatableSection) {
              this._reportError(node, 'Unexpected section start');
          }
          else {
              this._msgCountAtSectionStart = this._messages.length;
          }
      };
      Object.defineProperty(_Visitor.prototype, "_isInTranslatableSection", {
          /**
           * A translatable section could be:
           * - a translatable element,
           * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments
           */
          get: function () {
              return this._msgCountAtSectionStart !== void 0;
          },
          enumerable: true,
          configurable: true
      });
      /**
       * Terminates a section.
       *
       * If a section has only one significant children (comments not significant) then we should not
       * keep the message from this children:
       *
       * `<p i18n="meaning|description">{ICU message}</p>` would produce two messages:
       * - one for the <p> content with meaning and description,
       * - another one for the ICU message.
       *
       * In this case the last message is discarded as it contains less information (the AST is
       * otherwise identical).
       *
       * Note that we should still keep messages extracted from attributes inside the section (ie in the
       * ICU message here)
       */
      _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {
          if (!this._isInTranslatableSection) {
              this._reportError(node, 'Unexpected section end');
              return;
          }
          var startIndex = this._msgCountAtSectionStart;
          var significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);
          if (significantChildren == 1) {
              for (var i = this._messages.length - 1; i >= startIndex; i--) {
                  var ast = this._messages[i].nodes;
                  if (!(ast.length == 1 && ast[0] instanceof Text$1)) {
                      this._messages.splice(i, 1);
                      break;
                  }
              }
          }
          this._msgCountAtSectionStart = void 0;
      };
      _Visitor.prototype._reportError = function (node, msg) {
          this._errors.push(new I18nError(node.sourceSpan, msg));
      };
      return _Visitor;
  }());
  function _isOpeningComment(n) {
      return n instanceof Comment && n.value && n.value.startsWith('i18n');
  }
  function _isClosingComment(n) {
      return n instanceof Comment && n.value && n.value === '/i18n';
  }
  function _getI18nAttr(p) {
      return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;
  }
  function _splitMeaningAndDesc(i18n) {
      if (!i18n)
          return ['', ''];
      var pipeIndex = i18n.indexOf('|');
      return pipeIndex == -1 ? ['', i18n] : [i18n.slice(0, pipeIndex), i18n.slice(pipeIndex + 1)];
  }

  /**
   * A container for message extracted from the templates.
   */
  var MessageBundle = (function () {
      function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs) {
          this._htmlParser = _htmlParser;
          this._implicitTags = _implicitTags;
          this._implicitAttrs = _implicitAttrs;
          this._messageMap = {};
      }
      MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {
          var _this = this;
          var htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);
          if (htmlParserResult.errors.length) {
              return htmlParserResult.errors;
          }
          var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);
          if (i18nParserResult.errors.length) {
              return i18nParserResult.errors;
          }
          i18nParserResult.messages.forEach(function (message) { _this._messageMap[digestMessage(message)] = message; });
      };
      MessageBundle.prototype.getMessageMap = function () { return this._messageMap; };
      MessageBundle.prototype.write = function (serializer) { return serializer.write(this._messageMap); };
      return MessageBundle;
  }());

  var XmlTagDefinition = (function () {
      function XmlTagDefinition() {
          this.closedByParent = false;
          this.contentType = TagContentType.PARSABLE_DATA;
          this.isVoid = false;
          this.ignoreFirstLf = false;
          this.canSelfClose = true;
      }
      XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };
      XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };
      return XmlTagDefinition;
  }());
  var _TAG_DEFINITION = new XmlTagDefinition();
  function getXmlTagDefinition(tagName) {
      return _TAG_DEFINITION;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$7 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var XmlParser = (function (_super) {
      __extends$7(XmlParser, _super);
      function XmlParser() {
          _super.call(this, getXmlTagDefinition);
      }
      XmlParser.prototype.parse = function (source, url, parseExpansionForms) {
          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
          return _super.prototype.parse.call(this, source, url, parseExpansionForms, null);
      };
      return XmlParser;
  }(Parser$1));

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // Generate a map of placeholder to content indexed by message ids
  function extractPlaceholders(messageBundle) {
      var messageMap = messageBundle.getMessageMap();
      var placeholders = {};
      Object.keys(messageMap).forEach(function (msgId) {
          placeholders[msgId] = messageMap[msgId].placeholders;
      });
      return placeholders;
  }
  // Generate a map of placeholder to message ids indexed by message ids
  function extractPlaceholderToIds(messageBundle) {
      var messageMap = messageBundle.getMessageMap();
      var placeholderToIds = {};
      Object.keys(messageMap).forEach(function (msgId) {
          placeholderToIds[msgId] = messageMap[msgId].placeholderToMsgIds;
      });
      return placeholderToIds;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$8 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var _Visitor$1 = (function () {
      function _Visitor() {
      }
      _Visitor.prototype.visitTag = function (tag) {
          var _this = this;
          var strAttrs = this._serializeAttributes(tag.attrs);
          if (tag.children.length == 0) {
              return "<" + tag.name + strAttrs + "/>";
          }
          var strChildren = tag.children.map(function (node) { return node.visit(_this); });
          return "<" + tag.name + strAttrs + ">" + strChildren.join('') + "</" + tag.name + ">";
      };
      _Visitor.prototype.visitText = function (text) { return text.value; };
      _Visitor.prototype.visitDeclaration = function (decl) {
          return "<?xml" + this._serializeAttributes(decl.attrs) + " ?>";
      };
      _Visitor.prototype._serializeAttributes = function (attrs) {
          var strAttrs = Object.keys(attrs).map(function (name) { return (name + "=\"" + attrs[name] + "\""); }).join(' ');
          return strAttrs.length > 0 ? ' ' + strAttrs : '';
      };
      _Visitor.prototype.visitDoctype = function (doctype) {
          return "<!DOCTYPE " + doctype.rootTag + " [\n" + doctype.dtd + "\n]>";
      };
      return _Visitor;
  }());
  var _visitor = new _Visitor$1();
  function serialize(nodes) {
      return nodes.map(function (node) { return node.visit(_visitor); }).join('');
  }
  var Declaration = (function () {
      function Declaration(unescapedAttrs) {
          var _this = this;
          this.attrs = {};
          Object.keys(unescapedAttrs).forEach(function (k) {
              _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
          });
      }
      Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };
      return Declaration;
  }());
  var Doctype = (function () {
      function Doctype(rootTag, dtd) {
          this.rootTag = rootTag;
          this.dtd = dtd;
      }
      ;
      Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };
      return Doctype;
  }());
  var Tag = (function () {
      function Tag(name, unescapedAttrs, children) {
          var _this = this;
          if (unescapedAttrs === void 0) { unescapedAttrs = {}; }
          if (children === void 0) { children = []; }
          this.name = name;
          this.children = children;
          this.attrs = {};
          Object.keys(unescapedAttrs).forEach(function (k) {
              _this.attrs[k] = _escapeXml(unescapedAttrs[k]);
          });
      }
      Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };
      return Tag;
  }());
  var Text$2 = (function () {
      function Text(unescapedValue) {
          this.value = _escapeXml(unescapedValue);
      }
      ;
      Text.prototype.visit = function (visitor) { return visitor.visitText(this); };
      return Text;
  }());
  var CR = (function (_super) {
      __extends$8(CR, _super);
      function CR(ws) {
          if (ws === void 0) { ws = 0; }
          _super.call(this, "\n" + new Array(ws + 1).join(' '));
      }
      return CR;
  }(Text$2));
  var _ESCAPED_CHARS = [
      [/&/g, '&amp;'],
      [/"/g, '&quot;'],
      [/'/g, '&apos;'],
      [/</g, '&lt;'],
      [/>/g, '&gt;'],
  ];
  function _escapeXml(text) {
      return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);
  }

  var _VERSION = '1.2';
  var _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';
  // TODO(vicb): make this a param (s/_/-/)
  var _SOURCE_LANG = 'en';
  var _PLACEHOLDER_TAG = 'x';
  var _SOURCE_TAG = 'source';
  var _TARGET_TAG = 'target';
  var _UNIT_TAG = 'trans-unit';
  // http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html
  // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html
  var Xliff = (function () {
      function Xliff(_htmlParser, _interpolationConfig) {
          this._htmlParser = _htmlParser;
          this._interpolationConfig = _interpolationConfig;
      }
      Xliff.prototype.write = function (messageMap) {
          var visitor = new _WriteVisitor();
          var transUnits = [];
          Object.keys(messageMap).forEach(function (id) {
              var message = messageMap[id];
              var transUnit = new Tag(_UNIT_TAG, { id: id, datatype: 'html' });
              transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(8), new Tag(_TARGET_TAG));
              if (message.description) {
                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));
              }
              if (message.meaning) {
                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));
              }
              transUnit.children.push(new CR(6));
              transUnits.push(new CR(6), transUnit);
          });
          var body = new Tag('body', {}, transUnits.concat([new CR(4)]));
          var file = new Tag('file', { 'source-language': _SOURCE_LANG, datatype: 'plaintext', original: 'ng2.template' }, [new CR(4), body, new CR(2)]);
          var xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);
          return serialize([
              new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()
          ]);
      };
      Xliff.prototype.load = function (content, url, messageBundle) {
          var _this = this;
          // Parse the xtb file into xml nodes
          var result = new XmlParser().parse(content, url);
          if (result.errors.length) {
              throw new Error("xtb parse errors:\n" + result.errors.join('\n'));
          }
          // Replace the placeholders, messages are now string
          var _a = new _LoadVisitor().parse(result.rootNodes, messageBundle), messages = _a.messages, errors = _a.errors;
          if (errors.length) {
              throw new Error("xtb parse errors:\n" + errors.join('\n'));
          }
          // Convert the string messages to html ast
          // TODO(vicb): map error message back to the original message in xtb
          var messageMap = {};
          var parseErrors = [];
          Object.keys(messages).forEach(function (id) {
              var res = _this._htmlParser.parse(messages[id], url, true, _this._interpolationConfig);
              parseErrors.push.apply(parseErrors, res.errors);
              messageMap[id] = res.rootNodes;
          });
          if (parseErrors.length) {
              throw new Error("xtb parse errors:\n" + parseErrors.join('\n'));
          }
          return messageMap;
      };
      return Xliff;
  }());
  var _WriteVisitor = (function () {
      function _WriteVisitor() {
      }
      _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };
      _WriteVisitor.prototype.visitContainer = function (container, context) {
          var _this = this;
          var nodes = [];
          container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });
          return nodes;
      };
      _WriteVisitor.prototype.visitIcu = function (icu, context) {
          if (this._isInIcu) {
              // nested ICU is not supported
              throw new Error('xliff does not support nested ICU messages');
          }
          this._isInIcu = true;
          // TODO(vicb): support ICU messages
          // https://lists.oasis-open.org/archives/xliff/201201/msg00028.html
          // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-po/xliff-profile-po-1.2-cd02.html
          var nodes = [];
          this._isInIcu = false;
          return nodes;
      };
      _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {
          var ctype = getCtypeForTag(ph.tag);
          var startTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype: ctype });
          if (ph.isVoid) {
              // void tags have no children nor closing tags
              return [startTagPh];
          }
          var closeTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype: ctype });
          return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
      };
      _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {
          return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];
      };
      _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {
          return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];
      };
      _WriteVisitor.prototype.serialize = function (nodes) {
          var _this = this;
          this._isInIcu = false;
          return ListWrapper.flatten(nodes.map(function (node) { return node.visit(_this); }));
      };
      return _WriteVisitor;
  }());
  // TODO(vicb): add error management (structure)
  // TODO(vicb): factorize (xtb) ?
  var _LoadVisitor = (function () {
      function _LoadVisitor() {
      }
      _LoadVisitor.prototype.parse = function (nodes, messageBundle) {
          var _this = this;
          this._messageNodes = [];
          this._translatedMessages = {};
          this._msgId = '';
          this._target = [];
          this._errors = [];
          // Find all messages
          visitAll(this, nodes, null);
          var messageMap = messageBundle.getMessageMap();
          var placeholders = extractPlaceholders(messageBundle);
          var placeholderToIds = extractPlaceholderToIds(messageBundle);
          this._messageNodes
              .filter(function (message) {
              // Remove any messages that is not present in the source message bundle.
              return messageMap.hasOwnProperty(message[0]);
          })
              .sort(function (a, b) {
              // Because there could be no ICU placeholders inside an ICU message,
              // we do not need to take into account the `placeholderToMsgIds` of the referenced
              // messages, those would always be empty
              // TODO(vicb): overkill - create 2 buckets and [...woDeps, ...wDeps].process()
              if (Object.keys(messageMap[a[0]].placeholderToMsgIds).length == 0) {
                  return -1;
              }
              if (Object.keys(messageMap[b[0]].placeholderToMsgIds).length == 0) {
                  return 1;
              }
              return 0;
          })
              .forEach(function (message) {
              var id = message[0];
              _this._placeholders = placeholders[id] || {};
              _this._placeholderToIds = placeholderToIds[id] || {};
              // TODO(vicb): make sure there is no `_TRANSLATIONS_TAG` nor `_TRANSLATION_TAG`
              _this._translatedMessages[id] = visitAll(_this, message[1]).join('');
          });
          return { messages: this._translatedMessages, errors: this._errors };
      };
      _LoadVisitor.prototype.visitElement = function (element, context) {
          switch (element.name) {
              case _UNIT_TAG:
                  this._target = null;
                  var msgId = element.attrs.find(function (attr) { return attr.name === 'id'; });
                  if (!msgId) {
                      this._addError(element, "<" + _UNIT_TAG + "> misses the \"id\" attribute");
                  }
                  else {
                      this._msgId = msgId.value;
                  }
                  visitAll(this, element.children, null);
                  if (this._msgId !== null) {
                      this._messageNodes.push([this._msgId, this._target]);
                  }
                  break;
              case _SOURCE_TAG:
                  // ignore source message
                  break;
              case _TARGET_TAG:
                  this._target = element.children;
                  break;
              case _PLACEHOLDER_TAG:
                  var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });
                  if (!idAttr) {
                      this._addError(element, "<" + _PLACEHOLDER_TAG + "> misses the \"id\" attribute");
                  }
                  else {
                      var id = idAttr.value;
                      if (this._placeholders.hasOwnProperty(id)) {
                          return this._placeholders[id];
                      }
                      if (this._placeholderToIds.hasOwnProperty(id) &&
                          this._translatedMessages.hasOwnProperty(this._placeholderToIds[id])) {
                          return this._translatedMessages[this._placeholderToIds[id]];
                      }
                      // TODO(vicb): better error message for when
                      // !this._translatedMessages.hasOwnProperty(this._placeholderToIds[id])
                      this._addError(element, "The placeholder \"" + id + "\" does not exists in the source message");
                  }
                  break;
              default:
                  visitAll(this, element.children, null);
          }
      };
      _LoadVisitor.prototype.visitAttribute = function (attribute, context) {
          throw new Error('unreachable code');
      };
      _LoadVisitor.prototype.visitText = function (text, context) { return text.value; };
      _LoadVisitor.prototype.visitComment = function (comment, context) { return ''; };
      _LoadVisitor.prototype.visitExpansion = function (expansion, context) {
          throw new Error('unreachable code');
      };
      _LoadVisitor.prototype.visitExpansionCase = function (expansionCase, context) {
          throw new Error('unreachable code');
      };
      _LoadVisitor.prototype._addError = function (node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      };
      return _LoadVisitor;
  }());
  function getCtypeForTag(tag) {
      switch (tag.toLowerCase()) {
          case 'br':
              return 'lb';
          case 'img':
              return 'image';
          default:
              return "x-" + tag;
      }
  }

  var _MESSAGES_TAG = 'messagebundle';
  var _MESSAGE_TAG = 'msg';
  var _PLACEHOLDER_TAG$1 = 'ph';
  var _EXEMPLE_TAG = 'ex';
  var _DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";
  var Xmb = (function () {
      function Xmb() {
      }
      Xmb.prototype.write = function (messageMap) {
          var visitor = new _Visitor$2();
          var rootNode = new Tag(_MESSAGES_TAG);
          Object.keys(messageMap).forEach(function (id) {
              var message = messageMap[id];
              var attrs = { id: id };
              if (message.description) {
                  attrs['desc'] = message.description;
              }
              if (message.meaning) {
                  attrs['meaning'] = message.meaning;
              }
              rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, visitor.serialize(message.nodes)));
          });
          rootNode.children.push(new CR());
          return serialize([
              new Declaration({ version: '1.0', encoding: 'UTF-8' }),
              new CR(),
              new Doctype(_MESSAGES_TAG, _DOCTYPE),
              new CR(),
              rootNode,
              new CR(),
          ]);
      };
      Xmb.prototype.load = function (content, url, messageBundle) {
          throw new Error('Unsupported');
      };
      return Xmb;
  }());
  var _Visitor$2 = (function () {
      function _Visitor() {
      }
      _Visitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };
      _Visitor.prototype.visitContainer = function (container, context) {
          var _this = this;
          var nodes = [];
          container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });
          return nodes;
      };
      _Visitor.prototype.visitIcu = function (icu, context) {
          var _this = this;
          var nodes = [new Text$2("{" + icu.expression + ", " + icu.type + ", ")];
          Object.keys(icu.cases).forEach(function (c) {
              nodes.push.apply(nodes, [new Text$2(c + " {")].concat(icu.cases[c].visit(_this), [new Text$2("} ")]));
          });
          nodes.push(new Text$2("}"));
          return nodes;
      };
      _Visitor.prototype.visitTagPlaceholder = function (ph, context) {
          var startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("<" + ph.tag + ">")]);
          var startTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.startName }, [startEx]);
          if (ph.isVoid) {
              // void tags have no children nor closing tags
              return [startTagPh];
          }
          var closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2("</" + ph.tag + ">")]);
          var closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.closeName }, [closeEx]);
          return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);
      };
      _Visitor.prototype.visitPlaceholder = function (ph, context) {
          return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];
      };
      _Visitor.prototype.visitIcuPlaceholder = function (ph, context) {
          return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];
      };
      _Visitor.prototype.serialize = function (nodes) {
          var _this = this;
          return ListWrapper.flatten(nodes.map(function (node) { return node.visit(_this); }));
      };
      return _Visitor;
  }());

  var _TRANSLATIONS_TAG = 'translationbundle';
  var _TRANSLATION_TAG = 'translation';
  var _PLACEHOLDER_TAG$2 = 'ph';
  var Xtb = (function () {
      function Xtb(_htmlParser, _interpolationConfig) {
          this._htmlParser = _htmlParser;
          this._interpolationConfig = _interpolationConfig;
      }
      Xtb.prototype.write = function (messageMap) { throw new Error('Unsupported'); };
      Xtb.prototype.load = function (content, url, messageBundle) {
          var _this = this;
          // Parse the xtb file into xml nodes
          var result = new XmlParser().parse(content, url);
          if (result.errors.length) {
              throw new Error("xtb parse errors:\n" + result.errors.join('\n'));
          }
          // Replace the placeholders, messages are now string
          var _a = new _Visitor$3().parse(result.rootNodes, messageBundle), messages = _a.messages, errors = _a.errors;
          if (errors.length) {
              throw new Error("xtb parse errors:\n" + errors.join('\n'));
          }
          // Convert the string messages to html ast
          // TODO(vicb): map error message back to the original message in xtb
          var messageMap = {};
          var parseErrors = [];
          Object.keys(messages).forEach(function (id) {
              var res = _this._htmlParser.parse(messages[id], url, true, _this._interpolationConfig);
              parseErrors.push.apply(parseErrors, res.errors);
              messageMap[id] = res.rootNodes;
          });
          if (parseErrors.length) {
              throw new Error("xtb parse errors:\n" + parseErrors.join('\n'));
          }
          return messageMap;
      };
      return Xtb;
  }());
  var _Visitor$3 = (function () {
      function _Visitor() {
      }
      _Visitor.prototype.parse = function (nodes, messageBundle) {
          var _this = this;
          this._messageNodes = [];
          this._translatedMessages = {};
          this._bundleDepth = 0;
          this._translationDepth = 0;
          this._errors = [];
          // Find all messages
          visitAll(this, nodes, null);
          var messageMap = messageBundle.getMessageMap();
          var placeholders = extractPlaceholders(messageBundle);
          var placeholderToIds = extractPlaceholderToIds(messageBundle);
          this._messageNodes
              .filter(function (message) {
              // Remove any messages that is not present in the source message bundle.
              return messageMap.hasOwnProperty(message[0]);
          })
              .sort(function (a, b) {
              // Because there could be no ICU placeholders inside an ICU message,
              // we do not need to take into account the `placeholderToMsgIds` of the referenced
              // messages, those would always be empty
              // TODO(vicb): overkill - create 2 buckets and [...woDeps, ...wDeps].process()
              if (Object.keys(messageMap[a[0]].placeholderToMsgIds).length == 0) {
                  return -1;
              }
              if (Object.keys(messageMap[b[0]].placeholderToMsgIds).length == 0) {
                  return 1;
              }
              return 0;
          })
              .forEach(function (message) {
              var id = message[0];
              _this._placeholders = placeholders[id] || {};
              _this._placeholderToIds = placeholderToIds[id] || {};
              // TODO(vicb): make sure there is no `_TRANSLATIONS_TAG` nor `_TRANSLATION_TAG`
              _this._translatedMessages[id] = visitAll(_this, message[1]).join('');
          });
          return { messages: this._translatedMessages, errors: this._errors };
      };
      _Visitor.prototype.visitElement = function (element, context) {
          switch (element.name) {
              case _TRANSLATIONS_TAG:
                  this._bundleDepth++;
                  if (this._bundleDepth > 1) {
                      this._addError(element, "<" + _TRANSLATIONS_TAG + "> elements can not be nested");
                  }
                  visitAll(this, element.children, null);
                  this._bundleDepth--;
                  break;
              case _TRANSLATION_TAG:
                  this._translationDepth++;
                  if (this._translationDepth > 1) {
                      this._addError(element, "<" + _TRANSLATION_TAG + "> elements can not be nested");
                  }
                  var idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });
                  if (!idAttr) {
                      this._addError(element, "<" + _TRANSLATION_TAG + "> misses the \"id\" attribute");
                  }
                  else {
                      // ICU placeholders are reference to other messages.
                      // The referenced message might not have been decoded yet.
                      // We need to have all messages available to make sure deps are decoded first.
                      // TODO(vicb): report an error on duplicate id
                      this._messageNodes.push([idAttr.value, element.children]);
                  }
                  this._translationDepth--;
                  break;
              case _PLACEHOLDER_TAG$2:
                  var nameAttr = element.attrs.find(function (attr) { return attr.name === 'name'; });
                  if (!nameAttr) {
                      this._addError(element, "<" + _PLACEHOLDER_TAG$2 + "> misses the \"name\" attribute");
                  }
                  else {
                      var name_1 = nameAttr.value;
                      if (this._placeholders.hasOwnProperty(name_1)) {
                          return this._placeholders[name_1];
                      }
                      if (this._placeholderToIds.hasOwnProperty(name_1) &&
                          this._translatedMessages.hasOwnProperty(this._placeholderToIds[name_1])) {
                          return this._translatedMessages[this._placeholderToIds[name_1]];
                      }
                      // TODO(vicb): better error message for when
                      // !this._translatedMessages.hasOwnProperty(this._placeholderToIds[name])
                      this._addError(element, "The placeholder \"" + name_1 + "\" does not exists in the source message");
                  }
                  break;
              default:
                  this._addError(element, 'Unexpected tag');
          }
      };
      _Visitor.prototype.visitAttribute = function (attribute, context) {
          throw new Error('unreachable code');
      };
      _Visitor.prototype.visitText = function (text, context) { return text.value; };
      _Visitor.prototype.visitComment = function (comment, context) { return ''; };
      _Visitor.prototype.visitExpansion = function (expansion, context) {
          var _this = this;
          var strCases = expansion.cases.map(function (c) { return c.visit(_this, null); });
          return "{" + expansion.switchValue + ", " + expansion.type + ", strCases.join(' ')}";
      };
      _Visitor.prototype.visitExpansionCase = function (expansionCase, context) {
          return expansionCase.value + " {" + visitAll(this, expansionCase.expression, null) + "}";
      };
      _Visitor.prototype._addError = function (node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      };
      return _Visitor;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * A container for translated messages
   */
  var TranslationBundle = (function () {
      function TranslationBundle(_messageMap) {
          if (_messageMap === void 0) { _messageMap = {}; }
          this._messageMap = _messageMap;
      }
      TranslationBundle.load = function (content, url, messageBundle, serializer) {
          return new TranslationBundle(serializer.load(content, url, messageBundle));
      };
      TranslationBundle.prototype.get = function (id) { return this._messageMap[id]; };
      TranslationBundle.prototype.has = function (id) { return id in this._messageMap; };
      return TranslationBundle;
  }());

  var I18NHtmlParser = (function () {
      // TODO(vicb): transB.load() should not need a msgB & add transB.resolve(msgB,
      // interpolationConfig)
      // TODO(vicb): remove the interpolationConfig from the Xtb serializer
      function I18NHtmlParser(_htmlParser, _translations, _translationsFormat) {
          this._htmlParser = _htmlParser;
          this._translations = _translations;
          this._translationsFormat = _translationsFormat;
      }
      I18NHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          var parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);
          if (!this._translations || this._translations === '') {
              // Do not enable i18n when no translation bundle is provided
              return parseResult;
          }
          // TODO(vicb): add support for implicit tags / attributes
          var messageBundle = new MessageBundle(this._htmlParser, [], {});
          var errors = messageBundle.updateFromTemplate(source, url, interpolationConfig);
          if (errors && errors.length) {
              return new ParseTreeResult(parseResult.rootNodes, parseResult.errors.concat(errors));
          }
          var serializer = this._createSerializer(interpolationConfig);
          var translationBundle = TranslationBundle.load(this._translations, url, messageBundle, serializer);
          return mergeTranslations(parseResult.rootNodes, translationBundle, interpolationConfig, [], {});
      };
      I18NHtmlParser.prototype._createSerializer = function (interpolationConfig) {
          var format = (this._translationsFormat || 'xlf').toLowerCase();
          switch (format) {
              case 'xmb':
                  return new Xmb();
              case 'xtb':
                  return new Xtb(this._htmlParser, interpolationConfig);
              case 'xliff':
              case 'xlf':
              default:
                  return new Xliff(this._htmlParser, interpolationConfig);
          }
      };
      return I18NHtmlParser;
  }());

  var isDefaultChangeDetectionStrategy = _angular_core.__core_private__.isDefaultChangeDetectionStrategy;
  var ChangeDetectorStatus = _angular_core.__core_private__.ChangeDetectorStatus;
  var LifecycleHooks = _angular_core.__core_private__.LifecycleHooks;
  var LIFECYCLE_HOOKS_VALUES = _angular_core.__core_private__.LIFECYCLE_HOOKS_VALUES;
  var ReflectorReader = _angular_core.__core_private__.ReflectorReader;
  var AppElement = _angular_core.__core_private__.AppElement;
  var CodegenComponentFactoryResolver = _angular_core.__core_private__.CodegenComponentFactoryResolver;
  var AppView = _angular_core.__core_private__.AppView;
  var DebugAppView = _angular_core.__core_private__.DebugAppView;
  var NgModuleInjector = _angular_core.__core_private__.NgModuleInjector;
  var registerModuleFactory = _angular_core.__core_private__.registerModuleFactory;
  var ViewType = _angular_core.__core_private__.ViewType;
  var MAX_INTERPOLATION_VALUES = _angular_core.__core_private__.MAX_INTERPOLATION_VALUES;
  var checkBinding = _angular_core.__core_private__.checkBinding;
  var flattenNestedViewRenderNodes = _angular_core.__core_private__.flattenNestedViewRenderNodes;
  var interpolate = _angular_core.__core_private__.interpolate;
  var ViewUtils = _angular_core.__core_private__.ViewUtils;
  var DebugContext = _angular_core.__core_private__.DebugContext;
  var StaticNodeDebugInfo = _angular_core.__core_private__.StaticNodeDebugInfo;
  var devModeEqual = _angular_core.__core_private__.devModeEqual;
  var UNINITIALIZED = _angular_core.__core_private__.UNINITIALIZED;
  var ValueUnwrapper = _angular_core.__core_private__.ValueUnwrapper;
  var TemplateRef_ = _angular_core.__core_private__.TemplateRef_;
  var EMPTY_ARRAY = _angular_core.__core_private__.EMPTY_ARRAY;
  var EMPTY_MAP = _angular_core.__core_private__.EMPTY_MAP;
  var pureProxy1 = _angular_core.__core_private__.pureProxy1;
  var pureProxy2 = _angular_core.__core_private__.pureProxy2;
  var pureProxy3 = _angular_core.__core_private__.pureProxy3;
  var pureProxy4 = _angular_core.__core_private__.pureProxy4;
  var pureProxy5 = _angular_core.__core_private__.pureProxy5;
  var pureProxy6 = _angular_core.__core_private__.pureProxy6;
  var pureProxy7 = _angular_core.__core_private__.pureProxy7;
  var pureProxy8 = _angular_core.__core_private__.pureProxy8;
  var pureProxy9 = _angular_core.__core_private__.pureProxy9;
  var pureProxy10 = _angular_core.__core_private__.pureProxy10;
  var castByValue = _angular_core.__core_private__.castByValue;
  var Console = _angular_core.__core_private__.Console;
  var reflector = _angular_core.__core_private__.reflector;
  var Reflector = _angular_core.__core_private__.Reflector;
  var ReflectionCapabilities = _angular_core.__core_private__.ReflectionCapabilities;
  var NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;
  var AnimationSequencePlayer = _angular_core.__core_private__.AnimationSequencePlayer;
  var AnimationGroupPlayer = _angular_core.__core_private__.AnimationGroupPlayer;
  var AnimationKeyframe = _angular_core.__core_private__.AnimationKeyframe;
  var AnimationStyles = _angular_core.__core_private__.AnimationStyles;
  var ANY_STATE = _angular_core.__core_private__.ANY_STATE;
  var DEFAULT_STATE = _angular_core.__core_private__.DEFAULT_STATE;
  var EMPTY_ANIMATION_STATE = _angular_core.__core_private__.EMPTY_STATE;
  var FILL_STYLE_FLAG = _angular_core.__core_private__.FILL_STYLE_FLAG;
  var prepareFinalAnimationStyles = _angular_core.__core_private__.prepareFinalAnimationStyles;
  var balanceAnimationKeyframes = _angular_core.__core_private__.balanceAnimationKeyframes;
  var clearStyles = _angular_core.__core_private__.clearStyles;
  var collectAndResolveStyles = _angular_core.__core_private__.collectAndResolveStyles;
  var renderStyles = _angular_core.__core_private__.renderStyles;
  var ComponentStillLoadingError = _angular_core.__core_private__.ComponentStillLoadingError;

  var APP_VIEW_MODULE_URL = assetUrl('core', 'linker/view');
  var VIEW_UTILS_MODULE_URL = assetUrl('core', 'linker/view_utils');
  var CD_MODULE_URL = assetUrl('core', 'change_detection/change_detection');
  var ANIMATION_STYLE_UTIL_ASSET_URL = assetUrl('core', 'animation/animation_style_util');
  var Identifiers = (function () {
      function Identifiers() {
      }
      Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {
          name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
          moduleUrl: assetUrl('core', 'metadata/di'),
          runtime: _angular_core.ANALYZE_FOR_ENTRY_COMPONENTS
      };
      Identifiers.ViewUtils = {
          name: 'ViewUtils',
          moduleUrl: assetUrl('core', 'linker/view_utils'),
          runtime: ViewUtils
      };
      Identifiers.AppView = { name: 'AppView', moduleUrl: APP_VIEW_MODULE_URL, runtime: AppView };
      Identifiers.DebugAppView = {
          name: 'DebugAppView',
          moduleUrl: APP_VIEW_MODULE_URL,
          runtime: DebugAppView
      };
      Identifiers.AppElement = {
          name: 'AppElement',
          moduleUrl: assetUrl('core', 'linker/element'),
          runtime: AppElement
      };
      Identifiers.ElementRef = {
          name: 'ElementRef',
          moduleUrl: assetUrl('core', 'linker/element_ref'),
          runtime: _angular_core.ElementRef
      };
      Identifiers.ViewContainerRef = {
          name: 'ViewContainerRef',
          moduleUrl: assetUrl('core', 'linker/view_container_ref'),
          runtime: _angular_core.ViewContainerRef
      };
      Identifiers.ChangeDetectorRef = {
          name: 'ChangeDetectorRef',
          moduleUrl: assetUrl('core', 'change_detection/change_detector_ref'),
          runtime: _angular_core.ChangeDetectorRef
      };
      Identifiers.RenderComponentType = {
          name: 'RenderComponentType',
          moduleUrl: assetUrl('core', 'render/api'),
          runtime: _angular_core.RenderComponentType
      };
      Identifiers.QueryList = {
          name: 'QueryList',
          moduleUrl: assetUrl('core', 'linker/query_list'),
          runtime: _angular_core.QueryList
      };
      Identifiers.TemplateRef = {
          name: 'TemplateRef',
          moduleUrl: assetUrl('core', 'linker/template_ref'),
          runtime: _angular_core.TemplateRef
      };
      Identifiers.TemplateRef_ = {
          name: 'TemplateRef_',
          moduleUrl: assetUrl('core', 'linker/template_ref'),
          runtime: TemplateRef_
      };
      Identifiers.CodegenComponentFactoryResolver = {
          name: 'CodegenComponentFactoryResolver',
          moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
          runtime: CodegenComponentFactoryResolver
      };
      Identifiers.ComponentFactoryResolver = {
          name: 'ComponentFactoryResolver',
          moduleUrl: assetUrl('core', 'linker/component_factory_resolver'),
          runtime: _angular_core.ComponentFactoryResolver
      };
      Identifiers.ComponentFactory = {
          name: 'ComponentFactory',
          runtime: _angular_core.ComponentFactory,
          moduleUrl: assetUrl('core', 'linker/component_factory')
      };
      Identifiers.NgModuleFactory = {
          name: 'NgModuleFactory',
          runtime: _angular_core.NgModuleFactory,
          moduleUrl: assetUrl('core', 'linker/ng_module_factory')
      };
      Identifiers.NgModuleInjector = {
          name: 'NgModuleInjector',
          runtime: NgModuleInjector,
          moduleUrl: assetUrl('core', 'linker/ng_module_factory')
      };
      Identifiers.RegisterModuleFactoryFn = {
          name: 'registerModuleFactory',
          runtime: registerModuleFactory,
          moduleUrl: assetUrl('core', 'linker/ng_module_factory_loader')
      };
      Identifiers.ValueUnwrapper = { name: 'ValueUnwrapper', moduleUrl: CD_MODULE_URL, runtime: ValueUnwrapper };
      Identifiers.Injector = {
          name: 'Injector',
          moduleUrl: assetUrl('core', 'di/injector'),
          runtime: _angular_core.Injector
      };
      Identifiers.ViewEncapsulation = {
          name: 'ViewEncapsulation',
          moduleUrl: assetUrl('core', 'metadata/view'),
          runtime: _angular_core.ViewEncapsulation
      };
      Identifiers.ViewType = {
          name: 'ViewType',
          moduleUrl: assetUrl('core', 'linker/view_type'),
          runtime: ViewType
      };
      Identifiers.ChangeDetectionStrategy = {
          name: 'ChangeDetectionStrategy',
          moduleUrl: CD_MODULE_URL,
          runtime: _angular_core.ChangeDetectionStrategy
      };
      Identifiers.StaticNodeDebugInfo = {
          name: 'StaticNodeDebugInfo',
          moduleUrl: assetUrl('core', 'linker/debug_context'),
          runtime: StaticNodeDebugInfo
      };
      Identifiers.DebugContext = {
          name: 'DebugContext',
          moduleUrl: assetUrl('core', 'linker/debug_context'),
          runtime: DebugContext
      };
      Identifiers.Renderer = {
          name: 'Renderer',
          moduleUrl: assetUrl('core', 'render/api'),
          runtime: _angular_core.Renderer
      };
      Identifiers.SimpleChange = { name: 'SimpleChange', moduleUrl: CD_MODULE_URL, runtime: _angular_core.SimpleChange };
      Identifiers.UNINITIALIZED = { name: 'UNINITIALIZED', moduleUrl: CD_MODULE_URL, runtime: UNINITIALIZED };
      Identifiers.ChangeDetectorStatus = {
          name: 'ChangeDetectorStatus',
          moduleUrl: CD_MODULE_URL,
          runtime: ChangeDetectorStatus
      };
      Identifiers.checkBinding = {
          name: 'checkBinding',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: checkBinding
      };
      Identifiers.flattenNestedViewRenderNodes = {
          name: 'flattenNestedViewRenderNodes',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: flattenNestedViewRenderNodes
      };
      Identifiers.devModeEqual = { name: 'devModeEqual', moduleUrl: CD_MODULE_URL, runtime: devModeEqual };
      Identifiers.interpolate = {
          name: 'interpolate',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: interpolate
      };
      Identifiers.castByValue = {
          name: 'castByValue',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: castByValue
      };
      Identifiers.EMPTY_ARRAY = {
          name: 'EMPTY_ARRAY',
          moduleUrl: VIEW_UTILS_MODULE_URL,
          runtime: EMPTY_ARRAY
      };
      Identifiers.EMPTY_MAP = { name: 'EMPTY_MAP', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: EMPTY_MAP };
      Identifiers.pureProxies = [
          null,
          { name: 'pureProxy1', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy1 },
          { name: 'pureProxy2', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy2 },
          { name: 'pureProxy3', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy3 },
          { name: 'pureProxy4', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy4 },
          { name: 'pureProxy5', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy5 },
          { name: 'pureProxy6', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy6 },
          { name: 'pureProxy7', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy7 },
          { name: 'pureProxy8', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy8 },
          { name: 'pureProxy9', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy9 },
          { name: 'pureProxy10', moduleUrl: VIEW_UTILS_MODULE_URL, runtime: pureProxy10 },
      ];
      Identifiers.SecurityContext = {
          name: 'SecurityContext',
          moduleUrl: assetUrl('core', 'security'),
          runtime: _angular_core.SecurityContext,
      };
      Identifiers.AnimationKeyframe = {
          name: 'AnimationKeyframe',
          moduleUrl: assetUrl('core', 'animation/animation_keyframe'),
          runtime: AnimationKeyframe
      };
      Identifiers.AnimationStyles = {
          name: 'AnimationStyles',
          moduleUrl: assetUrl('core', 'animation/animation_styles'),
          runtime: AnimationStyles
      };
      Identifiers.NoOpAnimationPlayer = {
          name: 'NoOpAnimationPlayer',
          moduleUrl: assetUrl('core', 'animation/animation_player'),
          runtime: NoOpAnimationPlayer
      };
      Identifiers.AnimationGroupPlayer = {
          name: 'AnimationGroupPlayer',
          moduleUrl: assetUrl('core', 'animation/animation_group_player'),
          runtime: AnimationGroupPlayer
      };
      Identifiers.AnimationSequencePlayer = {
          name: 'AnimationSequencePlayer',
          moduleUrl: assetUrl('core', 'animation/animation_sequence_player'),
          runtime: AnimationSequencePlayer
      };
      Identifiers.prepareFinalAnimationStyles = {
          name: 'prepareFinalAnimationStyles',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: prepareFinalAnimationStyles
      };
      Identifiers.balanceAnimationKeyframes = {
          name: 'balanceAnimationKeyframes',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: balanceAnimationKeyframes
      };
      Identifiers.clearStyles = {
          name: 'clearStyles',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: clearStyles
      };
      Identifiers.renderStyles = {
          name: 'renderStyles',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: renderStyles
      };
      Identifiers.collectAndResolveStyles = {
          name: 'collectAndResolveStyles',
          moduleUrl: ANIMATION_STYLE_UTIL_ASSET_URL,
          runtime: collectAndResolveStyles
      };
      Identifiers.LOCALE_ID = {
          name: 'LOCALE_ID',
          moduleUrl: assetUrl('core', 'i18n/tokens'),
          runtime: _angular_core.LOCALE_ID
      };
      Identifiers.TRANSLATIONS_FORMAT = {
          name: 'TRANSLATIONS_FORMAT',
          moduleUrl: assetUrl('core', 'i18n/tokens'),
          runtime: _angular_core.TRANSLATIONS_FORMAT
      };
      return Identifiers;
  }());
  function resolveIdentifier(identifier) {
      return new CompileIdentifierMetadata({
          name: identifier.name,
          moduleUrl: identifier.moduleUrl,
          reference: reflector.resolveIdentifier(identifier.name, identifier.moduleUrl, identifier.runtime)
      });
  }
  function identifierToken(identifier) {
      return new CompileTokenMetadata({ identifier: identifier });
  }
  function resolveIdentifierToken(identifier) {
      return identifierToken(resolveIdentifier(identifier));
  }
  function resolveEnumIdentifier(enumType, name) {
      var resolvedEnum = reflector.resolveEnum(enumType.reference, name);
      return new CompileIdentifierMetadata({ name: enumType.name + "." + name, moduleUrl: enumType.moduleUrl, reference: resolvedEnum });
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$9 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var HtmlParser = (function (_super) {
      __extends$9(HtmlParser, _super);
      function HtmlParser() {
          _super.call(this, getHtmlTagDefinition);
      }
      HtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {
          if (parseExpansionForms === void 0) { parseExpansionForms = false; }
          if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }
          return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);
      };
      HtmlParser.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      HtmlParser.ctorParameters = [];
      return HtmlParser;
  }(Parser$1));

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$10 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  // http://cldr.unicode.org/index/cldr-spec/plural-rules
  var PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
  /**
   * Expands special forms into elements.
   *
   * For example,
   *
   * ```
   * { messages.length, plural,
   *   =0 {zero}
   *   =1 {one}
   *   other {more than one}
   * }
   * ```
   *
   * will be expanded into
   *
   * ```
   * <ng-container [ngPlural]="messages.length">
   *   <template ngPluralCase="=0">zero</ng-container>
   *   <template ngPluralCase="=1">one</ng-container>
   *   <template ngPluralCase="other">more than one</ng-container>
   * </ng-container>
   * ```
   */
  function expandNodes(nodes) {
      var expander = new _Expander();
      return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);
  }
  var ExpansionResult = (function () {
      function ExpansionResult(nodes, expanded, errors) {
          this.nodes = nodes;
          this.expanded = expanded;
          this.errors = errors;
      }
      return ExpansionResult;
  }());
  var ExpansionError = (function (_super) {
      __extends$10(ExpansionError, _super);
      function ExpansionError(span, errorMsg) {
          _super.call(this, span, errorMsg);
      }
      return ExpansionError;
  }(ParseError));
  /**
   * Expand expansion forms (plural, select) to directives
   *
   * @internal
   */
  var _Expander = (function () {
      function _Expander() {
          this.isExpanded = false;
          this.errors = [];
      }
      _Expander.prototype.visitElement = function (element, context) {
          return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
      };
      _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };
      _Expander.prototype.visitText = function (text, context) { return text; };
      _Expander.prototype.visitComment = function (comment, context) { return comment; };
      _Expander.prototype.visitExpansion = function (icu, context) {
          this.isExpanded = true;
          return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :
              _expandDefaultForm(icu, this.errors);
      };
      _Expander.prototype.visitExpansionCase = function (icuCase, context) {
          throw new Error('Should not be reached');
      };
      return _Expander;
  }());
  function _expandPluralForm(ast, errors) {
      var children = ast.cases.map(function (c) {
          if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\d+$/)) {
              errors.push(new ExpansionError(c.valueSourceSpan, "Plural cases should be \"=<number>\" or one of " + PLURAL_CASES.join(", ")));
          }
          var expansionResult = expandNodes(c.expression);
          errors.push.apply(errors, expansionResult.errors);
          return new Element("template", [new Attribute$1('ngPluralCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
      });
      var switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);
      return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }
  function _expandDefaultForm(ast, errors) {
      var children = ast.cases.map(function (c) {
          var expansionResult = expandNodes(c.expression);
          errors.push.apply(errors, expansionResult.errors);
          return new Element("template", [new Attribute$1('ngSwitchCase', "" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
      });
      var switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);
      return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$11 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var ProviderError = (function (_super) {
      __extends$11(ProviderError, _super);
      function ProviderError(message, span) {
          _super.call(this, span, message);
      }
      return ProviderError;
  }(ParseError));
  var ProviderViewContext = (function () {
      function ProviderViewContext(component, sourceSpan) {
          var _this = this;
          this.component = component;
          this.sourceSpan = sourceSpan;
          this.errors = [];
          this.viewQueries = _getViewQueries(component);
          this.viewProviders = new Map();
          _normalizeProviders(component.viewProviders, sourceSpan, this.errors).forEach(function (provider) {
              if (isBlank(_this.viewProviders.get(provider.token.reference))) {
                  _this.viewProviders.set(provider.token.reference, true);
              }
          });
      }
      return ProviderViewContext;
  }());
  var ProviderElementContext = (function () {
      function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, _sourceSpan) {
          var _this = this;
          this.viewContext = viewContext;
          this._parent = _parent;
          this._isViewRoot = _isViewRoot;
          this._directiveAsts = _directiveAsts;
          this._sourceSpan = _sourceSpan;
          this._transformedProviders = new Map();
          this._seenProviders = new Map();
          this._hasViewContainer = false;
          this._attrs = {};
          attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });
          var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });
          this._allProviders =
              _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);
          this._contentQueries = _getContentQueries(directivesMeta);
          var queriedTokens = new Map();
          MapWrapper.values(this._allProviders).forEach(function (provider) {
              _this._addQueryReadsTo(provider.token, queriedTokens);
          });
          refs.forEach(function (refAst) {
              _this._addQueryReadsTo(new CompileTokenMetadata({ value: refAst.name }), queriedTokens);
          });
          if (isPresent(queriedTokens.get(resolveIdentifierToken(Identifiers.ViewContainerRef).reference))) {
              this._hasViewContainer = true;
          }
          // create the providers that we know are eager first
          MapWrapper.values(this._allProviders).forEach(function (provider) {
              var eager = provider.eager || isPresent(queriedTokens.get(provider.token.reference));
              if (eager) {
                  _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
              }
          });
      }
      ProviderElementContext.prototype.afterElement = function () {
          var _this = this;
          // collect lazy providers
          MapWrapper.values(this._allProviders).forEach(function (provider) {
              _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
          });
      };
      Object.defineProperty(ProviderElementContext.prototype, "transformProviders", {
          get: function () { return MapWrapper.values(this._transformedProviders); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ProviderElementContext.prototype, "transformedDirectiveAsts", {
          get: function () {
              var sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });
              var sortedDirectives = ListWrapper.clone(this._directiveAsts);
              ListWrapper.sort(sortedDirectives, function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -
                  sortedProviderTypes.indexOf(dir2.directive.type); });
              return sortedDirectives;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(ProviderElementContext.prototype, "transformedHasViewContainer", {
          get: function () { return this._hasViewContainer; },
          enumerable: true,
          configurable: true
      });
      ProviderElementContext.prototype._addQueryReadsTo = function (token, queryReadTokens) {
          this._getQueriesFor(token).forEach(function (query) {
              var queryReadToken = isPresent(query.read) ? query.read : token;
              if (isBlank(queryReadTokens.get(queryReadToken.reference))) {
                  queryReadTokens.set(queryReadToken.reference, true);
              }
          });
      };
      ProviderElementContext.prototype._getQueriesFor = function (token) {
          var result = [];
          var currentEl = this;
          var distance = 0;
          var queries;
          while (currentEl !== null) {
              queries = currentEl._contentQueries.get(token.reference);
              if (isPresent(queries)) {
                  ListWrapper.addAll(result, queries.filter(function (query) { return query.descendants || distance <= 1; }));
              }
              if (currentEl._directiveAsts.length > 0) {
                  distance++;
              }
              currentEl = currentEl._parent;
          }
          queries = this.viewContext.viewQueries.get(token.reference);
          if (isPresent(queries)) {
              ListWrapper.addAll(result, queries);
          }
          return result;
      };
      ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {
          var _this = this;
          var resolvedProvider = this._allProviders.get(token.reference);
          if (!resolvedProvider || ((requestingProviderType === exports.ProviderAstType.Directive ||
              requestingProviderType === exports.ProviderAstType.PublicService) &&
              resolvedProvider.providerType === exports.ProviderAstType.PrivateService) ||
              ((requestingProviderType === exports.ProviderAstType.PrivateService ||
                  requestingProviderType === exports.ProviderAstType.PublicService) &&
                  resolvedProvider.providerType === exports.ProviderAstType.Builtin)) {
              return null;
          }
          var transformedProviderAst = this._transformedProviders.get(token.reference);
          if (isPresent(transformedProviderAst)) {
              return transformedProviderAst;
          }
          if (isPresent(this._seenProviders.get(token.reference))) {
              this.viewContext.errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, this._sourceSpan));
              return null;
          }
          this._seenProviders.set(token.reference, true);
          var transformedProviders = resolvedProvider.providers.map(function (provider) {
              var transformedUseValue = provider.useValue;
              var transformedUseExisting = provider.useExisting;
              var transformedDeps;
              if (isPresent(provider.useExisting)) {
                  var existingDiDep = _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }), eager);
                  if (isPresent(existingDiDep.token)) {
                      transformedUseExisting = existingDiDep.token;
                  }
                  else {
                      transformedUseExisting = null;
                      transformedUseValue = existingDiDep.value;
                  }
              }
              else if (isPresent(provider.useFactory)) {
                  var deps = isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
                  transformedDeps =
                      deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
              }
              else if (isPresent(provider.useClass)) {
                  var deps = isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
                  transformedDeps =
                      deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });
              }
              return _transformProvider(provider, {
                  useExisting: transformedUseExisting,
                  useValue: transformedUseValue,
                  deps: transformedDeps
              });
          });
          transformedProviderAst =
              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
          this._transformedProviders.set(token.reference, transformedProviderAst);
          return transformedProviderAst;
      };
      ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {
          if (eager === void 0) { eager = null; }
          if (dep.isAttribute) {
              var attrValue = this._attrs[dep.token.value];
              return new CompileDiDependencyMetadata({ isValue: true, value: normalizeBlank(attrValue) });
          }
          if (isPresent(dep.query) || isPresent(dep.viewQuery)) {
              return dep;
          }
          if (isPresent(dep.token)) {
              // access builtints
              if ((requestingProviderType === exports.ProviderAstType.Directive ||
                  requestingProviderType === exports.ProviderAstType.Component)) {
                  if (dep.token.reference === resolveIdentifierToken(Identifiers.Renderer).reference ||
                      dep.token.reference === resolveIdentifierToken(Identifiers.ElementRef).reference ||
                      dep.token.reference ===
                          resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference ||
                      dep.token.reference === resolveIdentifierToken(Identifiers.TemplateRef).reference) {
                      return dep;
                  }
                  if (dep.token.reference ===
                      resolveIdentifierToken(Identifiers.ViewContainerRef).reference) {
                      this._hasViewContainer = true;
                  }
              }
              // access the injector
              if (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference) {
                  return dep;
              }
              // access providers
              if (isPresent(this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager))) {
                  return dep;
              }
          }
          return null;
      };
      ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {
          if (eager === void 0) { eager = null; }
          var currElement = this;
          var currEager = eager;
          var result = null;
          if (!dep.isSkipSelf) {
              result = this._getLocalDependency(requestingProviderType, dep, eager);
          }
          if (dep.isSelf) {
              if (!result && dep.isOptional) {
                  result = new CompileDiDependencyMetadata({ isValue: true, value: null });
              }
          }
          else {
              // check parent elements
              while (!result && isPresent(currElement._parent)) {
                  var prevElement = currElement;
                  currElement = currElement._parent;
                  if (prevElement._isViewRoot) {
                      currEager = false;
                  }
                  result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, dep, currEager);
              }
              // check @Host restriction
              if (!result) {
                  if (!dep.isHost || this.viewContext.component.type.isHost ||
                      this.viewContext.component.type.reference === dep.token.reference ||
                      isPresent(this.viewContext.viewProviders.get(dep.token.reference))) {
                      result = dep;
                  }
                  else {
                      result = dep.isOptional ?
                          result = new CompileDiDependencyMetadata({ isValue: true, value: null }) :
                          null;
                  }
              }
          }
          if (!result) {
              this.viewContext.errors.push(new ProviderError("No provider for " + dep.token.name, this._sourceSpan));
          }
          return result;
      };
      return ProviderElementContext;
  }());
  var NgModuleProviderAnalyzer = (function () {
      function NgModuleProviderAnalyzer(ngModule, extraProviders, sourceSpan) {
          var _this = this;
          this._transformedProviders = new Map();
          this._seenProviders = new Map();
          this._errors = [];
          this._allProviders = new Map();
          var ngModuleTypes = ngModule.transitiveModule.modules.map(function (moduleMeta) { return moduleMeta.type; });
          ngModuleTypes.forEach(function (ngModuleType) {
              var ngModuleProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: ngModuleType }), useClass: ngModuleType });
              _resolveProviders([ngModuleProvider], exports.ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);
          });
          _resolveProviders(_normalizeProviders(ngModule.transitiveModule.providers.concat(extraProviders), sourceSpan, this._errors), exports.ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);
      }
      NgModuleProviderAnalyzer.prototype.parse = function () {
          var _this = this;
          MapWrapper.values(this._allProviders).forEach(function (provider) {
              _this._getOrCreateLocalProvider(provider.token, provider.eager);
          });
          if (this._errors.length > 0) {
              var errorString = this._errors.join('\n');
              throw new Error("Provider parse errors:\n" + errorString);
          }
          return MapWrapper.values(this._transformedProviders);
      };
      NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {
          var _this = this;
          var resolvedProvider = this._allProviders.get(token.reference);
          if (!resolvedProvider) {
              return null;
          }
          var transformedProviderAst = this._transformedProviders.get(token.reference);
          if (isPresent(transformedProviderAst)) {
              return transformedProviderAst;
          }
          if (isPresent(this._seenProviders.get(token.reference))) {
              this._errors.push(new ProviderError("Cannot instantiate cyclic dependency! " + token.name, resolvedProvider.sourceSpan));
              return null;
          }
          this._seenProviders.set(token.reference, true);
          var transformedProviders = resolvedProvider.providers.map(function (provider) {
              var transformedUseValue = provider.useValue;
              var transformedUseExisting = provider.useExisting;
              var transformedDeps;
              if (isPresent(provider.useExisting)) {
                  var existingDiDep = _this._getDependency(new CompileDiDependencyMetadata({ token: provider.useExisting }), eager, resolvedProvider.sourceSpan);
                  if (isPresent(existingDiDep.token)) {
                      transformedUseExisting = existingDiDep.token;
                  }
                  else {
                      transformedUseExisting = null;
                      transformedUseValue = existingDiDep.value;
                  }
              }
              else if (isPresent(provider.useFactory)) {
                  var deps = isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
                  transformedDeps =
                      deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });
              }
              else if (isPresent(provider.useClass)) {
                  var deps = isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
                  transformedDeps =
                      deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });
              }
              return _transformProvider(provider, {
                  useExisting: transformedUseExisting,
                  useValue: transformedUseValue,
                  deps: transformedDeps
              });
          });
          transformedProviderAst =
              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
          this._transformedProviders.set(token.reference, transformedProviderAst);
          return transformedProviderAst;
      };
      NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {
          if (eager === void 0) { eager = null; }
          var foundLocal = false;
          if (!dep.isSkipSelf && isPresent(dep.token)) {
              // access the injector
              if (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference ||
                  dep.token.reference ===
                      resolveIdentifierToken(Identifiers.ComponentFactoryResolver).reference) {
                  foundLocal = true;
              }
              else if (isPresent(this._getOrCreateLocalProvider(dep.token, eager))) {
                  foundLocal = true;
              }
          }
          var result = dep;
          if (dep.isSelf && !foundLocal) {
              if (dep.isOptional) {
                  result = new CompileDiDependencyMetadata({ isValue: true, value: null });
              }
              else {
                  this._errors.push(new ProviderError("No provider for " + dep.token.name, requestorSourceSpan));
              }
          }
          return result;
      };
      return NgModuleProviderAnalyzer;
  }());
  function _transformProvider(provider, _a) {
      var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;
      return new CompileProviderMetadata({
          token: provider.token,
          useClass: provider.useClass,
          useExisting: useExisting,
          useFactory: provider.useFactory,
          useValue: useValue,
          deps: deps,
          multi: provider.multi
      });
  }
  function _transformProviderAst(provider, _a) {
      var eager = _a.eager, providers = _a.providers;
      return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);
  }
  function _normalizeProviders(providers, sourceSpan, targetErrors, targetProviders) {
      if (targetProviders === void 0) { targetProviders = null; }
      if (!targetProviders) {
          targetProviders = [];
      }
      if (isPresent(providers)) {
          providers.forEach(function (provider) {
              if (isArray(provider)) {
                  _normalizeProviders(provider, sourceSpan, targetErrors, targetProviders);
              }
              else {
                  var normalizeProvider = void 0;
                  if (provider instanceof CompileProviderMetadata) {
                      normalizeProvider = provider;
                  }
                  else if (provider instanceof CompileTypeMetadata) {
                      normalizeProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: provider }), useClass: provider });
                  }
                  else {
                      targetErrors.push(new ProviderError("Unknown provider type " + provider, sourceSpan));
                  }
                  if (isPresent(normalizeProvider)) {
                      targetProviders.push(normalizeProvider);
                  }
              }
          });
      }
      return targetProviders;
  }
  function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
      var providersByToken = new Map();
      directives.forEach(function (directive) {
          var dirProvider = new CompileProviderMetadata({ token: new CompileTokenMetadata({ identifier: directive.type }), useClass: directive.type });
          _resolveProviders([dirProvider], directive.isComponent ? exports.ProviderAstType.Component : exports.ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);
      });
      // Note: directives need to be able to overwrite providers of a component!
      var directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));
      directivesWithComponentFirst.forEach(function (directive) {
          _resolveProviders(_normalizeProviders(directive.providers, sourceSpan, targetErrors), exports.ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);
          _resolveProviders(_normalizeProviders(directive.viewProviders, sourceSpan, targetErrors), exports.ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);
      });
      return providersByToken;
  }
  function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {
      providers.forEach(function (provider) {
          var resolvedProvider = targetProvidersByToken.get(provider.token.reference);
          if (isPresent(resolvedProvider) && resolvedProvider.multiProvider !== provider.multi) {
              targetErrors.push(new ProviderError("Mixing multi and non multi provider is not possible for token " + resolvedProvider.token.name, sourceSpan));
          }
          if (!resolvedProvider) {
              var lifecycleHooks = provider.token.identifier && provider.token.identifier instanceof CompileTypeMetadata ?
                  provider.token.identifier.lifecycleHooks :
                  [];
              resolvedProvider = new ProviderAst(provider.token, provider.multi, eager || lifecycleHooks.length > 0, [provider], providerType, lifecycleHooks, sourceSpan);
              targetProvidersByToken.set(provider.token.reference, resolvedProvider);
          }
          else {
              if (!provider.multi) {
                  ListWrapper.clear(resolvedProvider.providers);
              }
              resolvedProvider.providers.push(provider);
          }
      });
  }
  function _getViewQueries(component) {
      var viewQueries = new Map();
      if (isPresent(component.viewQueries)) {
          component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, query); });
      }
      component.type.diDeps.forEach(function (dep) {
          if (isPresent(dep.viewQuery)) {
              _addQueryToTokenMap(viewQueries, dep.viewQuery);
          }
      });
      return viewQueries;
  }
  function _getContentQueries(directives) {
      var contentQueries = new Map();
      directives.forEach(function (directive) {
          if (isPresent(directive.queries)) {
              directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, query); });
          }
          directive.type.diDeps.forEach(function (dep) {
              if (isPresent(dep.query)) {
                  _addQueryToTokenMap(contentQueries, dep.query);
              }
          });
      });
      return contentQueries;
  }
  function _addQueryToTokenMap(map, query) {
      query.selectors.forEach(function (token) {
          var entry = map.get(token.reference);
          if (!entry) {
              entry = [];
              map.set(token.reference, entry);
          }
          entry.push(query);
      });
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var ElementSchemaRegistry = (function () {
      function ElementSchemaRegistry() {
      }
      return ElementSchemaRegistry;
  }());

  var StyleWithImports = (function () {
      function StyleWithImports(style, styleUrls) {
          this.style = style;
          this.styleUrls = styleUrls;
      }
      return StyleWithImports;
  }());
  function isStyleUrlResolvable(url) {
      if (isBlank(url) || url.length === 0 || url[0] == '/')
          return false;
      var schemeMatch = url.match(_urlWithSchemaRe);
      return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
  }
  /**
   * Rewrites stylesheets by resolving and removing the @import urls that
   * are either relative or don't have a `package:` scheme
   */
  function extractStyleUrls(resolver, baseUrl, cssText) {
      var foundUrls = [];
      var modifiedCssText = StringWrapper.replaceAllMapped(cssText, _cssImportRe, function (m) {
          var url = isPresent(m[1]) ? m[1] : m[2];
          if (!isStyleUrlResolvable(url)) {
              // Do not attempt to resolve non-package absolute URLs with URI scheme
              return m[0];
          }
          foundUrls.push(resolver.resolve(baseUrl, url));
          return '';
      });
      return new StyleWithImports(modifiedCssText, foundUrls);
  }
  var _cssImportRe = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
  var _urlWithSchemaRe = /^([^:/?#]+):/;

  var NG_CONTENT_SELECT_ATTR = 'select';
  var NG_CONTENT_ELEMENT = 'ng-content';
  var LINK_ELEMENT = 'link';
  var LINK_STYLE_REL_ATTR = 'rel';
  var LINK_STYLE_HREF_ATTR = 'href';
  var LINK_STYLE_REL_VALUE = 'stylesheet';
  var STYLE_ELEMENT = 'style';
  var SCRIPT_ELEMENT = 'script';
  var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
  var NG_PROJECT_AS = 'ngProjectAs';
  function preparseElement(ast) {
      var selectAttr = null;
      var hrefAttr = null;
      var relAttr = null;
      var nonBindable = false;
      var projectAs = null;
      ast.attrs.forEach(function (attr) {
          var lcAttrName = attr.name.toLowerCase();
          if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
              selectAttr = attr.value;
          }
          else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
              hrefAttr = attr.value;
          }
          else if (lcAttrName == LINK_STYLE_REL_ATTR) {
              relAttr = attr.value;
          }
          else if (attr.name == NG_NON_BINDABLE_ATTR) {
              nonBindable = true;
          }
          else if (attr.name == NG_PROJECT_AS) {
              if (attr.value.length > 0) {
                  projectAs = attr.value;
              }
          }
      });
      selectAttr = normalizeNgContentSelect(selectAttr);
      var nodeName = ast.name.toLowerCase();
      var type = PreparsedElementType.OTHER;
      if (splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {
          type = PreparsedElementType.NG_CONTENT;
      }
      else if (nodeName == STYLE_ELEMENT) {
          type = PreparsedElementType.STYLE;
      }
      else if (nodeName == SCRIPT_ELEMENT) {
          type = PreparsedElementType.SCRIPT;
      }
      else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
          type = PreparsedElementType.STYLESHEET;
      }
      return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
  }
  var PreparsedElementType;
  (function (PreparsedElementType) {
      PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
      PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
      PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
      PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
      PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
  })(PreparsedElementType || (PreparsedElementType = {}));
  var PreparsedElement = (function () {
      function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
          this.type = type;
          this.selectAttr = selectAttr;
          this.hrefAttr = hrefAttr;
          this.nonBindable = nonBindable;
          this.projectAs = projectAs;
      }
      return PreparsedElement;
  }());
  function normalizeNgContentSelect(selectAttr) {
      if (selectAttr === null || selectAttr.length === 0) {
          return '*';
      }
      return selectAttr;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  // Group 1 = "bind-"
  // Group 2 = "let-"
  // Group 3 = "ref-/#"
  // Group 4 = "on-"
  // Group 5 = "bindon-"
  // Group 6 = "@"
  // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
  // Group 8 = identifier inside [()]
  // Group 9 = identifier inside []
  // Group 10 = identifier inside ()
  var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
  var KW_BIND_IDX = 1;
  var KW_LET_IDX = 2;
  var KW_REF_IDX = 3;
  var KW_ON_IDX = 4;
  var KW_BINDON_IDX = 5;
  var KW_AT_IDX = 6;
  var IDENT_KW_IDX = 7;
  var IDENT_BANANA_BOX_IDX = 8;
  var IDENT_PROPERTY_IDX = 9;
  var IDENT_EVENT_IDX = 10;
  var ANIMATE_PROP_PREFIX = 'animate-';
  var TEMPLATE_ELEMENT = 'template';
  var TEMPLATE_ATTR = 'template';
  var TEMPLATE_ATTR_PREFIX = '*';
  var CLASS_ATTR = 'class';
  var PROPERTY_PARTS_SEPARATOR = '.';
  var ATTRIBUTE_PREFIX = 'attr';
  var CLASS_PREFIX = 'class';
  var STYLE_PREFIX = 'style';
  var TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
  /**
   * Provides an array of {@link TemplateAstVisitor}s which will be used to transform
   * parsed templates before compilation is invoked, allowing custom expression syntax
   * and other advanced transformations.
   *
   * This is currently an internal-only feature and not meant for general use.
   */
  var TEMPLATE_TRANSFORMS = new _angular_core.OpaqueToken('TemplateTransforms');
  var TemplateParseError = (function (_super) {
      __extends(TemplateParseError, _super);
      function TemplateParseError(message, span, level) {
          _super.call(this, span, message, level);
      }
      return TemplateParseError;
  }(ParseError));
  var TemplateParseResult = (function () {
      function TemplateParseResult(templateAst, errors) {
          this.templateAst = templateAst;
          this.errors = errors;
      }
      return TemplateParseResult;
  }());
  var TemplateParser = (function () {
      function TemplateParser(_exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
          this._exprParser = _exprParser;
          this._schemaRegistry = _schemaRegistry;
          this._htmlParser = _htmlParser;
          this._console = _console;
          this.transforms = transforms;
      }
      TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl) {
          var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);
          var warnings = result.errors.filter(function (error) { return error.level === ParseErrorLevel.WARNING; });
          var errors = result.errors.filter(function (error) { return error.level === ParseErrorLevel.FATAL; });
          if (warnings.length > 0) {
              this._console.warn("Template parse warnings:\n" + warnings.join('\n'));
          }
          if (errors.length > 0) {
              var errorString = errors.join('\n');
              throw new Error("Template parse errors:\n" + errorString);
          }
          return result.templateAst;
      };
      TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl) {
          var interpolationConfig;
          if (component.template) {
              interpolationConfig = InterpolationConfig.fromArray(component.template.interpolation);
          }
          var htmlAstWithErrors = this._htmlParser.parse(template, templateUrl, true, interpolationConfig);
          var errors = htmlAstWithErrors.errors;
          var result;
          if (errors.length == 0) {
              // Transform ICU messages to angular directives
              var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);
              errors.push.apply(errors, expandedHtmlAst.errors);
              htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);
          }
          if (htmlAstWithErrors.rootNodes.length > 0) {
              var uniqDirectives = removeIdentifierDuplicates(directives);
              var uniqPipes = removeIdentifierDuplicates(pipes);
              var providerViewContext = new ProviderViewContext(component, htmlAstWithErrors.rootNodes[0].sourceSpan);
              var parseVisitor = new TemplateParseVisitor(providerViewContext, uniqDirectives, uniqPipes, schemas, this._exprParser, this._schemaRegistry);
              result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
              errors.push.apply(errors, parseVisitor.errors.concat(providerViewContext.errors));
          }
          else {
              result = [];
          }
          this._assertNoReferenceDuplicationOnTemplate(result, errors);
          if (errors.length > 0) {
              return new TemplateParseResult(result, errors);
          }
          if (isPresent(this.transforms)) {
              this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });
          }
          return new TemplateParseResult(result, errors);
      };
      /** @internal */
      TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {
          var existingReferences = [];
          result.filter(function (element) { return !!element.references; })
              .forEach(function (element) { return element.references.forEach(function (reference) {
              var name = reference.name;
              if (existingReferences.indexOf(name) < 0) {
                  existingReferences.push(name);
              }
              else {
                  var error = new TemplateParseError("Reference \"#" + name + "\" is defined several times", reference.sourceSpan, ParseErrorLevel.FATAL);
                  errors.push(error);
              }
          }); });
      };
      TemplateParser.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      TemplateParser.ctorParameters = [
          { type: Parser, },
          { type: ElementSchemaRegistry, },
          { type: I18NHtmlParser, },
          { type: Console, },
          { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [TEMPLATE_TRANSFORMS,] },] },
      ];
      return TemplateParser;
  }());
  var TemplateParseVisitor = (function () {
      function TemplateParseVisitor(providerViewContext, directives, pipes, _schemas, _exprParser, _schemaRegistry) {
          var _this = this;
          this.providerViewContext = providerViewContext;
          this._schemas = _schemas;
          this._exprParser = _exprParser;
          this._schemaRegistry = _schemaRegistry;
          this.selectorMatcher = new SelectorMatcher();
          this.errors = [];
          this.directivesIndex = new Map();
          this.ngContentCount = 0;
          this.pipesByName = new Map();
          var tempMeta = providerViewContext.component.template;
          if (tempMeta && tempMeta.interpolation) {
              this._interpolationConfig = {
                  start: tempMeta.interpolation[0],
                  end: tempMeta.interpolation[1]
              };
          }
          directives.forEach(function (directive, index) {
              var selector = CssSelector.parse(directive.selector);
              _this.selectorMatcher.addSelectables(selector, directive);
              _this.directivesIndex.set(directive, index);
          });
          pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });
      }
      TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {
          if (level === void 0) { level = ParseErrorLevel.FATAL; }
          this.errors.push(new TemplateParseError(message, sourceSpan, level));
      };
      TemplateParseVisitor.prototype._reportParserErrors = function (errors, sourceSpan) {
          for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
              var error = errors_1[_i];
              this._reportError(error.message, sourceSpan);
          }
      };
      TemplateParseVisitor.prototype._parseInterpolation = function (value, sourceSpan) {
          var sourceInfo = sourceSpan.start.toString();
          try {
              var ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);
              if (ast)
                  this._reportParserErrors(ast.errors, sourceSpan);
              this._checkPipes(ast, sourceSpan);
              if (isPresent(ast) &&
                  ast.ast.expressions.length > MAX_INTERPOLATION_VALUES) {
                  throw new Error("Only support at most " + MAX_INTERPOLATION_VALUES + " interpolation values!");
              }
              return ast;
          }
          catch (e) {
              this._reportError("" + e, sourceSpan);
              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
          }
      };
      TemplateParseVisitor.prototype._parseAction = function (value, sourceSpan) {
          var sourceInfo = sourceSpan.start.toString();
          try {
              var ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);
              if (ast) {
                  this._reportParserErrors(ast.errors, sourceSpan);
              }
              if (!ast || ast.ast instanceof EmptyExpr) {
                  this._reportError("Empty expressions are not allowed", sourceSpan);
                  return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
              }
              this._checkPipes(ast, sourceSpan);
              return ast;
          }
          catch (e) {
              this._reportError("" + e, sourceSpan);
              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
          }
      };
      TemplateParseVisitor.prototype._parseBinding = function (value, sourceSpan) {
          var sourceInfo = sourceSpan.start.toString();
          try {
              var ast = this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);
              if (ast)
                  this._reportParserErrors(ast.errors, sourceSpan);
              this._checkPipes(ast, sourceSpan);
              return ast;
          }
          catch (e) {
              this._reportError("" + e, sourceSpan);
              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
          }
      };
      TemplateParseVisitor.prototype._parseTemplateBindings = function (value, sourceSpan) {
          var _this = this;
          var sourceInfo = sourceSpan.start.toString();
          try {
              var bindingsResult = this._exprParser.parseTemplateBindings(value, sourceInfo);
              this._reportParserErrors(bindingsResult.errors, sourceSpan);
              bindingsResult.templateBindings.forEach(function (binding) {
                  if (isPresent(binding.expression)) {
                      _this._checkPipes(binding.expression, sourceSpan);
                  }
              });
              bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });
              return bindingsResult.templateBindings;
          }
          catch (e) {
              this._reportError("" + e, sourceSpan);
              return [];
          }
      };
      TemplateParseVisitor.prototype._checkPipes = function (ast, sourceSpan) {
          var _this = this;
          if (isPresent(ast)) {
              var collector = new PipeCollector();
              ast.visit(collector);
              collector.pipes.forEach(function (pipeName) {
                  if (!_this.pipesByName.has(pipeName)) {
                      _this._reportError("The pipe '" + pipeName + "' could not be found", sourceSpan);
                  }
              });
          }
      };
      TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };
      TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };
      TemplateParseVisitor.prototype.visitText = function (text, parent) {
          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
          var expr = this._parseInterpolation(text.value, text.sourceSpan);
          if (isPresent(expr)) {
              return new BoundTextAst(expr, ngContentIndex, text.sourceSpan);
          }
          else {
              return new TextAst(text.value, ngContentIndex, text.sourceSpan);
          }
      };
      TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {
          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
      };
      TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };
      TemplateParseVisitor.prototype.visitElement = function (element, parent) {
          var _this = this;
          var nodeName = element.name;
          var preparsedElement = preparseElement(element);
          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
              preparsedElement.type === PreparsedElementType.STYLE) {
              // Skipping <script> for security reasons
              // Skipping <style> as we already processed them
              // in the StyleCompiler
              return null;
          }
          if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
              isStyleUrlResolvable(preparsedElement.hrefAttr)) {
              // Skipping stylesheets with either relative urls or package scheme as we already processed
              // them in the StyleCompiler
              return null;
          }
          var matchableAttrs = [];
          var elementOrDirectiveProps = [];
          var elementOrDirectiveRefs = [];
          var elementVars = [];
          var animationProps = [];
          var events = [];
          var templateElementOrDirectiveProps = [];
          var templateMatchableAttrs = [];
          var templateElementVars = [];
          var hasInlineTemplates = false;
          var attrs = [];
          var lcElName = splitNsName(nodeName.toLowerCase())[1];
          var isTemplateElement = lcElName == TEMPLATE_ELEMENT;
          element.attrs.forEach(function (attr) {
              var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, animationProps, events, elementOrDirectiveRefs, elementVars);
              var hasTemplateBinding = _this._parseInlineTemplateBinding(attr, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);
              if (hasTemplateBinding && hasInlineTemplates) {
                  _this._reportError("Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *", attr.sourceSpan);
              }
              if (!hasBinding && !hasTemplateBinding) {
                  // don't include the bindings as attributes as well in the AST
                  attrs.push(_this.visitAttribute(attr, null));
                  matchableAttrs.push([attr.name, attr.value]);
              }
              if (hasTemplateBinding) {
                  hasInlineTemplates = true;
              }
          });
          var elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);
          var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;
          var references = [];
          var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references);
          var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, directiveAsts)
              .concat(animationProps);
          var isViewRoot = parent.isTemplateElement || hasInlineTemplates;
          var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, element.sourceSpan);
          var children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
          providerContext.afterElement();
          // Override the actual selector when the `ngProjectAs` attribute is provided
          var projectionSelector = isPresent(preparsedElement.projectAs) ?
              CssSelector.parse(preparsedElement.projectAs)[0] :
              elementCssSelector;
          var ngContentIndex = parent.findNgContentIndex(projectionSelector);
          var parsedElement;
          if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
              if (isPresent(element.children) && element.children.length > 0) {
                  this._reportError("<ng-content> element cannot have content. <ng-content> must be immediately followed by </ng-content>", element.sourceSpan);
              }
              parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
          }
          else if (isTemplateElement) {
              this._assertAllEventsPublishedByDirectives(directiveAsts, events);
              this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
              parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
          }
          else {
              this._assertElementExists(matchElement, element);
              this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
              var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
              parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan);
              this._findComponentDirectives(directiveAsts)
                  .forEach(function (componentDirectiveAst) { return _this._validateElementAnimationInputOutputs(componentDirectiveAst.hostProperties, componentDirectiveAst.hostEvents, componentDirectiveAst.directive.template); });
              var componentTemplate = providerContext.viewContext.component.template;
              this._validateElementAnimationInputOutputs(elementProps, events, componentTemplate);
          }
          if (hasInlineTemplates) {
              var templateCssSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);
              var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateCssSelector).directives;
              var templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, []);
              var templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateDirectiveAsts);
              this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
              var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], element.sourceSpan);
              templateProviderContext.afterElement();
              parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, [parsedElement], ngContentIndex, element.sourceSpan);
          }
          return parsedElement;
      };
      TemplateParseVisitor.prototype._validateElementAnimationInputOutputs = function (inputs, outputs, template) {
          var _this = this;
          var triggerLookup = new Set();
          template.animations.forEach(function (entry) { triggerLookup.add(entry.name); });
          var animationInputs = inputs.filter(function (input) { return input.isAnimation; });
          animationInputs.forEach(function (input) {
              var name = input.name;
              if (!triggerLookup.has(name)) {
                  _this._reportError("Couldn't find an animation entry for \"" + name + "\"", input.sourceSpan);
              }
          });
          outputs.forEach(function (output) {
              if (output.isAnimation) {
                  var found = animationInputs.find(function (input) { return input.name == output.name; });
                  if (!found) {
                      _this._reportError("Unable to listen on (@" + output.name + "." + output.phase + ") because the animation trigger [@" + output.name + "] isn't being used on the same element", output.sourceSpan);
                  }
              }
          });
      };
      TemplateParseVisitor.prototype._parseInlineTemplateBinding = function (attr, targetMatchableAttrs, targetProps, targetVars) {
          var templateBindingsSource = null;
          if (this._normalizeAttributeName(attr.name) == TEMPLATE_ATTR) {
              templateBindingsSource = attr.value;
          }
          else if (attr.name.startsWith(TEMPLATE_ATTR_PREFIX)) {
              var key = attr.name.substring(TEMPLATE_ATTR_PREFIX.length); // remove the star
              templateBindingsSource = (attr.value.length == 0) ? key : key + ' ' + attr.value;
          }
          if (isPresent(templateBindingsSource)) {
              var bindings = this._parseTemplateBindings(templateBindingsSource, attr.sourceSpan);
              for (var i = 0; i < bindings.length; i++) {
                  var binding = bindings[i];
                  if (binding.keyIsVar) {
                      targetVars.push(new VariableAst(binding.key, binding.name, attr.sourceSpan));
                  }
                  else if (isPresent(binding.expression)) {
                      this._parsePropertyAst(binding.key, binding.expression, attr.sourceSpan, targetMatchableAttrs, targetProps);
                  }
                  else {
                      targetMatchableAttrs.push([binding.key, '']);
                      this._parseLiteralAttr(binding.key, null, attr.sourceSpan, targetProps);
                  }
              }
              return true;
          }
          return false;
      };
      TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetAnimationProps, targetEvents, targetRefs, targetVars) {
          var name = this._normalizeAttributeName(attr.name);
          var value = attr.value;
          var srcSpan = attr.sourceSpan;
          var bindParts = name.match(BIND_NAME_REGEXP);
          var hasBinding = false;
          if (bindParts !== null) {
              hasBinding = true;
              if (isPresent(bindParts[KW_BIND_IDX])) {
                  this._parsePropertyOrAnimation(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
              }
              else if (bindParts[KW_LET_IDX]) {
                  if (isTemplateElement) {
                      var identifier = bindParts[IDENT_KW_IDX];
                      this._parseVariable(identifier, value, srcSpan, targetVars);
                  }
                  else {
                      this._reportError("\"let-\" is only supported on template elements.", srcSpan);
                  }
              }
              else if (bindParts[KW_REF_IDX]) {
                  var identifier = bindParts[IDENT_KW_IDX];
                  this._parseReference(identifier, value, srcSpan, targetRefs);
              }
              else if (bindParts[KW_ON_IDX]) {
                  this._parseEventOrAnimationEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
              }
              else if (bindParts[KW_BINDON_IDX]) {
                  this._parsePropertyOrAnimation(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
                  this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
              }
              else if (bindParts[KW_AT_IDX]) {
                  if (_isAnimationLabel(name) && isPresent(value) && value.length > 0) {
                      this._reportError("Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid." +
                          " Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.", srcSpan, ParseErrorLevel.FATAL);
                  }
                  this._parseAnimation(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetAnimationProps);
              }
              else if (bindParts[IDENT_BANANA_BOX_IDX]) {
                  this._parsePropertyOrAnimation(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
                  this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
              }
              else if (bindParts[IDENT_PROPERTY_IDX]) {
                  this._parsePropertyOrAnimation(bindParts[IDENT_PROPERTY_IDX], value, srcSpan, targetMatchableAttrs, targetProps, targetAnimationProps);
              }
              else if (bindParts[IDENT_EVENT_IDX]) {
                  this._parseEventOrAnimationEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);
              }
          }
          else {
              hasBinding =
                  this._parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);
          }
          if (!hasBinding) {
              this._parseLiteralAttr(name, value, srcSpan, targetProps);
          }
          return hasBinding;
      };
      TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {
          return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
      };
      TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {
          if (identifier.indexOf('-') > -1) {
              this._reportError("\"-\" is not allowed in variable names", sourceSpan);
          }
          targetVars.push(new VariableAst(identifier, value, sourceSpan));
      };
      TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {
          if (identifier.indexOf('-') > -1) {
              this._reportError("\"-\" is not allowed in reference names", sourceSpan);
          }
          targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
      };
      TemplateParseVisitor.prototype._parsePropertyOrAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps, targetAnimationProps) {
          var animatePropLength = ANIMATE_PROP_PREFIX.length;
          var isAnimationProp = _isAnimationLabel(name);
          var animationPrefixLength = 1;
          if (name.substring(0, animatePropLength) == ANIMATE_PROP_PREFIX) {
              isAnimationProp = true;
              animationPrefixLength = animatePropLength;
          }
          if (isAnimationProp) {
              this._parseAnimation(name.substr(animationPrefixLength), expression, sourceSpan, targetMatchableAttrs, targetAnimationProps);
          }
          else {
              this._parsePropertyAst(name, this._parseBinding(expression, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
          }
      };
      TemplateParseVisitor.prototype._parseAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetAnimationProps) {
          // This will occur when a @trigger is not paired with an expression.
          // For animations it is valid to not have an expression since */void
          // states will be applied by angular when the element is attached/detached
          if (!isPresent(expression) || expression.length == 0) {
              expression = 'null';
          }
          var ast = this._parseBinding(expression, sourceSpan);
          targetMatchableAttrs.push([name, ast.source]);
          targetAnimationProps.push(new BoundElementPropertyAst(name, exports.PropertyBindingType.Animation, _angular_core.SecurityContext.NONE, ast, null, sourceSpan));
      };
      TemplateParseVisitor.prototype._parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {
          var expr = this._parseInterpolation(value, sourceSpan);
          if (isPresent(expr)) {
              this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
              return true;
          }
          return false;
      };
      TemplateParseVisitor.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
          targetMatchableAttrs.push([name, ast.source]);
          targetProps.push(new BoundElementOrDirectiveProperty(name, ast, false, sourceSpan));
      };
      TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
          this._parseEventOrAnimationEvent(name + "Change", expression + "=$event", sourceSpan, targetMatchableAttrs, targetEvents);
      };
      TemplateParseVisitor.prototype._parseEventOrAnimationEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
          if (_isAnimationLabel(name)) {
              name = name.substr(1);
              this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);
          }
          else {
              this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);
          }
      };
      TemplateParseVisitor.prototype._parseAnimationEvent = function (name, expression, sourceSpan, targetEvents) {
          var matches = splitAtPeriod(name, [name, '']);
          var eventName = matches[0];
          var phase = matches[1].toLowerCase();
          if (phase) {
              switch (phase) {
                  case 'start':
                  case 'done':
                      var ast = this._parseAction(expression, sourceSpan);
                      targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));
                      break;
                  default:
                      this._reportError("The provided animation output phase value \"" + phase + "\" for \"@" + eventName + "\" is not supported (use start or done)", sourceSpan);
                      break;
              }
          }
          else {
              this._reportError("The animation trigger output event (@" + eventName + ") is missing its phase value name (start or done are currently supported)", sourceSpan);
          }
      };
      TemplateParseVisitor.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
          // long format: 'target: eventName'
          var _a = splitAtColon(name, [null, name]), target = _a[0], eventName = _a[1];
          var ast = this._parseAction(expression, sourceSpan);
          targetMatchableAttrs.push([name, ast.source]);
          targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));
          // Don't detect directives for event names for now,
          // so don't add the event name to the matchableAttrs
      };
      TemplateParseVisitor.prototype._parseLiteralAttr = function (name, value, sourceSpan, targetProps) {
          targetProps.push(new BoundElementOrDirectiveProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), true, sourceSpan));
      };
      TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {
          var _this = this;
          // Need to sort the directives so that we get consistent results throughout,
          // as selectorMatcher uses Maps inside.
          // Also deduplicate directives as they might match more than one time!
          var directives = new Array(this.directivesIndex.size);
          // Whether any directive selector matches on the element name
          var matchElement = false;
          selectorMatcher.match(elementCssSelector, function (selector, directive) {
              directives[_this.directivesIndex.get(directive)] = directive;
              matchElement = matchElement || selector.hasElementSelector();
          });
          return {
              directives: directives.filter(function (dir) { return !!dir; }),
              matchElement: matchElement,
          };
      };
      TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences) {
          var _this = this;
          var matchedReferences = new Set();
          var component = null;
          var directiveAsts = directives.map(function (directive) {
              var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, "Directive " + directive.type.name);
              if (directive.isComponent) {
                  component = directive;
              }
              var hostProperties = [];
              var hostEvents = [];
              var directiveProperties = [];
              _this._createDirectiveHostPropertyAsts(elementName, directive.hostProperties, sourceSpan, hostProperties);
              _this._createDirectiveHostEventAsts(directive.hostListeners, sourceSpan, hostEvents);
              _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties);
              elementOrDirectiveRefs.forEach(function (elOrDirRef) {
                  if ((elOrDirRef.value.length === 0 && directive.isComponent) ||
                      (directive.exportAs == elOrDirRef.value)) {
                      targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));
                      matchedReferences.add(elOrDirRef.name);
                  }
              });
              return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, sourceSpan);
          });
          elementOrDirectiveRefs.forEach(function (elOrDirRef) {
              if (elOrDirRef.value.length > 0) {
                  if (!matchedReferences.has(elOrDirRef.name)) {
                      _this._reportError("There is no directive with \"exportAs\" set to \"" + elOrDirRef.value + "\"", elOrDirRef.sourceSpan);
                  }
              }
              else if (!component) {
                  var refToken = null;
                  if (isTemplateElement) {
                      refToken = resolveIdentifierToken(Identifiers.TemplateRef);
                  }
                  targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));
              }
          }); // fix syntax highlighting issue: `
          return directiveAsts;
      };
      TemplateParseVisitor.prototype._createDirectiveHostPropertyAsts = function (elementName, hostProps, sourceSpan, targetPropertyAsts) {
          var _this = this;
          if (hostProps) {
              Object.keys(hostProps).forEach(function (propName) {
                  var expression = hostProps[propName];
                  if (isString(expression)) {
                      var exprAst = _this._parseBinding(expression, sourceSpan);
                      targetPropertyAsts.push(_this._createElementPropertyAst(elementName, propName, exprAst, sourceSpan));
                  }
                  else {
                      _this._reportError("Value of the host property binding \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
                  }
              });
          }
      };
      TemplateParseVisitor.prototype._createDirectiveHostEventAsts = function (hostListeners, sourceSpan, targetEventAsts) {
          var _this = this;
          if (hostListeners) {
              Object.keys(hostListeners).forEach(function (propName) {
                  var expression = hostListeners[propName];
                  if (isString(expression)) {
                      _this._parseEventOrAnimationEvent(propName, expression, sourceSpan, [], targetEventAsts);
                  }
                  else {
                      _this._reportError("Value of the host listener \"" + propName + "\" needs to be a string representing an expression but got \"" + expression + "\" (" + typeof expression + ")", sourceSpan);
                  }
              });
          }
      };
      TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps) {
          if (directiveProperties) {
              var boundPropsByName_1 = new Map();
              boundProps.forEach(function (boundProp) {
                  var prevValue = boundPropsByName_1.get(boundProp.name);
                  if (!prevValue || prevValue.isLiteral) {
                      // give [a]="b" a higher precedence than a="b" on the same element
                      boundPropsByName_1.set(boundProp.name, boundProp);
                  }
              });
              Object.keys(directiveProperties).forEach(function (dirProp) {
                  var elProp = directiveProperties[dirProp];
                  var boundProp = boundPropsByName_1.get(elProp);
                  // Bindings are optional, so this binding only needs to be set up if an expression is given.
                  if (boundProp) {
                      targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
                  }
              });
          }
      };
      TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, directives) {
          var _this = this;
          var boundElementProps = [];
          var boundDirectivePropsIndex = new Map();
          directives.forEach(function (directive) {
              directive.inputs.forEach(function (prop) {
                  boundDirectivePropsIndex.set(prop.templateName, prop);
              });
          });
          props.forEach(function (prop) {
              if (!prop.isLiteral && !boundDirectivePropsIndex.get(prop.name)) {
                  boundElementProps.push(_this._createElementPropertyAst(elementName, prop.name, prop.expression, prop.sourceSpan));
              }
          });
          return boundElementProps;
      };
      TemplateParseVisitor.prototype._createElementPropertyAst = function (elementName, name, ast, sourceSpan) {
          var unit = null;
          var bindingType;
          var boundPropertyName;
          var parts = name.split(PROPERTY_PARTS_SEPARATOR);
          var securityContext;
          if (parts.length === 1) {
              var partValue = parts[0];
              if (_isAnimationLabel(partValue)) {
                  boundPropertyName = partValue.substr(1);
                  bindingType = exports.PropertyBindingType.Animation;
                  securityContext = _angular_core.SecurityContext.NONE;
              }
              else {
                  boundPropertyName = this._schemaRegistry.getMappedPropName(partValue);
                  securityContext = this._schemaRegistry.securityContext(elementName, boundPropertyName);
                  bindingType = exports.PropertyBindingType.Property;
                  this._validatePropertyOrAttributeName(boundPropertyName, sourceSpan, false);
                  if (!this._schemaRegistry.hasProperty(elementName, boundPropertyName, this._schemas)) {
                      var errorMsg = "Can't bind to '" + boundPropertyName + "' since it isn't a known property of '" + elementName + "'.";
                      if (elementName.indexOf('-') > -1) {
                          errorMsg +=
                              ("\n1. If '" + elementName + "' is an Angular component and it has '" + boundPropertyName + "' input, then verify that it is part of this module.") +
                                  ("\n2. If '" + elementName + "' is a Web Component then add \"CUSTOM_ELEMENTS_SCHEMA\" to the '@NgModule.schemas' of this component to suppress this message.\n");
                      }
                      this._reportError(errorMsg, sourceSpan);
                  }
              }
          }
          else {
              if (parts[0] == ATTRIBUTE_PREFIX) {
                  boundPropertyName = parts[1];
                  this._validatePropertyOrAttributeName(boundPropertyName, sourceSpan, true);
                  // NB: For security purposes, use the mapped property name, not the attribute name.
                  var mapPropName = this._schemaRegistry.getMappedPropName(boundPropertyName);
                  securityContext = this._schemaRegistry.securityContext(elementName, mapPropName);
                  var nsSeparatorIdx = boundPropertyName.indexOf(':');
                  if (nsSeparatorIdx > -1) {
                      var ns = boundPropertyName.substring(0, nsSeparatorIdx);
                      var name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);
                      boundPropertyName = mergeNsAndName(ns, name_1);
                  }
                  bindingType = exports.PropertyBindingType.Attribute;
              }
              else if (parts[0] == CLASS_PREFIX) {
                  boundPropertyName = parts[1];
                  bindingType = exports.PropertyBindingType.Class;
                  securityContext = _angular_core.SecurityContext.NONE;
              }
              else if (parts[0] == STYLE_PREFIX) {
                  unit = parts.length > 2 ? parts[2] : null;
                  boundPropertyName = parts[1];
                  bindingType = exports.PropertyBindingType.Style;
                  securityContext = _angular_core.SecurityContext.STYLE;
              }
              else {
                  this._reportError("Invalid property name '" + name + "'", sourceSpan);
                  bindingType = null;
                  securityContext = null;
              }
          }
          return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContext, ast, unit, sourceSpan);
      };
      /**
       * @param propName the name of the property / attribute
       * @param sourceSpan
       * @param isAttr true when binding to an attribute
       * @private
       */
      TemplateParseVisitor.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {
          var report = isAttr ? this._schemaRegistry.validateAttribute(propName) :
              this._schemaRegistry.validateProperty(propName);
          if (report.error) {
              this._reportError(report.msg, sourceSpan, ParseErrorLevel.FATAL);
          }
      };
      TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {
          return directives.filter(function (directive) { return directive.directive.isComponent; });
      };
      TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {
          return this._findComponentDirectives(directives)
              .map(function (directive) { return directive.directive.type.name; });
      };
      TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {
          var componentTypeNames = this._findComponentDirectiveNames(directives);
          if (componentTypeNames.length > 1) {
              this._reportError("More than one component: " + componentTypeNames.join(','), sourceSpan);
          }
      };
      /**
       * Make sure that non-angular tags conform to the schemas.
       *
       * Note: An element is considered an angular tag when at least one directive selector matches the
       * tag name.
       *
       * @param matchElement Whether any directive has matched on the tag name
       * @param element the html element
       */
      TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {
          var elName = element.name.replace(/^:xhtml:/, '');
          if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {
              var errorMsg = ("'" + elName + "' is not a known element:\n") +
                  ("1. If '" + elName + "' is an Angular component, then verify that it is part of this module.\n") +
                  ("2. If '" + elName + "' is a Web Component then add \"CUSTOM_ELEMENTS_SCHEMA\" to the '@NgModule.schemas' of this component to suppress this message.");
              this._reportError(errorMsg, element.sourceSpan);
          }
      };
      TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {
          var _this = this;
          var componentTypeNames = this._findComponentDirectiveNames(directives);
          if (componentTypeNames.length > 0) {
              this._reportError("Components on an embedded template: " + componentTypeNames.join(','), sourceSpan);
          }
          elementProps.forEach(function (prop) {
              _this._reportError("Property binding " + prop.name + " not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"directives\" section.", sourceSpan);
          });
      };
      TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {
          var _this = this;
          var allDirectiveEvents = new Set();
          directives.forEach(function (directive) {
              Object.keys(directive.directive.outputs).forEach(function (k) {
                  var eventName = directive.directive.outputs[k];
                  allDirectiveEvents.add(eventName);
              });
          });
          events.forEach(function (event) {
              if (isPresent(event.target) || !allDirectiveEvents.has(event.name)) {
                  _this._reportError("Event binding " + event.fullName + " not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"directives\" section.", event.sourceSpan);
              }
          });
      };
      return TemplateParseVisitor;
  }());
  var NonBindableVisitor = (function () {
      function NonBindableVisitor() {
      }
      NonBindableVisitor.prototype.visitElement = function (ast, parent) {
          var preparsedElement = preparseElement(ast);
          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
              preparsedElement.type === PreparsedElementType.STYLE ||
              preparsedElement.type === PreparsedElementType.STYLESHEET) {
              // Skipping <script> for security reasons
              // Skipping <style> and stylesheets as we already processed them
              // in the StyleCompiler
              return null;
          }
          var attrNameAndValues = ast.attrs.map(function (attrAst) { return [attrAst.name, attrAst.value]; });
          var selector = createElementCssSelector(ast.name, attrNameAndValues);
          var ngContentIndex = parent.findNgContentIndex(selector);
          var children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
          return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, children, ngContentIndex, ast.sourceSpan);
      };
      NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };
      NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {
          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
      };
      NonBindableVisitor.prototype.visitText = function (text, parent) {
          var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);
          return new TextAst(text.value, ngContentIndex, text.sourceSpan);
      };
      NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };
      NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };
      return NonBindableVisitor;
  }());
  var BoundElementOrDirectiveProperty = (function () {
      function BoundElementOrDirectiveProperty(name, expression, isLiteral, sourceSpan) {
          this.name = name;
          this.expression = expression;
          this.isLiteral = isLiteral;
          this.sourceSpan = sourceSpan;
      }
      return BoundElementOrDirectiveProperty;
  }());
  var ElementOrDirectiveRef = (function () {
      function ElementOrDirectiveRef(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      return ElementOrDirectiveRef;
  }());
  function splitClasses(classAttrValue) {
      return classAttrValue.trim().split(/\s+/g);
  }
  var ElementContext = (function () {
      function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
          this.isTemplateElement = isTemplateElement;
          this._ngContentIndexMatcher = _ngContentIndexMatcher;
          this._wildcardNgContentIndex = _wildcardNgContentIndex;
          this.providerContext = providerContext;
      }
      ElementContext.create = function (isTemplateElement, directives, providerContext) {
          var matcher = new SelectorMatcher();
          var wildcardNgContentIndex = null;
          var component = directives.find(function (directive) { return directive.directive.isComponent; });
          if (component) {
              var ngContentSelectors = component.directive.template.ngContentSelectors;
              for (var i = 0; i < ngContentSelectors.length; i++) {
                  var selector = ngContentSelectors[i];
                  if (selector === '*') {
                      wildcardNgContentIndex = i;
                  }
                  else {
                      matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
                  }
              }
          }
          return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
      };
      ElementContext.prototype.findNgContentIndex = function (selector) {
          var ngContentIndices = [];
          this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });
          ngContentIndices.sort();
          if (isPresent(this._wildcardNgContentIndex)) {
              ngContentIndices.push(this._wildcardNgContentIndex);
          }
          return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
      };
      return ElementContext;
  }());
  function createElementCssSelector(elementName, matchableAttrs) {
      var cssSelector = new CssSelector();
      var elNameNoNs = splitNsName(elementName)[1];
      cssSelector.setElement(elNameNoNs);
      for (var i = 0; i < matchableAttrs.length; i++) {
          var attrName = matchableAttrs[i][0];
          var attrNameNoNs = splitNsName(attrName)[1];
          var attrValue = matchableAttrs[i][1];
          cssSelector.addAttribute(attrNameNoNs, attrValue);
          if (attrName.toLowerCase() == CLASS_ATTR) {
              var classes = splitClasses(attrValue);
              classes.forEach(function (className) { return cssSelector.addClassName(className); });
          }
      }
      return cssSelector;
  }
  var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
  var NON_BINDABLE_VISITOR = new NonBindableVisitor();
  var PipeCollector = (function (_super) {
      __extends(PipeCollector, _super);
      function PipeCollector() {
          _super.apply(this, arguments);
          this.pipes = new Set();
      }
      PipeCollector.prototype.visitPipe = function (ast, context) {
          this.pipes.add(ast.name);
          ast.exp.visit(this);
          this.visitAll(ast.args, context);
          return null;
      };
      return PipeCollector;
  }(RecursiveAstVisitor));
  function _isAnimationLabel(name) {
      return name[0] == '@';
  }

  function unimplemented$1() {
      throw new Error('unimplemented');
  }
  var CompilerConfig = (function () {
      function CompilerConfig(_a) {
          var _b = _a === void 0 ? {} : _a, _c = _b.renderTypes, renderTypes = _c === void 0 ? new DefaultRenderTypes() : _c, _d = _b.defaultEncapsulation, defaultEncapsulation = _d === void 0 ? _angular_core.ViewEncapsulation.Emulated : _d, genDebugInfo = _b.genDebugInfo, logBindingUpdate = _b.logBindingUpdate, _e = _b.useJit, useJit = _e === void 0 ? true : _e;
          this.renderTypes = renderTypes;
          this.defaultEncapsulation = defaultEncapsulation;
          this._genDebugInfo = genDebugInfo;
          this._logBindingUpdate = logBindingUpdate;
          this.useJit = useJit;
      }
      Object.defineProperty(CompilerConfig.prototype, "genDebugInfo", {
          get: function () {
              return this._genDebugInfo === void 0 ? _angular_core.isDevMode() : this._genDebugInfo;
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(CompilerConfig.prototype, "logBindingUpdate", {
          get: function () {
              return this._logBindingUpdate === void 0 ? _angular_core.isDevMode() : this._logBindingUpdate;
          },
          enumerable: true,
          configurable: true
      });
      return CompilerConfig;
  }());
  /**
   * Types used for the renderer.
   * Can be replaced to specialize the generated output to a specific renderer
   * to help tree shaking.
   */
  var RenderTypes = (function () {
      function RenderTypes() {
      }
      Object.defineProperty(RenderTypes.prototype, "renderer", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderText", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderElement", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderComment", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderNode", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(RenderTypes.prototype, "renderEvent", {
          get: function () { return unimplemented$1(); },
          enumerable: true,
          configurable: true
      });
      return RenderTypes;
  }());
  var DefaultRenderTypes = (function () {
      function DefaultRenderTypes() {
          this.renderText = null;
          this.renderElement = null;
          this.renderComment = null;
          this.renderNode = null;
          this.renderEvent = null;
      }
      Object.defineProperty(DefaultRenderTypes.prototype, "renderer", {
          get: function () { return resolveIdentifier(Identifiers.Renderer); },
          enumerable: true,
          configurable: true
      });
      ;
      return DefaultRenderTypes;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$12 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var AnimationAst = (function () {
      function AnimationAst() {
          this.startTime = 0;
          this.playTime = 0;
      }
      return AnimationAst;
  }());
  var AnimationStateAst = (function (_super) {
      __extends$12(AnimationStateAst, _super);
      function AnimationStateAst() {
          _super.apply(this, arguments);
      }
      return AnimationStateAst;
  }(AnimationAst));
  var AnimationEntryAst = (function (_super) {
      __extends$12(AnimationEntryAst, _super);
      function AnimationEntryAst(name, stateDeclarations, stateTransitions) {
          _super.call(this);
          this.name = name;
          this.stateDeclarations = stateDeclarations;
          this.stateTransitions = stateTransitions;
      }
      AnimationEntryAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationEntry(this, context);
      };
      return AnimationEntryAst;
  }(AnimationAst));
  var AnimationStateDeclarationAst = (function (_super) {
      __extends$12(AnimationStateDeclarationAst, _super);
      function AnimationStateDeclarationAst(stateName, styles) {
          _super.call(this);
          this.stateName = stateName;
          this.styles = styles;
      }
      AnimationStateDeclarationAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationStateDeclaration(this, context);
      };
      return AnimationStateDeclarationAst;
  }(AnimationStateAst));
  var AnimationStateTransitionExpression = (function () {
      function AnimationStateTransitionExpression(fromState, toState) {
          this.fromState = fromState;
          this.toState = toState;
      }
      return AnimationStateTransitionExpression;
  }());
  var AnimationStateTransitionAst = (function (_super) {
      __extends$12(AnimationStateTransitionAst, _super);
      function AnimationStateTransitionAst(stateChanges, animation) {
          _super.call(this);
          this.stateChanges = stateChanges;
          this.animation = animation;
      }
      AnimationStateTransitionAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationStateTransition(this, context);
      };
      return AnimationStateTransitionAst;
  }(AnimationStateAst));
  var AnimationStepAst = (function (_super) {
      __extends$12(AnimationStepAst, _super);
      function AnimationStepAst(startingStyles, keyframes, duration, delay, easing) {
          _super.call(this);
          this.startingStyles = startingStyles;
          this.keyframes = keyframes;
          this.duration = duration;
          this.delay = delay;
          this.easing = easing;
      }
      AnimationStepAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationStep(this, context);
      };
      return AnimationStepAst;
  }(AnimationAst));
  var AnimationStylesAst = (function (_super) {
      __extends$12(AnimationStylesAst, _super);
      function AnimationStylesAst(styles) {
          _super.call(this);
          this.styles = styles;
      }
      AnimationStylesAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationStyles(this, context);
      };
      return AnimationStylesAst;
  }(AnimationAst));
  var AnimationKeyframeAst = (function (_super) {
      __extends$12(AnimationKeyframeAst, _super);
      function AnimationKeyframeAst(offset, styles) {
          _super.call(this);
          this.offset = offset;
          this.styles = styles;
      }
      AnimationKeyframeAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationKeyframe(this, context);
      };
      return AnimationKeyframeAst;
  }(AnimationAst));
  var AnimationWithStepsAst = (function (_super) {
      __extends$12(AnimationWithStepsAst, _super);
      function AnimationWithStepsAst(steps) {
          _super.call(this);
          this.steps = steps;
      }
      return AnimationWithStepsAst;
  }(AnimationAst));
  var AnimationGroupAst = (function (_super) {
      __extends$12(AnimationGroupAst, _super);
      function AnimationGroupAst(steps) {
          _super.call(this, steps);
      }
      AnimationGroupAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationGroup(this, context);
      };
      return AnimationGroupAst;
  }(AnimationWithStepsAst));
  var AnimationSequenceAst = (function (_super) {
      __extends$12(AnimationSequenceAst, _super);
      function AnimationSequenceAst(steps) {
          _super.call(this, steps);
      }
      AnimationSequenceAst.prototype.visit = function (visitor, context) {
          return visitor.visitAnimationSequence(this, context);
      };
      return AnimationSequenceAst;
  }(AnimationWithStepsAst));

  var AnimationEntryCompileResult = (function () {
      function AnimationEntryCompileResult(name, statements, fnExp) {
          this.name = name;
          this.statements = statements;
          this.fnExp = fnExp;
      }
      return AnimationEntryCompileResult;
  }());
  var AnimationCompiler = (function () {
      function AnimationCompiler() {
      }
      AnimationCompiler.prototype.compile = function (factoryNamePrefix, parsedAnimations) {
          return parsedAnimations.map(function (entry) {
              var factoryName = factoryNamePrefix + "_" + entry.name;
              var visitor = new _AnimationBuilder(entry.name, factoryName);
              return visitor.build(entry);
          });
      };
      return AnimationCompiler;
  }());
  var _ANIMATION_FACTORY_ELEMENT_VAR = variable('element');
  var _ANIMATION_DEFAULT_STATE_VAR = variable('defaultStateStyles');
  var _ANIMATION_FACTORY_VIEW_VAR = variable('view');
  var _ANIMATION_FACTORY_RENDERER_VAR = _ANIMATION_FACTORY_VIEW_VAR.prop('renderer');
  var _ANIMATION_CURRENT_STATE_VAR = variable('currentState');
  var _ANIMATION_NEXT_STATE_VAR = variable('nextState');
  var _ANIMATION_PLAYER_VAR = variable('player');
  var _ANIMATION_TIME_VAR = variable('totalTime');
  var _ANIMATION_START_STATE_STYLES_VAR = variable('startStateStyles');
  var _ANIMATION_END_STATE_STYLES_VAR = variable('endStateStyles');
  var _ANIMATION_COLLECTED_STYLES = variable('collectedStyles');
  var EMPTY_MAP$1 = literalMap([]);
  var _AnimationBuilder = (function () {
      function _AnimationBuilder(animationName, factoryName) {
          this.animationName = animationName;
          this._fnVarName = factoryName + '_factory';
          this._statesMapVarName = factoryName + '_states';
          this._statesMapVar = variable(this._statesMapVarName);
      }
      _AnimationBuilder.prototype.visitAnimationStyles = function (ast, context) {
          var stylesArr = [];
          if (context.isExpectingFirstStyleStep) {
              stylesArr.push(_ANIMATION_START_STATE_STYLES_VAR);
              context.isExpectingFirstStyleStep = false;
          }
          ast.styles.forEach(function (entry) {
              stylesArr.push(literalMap(Object.keys(entry).map(function (key) { return [key, literal(entry[key])]; })));
          });
          return importExpr(resolveIdentifier(Identifiers.AnimationStyles)).instantiate([
              importExpr(resolveIdentifier(Identifiers.collectAndResolveStyles)).callFn([
                  _ANIMATION_COLLECTED_STYLES, literalArr(stylesArr)
              ])
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationKeyframe = function (ast, context) {
          return importExpr(resolveIdentifier(Identifiers.AnimationKeyframe)).instantiate([
              literal(ast.offset), ast.styles.visit(this, context)
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationStep = function (ast, context) {
          var _this = this;
          if (context.endStateAnimateStep === ast) {
              return this._visitEndStateAnimation(ast, context);
          }
          var startingStylesExpr = ast.startingStyles.visit(this, context);
          var keyframeExpressions = ast.keyframes.map(function (keyframeEntry) { return keyframeEntry.visit(_this, context); });
          return this._callAnimateMethod(ast, startingStylesExpr, literalArr(keyframeExpressions), context);
      };
      /** @internal */
      _AnimationBuilder.prototype._visitEndStateAnimation = function (ast, context) {
          var _this = this;
          var startingStylesExpr = ast.startingStyles.visit(this, context);
          var keyframeExpressions = ast.keyframes.map(function (keyframe) { return keyframe.visit(_this, context); });
          var keyframesExpr = importExpr(resolveIdentifier(Identifiers.balanceAnimationKeyframes)).callFn([
              _ANIMATION_COLLECTED_STYLES, _ANIMATION_END_STATE_STYLES_VAR,
              literalArr(keyframeExpressions)
          ]);
          return this._callAnimateMethod(ast, startingStylesExpr, keyframesExpr, context);
      };
      /** @internal */
      _AnimationBuilder.prototype._callAnimateMethod = function (ast, startingStylesExpr, keyframesExpr, context) {
          context.totalTransitionTime += ast.duration + ast.delay;
          return _ANIMATION_FACTORY_RENDERER_VAR.callMethod('animate', [
              _ANIMATION_FACTORY_ELEMENT_VAR, startingStylesExpr, keyframesExpr, literal(ast.duration),
              literal(ast.delay), literal(ast.easing)
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationSequence = function (ast, context) {
          var _this = this;
          var playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });
          return importExpr(resolveIdentifier(Identifiers.AnimationSequencePlayer)).instantiate([
              literalArr(playerExprs)
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationGroup = function (ast, context) {
          var _this = this;
          var playerExprs = ast.steps.map(function (step) { return step.visit(_this, context); });
          return importExpr(resolveIdentifier(Identifiers.AnimationGroupPlayer)).instantiate([
              literalArr(playerExprs)
          ]);
      };
      _AnimationBuilder.prototype.visitAnimationStateDeclaration = function (ast, context) {
          var flatStyles = {};
          _getStylesArray(ast).forEach(function (entry) { Object.keys(entry).forEach(function (key) { flatStyles[key] = entry[key]; }); });
          context.stateMap.registerState(ast.stateName, flatStyles);
      };
      _AnimationBuilder.prototype.visitAnimationStateTransition = function (ast, context) {
          var steps = ast.animation.steps;
          var lastStep = steps[steps.length - 1];
          if (_isEndStateAnimateStep(lastStep)) {
              context.endStateAnimateStep = lastStep;
          }
          context.totalTransitionTime = 0;
          context.isExpectingFirstStyleStep = true;
          var stateChangePreconditions = [];
          ast.stateChanges.forEach(function (stateChange) {
              stateChangePreconditions.push(_compareToAnimationStateExpr(_ANIMATION_CURRENT_STATE_VAR, stateChange.fromState)
                  .and(_compareToAnimationStateExpr(_ANIMATION_NEXT_STATE_VAR, stateChange.toState)));
              if (stateChange.fromState != ANY_STATE) {
                  context.stateMap.registerState(stateChange.fromState);
              }
              if (stateChange.toState != ANY_STATE) {
                  context.stateMap.registerState(stateChange.toState);
              }
          });
          var animationPlayerExpr = ast.animation.visit(this, context);
          var reducedStateChangesPrecondition = stateChangePreconditions.reduce(function (a, b) { return a.or(b); });
          var precondition = _ANIMATION_PLAYER_VAR.equals(NULL_EXPR).and(reducedStateChangesPrecondition);
          var animationStmt = _ANIMATION_PLAYER_VAR.set(animationPlayerExpr).toStmt();
          var totalTimeStmt = _ANIMATION_TIME_VAR.set(literal(context.totalTransitionTime)).toStmt();
          return new IfStmt(precondition, [animationStmt, totalTimeStmt]);
      };
      _AnimationBuilder.prototype.visitAnimationEntry = function (ast, context) {
          var _this = this;
          // visit each of the declarations first to build the context state map
          ast.stateDeclarations.forEach(function (def) { return def.visit(_this, context); });
          // this should always be defined even if the user overrides it
          context.stateMap.registerState(DEFAULT_STATE, {});
          var statements = [];
          statements.push(_ANIMATION_FACTORY_VIEW_VAR
              .callMethod('cancelActiveAnimation', [
              _ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName),
              _ANIMATION_NEXT_STATE_VAR.equals(literal(EMPTY_ANIMATION_STATE))
          ])
              .toStmt());
          statements.push(_ANIMATION_COLLECTED_STYLES.set(EMPTY_MAP$1).toDeclStmt());
          statements.push(_ANIMATION_PLAYER_VAR.set(NULL_EXPR).toDeclStmt());
          statements.push(_ANIMATION_TIME_VAR.set(literal(0)).toDeclStmt());
          statements.push(_ANIMATION_DEFAULT_STATE_VAR.set(this._statesMapVar.key(literal(DEFAULT_STATE)))
              .toDeclStmt());
          statements.push(_ANIMATION_START_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_CURRENT_STATE_VAR))
              .toDeclStmt());
          statements.push(new IfStmt(_ANIMATION_START_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_START_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
          statements.push(_ANIMATION_END_STATE_STYLES_VAR.set(this._statesMapVar.key(_ANIMATION_NEXT_STATE_VAR))
              .toDeclStmt());
          statements.push(new IfStmt(_ANIMATION_END_STATE_STYLES_VAR.equals(NULL_EXPR), [_ANIMATION_END_STATE_STYLES_VAR.set(_ANIMATION_DEFAULT_STATE_VAR).toStmt()]));
          var RENDER_STYLES_FN = importExpr(resolveIdentifier(Identifiers.renderStyles));
          // before we start any animation we want to clear out the starting
          // styles from the element's style property (since they were placed
          // there at the end of the last animation
          statements.push(RENDER_STYLES_FN
              .callFn([
              _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,
              importExpr(resolveIdentifier(Identifiers.clearStyles))
                  .callFn([_ANIMATION_START_STATE_STYLES_VAR])
          ])
              .toStmt());
          ast.stateTransitions.forEach(function (transAst) { return statements.push(transAst.visit(_this, context)); });
          // this check ensures that the animation factory always returns a player
          // so that the onDone callback can be used for tracking
          statements.push(new IfStmt(_ANIMATION_PLAYER_VAR.equals(NULL_EXPR), [_ANIMATION_PLAYER_VAR
                  .set(importExpr(resolveIdentifier(Identifiers.NoOpAnimationPlayer)).instantiate([]))
                  .toStmt()]));
          // once complete we want to apply the styles on the element
          // since the destination state's values should persist once
          // the animation sequence has completed.
          statements.push(_ANIMATION_PLAYER_VAR
              .callMethod('onDone', [fn([], [RENDER_STYLES_FN
                      .callFn([
                      _ANIMATION_FACTORY_ELEMENT_VAR, _ANIMATION_FACTORY_RENDERER_VAR,
                      importExpr(resolveIdentifier(Identifiers.prepareFinalAnimationStyles))
                          .callFn([
                          _ANIMATION_START_STATE_STYLES_VAR, _ANIMATION_END_STATE_STYLES_VAR
                      ])
                  ])
                      .toStmt()])])
              .toStmt());
          statements.push(_ANIMATION_FACTORY_VIEW_VAR
              .callMethod('queueAnimation', [
              _ANIMATION_FACTORY_ELEMENT_VAR, literal(this.animationName),
              _ANIMATION_PLAYER_VAR, _ANIMATION_TIME_VAR,
              _ANIMATION_CURRENT_STATE_VAR, _ANIMATION_NEXT_STATE_VAR
          ])
              .toStmt());
          return fn([
              new FnParam(_ANIMATION_FACTORY_VIEW_VAR.name, importType(resolveIdentifier(Identifiers.AppView), [DYNAMIC_TYPE])),
              new FnParam(_ANIMATION_FACTORY_ELEMENT_VAR.name, DYNAMIC_TYPE),
              new FnParam(_ANIMATION_CURRENT_STATE_VAR.name, DYNAMIC_TYPE),
              new FnParam(_ANIMATION_NEXT_STATE_VAR.name, DYNAMIC_TYPE)
          ], statements);
      };
      _AnimationBuilder.prototype.build = function (ast) {
          var context = new _AnimationBuilderContext();
          var fnStatement = ast.visit(this, context).toDeclStmt(this._fnVarName);
          var fnVariable = variable(this._fnVarName);
          var lookupMap = [];
          Object.keys(context.stateMap.states).forEach(function (stateName) {
              var value = context.stateMap.states[stateName];
              var variableValue = EMPTY_MAP$1;
              if (isPresent(value)) {
                  var styleMap_1 = [];
                  Object.keys(value).forEach(function (key) { styleMap_1.push([key, literal(value[key])]); });
                  variableValue = literalMap(styleMap_1);
              }
              lookupMap.push([stateName, variableValue]);
          });
          var compiledStatesMapStmt = this._statesMapVar.set(literalMap(lookupMap)).toDeclStmt();
          var statements = [compiledStatesMapStmt, fnStatement];
          return new AnimationEntryCompileResult(this.animationName, statements, fnVariable);
      };
      return _AnimationBuilder;
  }());
  var _AnimationBuilderContext = (function () {
      function _AnimationBuilderContext() {
          this.stateMap = new _AnimationBuilderStateMap();
          this.endStateAnimateStep = null;
          this.isExpectingFirstStyleStep = false;
          this.totalTransitionTime = 0;
      }
      return _AnimationBuilderContext;
  }());
  var _AnimationBuilderStateMap = (function () {
      function _AnimationBuilderStateMap() {
          this._states = {};
      }
      Object.defineProperty(_AnimationBuilderStateMap.prototype, "states", {
          get: function () { return this._states; },
          enumerable: true,
          configurable: true
      });
      _AnimationBuilderStateMap.prototype.registerState = function (name, value) {
          if (value === void 0) { value = null; }
          var existingEntry = this._states[name];
          if (!existingEntry) {
              this._states[name] = value;
          }
      };
      return _AnimationBuilderStateMap;
  }());
  function _compareToAnimationStateExpr(value, animationState) {
      var emptyStateLiteral = literal(EMPTY_ANIMATION_STATE);
      switch (animationState) {
          case EMPTY_ANIMATION_STATE:
              return value.equals(emptyStateLiteral);
          case ANY_STATE:
              return literal(true);
          default:
              return value.equals(literal(animationState));
      }
  }
  function _isEndStateAnimateStep(step) {
      // the final animation step is characterized by having only TWO
      // keyframe values and it must have zero styles for both keyframes
      if (step instanceof AnimationStepAst && step.duration > 0 && step.keyframes.length == 2) {
          var styles1 = _getStylesArray(step.keyframes[0])[0];
          var styles2 = _getStylesArray(step.keyframes[1])[0];
          return Object.keys(styles1).length === 0 && Object.keys(styles2).length === 0;
      }
      return false;
  }
  function _getStylesArray(obj) {
      return obj.styles.styles;
  }

  var Math$1 = global$1.Math;

  var StylesCollectionEntry = (function () {
      function StylesCollectionEntry(time, value) {
          this.time = time;
          this.value = value;
      }
      StylesCollectionEntry.prototype.matches = function (time, value) {
          return time == this.time && value == this.value;
      };
      return StylesCollectionEntry;
  }());
  var StylesCollection = (function () {
      function StylesCollection() {
          this.styles = {};
      }
      StylesCollection.prototype.insertAtTime = function (property, time, value) {
          var tuple = new StylesCollectionEntry(time, value);
          var entries = this.styles[property];
          if (!isPresent(entries)) {
              entries = this.styles[property] = [];
          }
          // insert this at the right stop in the array
          // this way we can keep it sorted
          var insertionIndex = 0;
          for (var i = entries.length - 1; i >= 0; i--) {
              if (entries[i].time <= time) {
                  insertionIndex = i + 1;
                  break;
              }
          }
          ListWrapper.insert(entries, insertionIndex, tuple);
      };
      StylesCollection.prototype.getByIndex = function (property, index) {
          var items = this.styles[property];
          if (isPresent(items)) {
              return index >= items.length ? null : items[index];
          }
          return null;
      };
      StylesCollection.prototype.indexOfAtOrBeforeTime = function (property, time) {
          var entries = this.styles[property];
          if (isPresent(entries)) {
              for (var i = entries.length - 1; i >= 0; i--) {
                  if (entries[i].time <= time)
                      return i;
              }
          }
          return null;
      };
      return StylesCollection;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$13 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var _INITIAL_KEYFRAME = 0;
  var _TERMINAL_KEYFRAME = 1;
  var _ONE_SECOND = 1000;
  var AnimationParseError = (function (_super) {
      __extends$13(AnimationParseError, _super);
      function AnimationParseError(message) {
          _super.call(this, null, message);
      }
      AnimationParseError.prototype.toString = function () { return "" + this.msg; };
      return AnimationParseError;
  }(ParseError));
  var AnimationEntryParseResult = (function () {
      function AnimationEntryParseResult(ast, errors) {
          this.ast = ast;
          this.errors = errors;
      }
      return AnimationEntryParseResult;
  }());
  var AnimationParser = (function () {
      function AnimationParser() {
      }
      AnimationParser.prototype.parseComponent = function (component) {
          var _this = this;
          var errors = [];
          var componentName = component.type.name;
          var animationTriggerNames = new Set();
          var asts = component.template.animations.map(function (entry) {
              var result = _this.parseEntry(entry);
              var ast = result.ast;
              var triggerName = ast.name;
              if (animationTriggerNames.has(triggerName)) {
                  result.errors.push(new AnimationParseError("The animation trigger \"" + triggerName + "\" has already been registered for the " + componentName + " component"));
              }
              else {
                  animationTriggerNames.add(triggerName);
              }
              if (result.errors.length > 0) {
                  var errorMessage_1 = "- Unable to parse the animation sequence for \"" + triggerName + "\" on the " + componentName + " component due to the following errors:";
                  result.errors.forEach(function (error) { errorMessage_1 += '\n-- ' + error.msg; });
                  errors.push(errorMessage_1);
              }
              return ast;
          });
          if (errors.length > 0) {
              var errorString = errors.join('\n');
              throw new Error("Animation parse errors:\n" + errorString);
          }
          return asts;
      };
      AnimationParser.prototype.parseEntry = function (entry) {
          var errors = [];
          var stateStyles = {};
          var transitions = [];
          var stateDeclarationAsts = [];
          entry.definitions.forEach(function (def) {
              if (def instanceof CompileAnimationStateDeclarationMetadata) {
                  _parseAnimationDeclarationStates(def, errors).forEach(function (ast) {
                      stateDeclarationAsts.push(ast);
                      stateStyles[ast.stateName] = ast.styles;
                  });
              }
              else {
                  transitions.push(def);
              }
          });
          var stateTransitionAsts = transitions.map(function (transDef) { return _parseAnimationStateTransition(transDef, stateStyles, errors); });
          var ast = new AnimationEntryAst(entry.name, stateDeclarationAsts, stateTransitionAsts);
          return new AnimationEntryParseResult(ast, errors);
      };
      return AnimationParser;
  }());
  function _parseAnimationDeclarationStates(stateMetadata, errors) {
      var styleValues = [];
      stateMetadata.styles.styles.forEach(function (stylesEntry) {
          // TODO (matsko): change this when we get CSS class integration support
          if (isStringMap(stylesEntry)) {
              styleValues.push(stylesEntry);
          }
          else {
              errors.push(new AnimationParseError("State based animations cannot contain references to other states"));
          }
      });
      var defStyles = new AnimationStylesAst(styleValues);
      var states = stateMetadata.stateNameExpr.split(/\s*,\s*/);
      return states.map(function (state) { return new AnimationStateDeclarationAst(state, defStyles); });
  }
  function _parseAnimationStateTransition(transitionStateMetadata, stateStyles, errors) {
      var styles = new StylesCollection();
      var transitionExprs = [];
      var transitionStates = transitionStateMetadata.stateChangeExpr.split(/\s*,\s*/);
      transitionStates.forEach(function (expr) {
          _parseAnimationTransitionExpr(expr, errors).forEach(function (transExpr) {
              transitionExprs.push(transExpr);
          });
      });
      var entry = _normalizeAnimationEntry(transitionStateMetadata.steps);
      var animation = _normalizeStyleSteps(entry, stateStyles, errors);
      var animationAst = _parseTransitionAnimation(animation, 0, styles, stateStyles, errors);
      if (errors.length == 0) {
          _fillAnimationAstStartingKeyframes(animationAst, styles, errors);
      }
      var stepsAst = (animationAst instanceof AnimationWithStepsAst) ?
          animationAst :
          new AnimationSequenceAst([animationAst]);
      return new AnimationStateTransitionAst(transitionExprs, stepsAst);
  }
  function _parseAnimationTransitionExpr(eventStr, errors) {
      var expressions = [];
      var match = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
      if (!isPresent(match) || match.length < 4) {
          errors.push(new AnimationParseError("the provided " + eventStr + " is not of a supported format"));
          return expressions;
      }
      var fromState = match[1];
      var separator = match[2];
      var toState = match[3];
      expressions.push(new AnimationStateTransitionExpression(fromState, toState));
      var isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
      if (separator[0] == '<' && !isFullAnyStateExpr) {
          expressions.push(new AnimationStateTransitionExpression(toState, fromState));
      }
      return expressions;
  }
  function _normalizeAnimationEntry(entry) {
      return isArray(entry) ? new CompileAnimationSequenceMetadata(entry) :
          entry;
  }
  function _normalizeStyleMetadata(entry, stateStyles, errors) {
      var normalizedStyles = [];
      entry.styles.forEach(function (styleEntry) {
          if (isString(styleEntry)) {
              ListWrapper.addAll(normalizedStyles, _resolveStylesFromState(styleEntry, stateStyles, errors));
          }
          else {
              normalizedStyles.push(styleEntry);
          }
      });
      return normalizedStyles;
  }
  function _normalizeStyleSteps(entry, stateStyles, errors) {
      var steps = _normalizeStyleStepEntry(entry, stateStyles, errors);
      return (entry instanceof CompileAnimationGroupMetadata) ?
          new CompileAnimationGroupMetadata(steps) :
          new CompileAnimationSequenceMetadata(steps);
  }
  function _mergeAnimationStyles(stylesList, newItem) {
      if (isStringMap(newItem) && stylesList.length > 0) {
          var lastIndex = stylesList.length - 1;
          var lastItem = stylesList[lastIndex];
          if (isStringMap(lastItem)) {
              stylesList[lastIndex] = StringMapWrapper.merge(lastItem, newItem);
              return;
          }
      }
      stylesList.push(newItem);
  }
  function _normalizeStyleStepEntry(entry, stateStyles, errors) {
      var steps;
      if (entry instanceof CompileAnimationWithStepsMetadata) {
          steps = entry.steps;
      }
      else {
          return [entry];
      }
      var newSteps = [];
      var combinedStyles;
      steps.forEach(function (step) {
          if (step instanceof CompileAnimationStyleMetadata) {
              // this occurs when a style step is followed by a previous style step
              // or when the first style step is run. We want to concatenate all subsequent
              // style steps together into a single style step such that we have the correct
              // starting keyframe data to pass into the animation player.
              if (!isPresent(combinedStyles)) {
                  combinedStyles = [];
              }
              _normalizeStyleMetadata(step, stateStyles, errors)
                  .forEach(function (entry) { _mergeAnimationStyles(combinedStyles, entry); });
          }
          else {
              // it is important that we create a metadata entry of the combined styles
              // before we go on an process the animate, sequence or group metadata steps.
              // This will ensure that the AST will have the previous styles painted on
              // screen before any further animations that use the styles take place.
              if (isPresent(combinedStyles)) {
                  newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
                  combinedStyles = null;
              }
              if (step instanceof CompileAnimationAnimateMetadata) {
                  // we do not recurse into CompileAnimationAnimateMetadata since
                  // those style steps are not going to be squashed
                  var animateStyleValue = step.styles;
                  if (animateStyleValue instanceof CompileAnimationStyleMetadata) {
                      animateStyleValue.styles =
                          _normalizeStyleMetadata(animateStyleValue, stateStyles, errors);
                  }
                  else if (animateStyleValue instanceof CompileAnimationKeyframesSequenceMetadata) {
                      animateStyleValue.steps.forEach(function (step) { step.styles = _normalizeStyleMetadata(step, stateStyles, errors); });
                  }
              }
              else if (step instanceof CompileAnimationWithStepsMetadata) {
                  var innerSteps = _normalizeStyleStepEntry(step, stateStyles, errors);
                  step = step instanceof CompileAnimationGroupMetadata ?
                      new CompileAnimationGroupMetadata(innerSteps) :
                      new CompileAnimationSequenceMetadata(innerSteps);
              }
              newSteps.push(step);
          }
      });
      // this happens when only styles were animated within the sequence
      if (isPresent(combinedStyles)) {
          newSteps.push(new CompileAnimationStyleMetadata(0, combinedStyles));
      }
      return newSteps;
  }
  function _resolveStylesFromState(stateName, stateStyles, errors) {
      var styles = [];
      if (stateName[0] != ':') {
          errors.push(new AnimationParseError("Animation states via styles must be prefixed with a \":\""));
      }
      else {
          var normalizedStateName = stateName.substring(1);
          var value = stateStyles[normalizedStateName];
          if (!isPresent(value)) {
              errors.push(new AnimationParseError("Unable to apply styles due to missing a state: \"" + normalizedStateName + "\""));
          }
          else {
              value.styles.forEach(function (stylesEntry) {
                  if (isStringMap(stylesEntry)) {
                      styles.push(stylesEntry);
                  }
              });
          }
      }
      return styles;
  }
  var _AnimationTimings = (function () {
      function _AnimationTimings(duration, delay, easing) {
          this.duration = duration;
          this.delay = delay;
          this.easing = easing;
      }
      return _AnimationTimings;
  }());
  function _parseAnimationKeyframes(keyframeSequence, currentTime, collectedStyles, stateStyles, errors) {
      var totalEntries = keyframeSequence.steps.length;
      var totalOffsets = 0;
      keyframeSequence.steps.forEach(function (step) { return totalOffsets += (isPresent(step.offset) ? 1 : 0); });
      if (totalOffsets > 0 && totalOffsets < totalEntries) {
          errors.push(new AnimationParseError("Not all style() entries contain an offset for the provided keyframe()"));
          totalOffsets = totalEntries;
      }
      var limit = totalEntries - 1;
      var margin = totalOffsets == 0 ? (1 / limit) : 0;
      var rawKeyframes = [];
      var index = 0;
      var doSortKeyframes = false;
      var lastOffset = 0;
      keyframeSequence.steps.forEach(function (styleMetadata) {
          var offset = styleMetadata.offset;
          var keyframeStyles = {};
          styleMetadata.styles.forEach(function (entry) {
              Object.keys(entry).forEach(function (prop) {
                  if (prop != 'offset') {
                      keyframeStyles[prop] = entry[prop];
                  }
              });
          });
          if (isPresent(offset)) {
              doSortKeyframes = doSortKeyframes || (offset < lastOffset);
          }
          else {
              offset = index == limit ? _TERMINAL_KEYFRAME : (margin * index);
          }
          rawKeyframes.push([offset, keyframeStyles]);
          lastOffset = offset;
          index++;
      });
      if (doSortKeyframes) {
          ListWrapper.sort(rawKeyframes, function (a, b) { return a[0] <= b[0] ? -1 : 1; });
      }
      var i;
      var firstKeyframe = rawKeyframes[0];
      if (firstKeyframe[0] != _INITIAL_KEYFRAME) {
          ListWrapper.insert(rawKeyframes, 0, firstKeyframe = [_INITIAL_KEYFRAME, {}]);
      }
      var firstKeyframeStyles = firstKeyframe[1];
      limit = rawKeyframes.length - 1;
      var lastKeyframe = rawKeyframes[limit];
      if (lastKeyframe[0] != _TERMINAL_KEYFRAME) {
          rawKeyframes.push(lastKeyframe = [_TERMINAL_KEYFRAME, {}]);
          limit++;
      }
      var lastKeyframeStyles = lastKeyframe[1];
      for (i = 1; i <= limit; i++) {
          var entry = rawKeyframes[i];
          var styles = entry[1];
          Object.keys(styles).forEach(function (prop) {
              if (!isPresent(firstKeyframeStyles[prop])) {
                  firstKeyframeStyles[prop] = FILL_STYLE_FLAG;
              }
          });
      }
      var _loop_1 = function() {
          var entry = rawKeyframes[i];
          var styles = entry[1];
          Object.keys(styles).forEach(function (prop) {
              if (!isPresent(lastKeyframeStyles[prop])) {
                  lastKeyframeStyles[prop] = styles[prop];
              }
          });
      };
      for (i = limit - 1; i >= 0; i--) {
          _loop_1();
      }
      return rawKeyframes.map(function (entry) { return new AnimationKeyframeAst(entry[0], new AnimationStylesAst([entry[1]])); });
  }
  function _parseTransitionAnimation(entry, currentTime, collectedStyles, stateStyles, errors) {
      var ast;
      var playTime = 0;
      var startingTime = currentTime;
      if (entry instanceof CompileAnimationWithStepsMetadata) {
          var maxDuration = 0;
          var steps = [];
          var isGroup = entry instanceof CompileAnimationGroupMetadata;
          var previousStyles;
          entry.steps.forEach(function (entry) {
              // these will get picked up by the next step...
              var time = isGroup ? startingTime : currentTime;
              if (entry instanceof CompileAnimationStyleMetadata) {
                  entry.styles.forEach(function (stylesEntry) {
                      // by this point we know that we only have stringmap values
                      var map = stylesEntry;
                      Object.keys(map).forEach(function (prop) { collectedStyles.insertAtTime(prop, time, map[prop]); });
                  });
                  previousStyles = entry.styles;
                  return;
              }
              var innerAst = _parseTransitionAnimation(entry, time, collectedStyles, stateStyles, errors);
              if (isPresent(previousStyles)) {
                  if (entry instanceof CompileAnimationWithStepsMetadata) {
                      var startingStyles = new AnimationStylesAst(previousStyles);
                      steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
                  }
                  else {
                      var innerStep = innerAst;
                      ListWrapper.addAll(innerStep.startingStyles.styles, previousStyles);
                  }
                  previousStyles = null;
              }
              var astDuration = innerAst.playTime;
              currentTime += astDuration;
              playTime += astDuration;
              maxDuration = Math$1.max(astDuration, maxDuration);
              steps.push(innerAst);
          });
          if (isPresent(previousStyles)) {
              var startingStyles = new AnimationStylesAst(previousStyles);
              steps.push(new AnimationStepAst(startingStyles, [], 0, 0, ''));
          }
          if (isGroup) {
              ast = new AnimationGroupAst(steps);
              playTime = maxDuration;
              currentTime = startingTime + playTime;
          }
          else {
              ast = new AnimationSequenceAst(steps);
          }
      }
      else if (entry instanceof CompileAnimationAnimateMetadata) {
          var timings = _parseTimeExpression(entry.timings, errors);
          var styles = entry.styles;
          var keyframes;
          if (styles instanceof CompileAnimationKeyframesSequenceMetadata) {
              keyframes =
                  _parseAnimationKeyframes(styles, currentTime, collectedStyles, stateStyles, errors);
          }
          else {
              var styleData = styles;
              var offset = _TERMINAL_KEYFRAME;
              var styleAst = new AnimationStylesAst(styleData.styles);
              var keyframe = new AnimationKeyframeAst(offset, styleAst);
              keyframes = [keyframe];
          }
          ast = new AnimationStepAst(new AnimationStylesAst([]), keyframes, timings.duration, timings.delay, timings.easing);
          playTime = timings.duration + timings.delay;
          currentTime += playTime;
          keyframes.forEach(function (keyframe /** TODO #9100 */) { return keyframe.styles.styles.forEach(function (entry /** TODO #9100 */) { return Object.keys(entry).forEach(function (prop) { collectedStyles.insertAtTime(prop, currentTime, entry[prop]); }); }); });
      }
      else {
          // if the code reaches this stage then an error
          // has already been populated within the _normalizeStyleSteps()
          // operation...
          ast = new AnimationStepAst(null, [], 0, 0, '');
      }
      ast.playTime = playTime;
      ast.startTime = startingTime;
      return ast;
  }
  function _fillAnimationAstStartingKeyframes(ast, collectedStyles, errors) {
      // steps that only contain style will not be filled
      if ((ast instanceof AnimationStepAst) && ast.keyframes.length > 0) {
          var keyframes = ast.keyframes;
          if (keyframes.length == 1) {
              var endKeyframe = keyframes[0];
              var startKeyframe = _createStartKeyframeFromEndKeyframe(endKeyframe, ast.startTime, ast.playTime, collectedStyles, errors);
              ast.keyframes = [startKeyframe, endKeyframe];
          }
      }
      else if (ast instanceof AnimationWithStepsAst) {
          ast.steps.forEach(function (entry) { return _fillAnimationAstStartingKeyframes(entry, collectedStyles, errors); });
      }
  }
  function _parseTimeExpression(exp, errors) {
      var regex = /^([\.\d]+)(m?s)(?:\s+([\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?/i;
      var duration;
      var delay = 0;
      var easing = null;
      if (isString(exp)) {
          var matches = exp.match(regex);
          if (matches === null) {
              errors.push(new AnimationParseError("The provided timing value \"" + exp + "\" is invalid."));
              return new _AnimationTimings(0, 0, null);
          }
          var durationMatch = parseFloat(matches[1]);
          var durationUnit = matches[2];
          if (durationUnit == 's') {
              durationMatch *= _ONE_SECOND;
          }
          duration = Math$1.floor(durationMatch);
          var delayMatch = matches[3];
          var delayUnit = matches[4];
          if (isPresent(delayMatch)) {
              var delayVal = parseFloat(delayMatch);
              if (isPresent(delayUnit) && delayUnit == 's') {
                  delayVal *= _ONE_SECOND;
              }
              delay = Math$1.floor(delayVal);
          }
          var easingVal = matches[5];
          if (!isBlank(easingVal)) {
              easing = easingVal;
          }
      }
      else {
          duration = exp;
      }
      return new _AnimationTimings(duration, delay, easing);
  }
  function _createStartKeyframeFromEndKeyframe(endKeyframe, startTime, duration, collectedStyles, errors) {
      var values = {};
      var endTime = startTime + duration;
      endKeyframe.styles.styles.forEach(function (styleData) {
          Object.keys(styleData).forEach(function (prop) {
              var val = styleData[prop];
              if (prop == 'offset')
                  return;
              var resultIndex = collectedStyles.indexOfAtOrBeforeTime(prop, startTime);
              var resultEntry /** TODO #9100 */, nextEntry /** TODO #9100 */, value;
              if (isPresent(resultIndex)) {
                  resultEntry = collectedStyles.getByIndex(prop, resultIndex);
                  value = resultEntry.value;
                  nextEntry = collectedStyles.getByIndex(prop, resultIndex + 1);
              }
              else {
                  // this is a flag that the runtime code uses to pass
                  // in a value either from the state declaration styles
                  // or using the AUTO_STYLE value (e.g. getComputedStyle)
                  value = FILL_STYLE_FLAG;
              }
              if (isPresent(nextEntry) && !nextEntry.matches(endTime, val)) {
                  errors.push(new AnimationParseError("The animated CSS property \"" + prop + "\" unexpectedly changes between steps \"" + resultEntry.time + "ms\" and \"" + endTime + "ms\" at \"" + nextEntry.time + "ms\""));
              }
              values[prop] = value;
          });
      });
      return new AnimationKeyframeAst(_INITIAL_KEYFRAME, new AnimationStylesAst([values]));
  }

  function convertValueToOutputAst(value, type) {
      if (type === void 0) { type = null; }
      return visitValue(value, new _ValueOutputAstTransformer(), type);
  }
  var _ValueOutputAstTransformer = (function () {
      function _ValueOutputAstTransformer() {
      }
      _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {
          var _this = this;
          return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);
      };
      _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {
          var _this = this;
          var entries = [];
          Object.keys(map).forEach(function (key) { entries.push([key, visitValue(map[key], _this, null)]); });
          return literalMap(entries, type);
      };
      _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };
      _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {
          if (value instanceof CompileIdentifierMetadata) {
              return importExpr(value);
          }
          else if (value instanceof Expression) {
              return value;
          }
          else {
              throw new Error("Illegal state: Don't now how to compile value " + value);
          }
      };
      return _ValueOutputAstTransformer;
  }());

  var _DebugState = (function () {
      function _DebugState(nodeIndex, sourceAst) {
          this.nodeIndex = nodeIndex;
          this.sourceAst = sourceAst;
      }
      return _DebugState;
  }());
  var NULL_DEBUG_STATE = new _DebugState(null, null);
  var CompileMethod = (function () {
      function CompileMethod(_view) {
          this._view = _view;
          this._newState = NULL_DEBUG_STATE;
          this._currState = NULL_DEBUG_STATE;
          this._bodyStatements = [];
          this._debugEnabled = this._view.genConfig.genDebugInfo;
      }
      CompileMethod.prototype._updateDebugContextIfNeeded = function () {
          if (this._newState.nodeIndex !== this._currState.nodeIndex ||
              this._newState.sourceAst !== this._currState.sourceAst) {
              var expr = this._updateDebugContext(this._newState);
              if (isPresent(expr)) {
                  this._bodyStatements.push(expr.toStmt());
              }
          }
      };
      CompileMethod.prototype._updateDebugContext = function (newState) {
          this._currState = this._newState = newState;
          if (this._debugEnabled) {
              var sourceLocation = isPresent(newState.sourceAst) ? newState.sourceAst.sourceSpan.start : null;
              return THIS_EXPR.callMethod('debug', [
                  literal(newState.nodeIndex),
                  isPresent(sourceLocation) ? literal(sourceLocation.line) : NULL_EXPR,
                  isPresent(sourceLocation) ? literal(sourceLocation.col) : NULL_EXPR
              ]);
          }
          else {
              return null;
          }
      };
      CompileMethod.prototype.resetDebugInfoExpr = function (nodeIndex, templateAst) {
          var res = this._updateDebugContext(new _DebugState(nodeIndex, templateAst));
          return isPresent(res) ? res : NULL_EXPR;
      };
      CompileMethod.prototype.resetDebugInfo = function (nodeIndex, templateAst) {
          this._newState = new _DebugState(nodeIndex, templateAst);
      };
      CompileMethod.prototype.addStmt = function (stmt) {
          this._updateDebugContextIfNeeded();
          this._bodyStatements.push(stmt);
      };
      CompileMethod.prototype.addStmts = function (stmts) {
          this._updateDebugContextIfNeeded();
          ListWrapper.addAll(this._bodyStatements, stmts);
      };
      CompileMethod.prototype.finish = function () { return this._bodyStatements; };
      CompileMethod.prototype.isEmpty = function () { return this._bodyStatements.length === 0; };
      return CompileMethod;
  }());

  function getPropertyInView(property, callingView, definedView) {
      if (callingView === definedView) {
          return property;
      }
      else {
          var viewProp = THIS_EXPR;
          var currView = callingView;
          while (currView !== definedView && isPresent(currView.declarationElement.view)) {
              currView = currView.declarationElement.view;
              viewProp = viewProp.prop('parent');
          }
          if (currView !== definedView) {
              throw new Error("Internal error: Could not calculate a property in a parent view: " + property);
          }
          if (property instanceof ReadPropExpr) {
              var readPropExpr_1 = property;
              // Note: Don't cast for members of the AppView base class...
              if (definedView.fields.some(function (field) { return field.name == readPropExpr_1.name; }) ||
                  definedView.getters.some(function (field) { return field.name == readPropExpr_1.name; })) {
                  viewProp = viewProp.cast(definedView.classType);
              }
          }
          return replaceVarInExpression(THIS_EXPR.name, viewProp, property);
      }
  }
  function injectFromViewParentInjector(token, optional) {
      var args = [createDiTokenExpression(token)];
      if (optional) {
          args.push(NULL_EXPR);
      }
      return THIS_EXPR.prop('parentInjector').callMethod('get', args);
  }
  function getViewFactoryName(component, embeddedTemplateIndex) {
      return "viewFactory_" + component.type.name + embeddedTemplateIndex;
  }
  function createFlatArray(expressions) {
      var lastNonArrayExpressions = [];
      var result = literalArr([]);
      for (var i = 0; i < expressions.length; i++) {
          var expr = expressions[i];
          if (expr.type instanceof ArrayType) {
              if (lastNonArrayExpressions.length > 0) {
                  result =
                      result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
                  lastNonArrayExpressions = [];
              }
              result = result.callMethod(BuiltinMethod.ConcatArray, [expr]);
          }
          else {
              lastNonArrayExpressions.push(expr);
          }
      }
      if (lastNonArrayExpressions.length > 0) {
          result =
              result.callMethod(BuiltinMethod.ConcatArray, [literalArr(lastNonArrayExpressions)]);
      }
      return result;
  }
  function createPureProxy(fn, argCount, pureProxyProp, view) {
      view.fields.push(new ClassField(pureProxyProp.name, null));
      var pureProxyId = argCount < Identifiers.pureProxies.length ? Identifiers.pureProxies[argCount] : null;
      if (!pureProxyId) {
          throw new Error("Unsupported number of argument for pure functions: " + argCount);
      }
      view.createMethod.addStmt(THIS_EXPR.prop(pureProxyProp.name)
          .set(importExpr(resolveIdentifier(pureProxyId)).callFn([fn]))
          .toStmt());
  }

  var ViewQueryValues = (function () {
      function ViewQueryValues(view, values) {
          this.view = view;
          this.values = values;
      }
      return ViewQueryValues;
  }());
  var CompileQuery = (function () {
      function CompileQuery(meta, queryList, ownerDirectiveExpression, view) {
          this.meta = meta;
          this.queryList = queryList;
          this.ownerDirectiveExpression = ownerDirectiveExpression;
          this.view = view;
          this._values = new ViewQueryValues(view, []);
      }
      CompileQuery.prototype.addValue = function (value, view) {
          var currentView = view;
          var elPath = [];
          while (isPresent(currentView) && currentView !== this.view) {
              var parentEl = currentView.declarationElement;
              elPath.unshift(parentEl);
              currentView = parentEl.view;
          }
          var queryListForDirtyExpr = getPropertyInView(this.queryList, view, this.view);
          var viewValues = this._values;
          elPath.forEach(function (el) {
              var last = viewValues.values.length > 0 ? viewValues.values[viewValues.values.length - 1] : null;
              if (last instanceof ViewQueryValues && last.view === el.embeddedView) {
                  viewValues = last;
              }
              else {
                  var newViewValues = new ViewQueryValues(el.embeddedView, []);
                  viewValues.values.push(newViewValues);
                  viewValues = newViewValues;
              }
          });
          viewValues.values.push(value);
          if (elPath.length > 0) {
              view.dirtyParentQueriesMethod.addStmt(queryListForDirtyExpr.callMethod('setDirty', []).toStmt());
          }
      };
      CompileQuery.prototype._isStatic = function () {
          return !this._values.values.some(function (value) { return value instanceof ViewQueryValues; });
      };
      CompileQuery.prototype.afterChildren = function (targetStaticMethod /** TODO #9100 */, targetDynamicMethod) {
          var values = createQueryValues(this._values);
          var updateStmts = [this.queryList.callMethod('reset', [literalArr(values)]).toStmt()];
          if (isPresent(this.ownerDirectiveExpression)) {
              var valueExpr = this.meta.first ? this.queryList.prop('first') : this.queryList;
              updateStmts.push(this.ownerDirectiveExpression.prop(this.meta.propertyName).set(valueExpr).toStmt());
          }
          if (!this.meta.first) {
              updateStmts.push(this.queryList.callMethod('notifyOnChanges', []).toStmt());
          }
          if (this.meta.first && this._isStatic()) {
              // for queries that don't change and the user asked for a single element,
              // set it immediately. That is e.g. needed for querying for ViewContainerRefs, ...
              // we don't do this for QueryLists for now as this would break the timing when
              // we call QueryList listeners...
              targetStaticMethod.addStmts(updateStmts);
          }
          else {
              targetDynamicMethod.addStmt(new IfStmt(this.queryList.prop('dirty'), updateStmts));
          }
      };
      return CompileQuery;
  }());
  function createQueryValues(viewValues) {
      return ListWrapper.flatten(viewValues.values.map(function (entry) {
          if (entry instanceof ViewQueryValues) {
              return mapNestedViews(entry.view.declarationElement.appElement, entry.view, createQueryValues(entry));
          }
          else {
              return entry;
          }
      }));
  }
  function mapNestedViews(declarationAppElement, view, expressions) {
      var adjustedExpressions = expressions.map(function (expr) { return replaceVarInExpression(THIS_EXPR.name, variable('nestedView'), expr); });
      return declarationAppElement.callMethod('mapNestedViews', [
          variable(view.className),
          fn([new FnParam('nestedView', view.classType)], [new ReturnStatement(literalArr(adjustedExpressions))], DYNAMIC_TYPE)
      ]);
  }
  function createQueryList(query, directiveInstance, propertyName, compileView) {
      compileView.fields.push(new ClassField(propertyName, importType(resolveIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE])));
      var expr = THIS_EXPR.prop(propertyName);
      compileView.createMethod.addStmt(THIS_EXPR.prop(propertyName)
          .set(importExpr(resolveIdentifier(Identifiers.QueryList), [DYNAMIC_TYPE])
          .instantiate([]))
          .toStmt());
      return expr;
  }
  function addQueryToTokenMap(map, query) {
      query.meta.selectors.forEach(function (selector) {
          var entry = map.get(selector.reference);
          if (!entry) {
              entry = [];
              map.set(selector.reference, entry);
          }
          entry.push(query);
      });
  }

  function _enumExpression(classIdentifier, name) {
      return importExpr(resolveEnumIdentifier(classIdentifier, name));
  }
  var ViewTypeEnum = (function () {
      function ViewTypeEnum() {
      }
      ViewTypeEnum.fromValue = function (value) {
          var viewType = resolveIdentifier(Identifiers.ViewType);
          switch (value) {
              case ViewType.HOST:
                  return _enumExpression(viewType, 'HOST');
              case ViewType.COMPONENT:
                  return _enumExpression(viewType, 'COMPONENT');
              case ViewType.EMBEDDED:
                  return _enumExpression(viewType, 'EMBEDDED');
              default:
                  throw Error("Inavlid ViewType value: " + value);
          }
      };
      return ViewTypeEnum;
  }());
  var ViewEncapsulationEnum = (function () {
      function ViewEncapsulationEnum() {
      }
      ViewEncapsulationEnum.fromValue = function (value) {
          var viewEncapsulation = resolveIdentifier(Identifiers.ViewEncapsulation);
          switch (value) {
              case _angular_core.ViewEncapsulation.Emulated:
                  return _enumExpression(viewEncapsulation, 'Emulated');
              case _angular_core.ViewEncapsulation.Native:
                  return _enumExpression(viewEncapsulation, 'Native');
              case _angular_core.ViewEncapsulation.None:
                  return _enumExpression(viewEncapsulation, 'None');
              default:
                  throw Error("Inavlid ViewEncapsulation value: " + value);
          }
      };
      return ViewEncapsulationEnum;
  }());
  var ChangeDetectorStatusEnum = (function () {
      function ChangeDetectorStatusEnum() {
      }
      ChangeDetectorStatusEnum.fromValue = function (value) {
          var changeDetectorStatus = resolveIdentifier(Identifiers.ChangeDetectorStatus);
          switch (value) {
              case ChangeDetectorStatus.CheckOnce:
                  return _enumExpression(changeDetectorStatus, 'CheckOnce');
              case ChangeDetectorStatus.Checked:
                  return _enumExpression(changeDetectorStatus, 'Checked');
              case ChangeDetectorStatus.CheckAlways:
                  return _enumExpression(changeDetectorStatus, 'CheckAlways');
              case ChangeDetectorStatus.Detached:
                  return _enumExpression(changeDetectorStatus, 'Detached');
              case ChangeDetectorStatus.Errored:
                  return _enumExpression(changeDetectorStatus, 'Errored');
              case ChangeDetectorStatus.Destroyed:
                  return _enumExpression(changeDetectorStatus, 'Destroyed');
              default:
                  throw Error("Inavlid ChangeDetectorStatus value: " + value);
          }
      };
      return ChangeDetectorStatusEnum;
  }());
  var ViewConstructorVars = (function () {
      function ViewConstructorVars() {
      }
      ViewConstructorVars.viewUtils = variable('viewUtils');
      ViewConstructorVars.parentInjector = variable('parentInjector');
      ViewConstructorVars.declarationEl = variable('declarationEl');
      return ViewConstructorVars;
  }());
  var ViewProperties = (function () {
      function ViewProperties() {
      }
      ViewProperties.renderer = THIS_EXPR.prop('renderer');
      ViewProperties.projectableNodes = THIS_EXPR.prop('projectableNodes');
      ViewProperties.viewUtils = THIS_EXPR.prop('viewUtils');
      return ViewProperties;
  }());
  var EventHandlerVars = (function () {
      function EventHandlerVars() {
      }
      EventHandlerVars.event = variable('$event');
      return EventHandlerVars;
  }());
  var InjectMethodVars = (function () {
      function InjectMethodVars() {
      }
      InjectMethodVars.token = variable('token');
      InjectMethodVars.requestNodeIndex = variable('requestNodeIndex');
      InjectMethodVars.notFoundResult = variable('notFoundResult');
      return InjectMethodVars;
  }());
  var DetectChangesVars = (function () {
      function DetectChangesVars() {
      }
      DetectChangesVars.throwOnChange = variable("throwOnChange");
      DetectChangesVars.changes = variable("changes");
      DetectChangesVars.changed = variable("changed");
      DetectChangesVars.valUnwrapper = variable("valUnwrapper");
      return DetectChangesVars;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$14 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var CompileNode = (function () {
      function CompileNode(parent, view, nodeIndex, renderNode, sourceAst) {
          this.parent = parent;
          this.view = view;
          this.nodeIndex = nodeIndex;
          this.renderNode = renderNode;
          this.sourceAst = sourceAst;
      }
      CompileNode.prototype.isNull = function () { return !this.renderNode; };
      CompileNode.prototype.isRootElement = function () { return this.view != this.parent.view; };
      return CompileNode;
  }());
  var CompileElement = (function (_super) {
      __extends$14(CompileElement, _super);
      function CompileElement(parent, view, nodeIndex, renderNode, sourceAst, component, _directives, _resolvedProvidersArray, hasViewContainer, hasEmbeddedView, references) {
          var _this = this;
          _super.call(this, parent, view, nodeIndex, renderNode, sourceAst);
          this.component = component;
          this._directives = _directives;
          this._resolvedProvidersArray = _resolvedProvidersArray;
          this.hasViewContainer = hasViewContainer;
          this.hasEmbeddedView = hasEmbeddedView;
          this._compViewExpr = null;
          this.instances = new Map();
          this._queryCount = 0;
          this._queries = new Map();
          this._componentConstructorViewQueryLists = [];
          this.contentNodesByNgContentIndex = null;
          this.referenceTokens = {};
          references.forEach(function (ref) { return _this.referenceTokens[ref.name] = ref.value; });
          this.elementRef =
              importExpr(resolveIdentifier(Identifiers.ElementRef)).instantiate([this.renderNode]);
          this.instances.set(resolveIdentifierToken(Identifiers.ElementRef).reference, this.elementRef);
          this.injector = THIS_EXPR.callMethod('injector', [literal(this.nodeIndex)]);
          this.instances.set(resolveIdentifierToken(Identifiers.Injector).reference, this.injector);
          this.instances.set(resolveIdentifierToken(Identifiers.Renderer).reference, THIS_EXPR.prop('renderer'));
          if (this.hasViewContainer || this.hasEmbeddedView || isPresent(this.component)) {
              this._createAppElement();
          }
      }
      CompileElement.createNull = function () {
          return new CompileElement(null, null, null, null, null, null, [], [], false, false, []);
      };
      CompileElement.prototype._createAppElement = function () {
          var fieldName = "_appEl_" + this.nodeIndex;
          var parentNodeIndex = this.isRootElement() ? null : this.parent.nodeIndex;
          // private is fine here as no child view will reference an AppElement
          this.view.fields.push(new ClassField(fieldName, importType(resolveIdentifier(Identifiers.AppElement)), [StmtModifier.Private]));
          var statement = THIS_EXPR.prop(fieldName)
              .set(importExpr(resolveIdentifier(Identifiers.AppElement)).instantiate([
              literal(this.nodeIndex), literal(parentNodeIndex), THIS_EXPR, this.renderNode
          ]))
              .toStmt();
          this.view.createMethod.addStmt(statement);
          this.appElement = THIS_EXPR.prop(fieldName);
          this.instances.set(resolveIdentifierToken(Identifiers.AppElement).reference, this.appElement);
      };
      CompileElement.prototype.createComponentFactoryResolver = function (entryComponents) {
          if (!entryComponents || entryComponents.length === 0) {
              return;
          }
          var createComponentFactoryResolverExpr = importExpr(resolveIdentifier(Identifiers.CodegenComponentFactoryResolver)).instantiate([
              literalArr(entryComponents.map(function (entryComponent) { return importExpr(entryComponent); })),
              injectFromViewParentInjector(resolveIdentifierToken(Identifiers.ComponentFactoryResolver), false)
          ]);
          var provider = new CompileProviderMetadata({
              token: resolveIdentifierToken(Identifiers.ComponentFactoryResolver),
              useValue: createComponentFactoryResolverExpr
          });
          // Add ComponentFactoryResolver as first provider as it does not have deps on other providers
          // ProviderAstType.PrivateService as only the component and its view can see it,
          // but nobody else
          this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], exports.ProviderAstType.PrivateService, [], this.sourceAst.sourceSpan));
      };
      CompileElement.prototype.setComponentView = function (compViewExpr) {
          this._compViewExpr = compViewExpr;
          this.contentNodesByNgContentIndex =
              new Array(this.component.template.ngContentSelectors.length);
          for (var i = 0; i < this.contentNodesByNgContentIndex.length; i++) {
              this.contentNodesByNgContentIndex[i] = [];
          }
      };
      CompileElement.prototype.setEmbeddedView = function (embeddedView) {
          this.embeddedView = embeddedView;
          if (isPresent(embeddedView)) {
              var createTemplateRefExpr = importExpr(resolveIdentifier(Identifiers.TemplateRef_)).instantiate([
                  this.appElement, this.embeddedView.viewFactory
              ]);
              var provider = new CompileProviderMetadata({
                  token: resolveIdentifierToken(Identifiers.TemplateRef),
                  useValue: createTemplateRefExpr
              });
              // Add TemplateRef as first provider as it does not have deps on other providers
              this._resolvedProvidersArray.unshift(new ProviderAst(provider.token, false, true, [provider], exports.ProviderAstType.Builtin, [], this.sourceAst.sourceSpan));
          }
      };
      CompileElement.prototype.beforeChildren = function () {
          var _this = this;
          if (this.hasViewContainer) {
              this.instances.set(resolveIdentifierToken(Identifiers.ViewContainerRef).reference, this.appElement.prop('vcRef'));
          }
          this._resolvedProviders = new Map();
          this._resolvedProvidersArray.forEach(function (provider) { return _this._resolvedProviders.set(provider.token.reference, provider); });
          // create all the provider instances, some in the view constructor,
          // some as getters. We rely on the fact that they are already sorted topologically.
          MapWrapper.values(this._resolvedProviders).forEach(function (resolvedProvider) {
              var providerValueExpressions = resolvedProvider.providers.map(function (provider) {
                  if (isPresent(provider.useExisting)) {
                      return _this._getDependency(resolvedProvider.providerType, new CompileDiDependencyMetadata({ token: provider.useExisting }));
                  }
                  else if (isPresent(provider.useFactory)) {
                      var deps = isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
                      var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
                      return importExpr(provider.useFactory).callFn(depsExpr);
                  }
                  else if (isPresent(provider.useClass)) {
                      var deps = isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
                      var depsExpr = deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep); });
                      return importExpr(provider.useClass)
                          .instantiate(depsExpr, importType(provider.useClass));
                  }
                  else {
                      return convertValueToOutputAst(provider.useValue);
                  }
              });
              var propName = "_" + resolvedProvider.token.name + "_" + _this.nodeIndex + "_" + _this.instances.size;
              var instance = createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager, _this);
              _this.instances.set(resolvedProvider.token.reference, instance);
          });
          for (var i = 0; i < this._directives.length; i++) {
              var directive = this._directives[i];
              var directiveInstance = this.instances.get(identifierToken(directive.type).reference);
              directive.queries.forEach(function (queryMeta) { _this._addQuery(queryMeta, directiveInstance); });
          }
          var queriesWithReads = [];
          MapWrapper.values(this._resolvedProviders).forEach(function (resolvedProvider) {
              var queriesForProvider = _this._getQueriesFor(resolvedProvider.token);
              ListWrapper.addAll(queriesWithReads, queriesForProvider.map(function (query) { return new _QueryWithRead(query, resolvedProvider.token); }));
          });
          Object.keys(this.referenceTokens).forEach(function (varName) {
              var token = _this.referenceTokens[varName];
              var varValue;
              if (isPresent(token)) {
                  varValue = _this.instances.get(token.reference);
              }
              else {
                  varValue = _this.renderNode;
              }
              _this.view.locals.set(varName, varValue);
              var varToken = new CompileTokenMetadata({ value: varName });
              ListWrapper.addAll(queriesWithReads, _this._getQueriesFor(varToken).map(function (query) { return new _QueryWithRead(query, varToken); }));
          });
          queriesWithReads.forEach(function (queryWithRead) {
              var value;
              if (isPresent(queryWithRead.read.identifier)) {
                  // query for an identifier
                  value = _this.instances.get(queryWithRead.read.reference);
              }
              else {
                  // query for a reference
                  var token = _this.referenceTokens[queryWithRead.read.value];
                  if (isPresent(token)) {
                      value = _this.instances.get(token.reference);
                  }
                  else {
                      value = _this.elementRef;
                  }
              }
              if (isPresent(value)) {
                  queryWithRead.query.addValue(value, _this.view);
              }
          });
          if (isPresent(this.component)) {
              var componentConstructorViewQueryList = isPresent(this.component) ?
                  literalArr(this._componentConstructorViewQueryLists) :
                  NULL_EXPR;
              var compExpr = isPresent(this.getComponent()) ? this.getComponent() : NULL_EXPR;
              this.view.createMethod.addStmt(this.appElement
                  .callMethod('initComponent', [compExpr, componentConstructorViewQueryList, this._compViewExpr])
                  .toStmt());
          }
      };
      CompileElement.prototype.afterChildren = function (childNodeCount) {
          var _this = this;
          MapWrapper.values(this._resolvedProviders).forEach(function (resolvedProvider) {
              // Note: afterChildren is called after recursing into children.
              // This is good so that an injector match in an element that is closer to a requesting element
              // matches first.
              var providerExpr = _this.instances.get(resolvedProvider.token.reference);
              // Note: view providers are only visible on the injector of that element.
              // This is not fully correct as the rules during codegen don't allow a directive
              // to get hold of a view provdier on the same element. We still do this semantic
              // as it simplifies our model to having only one runtime injector per element.
              var providerChildNodeCount = resolvedProvider.providerType === exports.ProviderAstType.PrivateService ? 0 : childNodeCount;
              _this.view.injectorGetMethod.addStmt(createInjectInternalCondition(_this.nodeIndex, providerChildNodeCount, resolvedProvider, providerExpr));
          });
          MapWrapper.values(this._queries)
              .forEach(function (queries) { return queries.forEach(function (query) { return query.afterChildren(_this.view.createMethod, _this.view.updateContentQueriesMethod); }); });
      };
      CompileElement.prototype.addContentNode = function (ngContentIndex, nodeExpr) {
          this.contentNodesByNgContentIndex[ngContentIndex].push(nodeExpr);
      };
      CompileElement.prototype.getComponent = function () {
          return isPresent(this.component) ?
              this.instances.get(identifierToken(this.component.type).reference) :
              null;
      };
      CompileElement.prototype.getProviderTokens = function () {
          return MapWrapper.values(this._resolvedProviders)
              .map(function (resolvedProvider) { return createDiTokenExpression(resolvedProvider.token); });
      };
      CompileElement.prototype._getQueriesFor = function (token) {
          var result = [];
          var currentEl = this;
          var distance = 0;
          var queries;
          while (!currentEl.isNull()) {
              queries = currentEl._queries.get(token.reference);
              if (isPresent(queries)) {
                  ListWrapper.addAll(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));
              }
              if (currentEl._directives.length > 0) {
                  distance++;
              }
              currentEl = currentEl.parent;
          }
          queries = this.view.componentView.viewQueries.get(token.reference);
          if (isPresent(queries)) {
              ListWrapper.addAll(result, queries);
          }
          return result;
      };
      CompileElement.prototype._addQuery = function (queryMeta, directiveInstance) {
          var propName = "_query_" + queryMeta.selectors[0].name + "_" + this.nodeIndex + "_" + this._queryCount++;
          var queryList = createQueryList(queryMeta, directiveInstance, propName, this.view);
          var query = new CompileQuery(queryMeta, queryList, directiveInstance, this.view);
          addQueryToTokenMap(this._queries, query);
          return query;
      };
      CompileElement.prototype._getLocalDependency = function (requestingProviderType, dep) {
          var result = null;
          // constructor content query
          if (!result && isPresent(dep.query)) {
              result = this._addQuery(dep.query, null).queryList;
          }
          // constructor view query
          if (!result && isPresent(dep.viewQuery)) {
              result = createQueryList(dep.viewQuery, null, "_viewQuery_" + dep.viewQuery.selectors[0].name + "_" + this.nodeIndex + "_" + this._componentConstructorViewQueryLists.length, this.view);
              this._componentConstructorViewQueryLists.push(result);
          }
          if (isPresent(dep.token)) {
              // access builtins with special visibility
              if (!result) {
                  if (dep.token.reference ===
                      resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference) {
                      if (requestingProviderType === exports.ProviderAstType.Component) {
                          return this._compViewExpr.prop('ref');
                      }
                      else {
                          return getPropertyInView(THIS_EXPR.prop('ref'), this.view, this.view.componentView);
                      }
                  }
              }
              // access regular providers on the element
              if (!result) {
                  var resolvedProvider = this._resolvedProviders.get(dep.token.reference);
                  // don't allow directives / public services to access private services.
                  // only components and private services can access private services.
                  if (resolvedProvider && (requestingProviderType === exports.ProviderAstType.Directive ||
                      requestingProviderType === exports.ProviderAstType.PublicService) &&
                      resolvedProvider.providerType === exports.ProviderAstType.PrivateService) {
                      return null;
                  }
                  result = this.instances.get(dep.token.reference);
              }
          }
          return result;
      };
      CompileElement.prototype._getDependency = function (requestingProviderType, dep) {
          var currElement = this;
          var result = null;
          if (dep.isValue) {
              result = literal(dep.value);
          }
          if (!result && !dep.isSkipSelf) {
              result = this._getLocalDependency(requestingProviderType, dep);
          }
          // check parent elements
          while (!result && !currElement.parent.isNull()) {
              currElement = currElement.parent;
              result = currElement._getLocalDependency(exports.ProviderAstType.PublicService, new CompileDiDependencyMetadata({ token: dep.token }));
          }
          if (!result) {
              result = injectFromViewParentInjector(dep.token, dep.isOptional);
          }
          if (!result) {
              result = NULL_EXPR;
          }
          return getPropertyInView(result, this.view, currElement.view);
      };
      return CompileElement;
  }(CompileNode));
  function createInjectInternalCondition(nodeIndex, childNodeCount, provider, providerExpr) {
      var indexCondition;
      if (childNodeCount > 0) {
          indexCondition = literal(nodeIndex)
              .lowerEquals(InjectMethodVars.requestNodeIndex)
              .and(InjectMethodVars.requestNodeIndex.lowerEquals(literal(nodeIndex + childNodeCount)));
      }
      else {
          indexCondition = literal(nodeIndex).identical(InjectMethodVars.requestNodeIndex);
      }
      return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(provider.token)).and(indexCondition), [new ReturnStatement(providerExpr)]);
  }
  function createProviderProperty(propName, provider, providerValueExpressions, isMulti, isEager, compileElement) {
      var view = compileElement.view;
      var resolvedProviderValueExpr;
      var type;
      if (isMulti) {
          resolvedProviderValueExpr = literalArr(providerValueExpressions);
          type = new ArrayType(DYNAMIC_TYPE);
      }
      else {
          resolvedProviderValueExpr = providerValueExpressions[0];
          type = providerValueExpressions[0].type;
      }
      if (!type) {
          type = DYNAMIC_TYPE;
      }
      if (isEager) {
          view.fields.push(new ClassField(propName, type));
          view.createMethod.addStmt(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
      }
      else {
          var internalField = "_" + propName;
          view.fields.push(new ClassField(internalField, type));
          var getter = new CompileMethod(view);
          getter.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
          // Note: Equals is important for JS so that it also checks the undefined case!
          getter.addStmt(new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]));
          getter.addStmt(new ReturnStatement(THIS_EXPR.prop(internalField)));
          view.getters.push(new ClassGetter(propName, getter.finish(), type));
      }
      return THIS_EXPR.prop(propName);
  }
  var _QueryWithRead = (function () {
      function _QueryWithRead(query, match) {
          this.query = query;
          this.read = isPresent(query.meta.read) ? query.meta.read : match;
      }
      return _QueryWithRead;
  }());

  var CompilePipe = (function () {
      function CompilePipe(view, meta) {
          var _this = this;
          this.view = view;
          this.meta = meta;
          this._purePipeProxyCount = 0;
          this.instance = THIS_EXPR.prop("_pipe_" + meta.name + "_" + view.pipeCount++);
          var deps = this.meta.type.diDeps.map(function (diDep) {
              if (diDep.token.reference ===
                  resolveIdentifierToken(Identifiers.ChangeDetectorRef).reference) {
                  return getPropertyInView(THIS_EXPR.prop('ref'), _this.view, _this.view.componentView);
              }
              return injectFromViewParentInjector(diDep.token, false);
          });
          this.view.fields.push(new ClassField(this.instance.name, importType(this.meta.type)));
          this.view.createMethod.resetDebugInfo(null, null);
          this.view.createMethod.addStmt(THIS_EXPR.prop(this.instance.name)
              .set(importExpr(this.meta.type).instantiate(deps))
              .toStmt());
      }
      CompilePipe.call = function (view, name, args) {
          var compView = view.componentView;
          var meta = _findPipeMeta(compView, name);
          var pipe;
          if (meta.pure) {
              // pure pipes live on the component view
              pipe = compView.purePipes.get(name);
              if (!pipe) {
                  pipe = new CompilePipe(compView, meta);
                  compView.purePipes.set(name, pipe);
                  compView.pipes.push(pipe);
              }
          }
          else {
              // Non pure pipes live on the view that called it
              pipe = new CompilePipe(view, meta);
              view.pipes.push(pipe);
          }
          return pipe._call(view, args);
      };
      Object.defineProperty(CompilePipe.prototype, "pure", {
          get: function () { return this.meta.pure; },
          enumerable: true,
          configurable: true
      });
      CompilePipe.prototype._call = function (callingView, args) {
          if (this.meta.pure) {
              // PurePipeProxies live on the view that called them.
              var purePipeProxyInstance = THIS_EXPR.prop(this.instance.name + "_" + this._purePipeProxyCount++);
              var pipeInstanceSeenFromPureProxy = getPropertyInView(this.instance, callingView, this.view);
              createPureProxy(pipeInstanceSeenFromPureProxy.prop('transform')
                  .callMethod(BuiltinMethod.Bind, [pipeInstanceSeenFromPureProxy]), args.length, purePipeProxyInstance, callingView);
              return importExpr(resolveIdentifier(Identifiers.castByValue))
                  .callFn([purePipeProxyInstance, pipeInstanceSeenFromPureProxy.prop('transform')])
                  .callFn(args);
          }
          else {
              return getPropertyInView(this.instance, callingView, this.view).callMethod('transform', args);
          }
      };
      return CompilePipe;
  }());
  function _findPipeMeta(view, name) {
      var pipeMeta = null;
      for (var i = view.pipeMetas.length - 1; i >= 0; i--) {
          var localPipeMeta = view.pipeMetas[i];
          if (localPipeMeta.name == name) {
              pipeMeta = localPipeMeta;
              break;
          }
      }
      if (!pipeMeta) {
          throw new Error("Illegal state: Could not find pipe " + name + " although the parser should have detected this error!");
      }
      return pipeMeta;
  }

  var CompileView = (function () {
      function CompileView(component, genConfig, pipeMetas, styles, animations, viewIndex, declarationElement, templateVariableBindings) {
          var _this = this;
          this.component = component;
          this.genConfig = genConfig;
          this.pipeMetas = pipeMetas;
          this.styles = styles;
          this.animations = animations;
          this.viewIndex = viewIndex;
          this.declarationElement = declarationElement;
          this.templateVariableBindings = templateVariableBindings;
          this.nodes = [];
          // root nodes or AppElements for ViewContainers
          this.rootNodesOrAppElements = [];
          this.bindings = [];
          this.classStatements = [];
          this.eventHandlerMethods = [];
          this.fields = [];
          this.getters = [];
          this.disposables = [];
          this.subscriptions = [];
          this.purePipes = new Map();
          this.pipes = [];
          this.locals = new Map();
          this.literalArrayCount = 0;
          this.literalMapCount = 0;
          this.pipeCount = 0;
          this.createMethod = new CompileMethod(this);
          this.animationBindingsMethod = new CompileMethod(this);
          this.injectorGetMethod = new CompileMethod(this);
          this.updateContentQueriesMethod = new CompileMethod(this);
          this.dirtyParentQueriesMethod = new CompileMethod(this);
          this.updateViewQueriesMethod = new CompileMethod(this);
          this.detectChangesInInputsMethod = new CompileMethod(this);
          this.detectChangesRenderPropertiesMethod = new CompileMethod(this);
          this.afterContentLifecycleCallbacksMethod = new CompileMethod(this);
          this.afterViewLifecycleCallbacksMethod = new CompileMethod(this);
          this.destroyMethod = new CompileMethod(this);
          this.detachMethod = new CompileMethod(this);
          this.viewType = getViewType(component, viewIndex);
          this.className = "_View_" + component.type.name + viewIndex;
          this.classType = importType(new CompileIdentifierMetadata({ name: this.className }));
          this.viewFactory = variable(getViewFactoryName(component, viewIndex));
          if (this.viewType === ViewType.COMPONENT || this.viewType === ViewType.HOST) {
              this.componentView = this;
          }
          else {
              this.componentView = this.declarationElement.view.componentView;
          }
          this.componentContext =
              getPropertyInView(THIS_EXPR.prop('context'), this, this.componentView);
          var viewQueries = new Map();
          if (this.viewType === ViewType.COMPONENT) {
              var directiveInstance = THIS_EXPR.prop('context');
              ListWrapper.forEachWithIndex(this.component.viewQueries, function (queryMeta, queryIndex) {
                  var propName = "_viewQuery_" + queryMeta.selectors[0].name + "_" + queryIndex;
                  var queryList = createQueryList(queryMeta, directiveInstance, propName, _this);
                  var query = new CompileQuery(queryMeta, queryList, directiveInstance, _this);
                  addQueryToTokenMap(viewQueries, query);
              });
              var constructorViewQueryCount = 0;
              this.component.type.diDeps.forEach(function (dep) {
                  if (isPresent(dep.viewQuery)) {
                      var queryList = THIS_EXPR.prop('declarationAppElement')
                          .prop('componentConstructorViewQueries')
                          .key(literal(constructorViewQueryCount++));
                      var query = new CompileQuery(dep.viewQuery, queryList, null, _this);
                      addQueryToTokenMap(viewQueries, query);
                  }
              });
          }
          this.viewQueries = viewQueries;
          templateVariableBindings.forEach(function (entry) { _this.locals.set(entry[1], THIS_EXPR.prop('context').prop(entry[0])); });
          if (!this.declarationElement.isNull()) {
              this.declarationElement.setEmbeddedView(this);
          }
      }
      CompileView.prototype.callPipe = function (name, input, args) {
          return CompilePipe.call(this, name, [input].concat(args));
      };
      CompileView.prototype.getLocal = function (name) {
          if (name == EventHandlerVars.event.name) {
              return EventHandlerVars.event;
          }
          var currView = this;
          var result = currView.locals.get(name);
          while (!result && isPresent(currView.declarationElement.view)) {
              currView = currView.declarationElement.view;
              result = currView.locals.get(name);
          }
          if (isPresent(result)) {
              return getPropertyInView(result, this, currView);
          }
          else {
              return null;
          }
      };
      CompileView.prototype.createLiteralArray = function (values) {
          if (values.length === 0) {
              return importExpr(resolveIdentifier(Identifiers.EMPTY_ARRAY));
          }
          var proxyExpr = THIS_EXPR.prop("_arr_" + this.literalArrayCount++);
          var proxyParams = [];
          var proxyReturnEntries = [];
          for (var i = 0; i < values.length; i++) {
              var paramName = "p" + i;
              proxyParams.push(new FnParam(paramName));
              proxyReturnEntries.push(variable(paramName));
          }
          createPureProxy(fn(proxyParams, [new ReturnStatement(literalArr(proxyReturnEntries))], new ArrayType(DYNAMIC_TYPE)), values.length, proxyExpr, this);
          return proxyExpr.callFn(values);
      };
      CompileView.prototype.createLiteralMap = function (entries) {
          if (entries.length === 0) {
              return importExpr(resolveIdentifier(Identifiers.EMPTY_MAP));
          }
          var proxyExpr = THIS_EXPR.prop("_map_" + this.literalMapCount++);
          var proxyParams = [];
          var proxyReturnEntries = [];
          var values = [];
          for (var i = 0; i < entries.length; i++) {
              var paramName = "p" + i;
              proxyParams.push(new FnParam(paramName));
              proxyReturnEntries.push([entries[i][0], variable(paramName)]);
              values.push(entries[i][1]);
          }
          createPureProxy(fn(proxyParams, [new ReturnStatement(literalMap(proxyReturnEntries))], new MapType(DYNAMIC_TYPE)), entries.length, proxyExpr, this);
          return proxyExpr.callFn(values);
      };
      CompileView.prototype.afterNodes = function () {
          var _this = this;
          MapWrapper.values(this.viewQueries)
              .forEach(function (queries) { return queries.forEach(function (query) { return query.afterChildren(_this.createMethod, _this.updateViewQueriesMethod); }); });
      };
      return CompileView;
  }());
  function getViewType(component, embeddedTemplateIndex) {
      if (embeddedTemplateIndex > 0) {
          return ViewType.EMBEDDED;
      }
      else if (component.type.isHost) {
          return ViewType.HOST;
      }
      else {
          return ViewType.COMPONENT;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var CompileBinding = (function () {
      function CompileBinding(node, sourceAst) {
          this.node = node;
          this.sourceAst = sourceAst;
      }
      return CompileBinding;
  }());

  var ExpressionWithWrappedValueInfo = (function () {
      function ExpressionWithWrappedValueInfo(expression, needsValueUnwrapper, temporaryCount) {
          this.expression = expression;
          this.needsValueUnwrapper = needsValueUnwrapper;
          this.temporaryCount = temporaryCount;
      }
      return ExpressionWithWrappedValueInfo;
  }());
  function convertCdExpressionToIr(nameResolver, implicitReceiver, expression, valueUnwrapper, bindingIndex) {
      var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, valueUnwrapper, bindingIndex);
      var irAst = expression.visit(visitor, _Mode.Expression);
      return new ExpressionWithWrappedValueInfo(irAst, visitor.needsValueUnwrapper, visitor.temporaryCount);
  }
  function convertCdStatementToIr(nameResolver, implicitReceiver, stmt, bindingIndex) {
      var visitor = new _AstToIrVisitor(nameResolver, implicitReceiver, null, bindingIndex);
      var statements = [];
      flattenStatements(stmt.visit(visitor, _Mode.Statement), statements);
      prependTemporaryDecls(visitor.temporaryCount, bindingIndex, statements);
      return statements;
  }
  function temporaryName(bindingIndex, temporaryNumber) {
      return "tmp_" + bindingIndex + "_" + temporaryNumber;
  }
  function temporaryDeclaration(bindingIndex, temporaryNumber) {
      return new DeclareVarStmt(temporaryName(bindingIndex, temporaryNumber), NULL_EXPR);
  }
  function prependTemporaryDecls(temporaryCount, bindingIndex, statements) {
      for (var i = temporaryCount - 1; i >= 0; i--) {
          statements.unshift(temporaryDeclaration(bindingIndex, i));
      }
  }
  var _Mode;
  (function (_Mode) {
      _Mode[_Mode["Statement"] = 0] = "Statement";
      _Mode[_Mode["Expression"] = 1] = "Expression";
  })(_Mode || (_Mode = {}));
  function ensureStatementMode(mode, ast) {
      if (mode !== _Mode.Statement) {
          throw new Error("Expected a statement, but saw " + ast);
      }
  }
  function ensureExpressionMode(mode, ast) {
      if (mode !== _Mode.Expression) {
          throw new Error("Expected an expression, but saw " + ast);
      }
  }
  function convertToStatementIfNeeded(mode, expr) {
      if (mode === _Mode.Statement) {
          return expr.toStmt();
      }
      else {
          return expr;
      }
  }
  var _AstToIrVisitor = (function () {
      function _AstToIrVisitor(_nameResolver, _implicitReceiver, _valueUnwrapper, bindingIndex) {
          this._nameResolver = _nameResolver;
          this._implicitReceiver = _implicitReceiver;
          this._valueUnwrapper = _valueUnwrapper;
          this.bindingIndex = bindingIndex;
          this._nodeMap = new Map();
          this._resultMap = new Map();
          this._currentTemporary = 0;
          this.needsValueUnwrapper = false;
          this.temporaryCount = 0;
      }
      _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {
          var op;
          switch (ast.operation) {
              case '+':
                  op = BinaryOperator.Plus;
                  break;
              case '-':
                  op = BinaryOperator.Minus;
                  break;
              case '*':
                  op = BinaryOperator.Multiply;
                  break;
              case '/':
                  op = BinaryOperator.Divide;
                  break;
              case '%':
                  op = BinaryOperator.Modulo;
                  break;
              case '&&':
                  op = BinaryOperator.And;
                  break;
              case '||':
                  op = BinaryOperator.Or;
                  break;
              case '==':
                  op = BinaryOperator.Equals;
                  break;
              case '!=':
                  op = BinaryOperator.NotEquals;
                  break;
              case '===':
                  op = BinaryOperator.Identical;
                  break;
              case '!==':
                  op = BinaryOperator.NotIdentical;
                  break;
              case '<':
                  op = BinaryOperator.Lower;
                  break;
              case '>':
                  op = BinaryOperator.Bigger;
                  break;
              case '<=':
                  op = BinaryOperator.LowerEquals;
                  break;
              case '>=':
                  op = BinaryOperator.BiggerEquals;
                  break;
              default:
                  throw new Error("Unsupported operation " + ast.operation);
          }
          return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitChain = function (ast, mode) {
          ensureStatementMode(mode, ast);
          return this.visitAll(ast.expressions, mode);
      };
      _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {
          var value = this.visit(ast.condition, _Mode.Expression);
          return convertToStatementIfNeeded(mode, value.conditional(this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {
          var input = this.visit(ast.exp, _Mode.Expression);
          var args = this.visitAll(ast.args, _Mode.Expression);
          var value = this._nameResolver.callPipe(ast.name, input, args);
          this.needsValueUnwrapper = true;
          return convertToStatementIfNeeded(mode, this._valueUnwrapper.callMethod('unwrap', [value]));
      };
      _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {
          return convertToStatementIfNeeded(mode, this.visit(ast.target, _Mode.Expression).callFn(this.visitAll(ast.args, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {
          ensureExpressionMode(mode, ast);
          return this._implicitReceiver;
      };
      _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {
          ensureExpressionMode(mode, ast);
          var args = [literal(ast.expressions.length)];
          for (var i = 0; i < ast.strings.length - 1; i++) {
              args.push(literal(ast.strings[i]));
              args.push(this.visit(ast.expressions[i], _Mode.Expression));
          }
          args.push(literal(ast.strings[ast.strings.length - 1]));
          return importExpr(resolveIdentifier(Identifiers.interpolate)).callFn(args);
      };
      _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {
          return convertToStatementIfNeeded(mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {
          var obj = this.visit(ast.obj, _Mode.Expression);
          var key = this.visit(ast.key, _Mode.Expression);
          var value = this.visit(ast.value, _Mode.Expression);
          return convertToStatementIfNeeded(mode, obj.key(key).set(value));
      };
      _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {
          return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralArray(this.visitAll(ast.expressions, mode)));
      };
      _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {
          var parts = [];
          for (var i = 0; i < ast.keys.length; i++) {
              parts.push([ast.keys[i], this.visit(ast.values[i], _Mode.Expression)]);
          }
          return convertToStatementIfNeeded(mode, this._nameResolver.createLiteralMap(parts));
      };
      _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {
          return convertToStatementIfNeeded(mode, literal(ast.value));
      };
      _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {
          var leftMostSafe = this.leftMostSafeNode(ast);
          if (leftMostSafe) {
              return this.convertSafeAccess(ast, leftMostSafe, mode);
          }
          else {
              var args = this.visitAll(ast.args, _Mode.Expression);
              var result = null;
              var receiver = this.visit(ast.receiver, _Mode.Expression);
              if (receiver === this._implicitReceiver) {
                  var varExpr = this._nameResolver.getLocal(ast.name);
                  if (isPresent(varExpr)) {
                      result = varExpr.callFn(args);
                  }
              }
              if (isBlank(result)) {
                  result = receiver.callMethod(ast.name, args);
              }
              return convertToStatementIfNeeded(mode, result);
          }
      };
      _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {
          return convertToStatementIfNeeded(mode, not(this.visit(ast.expression, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {
          var leftMostSafe = this.leftMostSafeNode(ast);
          if (leftMostSafe) {
              return this.convertSafeAccess(ast, leftMostSafe, mode);
          }
          else {
              var result = null;
              var receiver = this.visit(ast.receiver, _Mode.Expression);
              if (receiver === this._implicitReceiver) {
                  result = this._nameResolver.getLocal(ast.name);
              }
              if (isBlank(result)) {
                  result = receiver.prop(ast.name);
              }
              return convertToStatementIfNeeded(mode, result);
          }
      };
      _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {
          var receiver = this.visit(ast.receiver, _Mode.Expression);
          if (receiver === this._implicitReceiver) {
              var varExpr = this._nameResolver.getLocal(ast.name);
              if (isPresent(varExpr)) {
                  throw new Error('Cannot assign to a reference or variable!');
              }
          }
          return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));
      };
      _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {
          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
      };
      _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {
          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
      };
      _AstToIrVisitor.prototype.visitAll = function (asts, mode) {
          var _this = this;
          return asts.map(function (ast) { return _this.visit(ast, mode); });
      };
      _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {
          throw new Error('Quotes are not supported for evaluation!');
      };
      _AstToIrVisitor.prototype.visit = function (ast, mode) {
          var result = this._resultMap.get(ast);
          if (result)
              return result;
          return (this._nodeMap.get(ast) || ast).visit(this, mode);
      };
      _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {
          // If the expression contains a safe access node on the left it needs to be converted to
          // an expression that guards the access to the member by checking the receiver for blank. As
          // execution proceeds from left to right, the left most part of the expression must be guarded
          // first but, because member access is left associative, the right side of the expression is at
          // the top of the AST. The desired result requires lifting a copy of the the left part of the
          // expression up to test it for blank before generating the unguarded version.
          // Consider, for example the following expression: a?.b.c?.d.e
          // This results in the ast:
          //         .
          //        / \
          //       ?.   e
          //      /  \
          //     .    d
          //    / \
          //   ?.  c
          //  /  \
          // a    b
          // The following tree should be generated:
          //
          //        /---- ? ----\
          //       /      |      \
          //     a   /--- ? ---\  null
          //        /     |     \
          //       .      .     null
          //      / \    / \
          //     .  c   .   e
          //    / \    / \
          //   a   b  ,   d
          //         / \
          //        .   c
          //       / \
          //      a   b
          //
          // Notice that the first guard condition is the left hand of the left most safe access node
          // which comes in as leftMostSafe to this routine.
          var guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);
          var temporary;
          if (this.needsTemporary(leftMostSafe.receiver)) {
              // If the expression has method calls or pipes then we need to save the result into a
              // temporary variable to avoid calling stateful or impure code more than once.
              temporary = this.allocateTemporary();
              // Preserve the result in the temporary variable
              guardedExpression = temporary.set(guardedExpression);
              // Ensure all further references to the guarded expression refer to the temporary instead.
              this._resultMap.set(leftMostSafe.receiver, temporary);
          }
          var condition = guardedExpression.isBlank();
          // Convert the ast to an unguarded access to the receiver's member. The map will substitute
          // leftMostNode with its unguarded version in the call to `this.visit()`.
          if (leftMostSafe instanceof SafeMethodCall) {
              this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));
          }
          else {
              this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));
          }
          // Recursively convert the node now without the guarded member access.
          var access = this.visit(ast, _Mode.Expression);
          // Remove the mapping. This is not strictly required as the converter only traverses each node
          // once but is safer if the conversion is changed to traverse the nodes more than once.
          this._nodeMap.delete(leftMostSafe);
          // If we allcoated a temporary, release it.
          if (temporary) {
              this.releaseTemporary(temporary);
          }
          // Produce the conditional
          return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));
      };
      // Given a expression of the form a?.b.c?.d.e the the left most safe node is
      // the (a?.b). The . and ?. are left associative thus can be rewritten as:
      // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or
      // safe method call as this needs be transform initially to:
      //   a == null ? null : a.c.b.c?.d.e
      // then to:
      //   a == null ? null : a.b.c == null ? null : a.b.c.d.e
      _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {
          var _this = this;
          var visit = function (visitor, ast) {
              return (_this._nodeMap.get(ast) || ast).visit(visitor);
          };
          return ast.visit({
              visitBinary: function (ast) { return null; },
              visitChain: function (ast) { return null; },
              visitConditional: function (ast) { return null; },
              visitFunctionCall: function (ast) { return null; },
              visitImplicitReceiver: function (ast) { return null; },
              visitInterpolation: function (ast) { return null; },
              visitKeyedRead: function (ast) { return visit(this, ast.obj); },
              visitKeyedWrite: function (ast) { return null; },
              visitLiteralArray: function (ast) { return null; },
              visitLiteralMap: function (ast) { return null; },
              visitLiteralPrimitive: function (ast) { return null; },
              visitMethodCall: function (ast) { return visit(this, ast.receiver); },
              visitPipe: function (ast) { return null; },
              visitPrefixNot: function (ast) { return null; },
              visitPropertyRead: function (ast) { return visit(this, ast.receiver); },
              visitPropertyWrite: function (ast) { return null; },
              visitQuote: function (ast) { return null; },
              visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },
              visitSafePropertyRead: function (ast) {
                  return visit(this, ast.receiver) || ast;
              }
          });
      };
      // Returns true of the AST includes a method or a pipe indicating that, if the
      // expression is used as the target of a safe property or method access then
      // the expression should be stored into a temporary variable.
      _AstToIrVisitor.prototype.needsTemporary = function (ast) {
          var _this = this;
          var visit = function (visitor, ast) {
              return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);
          };
          var visitSome = function (visitor, ast) {
              return ast.some(function (ast) { return visit(visitor, ast); });
          };
          return ast.visit({
              visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },
              visitChain: function (ast) { return false; },
              visitConditional: function (ast) {
                  return visit(this, ast.condition) || visit(this, ast.trueExp) ||
                      visit(this, ast.falseExp);
              },
              visitFunctionCall: function (ast) { return true; },
              visitImplicitReceiver: function (ast) { return false; },
              visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },
              visitKeyedRead: function (ast) { return false; },
              visitKeyedWrite: function (ast) { return false; },
              visitLiteralArray: function (ast) { return true; },
              visitLiteralMap: function (ast) { return true; },
              visitLiteralPrimitive: function (ast) { return false; },
              visitMethodCall: function (ast) { return true; },
              visitPipe: function (ast) { return true; },
              visitPrefixNot: function (ast) { return visit(this, ast.expression); },
              visitPropertyRead: function (ast) { return false; },
              visitPropertyWrite: function (ast) { return false; },
              visitQuote: function (ast) { return false; },
              visitSafeMethodCall: function (ast) { return true; },
              visitSafePropertyRead: function (ast) { return false; }
          });
      };
      _AstToIrVisitor.prototype.allocateTemporary = function () {
          var tempNumber = this._currentTemporary++;
          this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
          return new ReadVarExpr(temporaryName(this.bindingIndex, tempNumber));
      };
      _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {
          this._currentTemporary--;
          if (temporary.name != temporaryName(this.bindingIndex, this._currentTemporary)) {
              throw new Error("Temporary " + temporary.name + " released out of order");
          }
      };
      return _AstToIrVisitor;
  }());
  function flattenStatements(arg, output) {
      if (isArray(arg)) {
          arg.forEach(function (entry) { return flattenStatements(entry, output); });
      }
      else {
          output.push(arg);
      }
  }

  var CompileEventListener = (function () {
      function CompileEventListener(compileElement, eventTarget, eventName, eventPhase, listenerIndex) {
          this.compileElement = compileElement;
          this.eventTarget = eventTarget;
          this.eventName = eventName;
          this.eventPhase = eventPhase;
          this._hasComponentHostListener = false;
          this._actionResultExprs = [];
          this._method = new CompileMethod(compileElement.view);
          this._methodName =
              "_handle_" + santitizeEventName(eventName) + "_" + compileElement.nodeIndex + "_" + listenerIndex;
          this._eventParam = new FnParam(EventHandlerVars.event.name, importType(this.compileElement.view.genConfig.renderTypes.renderEvent));
      }
      CompileEventListener.getOrCreate = function (compileElement, eventTarget, eventName, eventPhase, targetEventListeners) {
          var listener = targetEventListeners.find(function (listener) { return listener.eventTarget == eventTarget && listener.eventName == eventName &&
              listener.eventPhase == eventPhase; });
          if (!listener) {
              listener = new CompileEventListener(compileElement, eventTarget, eventName, eventPhase, targetEventListeners.length);
              targetEventListeners.push(listener);
          }
          return listener;
      };
      Object.defineProperty(CompileEventListener.prototype, "methodName", {
          get: function () { return this._methodName; },
          enumerable: true,
          configurable: true
      });
      CompileEventListener.prototype.addAction = function (hostEvent, directive, directiveInstance) {
          if (isPresent(directive) && directive.isComponent) {
              this._hasComponentHostListener = true;
          }
          this._method.resetDebugInfo(this.compileElement.nodeIndex, hostEvent);
          var context = isPresent(directiveInstance) ? directiveInstance :
              this.compileElement.view.componentContext;
          var actionStmts = convertCdStatementToIr(this.compileElement.view, context, hostEvent.handler, this.compileElement.nodeIndex);
          var lastIndex = actionStmts.length - 1;
          if (lastIndex >= 0) {
              var lastStatement = actionStmts[lastIndex];
              var returnExpr = convertStmtIntoExpression(lastStatement);
              var preventDefaultVar = variable("pd_" + this._actionResultExprs.length);
              this._actionResultExprs.push(preventDefaultVar);
              if (isPresent(returnExpr)) {
                  // Note: We need to cast the result of the method call to dynamic,
                  // as it might be a void method!
                  actionStmts[lastIndex] =
                      preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))
                          .toDeclStmt(null, [StmtModifier.Final]);
              }
          }
          this._method.addStmts(actionStmts);
      };
      CompileEventListener.prototype.finishMethod = function () {
          var markPathToRootStart = this._hasComponentHostListener ?
              this.compileElement.appElement.prop('componentView') :
              THIS_EXPR;
          var resultExpr = literal(true);
          this._actionResultExprs.forEach(function (expr) { resultExpr = resultExpr.and(expr); });
          var stmts = [markPathToRootStart.callMethod('markPathToRootAsCheckOnce', []).toStmt()]
              .concat(this._method.finish())
              .concat([new ReturnStatement(resultExpr)]);
          // private is fine here as no child view will reference the event handler...
          this.compileElement.view.eventHandlerMethods.push(new ClassMethod(this._methodName, [this._eventParam], stmts, BOOL_TYPE, [StmtModifier.Private]));
      };
      CompileEventListener.prototype.listenToRenderer = function () {
          var listenExpr;
          var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.Bind, [THIS_EXPR])]);
          if (isPresent(this.eventTarget)) {
              listenExpr = ViewProperties.renderer.callMethod('listenGlobal', [literal(this.eventTarget), literal(this.eventName), eventListener]);
          }
          else {
              listenExpr = ViewProperties.renderer.callMethod('listen', [this.compileElement.renderNode, literal(this.eventName), eventListener]);
          }
          var disposable = variable("disposable_" + this.compileElement.view.disposables.length);
          this.compileElement.view.disposables.push(disposable);
          // private is fine here as no child view will reference the event handler...
          this.compileElement.view.createMethod.addStmt(disposable.set(listenExpr).toDeclStmt(FUNCTION_TYPE, [StmtModifier.Private]));
      };
      CompileEventListener.prototype.listenToAnimation = function () {
          var outputListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.Bind, [THIS_EXPR])]);
          // tie the property callback method to the view animations map
          var stmt = THIS_EXPR
              .callMethod('registerAnimationOutput', [
              this.compileElement.renderNode, literal(this.eventName),
              literal(this.eventPhase), outputListener
          ])
              .toStmt();
          this.compileElement.view.createMethod.addStmt(stmt);
      };
      CompileEventListener.prototype.listenToDirective = function (directiveInstance, observablePropName) {
          var subscription = variable("subscription_" + this.compileElement.view.subscriptions.length);
          this.compileElement.view.subscriptions.push(subscription);
          var eventListener = THIS_EXPR.callMethod('eventHandler', [THIS_EXPR.prop(this._methodName).callMethod(BuiltinMethod.Bind, [THIS_EXPR])]);
          this.compileElement.view.createMethod.addStmt(subscription
              .set(directiveInstance.prop(observablePropName)
              .callMethod(BuiltinMethod.SubscribeObservable, [eventListener]))
              .toDeclStmt(null, [StmtModifier.Final]));
      };
      return CompileEventListener;
  }());
  function collectEventListeners(hostEvents, dirs, compileElement) {
      var eventListeners = [];
      hostEvents.forEach(function (hostEvent) {
          compileElement.view.bindings.push(new CompileBinding(compileElement, hostEvent));
          var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, hostEvent.phase, eventListeners);
          listener.addAction(hostEvent, null, null);
      });
      dirs.forEach(function (directiveAst) {
          var directiveInstance = compileElement.instances.get(identifierToken(directiveAst.directive.type).reference);
          directiveAst.hostEvents.forEach(function (hostEvent) {
              compileElement.view.bindings.push(new CompileBinding(compileElement, hostEvent));
              var listener = CompileEventListener.getOrCreate(compileElement, hostEvent.target, hostEvent.name, hostEvent.phase, eventListeners);
              listener.addAction(hostEvent, directiveAst.directive, directiveInstance);
          });
      });
      eventListeners.forEach(function (listener) { return listener.finishMethod(); });
      return eventListeners;
  }
  function bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners) {
      Object.keys(directiveAst.directive.outputs).forEach(function (observablePropName) {
          var eventName = directiveAst.directive.outputs[observablePropName];
          eventListeners.filter(function (listener) { return listener.eventName == eventName; }).forEach(function (listener) {
              listener.listenToDirective(directiveInstance, observablePropName);
          });
      });
  }
  function bindRenderOutputs(eventListeners) {
      eventListeners.forEach(function (listener) {
          if (listener.eventPhase) {
              listener.listenToAnimation();
          }
          else {
              listener.listenToRenderer();
          }
      });
  }
  function convertStmtIntoExpression(stmt) {
      if (stmt instanceof ExpressionStatement) {
          return stmt.expr;
      }
      else if (stmt instanceof ReturnStatement) {
          return stmt.value;
      }
      return null;
  }
  function santitizeEventName(name) {
      return StringWrapper.replaceAll(name, /[^a-zA-Z_]/g, '_');
  }

  var STATE_IS_NEVER_CHECKED = THIS_EXPR.prop('numberOfChecks').identical(new LiteralExpr(0));
  var NOT_THROW_ON_CHANGES = not(DetectChangesVars.throwOnChange);
  function bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement) {
      var view = compileElement.view;
      var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
      var lifecycleHooks = directiveAst.directive.type.lifecycleHooks;
      if (lifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1 && directiveAst.inputs.length > 0) {
          detectChangesInInputsMethod.addStmt(new IfStmt(DetectChangesVars.changes.notIdentical(NULL_EXPR), [directiveInstance.callMethod('ngOnChanges', [DetectChangesVars.changes]).toStmt()]));
      }
      if (lifecycleHooks.indexOf(LifecycleHooks.OnInit) !== -1) {
          detectChangesInInputsMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED.and(NOT_THROW_ON_CHANGES), [directiveInstance.callMethod('ngOnInit', []).toStmt()]));
      }
      if (lifecycleHooks.indexOf(LifecycleHooks.DoCheck) !== -1) {
          detectChangesInInputsMethod.addStmt(new IfStmt(NOT_THROW_ON_CHANGES, [directiveInstance.callMethod('ngDoCheck', []).toStmt()]));
      }
  }
  function bindDirectiveAfterContentLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
      var view = compileElement.view;
      var lifecycleHooks = directiveMeta.type.lifecycleHooks;
      var afterContentLifecycleCallbacksMethod = view.afterContentLifecycleCallbacksMethod;
      afterContentLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentInit) !== -1) {
          afterContentLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterContentInit', []).toStmt()]));
      }
      if (lifecycleHooks.indexOf(LifecycleHooks.AfterContentChecked) !== -1) {
          afterContentLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterContentChecked', []).toStmt());
      }
  }
  function bindDirectiveAfterViewLifecycleCallbacks(directiveMeta, directiveInstance, compileElement) {
      var view = compileElement.view;
      var lifecycleHooks = directiveMeta.type.lifecycleHooks;
      var afterViewLifecycleCallbacksMethod = view.afterViewLifecycleCallbacksMethod;
      afterViewLifecycleCallbacksMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewInit) !== -1) {
          afterViewLifecycleCallbacksMethod.addStmt(new IfStmt(STATE_IS_NEVER_CHECKED, [directiveInstance.callMethod('ngAfterViewInit', []).toStmt()]));
      }
      if (lifecycleHooks.indexOf(LifecycleHooks.AfterViewChecked) !== -1) {
          afterViewLifecycleCallbacksMethod.addStmt(directiveInstance.callMethod('ngAfterViewChecked', []).toStmt());
      }
  }
  function bindInjectableDestroyLifecycleCallbacks(provider, providerInstance, compileElement) {
      var onDestroyMethod = compileElement.view.destroyMethod;
      onDestroyMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      if (provider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
          onDestroyMethod.addStmt(providerInstance.callMethod('ngOnDestroy', []).toStmt());
      }
  }
  function bindPipeDestroyLifecycleCallbacks(pipeMeta, pipeInstance, view) {
      var onDestroyMethod = view.destroyMethod;
      if (pipeMeta.type.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
          onDestroyMethod.addStmt(pipeInstance.callMethod('ngOnDestroy', []).toStmt());
      }
  }

  function createBindFieldExpr(exprIndex) {
      return THIS_EXPR.prop("_expr_" + exprIndex);
  }
  function createCurrValueExpr(exprIndex) {
      return variable("currVal_" + exprIndex); // fix syntax highlighting: `
  }
  function bind(view, currValExpr, fieldExpr, parsedExpression, context, actions, method, bindingIndex) {
      var checkExpression = convertCdExpressionToIr(view, context, parsedExpression, DetectChangesVars.valUnwrapper, bindingIndex);
      if (!checkExpression.expression) {
          // e.g. an empty expression was given
          return;
      }
      if (checkExpression.temporaryCount) {
          for (var i = 0; i < checkExpression.temporaryCount; i++) {
              method.addStmt(temporaryDeclaration(bindingIndex, i));
          }
      }
      // private is fine here as no child view will reference the cached value...
      view.fields.push(new ClassField(fieldExpr.name, null, [StmtModifier.Private]));
      view.createMethod.addStmt(THIS_EXPR.prop(fieldExpr.name)
          .set(importExpr(resolveIdentifier(Identifiers.UNINITIALIZED)))
          .toStmt());
      if (checkExpression.needsValueUnwrapper) {
          var initValueUnwrapperStmt = DetectChangesVars.valUnwrapper.callMethod('reset', []).toStmt();
          method.addStmt(initValueUnwrapperStmt);
      }
      method.addStmt(currValExpr.set(checkExpression.expression).toDeclStmt(null, [StmtModifier.Final]));
      var condition = importExpr(resolveIdentifier(Identifiers.checkBinding)).callFn([
          DetectChangesVars.throwOnChange, fieldExpr, currValExpr
      ]);
      if (checkExpression.needsValueUnwrapper) {
          condition = DetectChangesVars.valUnwrapper.prop('hasWrappedValue').or(condition);
      }
      method.addStmt(new IfStmt(condition, actions.concat([THIS_EXPR.prop(fieldExpr.name).set(currValExpr).toStmt()])));
  }
  function bindRenderText(boundText, compileNode, view) {
      var bindingIndex = view.bindings.length;
      view.bindings.push(new CompileBinding(compileNode, boundText));
      var currValExpr = createCurrValueExpr(bindingIndex);
      var valueField = createBindFieldExpr(bindingIndex);
      view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileNode.nodeIndex, boundText);
      bind(view, currValExpr, valueField, boundText.value, view.componentContext, [THIS_EXPR.prop('renderer')
              .callMethod('setText', [compileNode.renderNode, currValExpr])
              .toStmt()], view.detectChangesRenderPropertiesMethod, bindingIndex);
  }
  function bindAndWriteToRenderer(boundProps, context, compileElement, isHostProp) {
      var view = compileElement.view;
      var renderNode = compileElement.renderNode;
      boundProps.forEach(function (boundProp) {
          var bindingIndex = view.bindings.length;
          view.bindings.push(new CompileBinding(compileElement, boundProp));
          view.detectChangesRenderPropertiesMethod.resetDebugInfo(compileElement.nodeIndex, boundProp);
          var fieldExpr = createBindFieldExpr(bindingIndex);
          var currValExpr = createCurrValueExpr(bindingIndex);
          var renderMethod;
          var oldRenderValue = sanitizedValue(boundProp, fieldExpr);
          var renderValue = sanitizedValue(boundProp, currValExpr);
          var updateStmts = [];
          var compileMethod = view.detectChangesRenderPropertiesMethod;
          switch (boundProp.type) {
              case exports.PropertyBindingType.Property:
                  if (view.genConfig.logBindingUpdate) {
                      updateStmts.push(logBindingUpdateStmt(renderNode, boundProp.name, renderValue));
                  }
                  updateStmts.push(THIS_EXPR.prop('renderer')
                      .callMethod('setElementProperty', [renderNode, literal(boundProp.name), renderValue])
                      .toStmt());
                  break;
              case exports.PropertyBindingType.Attribute:
                  renderValue =
                      renderValue.isBlank().conditional(NULL_EXPR, renderValue.callMethod('toString', []));
                  updateStmts.push(THIS_EXPR.prop('renderer')
                      .callMethod('setElementAttribute', [renderNode, literal(boundProp.name), renderValue])
                      .toStmt());
                  break;
              case exports.PropertyBindingType.Class:
                  updateStmts.push(THIS_EXPR.prop('renderer')
                      .callMethod('setElementClass', [renderNode, literal(boundProp.name), renderValue])
                      .toStmt());
                  break;
              case exports.PropertyBindingType.Style:
                  var strValue = renderValue.callMethod('toString', []);
                  if (isPresent(boundProp.unit)) {
                      strValue = strValue.plus(literal(boundProp.unit));
                  }
                  renderValue = renderValue.isBlank().conditional(NULL_EXPR, strValue);
                  updateStmts.push(THIS_EXPR.prop('renderer')
                      .callMethod('setElementStyle', [renderNode, literal(boundProp.name), renderValue])
                      .toStmt());
                  break;
              case exports.PropertyBindingType.Animation:
                  var animationName = boundProp.name;
                  var targetViewExpr = THIS_EXPR;
                  if (isHostProp) {
                      targetViewExpr = compileElement.appElement.prop('componentView');
                  }
                  compileMethod = view.animationBindingsMethod;
                  var animationFnExpr = targetViewExpr.prop('componentType').prop('animations').key(literal(animationName));
                  // it's important to normalize the void value as `void` explicitly
                  // so that the styles data can be obtained from the stringmap
                  var emptyStateValue = literal(EMPTY_ANIMATION_STATE);
                  // void => ...
                  var oldRenderVar = variable('oldRenderVar');
                  updateStmts.push(oldRenderVar.set(oldRenderValue).toDeclStmt());
                  updateStmts.push(new IfStmt(oldRenderVar.equals(importExpr(resolveIdentifier(Identifiers.UNINITIALIZED))), [oldRenderVar.set(emptyStateValue).toStmt()]));
                  // ... => void
                  var newRenderVar = variable('newRenderVar');
                  updateStmts.push(newRenderVar.set(renderValue).toDeclStmt());
                  updateStmts.push(new IfStmt(newRenderVar.equals(importExpr(resolveIdentifier(Identifiers.UNINITIALIZED))), [newRenderVar.set(emptyStateValue).toStmt()]));
                  updateStmts.push(animationFnExpr.callFn([THIS_EXPR, renderNode, oldRenderVar, newRenderVar]).toStmt());
                  view.detachMethod.addStmt(animationFnExpr.callFn([THIS_EXPR, renderNode, oldRenderValue, emptyStateValue])
                      .toStmt());
                  break;
          }
          bind(view, currValExpr, fieldExpr, boundProp.value, context, updateStmts, compileMethod, view.bindings.length);
      });
  }
  function sanitizedValue(boundProp, renderValue) {
      var enumValue;
      switch (boundProp.securityContext) {
          case _angular_core.SecurityContext.NONE:
              return renderValue; // No sanitization needed.
          case _angular_core.SecurityContext.HTML:
              enumValue = 'HTML';
              break;
          case _angular_core.SecurityContext.STYLE:
              enumValue = 'STYLE';
              break;
          case _angular_core.SecurityContext.SCRIPT:
              enumValue = 'SCRIPT';
              break;
          case _angular_core.SecurityContext.URL:
              enumValue = 'URL';
              break;
          case _angular_core.SecurityContext.RESOURCE_URL:
              enumValue = 'RESOURCE_URL';
              break;
          default:
              throw new Error("internal error, unexpected SecurityContext " + boundProp.securityContext + ".");
      }
      var ctx = ViewProperties.viewUtils.prop('sanitizer');
      var args = [importExpr(resolveIdentifier(Identifiers.SecurityContext)).prop(enumValue), renderValue];
      return ctx.callMethod('sanitize', args);
  }
  function bindRenderInputs(boundProps, compileElement) {
      bindAndWriteToRenderer(boundProps, compileElement.view.componentContext, compileElement, false);
  }
  function bindDirectiveHostProps(directiveAst, directiveInstance, compileElement) {
      bindAndWriteToRenderer(directiveAst.hostProperties, directiveInstance, compileElement, true);
  }
  function bindDirectiveInputs(directiveAst, directiveInstance, compileElement) {
      if (directiveAst.inputs.length === 0) {
          return;
      }
      var view = compileElement.view;
      var detectChangesInInputsMethod = view.detectChangesInInputsMethod;
      detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, compileElement.sourceAst);
      var lifecycleHooks = directiveAst.directive.type.lifecycleHooks;
      var calcChangesMap = lifecycleHooks.indexOf(LifecycleHooks.OnChanges) !== -1;
      var isOnPushComp = directiveAst.directive.isComponent &&
          !isDefaultChangeDetectionStrategy(directiveAst.directive.changeDetection);
      if (calcChangesMap) {
          detectChangesInInputsMethod.addStmt(DetectChangesVars.changes.set(NULL_EXPR).toStmt());
      }
      if (isOnPushComp) {
          detectChangesInInputsMethod.addStmt(DetectChangesVars.changed.set(literal(false)).toStmt());
      }
      directiveAst.inputs.forEach(function (input) {
          var bindingIndex = view.bindings.length;
          view.bindings.push(new CompileBinding(compileElement, input));
          detectChangesInInputsMethod.resetDebugInfo(compileElement.nodeIndex, input);
          var fieldExpr = createBindFieldExpr(bindingIndex);
          var currValExpr = createCurrValueExpr(bindingIndex);
          var statements = [directiveInstance.prop(input.directiveName).set(currValExpr).toStmt()];
          if (calcChangesMap) {
              statements.push(new IfStmt(DetectChangesVars.changes.identical(NULL_EXPR), [DetectChangesVars.changes
                      .set(literalMap([], new MapType(importType(resolveIdentifier(Identifiers.SimpleChange)))))
                      .toStmt()]));
              statements.push(DetectChangesVars.changes.key(literal(input.directiveName))
                  .set(importExpr(resolveIdentifier(Identifiers.SimpleChange))
                  .instantiate([fieldExpr, currValExpr]))
                  .toStmt());
          }
          if (isOnPushComp) {
              statements.push(DetectChangesVars.changed.set(literal(true)).toStmt());
          }
          if (view.genConfig.logBindingUpdate) {
              statements.push(logBindingUpdateStmt(compileElement.renderNode, input.directiveName, currValExpr));
          }
          bind(view, currValExpr, fieldExpr, input.value, view.componentContext, statements, detectChangesInInputsMethod, bindingIndex);
      });
      if (isOnPushComp) {
          detectChangesInInputsMethod.addStmt(new IfStmt(DetectChangesVars.changed, [
              compileElement.appElement.prop('componentView').callMethod('markAsCheckOnce', []).toStmt()
          ]));
      }
  }
  function logBindingUpdateStmt(renderNode, propName, value) {
      var tryStmt = THIS_EXPR.prop('renderer')
          .callMethod('setBindingDebugInfo', [
          renderNode, literal("ng-reflect-" + camelCaseToDashCase(propName)),
          value.isBlank().conditional(NULL_EXPR, value.callMethod('toString', []))
      ])
          .toStmt();
      var catchStmt = THIS_EXPR.prop('renderer')
          .callMethod('setBindingDebugInfo', [
          renderNode, literal("ng-reflect-" + camelCaseToDashCase(propName)),
          literal('[ERROR] Exception while trying to serialize the value')
      ])
          .toStmt();
      return new TryCatchStmt([tryStmt], [catchStmt]);
  }

  function bindView(view, parsedTemplate) {
      var visitor = new ViewBinderVisitor(view);
      templateVisitAll(visitor, parsedTemplate);
      view.pipes.forEach(function (pipe) { bindPipeDestroyLifecycleCallbacks(pipe.meta, pipe.instance, pipe.view); });
  }
  var ViewBinderVisitor = (function () {
      function ViewBinderVisitor(view) {
          this.view = view;
          this._nodeIndex = 0;
      }
      ViewBinderVisitor.prototype.visitBoundText = function (ast, parent) {
          var node = this.view.nodes[this._nodeIndex++];
          bindRenderText(ast, node, this.view);
          return null;
      };
      ViewBinderVisitor.prototype.visitText = function (ast, parent) {
          this._nodeIndex++;
          return null;
      };
      ViewBinderVisitor.prototype.visitNgContent = function (ast, parent) { return null; };
      ViewBinderVisitor.prototype.visitElement = function (ast, parent) {
          var compileElement = this.view.nodes[this._nodeIndex++];
          var eventListeners = [];
          collectEventListeners(ast.outputs, ast.directives, compileElement).forEach(function (entry) {
              eventListeners.push(entry);
          });
          bindRenderInputs(ast.inputs, compileElement);
          bindRenderOutputs(eventListeners);
          ast.directives.forEach(function (directiveAst) {
              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
              bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
              bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
              bindDirectiveHostProps(directiveAst, directiveInstance, compileElement);
              bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
          });
          templateVisitAll(this, ast.children, compileElement);
          // afterContent and afterView lifecycles need to be called bottom up
          // so that children are notified before parents
          ast.directives.forEach(function (directiveAst) {
              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
              bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
              bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
          });
          ast.providers.forEach(function (providerAst) {
              var providerInstance = compileElement.instances.get(providerAst.token.reference);
              bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
          });
          return null;
      };
      ViewBinderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
          var compileElement = this.view.nodes[this._nodeIndex++];
          var eventListeners = collectEventListeners(ast.outputs, ast.directives, compileElement);
          ast.directives.forEach(function (directiveAst) {
              var directiveInstance = compileElement.instances.get(directiveAst.directive.type.reference);
              bindDirectiveInputs(directiveAst, directiveInstance, compileElement);
              bindDirectiveDetectChangesLifecycleCallbacks(directiveAst, directiveInstance, compileElement);
              bindDirectiveOutputs(directiveAst, directiveInstance, eventListeners);
              bindDirectiveAfterContentLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
              bindDirectiveAfterViewLifecycleCallbacks(directiveAst.directive, directiveInstance, compileElement);
          });
          ast.providers.forEach(function (providerAst) {
              var providerInstance = compileElement.instances.get(providerAst.token.reference);
              bindInjectableDestroyLifecycleCallbacks(providerAst, providerInstance, compileElement);
          });
          bindView(compileElement.embeddedView, ast.children);
          return null;
      };
      ViewBinderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
      ViewBinderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
      ViewBinderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
          return null;
      };
      ViewBinderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
      ViewBinderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
      ViewBinderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
      ViewBinderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
      return ViewBinderVisitor;
  }());

  var IMPLICIT_TEMPLATE_VAR = '\$implicit';
  var CLASS_ATTR$1 = 'class';
  var STYLE_ATTR = 'style';
  var NG_CONTAINER_TAG = 'ng-container';
  var parentRenderNodeVar = variable('parentRenderNode');
  var rootSelectorVar = variable('rootSelector');
  var ViewFactoryDependency = (function () {
      function ViewFactoryDependency(comp, placeholder) {
          this.comp = comp;
          this.placeholder = placeholder;
      }
      return ViewFactoryDependency;
  }());
  var ComponentFactoryDependency = (function () {
      function ComponentFactoryDependency(comp, placeholder) {
          this.comp = comp;
          this.placeholder = placeholder;
      }
      return ComponentFactoryDependency;
  }());
  function buildView(view, template, targetDependencies) {
      var builderVisitor = new ViewBuilderVisitor(view, targetDependencies);
      templateVisitAll(builderVisitor, template, view.declarationElement.isNull() ? view.declarationElement : view.declarationElement.parent);
      return builderVisitor.nestedViewCount;
  }
  function finishView(view, targetStatements) {
      view.afterNodes();
      createViewTopLevelStmts(view, targetStatements);
      view.nodes.forEach(function (node) {
          if (node instanceof CompileElement && node.hasEmbeddedView) {
              finishView(node.embeddedView, targetStatements);
          }
      });
  }
  var ViewBuilderVisitor = (function () {
      function ViewBuilderVisitor(view, targetDependencies) {
          this.view = view;
          this.targetDependencies = targetDependencies;
          this.nestedViewCount = 0;
      }
      ViewBuilderVisitor.prototype._isRootNode = function (parent) { return parent.view !== this.view; };
      ViewBuilderVisitor.prototype._addRootNodeAndProject = function (node) {
          var projectedNode = _getOuterContainerOrSelf(node);
          var parent = projectedNode.parent;
          var ngContentIndex = projectedNode.sourceAst.ngContentIndex;
          var vcAppEl = (node instanceof CompileElement && node.hasViewContainer) ? node.appElement : null;
          if (this._isRootNode(parent)) {
              // store appElement as root node only for ViewContainers
              if (this.view.viewType !== ViewType.COMPONENT) {
                  this.view.rootNodesOrAppElements.push(isPresent(vcAppEl) ? vcAppEl : node.renderNode);
              }
          }
          else if (isPresent(parent.component) && isPresent(ngContentIndex)) {
              parent.addContentNode(ngContentIndex, isPresent(vcAppEl) ? vcAppEl : node.renderNode);
          }
      };
      ViewBuilderVisitor.prototype._getParentRenderNode = function (parent) {
          parent = _getOuterContainerParentOrSelf(parent);
          if (this._isRootNode(parent)) {
              if (this.view.viewType === ViewType.COMPONENT) {
                  return parentRenderNodeVar;
              }
              else {
                  // root node of an embedded/host view
                  return NULL_EXPR;
              }
          }
          else {
              return isPresent(parent.component) &&
                  parent.component.template.encapsulation !== _angular_core.ViewEncapsulation.Native ?
                  NULL_EXPR :
                  parent.renderNode;
          }
      };
      ViewBuilderVisitor.prototype.visitBoundText = function (ast, parent) {
          return this._visitText(ast, '', parent);
      };
      ViewBuilderVisitor.prototype.visitText = function (ast, parent) {
          return this._visitText(ast, ast.value, parent);
      };
      ViewBuilderVisitor.prototype._visitText = function (ast, value, parent) {
          var fieldName = "_text_" + this.view.nodes.length;
          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderText)));
          var renderNode = THIS_EXPR.prop(fieldName);
          var compileNode = new CompileNode(parent, this.view, this.view.nodes.length, renderNode, ast);
          var createRenderNode = THIS_EXPR.prop(fieldName)
              .set(ViewProperties.renderer.callMethod('createText', [
              this._getParentRenderNode(parent), literal(value),
              this.view.createMethod.resetDebugInfoExpr(this.view.nodes.length, ast)
          ]))
              .toStmt();
          this.view.nodes.push(compileNode);
          this.view.createMethod.addStmt(createRenderNode);
          this._addRootNodeAndProject(compileNode);
          return renderNode;
      };
      ViewBuilderVisitor.prototype.visitNgContent = function (ast, parent) {
          // the projected nodes originate from a different view, so we don't
          // have debug information for them...
          this.view.createMethod.resetDebugInfo(null, ast);
          var parentRenderNode = this._getParentRenderNode(parent);
          var nodesExpression = ViewProperties.projectableNodes.key(literal(ast.index), new ArrayType(importType(this.view.genConfig.renderTypes.renderNode)));
          if (parentRenderNode !== NULL_EXPR) {
              this.view.createMethod.addStmt(ViewProperties.renderer
                  .callMethod('projectNodes', [
                  parentRenderNode,
                  importExpr(resolveIdentifier(Identifiers.flattenNestedViewRenderNodes))
                      .callFn([nodesExpression])
              ])
                  .toStmt());
          }
          else if (this._isRootNode(parent)) {
              if (this.view.viewType !== ViewType.COMPONENT) {
                  // store root nodes only for embedded/host views
                  this.view.rootNodesOrAppElements.push(nodesExpression);
              }
          }
          else {
              if (isPresent(parent.component) && isPresent(ast.ngContentIndex)) {
                  parent.addContentNode(ast.ngContentIndex, nodesExpression);
              }
          }
          return null;
      };
      ViewBuilderVisitor.prototype.visitElement = function (ast, parent) {
          var _this = this;
          var nodeIndex = this.view.nodes.length;
          var createRenderNodeExpr;
          var debugContextExpr = this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast);
          if (nodeIndex === 0 && this.view.viewType === ViewType.HOST) {
              createRenderNodeExpr = THIS_EXPR.callMethod('selectOrCreateHostElement', [literal(ast.name), rootSelectorVar, debugContextExpr]);
          }
          else {
              if (ast.name === NG_CONTAINER_TAG) {
                  createRenderNodeExpr = ViewProperties.renderer.callMethod('createTemplateAnchor', [this._getParentRenderNode(parent), debugContextExpr]);
              }
              else {
                  createRenderNodeExpr = ViewProperties.renderer.callMethod('createElement', [this._getParentRenderNode(parent), literal(ast.name), debugContextExpr]);
              }
          }
          var fieldName = "_el_" + nodeIndex;
          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderElement)));
          this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName).set(createRenderNodeExpr).toStmt());
          var renderNode = THIS_EXPR.prop(fieldName);
          var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
          var component = directives.find(function (directive) { return directive.isComponent; });
          var htmlAttrs = _readHtmlAttrs(ast.attrs);
          var attrNameAndValues = _mergeHtmlAndDirectiveAttrs(htmlAttrs, directives);
          for (var i = 0; i < attrNameAndValues.length; i++) {
              var attrName = attrNameAndValues[i][0];
              if (ast.name !== NG_CONTAINER_TAG) {
                  // <ng-container> are not rendered in the DOM
                  var attrValue = attrNameAndValues[i][1];
                  this.view.createMethod.addStmt(ViewProperties.renderer
                      .callMethod('setElementAttribute', [renderNode, literal(attrName), literal(attrValue)])
                      .toStmt());
              }
          }
          var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, component, directives, ast.providers, ast.hasViewContainer, false, ast.references);
          this.view.nodes.push(compileElement);
          var compViewExpr = null;
          if (isPresent(component)) {
              var nestedComponentIdentifier = new CompileIdentifierMetadata({ name: getViewFactoryName(component, 0) });
              this.targetDependencies.push(new ViewFactoryDependency(component.type, nestedComponentIdentifier));
              var entryComponentIdentifiers = component.entryComponents.map(function (entryComponent) {
                  var id = new CompileIdentifierMetadata({ name: entryComponent.name });
                  _this.targetDependencies.push(new ComponentFactoryDependency(entryComponent, id));
                  return id;
              });
              compileElement.createComponentFactoryResolver(entryComponentIdentifiers);
              compViewExpr = variable("compView_" + nodeIndex); // fix highlighting: `
              compileElement.setComponentView(compViewExpr);
              this.view.createMethod.addStmt(compViewExpr
                  .set(importExpr(nestedComponentIdentifier).callFn([
                  ViewProperties.viewUtils, compileElement.injector, compileElement.appElement
              ]))
                  .toDeclStmt());
          }
          compileElement.beforeChildren();
          this._addRootNodeAndProject(compileElement);
          templateVisitAll(this, ast.children, compileElement);
          compileElement.afterChildren(this.view.nodes.length - nodeIndex - 1);
          if (isPresent(compViewExpr)) {
              var codeGenContentNodes;
              if (this.view.component.type.isHost) {
                  codeGenContentNodes = ViewProperties.projectableNodes;
              }
              else {
                  codeGenContentNodes = literalArr(compileElement.contentNodesByNgContentIndex.map(function (nodes) { return createFlatArray(nodes); }));
              }
              this.view.createMethod.addStmt(compViewExpr
                  .callMethod('create', [compileElement.getComponent(), codeGenContentNodes, NULL_EXPR])
                  .toStmt());
          }
          return null;
      };
      ViewBuilderVisitor.prototype.visitEmbeddedTemplate = function (ast, parent) {
          var nodeIndex = this.view.nodes.length;
          var fieldName = "_anchor_" + nodeIndex;
          this.view.fields.push(new ClassField(fieldName, importType(this.view.genConfig.renderTypes.renderComment)));
          this.view.createMethod.addStmt(THIS_EXPR.prop(fieldName)
              .set(ViewProperties.renderer.callMethod('createTemplateAnchor', [
              this._getParentRenderNode(parent),
              this.view.createMethod.resetDebugInfoExpr(nodeIndex, ast)
          ]))
              .toStmt());
          var renderNode = THIS_EXPR.prop(fieldName);
          var templateVariableBindings = ast.variables.map(function (varAst) { return [varAst.value.length > 0 ? varAst.value : IMPLICIT_TEMPLATE_VAR, varAst.name]; });
          var directives = ast.directives.map(function (directiveAst) { return directiveAst.directive; });
          var compileElement = new CompileElement(parent, this.view, nodeIndex, renderNode, ast, null, directives, ast.providers, ast.hasViewContainer, true, ast.references);
          this.view.nodes.push(compileElement);
          this.nestedViewCount++;
          var embeddedView = new CompileView(this.view.component, this.view.genConfig, this.view.pipeMetas, NULL_EXPR, this.view.animations, this.view.viewIndex + this.nestedViewCount, compileElement, templateVariableBindings);
          this.nestedViewCount += buildView(embeddedView, ast.children, this.targetDependencies);
          compileElement.beforeChildren();
          this._addRootNodeAndProject(compileElement);
          compileElement.afterChildren(0);
          return null;
      };
      ViewBuilderVisitor.prototype.visitAttr = function (ast, ctx) { return null; };
      ViewBuilderVisitor.prototype.visitDirective = function (ast, ctx) { return null; };
      ViewBuilderVisitor.prototype.visitEvent = function (ast, eventTargetAndNames) {
          return null;
      };
      ViewBuilderVisitor.prototype.visitReference = function (ast, ctx) { return null; };
      ViewBuilderVisitor.prototype.visitVariable = function (ast, ctx) { return null; };
      ViewBuilderVisitor.prototype.visitDirectiveProperty = function (ast, context) { return null; };
      ViewBuilderVisitor.prototype.visitElementProperty = function (ast, context) { return null; };
      return ViewBuilderVisitor;
  }());
  /**
   * Walks up the nodes while the direct parent is a container.
   *
   * Returns the outer container or the node itself when it is not a direct child of a container.
   *
   * @internal
   */
  function _getOuterContainerOrSelf(node) {
      var view = node.view;
      while (_isNgContainer(node.parent, view)) {
          node = node.parent;
      }
      return node;
  }
  /**
   * Walks up the nodes while they are container and returns the first parent which is not.
   *
   * Returns the parent of the outer container or the node itself when it is not a container.
   *
   * @internal
   */
  function _getOuterContainerParentOrSelf(el) {
      var view = el.view;
      while (_isNgContainer(el, view)) {
          el = el.parent;
      }
      return el;
  }
  function _isNgContainer(node, view) {
      return !node.isNull() && node.sourceAst.name === NG_CONTAINER_TAG &&
          node.view === view;
  }
  function _mergeHtmlAndDirectiveAttrs(declaredHtmlAttrs, directives) {
      var result = {};
      Object.keys(declaredHtmlAttrs).forEach(function (key) { result[key] = declaredHtmlAttrs[key]; });
      directives.forEach(function (directiveMeta) {
          Object.keys(directiveMeta.hostAttributes).forEach(function (name) {
              var value = directiveMeta.hostAttributes[name];
              var prevValue = result[name];
              result[name] = isPresent(prevValue) ? mergeAttributeValue(name, prevValue, value) : value;
          });
      });
      return mapToKeyValueArray(result);
  }
  function _readHtmlAttrs(attrs) {
      var htmlAttrs = {};
      attrs.forEach(function (ast) { htmlAttrs[ast.name] = ast.value; });
      return htmlAttrs;
  }
  function mergeAttributeValue(attrName, attrValue1, attrValue2) {
      if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {
          return attrValue1 + " " + attrValue2;
      }
      else {
          return attrValue2;
      }
  }
  function mapToKeyValueArray(data) {
      var entryArray = [];
      Object.keys(data).forEach(function (name) { entryArray.push([name, data[name]]); });
      // We need to sort to get a defined output order
      // for tests and for caching generated artifacts...
      ListWrapper.sort(entryArray, function (entry1, entry2) { return StringWrapper.compare(entry1[0], entry2[0]); });
      return entryArray;
  }
  function createViewTopLevelStmts(view, targetStatements) {
      var nodeDebugInfosVar = NULL_EXPR;
      if (view.genConfig.genDebugInfo) {
          nodeDebugInfosVar = variable("nodeDebugInfos_" + view.component.type.name + view.viewIndex); // fix highlighting: `
          targetStatements.push(nodeDebugInfosVar
              .set(literalArr(view.nodes.map(createStaticNodeDebugInfo), new ArrayType(new ExternalType(resolveIdentifier(Identifiers.StaticNodeDebugInfo)), [TypeModifier.Const])))
              .toDeclStmt(null, [StmtModifier.Final]));
      }
      var renderCompTypeVar = variable("renderType_" + view.component.type.name); // fix highlighting: `
      if (view.viewIndex === 0) {
          targetStatements.push(renderCompTypeVar.set(NULL_EXPR)
              .toDeclStmt(importType(resolveIdentifier(Identifiers.RenderComponentType))));
      }
      var viewClass = createViewClass(view, renderCompTypeVar, nodeDebugInfosVar);
      targetStatements.push(viewClass);
      targetStatements.push(createViewFactory(view, viewClass, renderCompTypeVar));
  }
  function createStaticNodeDebugInfo(node) {
      var compileElement = node instanceof CompileElement ? node : null;
      var providerTokens = [];
      var componentToken = NULL_EXPR;
      var varTokenEntries = [];
      if (isPresent(compileElement)) {
          providerTokens = compileElement.getProviderTokens();
          if (isPresent(compileElement.component)) {
              componentToken = createDiTokenExpression(identifierToken(compileElement.component.type));
          }
          Object.keys(compileElement.referenceTokens).forEach(function (varName) {
              var token = compileElement.referenceTokens[varName];
              varTokenEntries.push([varName, isPresent(token) ? createDiTokenExpression(token) : NULL_EXPR]);
          });
      }
      return importExpr(resolveIdentifier(Identifiers.StaticNodeDebugInfo))
          .instantiate([
          literalArr(providerTokens, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])),
          componentToken,
          literalMap(varTokenEntries, new MapType(DYNAMIC_TYPE, [TypeModifier.Const]))
      ], importType(resolveIdentifier(Identifiers.StaticNodeDebugInfo), null, [TypeModifier.Const]));
  }
  function createViewClass(view, renderCompTypeVar, nodeDebugInfosVar) {
      var viewConstructorArgs = [
          new FnParam(ViewConstructorVars.viewUtils.name, importType(resolveIdentifier(Identifiers.ViewUtils))),
          new FnParam(ViewConstructorVars.parentInjector.name, importType(resolveIdentifier(Identifiers.Injector))),
          new FnParam(ViewConstructorVars.declarationEl.name, importType(resolveIdentifier(Identifiers.AppElement)))
      ];
      var superConstructorArgs = [
          variable(view.className), renderCompTypeVar, ViewTypeEnum.fromValue(view.viewType),
          ViewConstructorVars.viewUtils, ViewConstructorVars.parentInjector,
          ViewConstructorVars.declarationEl,
          ChangeDetectorStatusEnum.fromValue(getChangeDetectionMode(view))
      ];
      if (view.genConfig.genDebugInfo) {
          superConstructorArgs.push(nodeDebugInfosVar);
      }
      var viewConstructor = new ClassMethod(null, viewConstructorArgs, [SUPER_EXPR.callFn(superConstructorArgs).toStmt()]);
      var viewMethods = [
          new ClassMethod('createInternal', [new FnParam(rootSelectorVar.name, STRING_TYPE)], generateCreateMethod(view), importType(resolveIdentifier(Identifiers.AppElement))),
          new ClassMethod('injectorGetInternal', [
              new FnParam(InjectMethodVars.token.name, DYNAMIC_TYPE),
              // Note: Can't use o.INT_TYPE here as the method in AppView uses number
              new FnParam(InjectMethodVars.requestNodeIndex.name, NUMBER_TYPE),
              new FnParam(InjectMethodVars.notFoundResult.name, DYNAMIC_TYPE)
          ], addReturnValuefNotEmpty(view.injectorGetMethod.finish(), InjectMethodVars.notFoundResult), DYNAMIC_TYPE),
          new ClassMethod('detectChangesInternal', [new FnParam(DetectChangesVars.throwOnChange.name, BOOL_TYPE)], generateDetectChangesMethod(view)),
          new ClassMethod('dirtyParentQueriesInternal', [], view.dirtyParentQueriesMethod.finish()),
          new ClassMethod('destroyInternal', [], view.destroyMethod.finish()),
          new ClassMethod('detachInternal', [], view.detachMethod.finish())
      ].concat(view.eventHandlerMethods);
      var superClass = view.genConfig.genDebugInfo ? Identifiers.DebugAppView : Identifiers.AppView;
      var viewClass = new ClassStmt(view.className, importExpr(resolveIdentifier(superClass), [getContextType(view)]), view.fields, view.getters, viewConstructor, viewMethods.filter(function (method) { return method.body.length > 0; }));
      return viewClass;
  }
  function createViewFactory(view, viewClass, renderCompTypeVar) {
      var viewFactoryArgs = [
          new FnParam(ViewConstructorVars.viewUtils.name, importType(resolveIdentifier(Identifiers.ViewUtils))),
          new FnParam(ViewConstructorVars.parentInjector.name, importType(resolveIdentifier(Identifiers.Injector))),
          new FnParam(ViewConstructorVars.declarationEl.name, importType(resolveIdentifier(Identifiers.AppElement)))
      ];
      var initRenderCompTypeStmts = [];
      var templateUrlInfo;
      if (view.component.template.templateUrl == view.component.type.moduleUrl) {
          templateUrlInfo =
              view.component.type.moduleUrl + " class " + view.component.type.name + " - inline template";
      }
      else {
          templateUrlInfo = view.component.template.templateUrl;
      }
      if (view.viewIndex === 0) {
          var animationsExpr = literalMap(view.animations.map(function (entry) { return [entry.name, entry.fnExp]; }));
          initRenderCompTypeStmts = [new IfStmt(renderCompTypeVar.identical(NULL_EXPR), [renderCompTypeVar
                      .set(ViewConstructorVars.viewUtils.callMethod('createRenderComponentType', [
                      view.genConfig.genDebugInfo ? literal(templateUrlInfo) : literal(''),
                      literal(view.component.template.ngContentSelectors.length),
                      ViewEncapsulationEnum.fromValue(view.component.template.encapsulation),
                      view.styles,
                      animationsExpr,
                  ]))
                      .toStmt()])];
      }
      return fn(viewFactoryArgs, initRenderCompTypeStmts.concat([new ReturnStatement(variable(viewClass.name)
              .instantiate(viewClass.constructorMethod.params.map(function (param) { return variable(param.name); })))]), importType(resolveIdentifier(Identifiers.AppView), [getContextType(view)]))
          .toDeclStmt(view.viewFactory.name, [StmtModifier.Final]);
  }
  function generateCreateMethod(view) {
      var parentRenderNodeExpr = NULL_EXPR;
      var parentRenderNodeStmts = [];
      if (view.viewType === ViewType.COMPONENT) {
          parentRenderNodeExpr = ViewProperties.renderer.callMethod('createViewRoot', [THIS_EXPR.prop('declarationAppElement').prop('nativeElement')]);
          parentRenderNodeStmts =
              [parentRenderNodeVar.set(parentRenderNodeExpr)
                      .toDeclStmt(importType(view.genConfig.renderTypes.renderNode), [StmtModifier.Final])];
      }
      var resultExpr;
      if (view.viewType === ViewType.HOST) {
          resultExpr = view.nodes[0].appElement;
      }
      else {
          resultExpr = NULL_EXPR;
      }
      return parentRenderNodeStmts.concat(view.createMethod.finish(), [
          THIS_EXPR
              .callMethod('init', [
              createFlatArray(view.rootNodesOrAppElements),
              literalArr(view.nodes.map(function (node) { return node.renderNode; })), literalArr(view.disposables),
              literalArr(view.subscriptions)
          ])
              .toStmt(),
          new ReturnStatement(resultExpr)
      ]);
  }
  function generateDetectChangesMethod(view) {
      var stmts = [];
      if (view.animationBindingsMethod.isEmpty() && view.detectChangesInInputsMethod.isEmpty() &&
          view.updateContentQueriesMethod.isEmpty() &&
          view.afterContentLifecycleCallbacksMethod.isEmpty() &&
          view.detectChangesRenderPropertiesMethod.isEmpty() &&
          view.updateViewQueriesMethod.isEmpty() && view.afterViewLifecycleCallbacksMethod.isEmpty()) {
          return stmts;
      }
      ListWrapper.addAll(stmts, view.animationBindingsMethod.finish());
      ListWrapper.addAll(stmts, view.detectChangesInInputsMethod.finish());
      stmts.push(THIS_EXPR.callMethod('detectContentChildrenChanges', [DetectChangesVars.throwOnChange])
          .toStmt());
      var afterContentStmts = view.updateContentQueriesMethod.finish().concat(view.afterContentLifecycleCallbacksMethod.finish());
      if (afterContentStmts.length > 0) {
          stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterContentStmts));
      }
      ListWrapper.addAll(stmts, view.detectChangesRenderPropertiesMethod.finish());
      stmts.push(THIS_EXPR.callMethod('detectViewChildrenChanges', [DetectChangesVars.throwOnChange])
          .toStmt());
      var afterViewStmts = view.updateViewQueriesMethod.finish().concat(view.afterViewLifecycleCallbacksMethod.finish());
      if (afterViewStmts.length > 0) {
          stmts.push(new IfStmt(not(DetectChangesVars.throwOnChange), afterViewStmts));
      }
      var varStmts = [];
      var readVars = findReadVarNames(stmts);
      if (readVars.has(DetectChangesVars.changed.name)) {
          varStmts.push(DetectChangesVars.changed.set(literal(true)).toDeclStmt(BOOL_TYPE));
      }
      if (readVars.has(DetectChangesVars.changes.name)) {
          varStmts.push(DetectChangesVars.changes.set(NULL_EXPR)
              .toDeclStmt(new MapType(importType(resolveIdentifier(Identifiers.SimpleChange)))));
      }
      if (readVars.has(DetectChangesVars.valUnwrapper.name)) {
          varStmts.push(DetectChangesVars.valUnwrapper
              .set(importExpr(resolveIdentifier(Identifiers.ValueUnwrapper)).instantiate([]))
              .toDeclStmt(null, [StmtModifier.Final]));
      }
      return varStmts.concat(stmts);
  }
  function addReturnValuefNotEmpty(statements, value) {
      if (statements.length > 0) {
          return statements.concat([new ReturnStatement(value)]);
      }
      else {
          return statements;
      }
  }
  function getContextType(view) {
      if (view.viewType === ViewType.COMPONENT) {
          return importType(view.component.type);
      }
      return DYNAMIC_TYPE;
  }
  function getChangeDetectionMode(view) {
      var mode;
      if (view.viewType === ViewType.COMPONENT) {
          mode = isDefaultChangeDetectionStrategy(view.component.changeDetection) ?
              ChangeDetectorStatus.CheckAlways :
              ChangeDetectorStatus.CheckOnce;
      }
      else {
          mode = ChangeDetectorStatus.CheckAlways;
      }
      return mode;
  }

  var ViewCompileResult = (function () {
      function ViewCompileResult(statements, viewFactoryVar, dependencies) {
          this.statements = statements;
          this.viewFactoryVar = viewFactoryVar;
          this.dependencies = dependencies;
      }
      return ViewCompileResult;
  }());
  var ViewCompiler = (function () {
      function ViewCompiler(_genConfig) {
          this._genConfig = _genConfig;
          this._animationCompiler = new AnimationCompiler();
      }
      ViewCompiler.prototype.compileComponent = function (component, template, styles, pipes, compiledAnimations) {
          var dependencies = [];
          var view = new CompileView(component, this._genConfig, pipes, styles, compiledAnimations, 0, CompileElement.createNull(), []);
          var statements = [];
          buildView(view, template, dependencies);
          // Need to separate binding from creation to be able to refer to
          // variables that have been declared after usage.
          bindView(view, template);
          finishView(view, statements);
          return new ViewCompileResult(statements, view.viewFactory.name, dependencies);
      };
      ViewCompiler.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      ViewCompiler.ctorParameters = [
          { type: CompilerConfig, },
      ];
      return ViewCompiler;
  }());

  var SourceModule = (function () {
      function SourceModule(moduleUrl, source) {
          this.moduleUrl = moduleUrl;
          this.source = source;
      }
      return SourceModule;
  }());
  var NgModulesSummary = (function () {
      function NgModulesSummary(ngModuleByComponent) {
          this.ngModuleByComponent = ngModuleByComponent;
      }
      return NgModulesSummary;
  }());
  var OfflineCompiler = (function () {
      function OfflineCompiler(_metadataResolver, _directiveNormalizer, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _outputEmitter, _localeId, _translationFormat) {
          this._metadataResolver = _metadataResolver;
          this._directiveNormalizer = _directiveNormalizer;
          this._templateParser = _templateParser;
          this._styleCompiler = _styleCompiler;
          this._viewCompiler = _viewCompiler;
          this._ngModuleCompiler = _ngModuleCompiler;
          this._outputEmitter = _outputEmitter;
          this._localeId = _localeId;
          this._translationFormat = _translationFormat;
          this._animationParser = new AnimationParser();
          this._animationCompiler = new AnimationCompiler();
      }
      OfflineCompiler.prototype.analyzeModules = function (ngModules) {
          var _this = this;
          var ngModuleByComponent = new Map();
          ngModules.forEach(function (ngModule) {
              var ngModuleMeta = _this._metadataResolver.getNgModuleMetadata(ngModule);
              ngModuleMeta.declaredDirectives.forEach(function (dirMeta) {
                  if (dirMeta.isComponent) {
                      ngModuleByComponent.set(dirMeta.type.reference, ngModuleMeta);
                  }
              });
          });
          return new NgModulesSummary(ngModuleByComponent);
      };
      OfflineCompiler.prototype.clearCache = function () {
          this._directiveNormalizer.clearCache();
          this._metadataResolver.clearCache();
      };
      OfflineCompiler.prototype.compile = function (moduleUrl, ngModulesSummary, components, ngModules) {
          var _this = this;
          var fileSuffix = _splitTypescriptSuffix(moduleUrl)[1];
          var statements = [];
          var exportedVars = [];
          var outputSourceModules = [];
          // compile all ng modules
          exportedVars.push.apply(exportedVars, ngModules.map(function (ngModuleType) { return _this._compileModule(ngModuleType, statements); }));
          // compile components
          return Promise
              .all(components.map(function (compType) {
              var compMeta = _this._metadataResolver.getDirectiveMetadata(compType);
              var ngModule = ngModulesSummary.ngModuleByComponent.get(compType);
              if (!ngModule) {
                  throw new Error("Cannot determine the module for component " + compMeta.type.name + "!");
              }
              return Promise
                  .all([compMeta].concat(ngModule.transitiveModule.directives).map(function (dirMeta) { return _this._directiveNormalizer.normalizeDirective(dirMeta).asyncResult; }))
                  .then(function (normalizedCompWithDirectives) {
                  var compMeta = normalizedCompWithDirectives[0], dirMetas = normalizedCompWithDirectives.slice(1);
                  _assertComponent(compMeta);
                  // compile styles
                  var stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);
                  stylesCompileResults.externalStylesheets.forEach(function (compiledStyleSheet) {
                      outputSourceModules.push(_this._codgenStyles(compiledStyleSheet, fileSuffix));
                  });
                  // compile components
                  exportedVars.push(_this._compileComponentFactory(compMeta, fileSuffix, statements), _this._compileComponent(compMeta, dirMetas, ngModule.transitiveModule.pipes, ngModule.schemas, stylesCompileResults.componentStylesheet, fileSuffix, statements));
              });
          }))
              .then(function () {
              if (statements.length > 0) {
                  outputSourceModules.unshift(_this._codegenSourceModule(_ngfactoryModuleUrl(moduleUrl), statements, exportedVars));
              }
              return outputSourceModules;
          });
      };
      OfflineCompiler.prototype._compileModule = function (ngModuleType, targetStatements) {
          var ngModule = this._metadataResolver.getNgModuleMetadata(ngModuleType);
          var providers = [];
          if (this._localeId) {
              providers.push(new CompileProviderMetadata({
                  token: resolveIdentifierToken(Identifiers.LOCALE_ID),
                  useValue: this._localeId,
              }));
          }
          if (this._translationFormat) {
              providers.push(new CompileProviderMetadata({
                  token: resolveIdentifierToken(Identifiers.TRANSLATIONS_FORMAT),
                  useValue: this._translationFormat
              }));
          }
          var appCompileResult = this._ngModuleCompiler.compile(ngModule, providers);
          appCompileResult.dependencies.forEach(function (dep) {
              dep.placeholder.name = _componentFactoryName(dep.comp);
              dep.placeholder.moduleUrl = _ngfactoryModuleUrl(dep.comp.moduleUrl);
          });
          targetStatements.push.apply(targetStatements, appCompileResult.statements);
          return appCompileResult.ngModuleFactoryVar;
      };
      OfflineCompiler.prototype._compileComponentFactory = function (compMeta, fileSuffix, targetStatements) {
          var hostMeta = createHostComponentMeta(compMeta);
          var hostViewFactoryVar = this._compileComponent(hostMeta, [compMeta], [], [], null, fileSuffix, targetStatements);
          var compFactoryVar = _componentFactoryName(compMeta.type);
          targetStatements.push(variable(compFactoryVar)
              .set(importExpr(resolveIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)])
              .instantiate([
              literal(compMeta.selector),
              variable(hostViewFactoryVar),
              importExpr(compMeta.type),
          ], importType(resolveIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)], [TypeModifier.Const])))
              .toDeclStmt(null, [StmtModifier.Final]));
          return compFactoryVar;
      };
      OfflineCompiler.prototype._compileComponent = function (compMeta, directives, pipes, schemas, componentStyles, fileSuffix, targetStatements) {
          var parsedAnimations = this._animationParser.parseComponent(compMeta);
          var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, schemas, compMeta.type.name);
          var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);
          var compiledAnimations = this._animationCompiler.compile(compMeta.type.name, parsedAnimations);
          var viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, pipes, compiledAnimations);
          if (componentStyles) {
              targetStatements.push.apply(targetStatements, _resolveStyleStatements(componentStyles, fileSuffix));
          }
          compiledAnimations.forEach(function (entry) { entry.statements.forEach(function (statement) { targetStatements.push(statement); }); });
          targetStatements.push.apply(targetStatements, _resolveViewStatements(viewResult));
          return viewResult.viewFactoryVar;
      };
      OfflineCompiler.prototype._codgenStyles = function (stylesCompileResult, fileSuffix) {
          _resolveStyleStatements(stylesCompileResult, fileSuffix);
          return this._codegenSourceModule(_stylesModuleUrl(stylesCompileResult.meta.moduleUrl, stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);
      };
      OfflineCompiler.prototype._codegenSourceModule = function (moduleUrl, statements, exportedVars) {
          return new SourceModule(moduleUrl, this._outputEmitter.emitStatements(moduleUrl, statements, exportedVars));
      };
      return OfflineCompiler;
  }());
  function _resolveViewStatements(compileResult) {
      compileResult.dependencies.forEach(function (dep) {
          if (dep instanceof ViewFactoryDependency) {
              var vfd = dep;
              vfd.placeholder.moduleUrl = _ngfactoryModuleUrl(vfd.comp.moduleUrl);
          }
          else if (dep instanceof ComponentFactoryDependency) {
              var cfd = dep;
              cfd.placeholder.name = _componentFactoryName(cfd.comp);
              cfd.placeholder.moduleUrl = _ngfactoryModuleUrl(cfd.comp.moduleUrl);
          }
      });
      return compileResult.statements;
  }
  function _resolveStyleStatements(compileResult, fileSuffix) {
      compileResult.dependencies.forEach(function (dep) {
          dep.valuePlaceholder.moduleUrl = _stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix);
      });
      return compileResult.statements;
  }
  function _ngfactoryModuleUrl(compUrl) {
      var urlWithSuffix = _splitTypescriptSuffix(compUrl);
      return urlWithSuffix[0] + ".ngfactory" + urlWithSuffix[1];
  }
  function _componentFactoryName(comp) {
      return comp.name + "NgFactory";
  }
  function _stylesModuleUrl(stylesheetUrl, shim, suffix) {
      return shim ? stylesheetUrl + ".shim" + suffix : "" + stylesheetUrl + suffix;
  }
  function _assertComponent(meta) {
      if (!meta.isComponent) {
          throw new Error("Could not compile '" + meta.type.name + "' because it is not a component.");
      }
  }
  function _splitTypescriptSuffix(path) {
      if (path.endsWith('.d.ts')) {
          return [path.slice(0, -5), '.ts'];
      }
      var lastDot = path.lastIndexOf('.');
      if (lastDot !== -1) {
          return [path.substring(0, lastDot), path.substring(lastDot)];
      }
      return [path, ''];
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * An interface for retrieving documents by URL that the compiler uses
   * to load templates.
   */
  var ResourceLoader = (function () {
      function ResourceLoader() {
      }
      ResourceLoader.prototype.get = function (url) { return null; };
      return ResourceLoader;
  }());

  var _ASSET_SCHEME = 'asset:';
  function createOfflineCompileUrlResolver() {
      return new UrlResolver(_ASSET_SCHEME);
  }
  /**
   * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
   */
  var DEFAULT_PACKAGE_URL_PROVIDER = {
      provide: _angular_core.PACKAGE_ROOT_URL,
      useValue: '/'
  };
  /**
   * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
   *
   * This class can be overridden by the application developer to create custom behavior.
   *
   * See {@link Compiler}
   *
   * ## Example
   *
   * {@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}
   *
   * @security  When compiling templates at runtime, you must
   * ensure that the entire template comes from a trusted source.
   * Attacker-controlled data introduced by a template could expose your
   * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
   */
  var UrlResolver = (function () {
      function UrlResolver(_packagePrefix) {
          if (_packagePrefix === void 0) { _packagePrefix = null; }
          this._packagePrefix = _packagePrefix;
      }
      /**
       * Resolves the `url` given the `baseUrl`:
       * - when the `url` is null, the `baseUrl` is returned,
       * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
       * `baseUrl` and `url`,
       * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
       * returned as is (ignoring the `baseUrl`)
       */
      UrlResolver.prototype.resolve = function (baseUrl, url) {
          var resolvedUrl = url;
          if (isPresent(baseUrl) && baseUrl.length > 0) {
              resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
          }
          var resolvedParts = _split(resolvedUrl);
          var prefix = this._packagePrefix;
          if (isPresent(prefix) && isPresent(resolvedParts) &&
              resolvedParts[_ComponentIndex.Scheme] == 'package') {
              var path = resolvedParts[_ComponentIndex.Path];
              if (this._packagePrefix === _ASSET_SCHEME) {
                  var pathSegements = path.split(/\//);
                  resolvedUrl = "asset:" + pathSegements[0] + "/lib/" + pathSegements.slice(1).join('/');
              }
              else {
                  prefix = StringWrapper.stripRight(prefix, '/');
                  path = StringWrapper.stripLeft(path, '/');
                  return prefix + "/" + path;
              }
          }
          return resolvedUrl;
      };
      UrlResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      UrlResolver.ctorParameters = [
          { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.PACKAGE_ROOT_URL,] },] },
      ];
      return UrlResolver;
  }());
  /**
   * Extract the scheme of a URL.
   */
  function getUrlScheme(url) {
      var match = _split(url);
      return (match && match[_ComponentIndex.Scheme]) || '';
  }
  // The code below is adapted from Traceur:
  // https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js
  /**
   * Builds a URI string from already-encoded parts.
   *
   * No encoding is performed.  Any component may be omitted as either null or
   * undefined.
   *
   * @param opt_scheme The scheme such as 'http'.
   * @param opt_userInfo The user name before the '@'.
   * @param opt_domain The domain such as 'www.google.com', already
   *     URI-encoded.
   * @param opt_port The port number.
   * @param opt_path The path, already URI-encoded.  If it is not
   *     empty, it must begin with a slash.
   * @param opt_queryData The URI-encoded query data.
   * @param opt_fragment The URI-encoded fragment identifier.
   * @return The fully combined URI.
   */
  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
      var out = [];
      if (isPresent(opt_scheme)) {
          out.push(opt_scheme + ':');
      }
      if (isPresent(opt_domain)) {
          out.push('//');
          if (isPresent(opt_userInfo)) {
              out.push(opt_userInfo + '@');
          }
          out.push(opt_domain);
          if (isPresent(opt_port)) {
              out.push(':' + opt_port);
          }
      }
      if (isPresent(opt_path)) {
          out.push(opt_path);
      }
      if (isPresent(opt_queryData)) {
          out.push('?' + opt_queryData);
      }
      if (isPresent(opt_fragment)) {
          out.push('#' + opt_fragment);
      }
      return out.join('');
  }
  /**
   * A regular expression for breaking a URI into its component parts.
   *
   * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
   * As the "first-match-wins" algorithm is identical to the "greedy"
   * disambiguation method used by POSIX regular expressions, it is natural and
   * commonplace to use a regular expression for parsing the potential five
   * components of a URI reference.
   *
   * The following line is the regular expression for breaking-down a
   * well-formed URI reference into its components.
   *
   * <pre>
   * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
   *  12            3  4          5       6  7        8 9
   * </pre>
   *
   * The numbers in the second line above are only to assist readability; they
   * indicate the reference points for each subexpression (i.e., each paired
   * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
   * For example, matching the above expression to
   * <pre>
   *     http://www.ics.uci.edu/pub/ietf/uri/#Related
   * </pre>
   * results in the following subexpression matches:
   * <pre>
   *    $1 = http:
   *    $2 = http
   *    $3 = //www.ics.uci.edu
   *    $4 = www.ics.uci.edu
   *    $5 = /pub/ietf/uri/
   *    $6 = <undefined>
   *    $7 = <undefined>
   *    $8 = #Related
   *    $9 = Related
   * </pre>
   * where <undefined> indicates that the component is not present, as is the
   * case for the query component in the above example. Therefore, we can
   * determine the value of the five components as
   * <pre>
   *    scheme    = $2
   *    authority = $4
   *    path      = $5
   *    query     = $7
   *    fragment  = $9
   * </pre>
   *
   * The regular expression has been modified slightly to expose the
   * userInfo, domain, and port separately from the authority.
   * The modified version yields
   * <pre>
   *    $1 = http              scheme
   *    $2 = <undefined>       userInfo -\
   *    $3 = www.ics.uci.edu   domain     | authority
   *    $4 = <undefined>       port     -/
   *    $5 = /pub/ietf/uri/    path
   *    $6 = <undefined>       query without ?
   *    $7 = Related           fragment without #
   * </pre>
   * @type {!RegExp}
   * @internal
   */
  var _splitRe = new RegExp('^' +
      '(?:' +
      '([^:/?#.]+)' +
      // used by other URL parts such as :,
      // ?, /, #, and .
      ':)?' +
      '(?://' +
      '(?:([^/?#]*)@)?' +
      '([\\w\\d\\-\\u0100-\\uffff.%]*)' +
      // digits, dashes, dots, percent
      // escapes, and unicode characters.
      '(?::([0-9]+))?' +
      ')?' +
      '([^?#]+)?' +
      '(?:\\?([^#]*))?' +
      '(?:#(.*))?' +
      '$');
  /**
   * The index of each URI component in the return value of goog.uri.utils.split.
   * @enum {number}
   */
  var _ComponentIndex;
  (function (_ComponentIndex) {
      _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
      _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
      _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
      _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
      _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
      _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
      _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
  })(_ComponentIndex || (_ComponentIndex = {}));
  /**
   * Splits a URI into its component parts.
   *
   * Each component can be accessed via the component indices; for example:
   * <pre>
   * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
   * </pre>
   *
   * @param uri The URI string to examine.
   * @return Each component still URI-encoded.
   *     Each component that is present will contain the encoded value, whereas
   *     components that are not present will be undefined or empty, depending
   *     on the browser's regular expression implementation.  Never null, since
   *     arbitrary strings may still look like path names.
   */
  function _split(uri) {
      return uri.match(_splitRe);
  }
  /**
    * Removes dot segments in given path component, as described in
    * RFC 3986, section 5.2.4.
    *
    * @param path A non-empty path component.
    * @return Path component with removed dot segments.
    */
  function _removeDotSegments(path) {
      if (path == '/')
          return '/';
      var leadingSlash = path[0] == '/' ? '/' : '';
      var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
      var segments = path.split('/');
      var out = [];
      var up = 0;
      for (var pos = 0; pos < segments.length; pos++) {
          var segment = segments[pos];
          switch (segment) {
              case '':
              case '.':
                  break;
              case '..':
                  if (out.length > 0) {
                      out.pop();
                  }
                  else {
                      up++;
                  }
                  break;
              default:
                  out.push(segment);
          }
      }
      if (leadingSlash == '') {
          while (up-- > 0) {
              out.unshift('..');
          }
          if (out.length === 0)
              out.push('.');
      }
      return leadingSlash + out.join('/') + trailingSlash;
  }
  /**
   * Takes an array of the parts from split and canonicalizes the path part
   * and then joins all the parts.
   */
  function _joinAndCanonicalizePath(parts) {
      var path = parts[_ComponentIndex.Path];
      path = isBlank(path) ? '' : _removeDotSegments(path);
      parts[_ComponentIndex.Path] = path;
      return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
  }
  /**
   * Resolves a URL.
   * @param base The URL acting as the base URL.
   * @param to The URL to resolve.
   */
  function _resolveUrl(base, url) {
      var parts = _split(encodeURI(url));
      var baseParts = _split(base);
      if (isPresent(parts[_ComponentIndex.Scheme])) {
          return _joinAndCanonicalizePath(parts);
      }
      else {
          parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
      }
      for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
          if (isBlank(parts[i])) {
              parts[i] = baseParts[i];
          }
      }
      if (parts[_ComponentIndex.Path][0] == '/') {
          return _joinAndCanonicalizePath(parts);
      }
      var path = baseParts[_ComponentIndex.Path];
      if (isBlank(path))
          path = '/';
      var index = path.lastIndexOf('/');
      path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
      parts[_ComponentIndex.Path] = path;
      return _joinAndCanonicalizePath(parts);
  }

  var DirectiveNormalizer = (function () {
      function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {
          this._resourceLoader = _resourceLoader;
          this._urlResolver = _urlResolver;
          this._htmlParser = _htmlParser;
          this._config = _config;
          this._resourceLoaderCache = new Map();
      }
      DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };
      DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {
          var _this = this;
          if (!normalizedDirective.isComponent) {
              return;
          }
          this._resourceLoaderCache.delete(normalizedDirective.template.templateUrl);
          normalizedDirective.template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(stylesheet.moduleUrl); });
      };
      DirectiveNormalizer.prototype._fetch = function (url) {
          var result = this._resourceLoaderCache.get(url);
          if (!result) {
              result = this._resourceLoader.get(url);
              this._resourceLoaderCache.set(url, result);
          }
          return result;
      };
      DirectiveNormalizer.prototype.normalizeDirective = function (directive) {
          var _this = this;
          if (!directive.isComponent) {
              // For non components there is nothing to be normalized yet.
              return new SyncAsyncResult(directive, Promise.resolve(directive));
          }
          var normalizedTemplateSync = null;
          var normalizedTemplateAsync;
          if (isPresent(directive.template.template)) {
              normalizedTemplateSync = this.normalizeTemplateSync(directive.type, directive.template);
              normalizedTemplateAsync = Promise.resolve(normalizedTemplateSync);
          }
          else if (directive.template.templateUrl) {
              normalizedTemplateAsync = this.normalizeTemplateAsync(directive.type, directive.template);
          }
          else {
              throw new Error("No template specified for component " + directive.type.name);
          }
          if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {
              // sync case
              var normalizedDirective = _cloneDirectiveWithTemplate(directive, normalizedTemplateSync);
              return new SyncAsyncResult(normalizedDirective, Promise.resolve(normalizedDirective));
          }
          else {
              // async case
              return new SyncAsyncResult(null, normalizedTemplateAsync
                  .then(function (normalizedTemplate) { return _this.normalizeExternalStylesheets(normalizedTemplate); })
                  .then(function (normalizedTemplate) {
                  return _cloneDirectiveWithTemplate(directive, normalizedTemplate);
              }));
          }
      };
      DirectiveNormalizer.prototype.normalizeTemplateSync = function (directiveType, template) {
          return this.normalizeLoadedTemplate(directiveType, template, template.template, directiveType.moduleUrl);
      };
      DirectiveNormalizer.prototype.normalizeTemplateAsync = function (directiveType, template) {
          var _this = this;
          var templateUrl = this._urlResolver.resolve(directiveType.moduleUrl, template.templateUrl);
          return this._fetch(templateUrl)
              .then(function (value) { return _this.normalizeLoadedTemplate(directiveType, template, value, templateUrl); });
      };
      DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (directiveType, templateMeta, template, templateAbsUrl) {
          var interpolationConfig = InterpolationConfig.fromArray(templateMeta.interpolation);
          var rootNodesAndErrors = this._htmlParser.parse(template, directiveType.name, false, interpolationConfig);
          if (rootNodesAndErrors.errors.length > 0) {
              var errorString = rootNodesAndErrors.errors.join('\n');
              throw new Error("Template parse errors:\n" + errorString);
          }
          var templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({
              styles: templateMeta.styles,
              styleUrls: templateMeta.styleUrls,
              moduleUrl: directiveType.moduleUrl
          }));
          var visitor = new TemplatePreparseVisitor();
          visitAll(visitor, rootNodesAndErrors.rootNodes);
          var templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));
          var encapsulation = templateMeta.encapsulation;
          if (isBlank(encapsulation)) {
              encapsulation = this._config.defaultEncapsulation;
          }
          var styles = templateMetadataStyles.styles.concat(templateStyles.styles);
          var styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
          if (encapsulation === _angular_core.ViewEncapsulation.Emulated && styles.length === 0 &&
              styleUrls.length === 0) {
              encapsulation = _angular_core.ViewEncapsulation.None;
          }
          return new CompileTemplateMetadata({
              encapsulation: encapsulation,
              template: template,
              templateUrl: templateAbsUrl, styles: styles, styleUrls: styleUrls,
              externalStylesheets: templateMeta.externalStylesheets,
              ngContentSelectors: visitor.ngContentSelectors,
              animations: templateMeta.animations,
              interpolation: templateMeta.interpolation,
          });
      };
      DirectiveNormalizer.prototype.normalizeExternalStylesheets = function (templateMeta) {
          return this._loadMissingExternalStylesheets(templateMeta.styleUrls)
              .then(function (externalStylesheets) { return new CompileTemplateMetadata({
              encapsulation: templateMeta.encapsulation,
              template: templateMeta.template,
              templateUrl: templateMeta.templateUrl,
              styles: templateMeta.styles,
              styleUrls: templateMeta.styleUrls,
              externalStylesheets: externalStylesheets,
              ngContentSelectors: templateMeta.ngContentSelectors,
              animations: templateMeta.animations,
              interpolation: templateMeta.interpolation
          }); });
      };
      DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {
          var _this = this;
          if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }
          return Promise
              .all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })
              .map(function (styleUrl) { return _this._fetch(styleUrl).then(function (loadedStyle) {
              var stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));
              loadedStylesheets.set(styleUrl, stylesheet);
              return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
          }); }))
              .then(function (_) { return MapWrapper.values(loadedStylesheets); });
      };
      DirectiveNormalizer.prototype.normalizeStylesheet = function (stylesheet) {
          var _this = this;
          var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)
              .map(function (url) { return _this._urlResolver.resolve(stylesheet.moduleUrl, url); });
          var allStyles = stylesheet.styles.map(function (style) {
              var styleWithImports = extractStyleUrls(_this._urlResolver, stylesheet.moduleUrl, style);
              allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);
              return styleWithImports.style;
          });
          return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: stylesheet.moduleUrl });
      };
      DirectiveNormalizer.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      DirectiveNormalizer.ctorParameters = [
          { type: ResourceLoader, },
          { type: UrlResolver, },
          { type: HtmlParser, },
          { type: CompilerConfig, },
      ];
      return DirectiveNormalizer;
  }());
  var TemplatePreparseVisitor = (function () {
      function TemplatePreparseVisitor() {
          this.ngContentSelectors = [];
          this.styles = [];
          this.styleUrls = [];
          this.ngNonBindableStackCount = 0;
      }
      TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {
          var preparsedElement = preparseElement(ast);
          switch (preparsedElement.type) {
              case PreparsedElementType.NG_CONTENT:
                  if (this.ngNonBindableStackCount === 0) {
                      this.ngContentSelectors.push(preparsedElement.selectAttr);
                  }
                  break;
              case PreparsedElementType.STYLE:
                  var textContent = '';
                  ast.children.forEach(function (child) {
                      if (child instanceof Text) {
                          textContent += child.value;
                      }
                  });
                  this.styles.push(textContent);
                  break;
              case PreparsedElementType.STYLESHEET:
                  this.styleUrls.push(preparsedElement.hrefAttr);
                  break;
              default:
                  break;
          }
          if (preparsedElement.nonBindable) {
              this.ngNonBindableStackCount++;
          }
          visitAll(this, ast.children);
          if (preparsedElement.nonBindable) {
              this.ngNonBindableStackCount--;
          }
          return null;
      };
      TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };
      TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };
      TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };
      TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { return null; };
      TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) { return null; };
      return TemplatePreparseVisitor;
  }());
  function _cloneDirectiveWithTemplate(directive, template) {
      return new CompileDirectiveMetadata({
          type: directive.type,
          isComponent: directive.isComponent,
          selector: directive.selector,
          exportAs: directive.exportAs,
          changeDetection: directive.changeDetection,
          inputs: directive.inputs,
          outputs: directive.outputs,
          hostListeners: directive.hostListeners,
          hostProperties: directive.hostProperties,
          hostAttributes: directive.hostAttributes,
          providers: directive.providers,
          viewProviders: directive.viewProviders,
          queries: directive.queries,
          viewQueries: directive.viewQueries,
          entryComponents: directive.entryComponents, template: template,
      });
  }

  /*
   * Resolve a `Type` for {@link Directive}.
   *
   * This interface can be overridden by the application developer to create custom behavior.
   *
   * See {@link Compiler}
   */
  var DirectiveResolver = (function () {
      function DirectiveResolver(_reflector) {
          if (_reflector === void 0) { _reflector = reflector; }
          this._reflector = _reflector;
      }
      /**
       * Return {@link Directive} for a given `Type`.
       */
      DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          var typeMetadata = this._reflector.annotations(_angular_core.resolveForwardRef(type));
          if (typeMetadata) {
              var metadata = typeMetadata.find(isDirectiveMetadata);
              if (metadata) {
                  var propertyMetadata = this._reflector.propMetadata(type);
                  return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);
              }
          }
          if (throwIfNotFound) {
              throw new Error("No Directive annotation found on " + stringify(type));
          }
          return null;
      };
      DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {
          var inputs = [];
          var outputs = [];
          var host = {};
          var queries = {};
          Object.keys(propertyMetadata).forEach(function (propName) {
              propertyMetadata[propName].forEach(function (a) {
                  if (a instanceof _angular_core.Input) {
                      if (a.bindingPropertyName) {
                          inputs.push(propName + ": " + a.bindingPropertyName);
                      }
                      else {
                          inputs.push(propName);
                      }
                  }
                  else if (a instanceof _angular_core.Output) {
                      var output = a;
                      if (output.bindingPropertyName) {
                          outputs.push(propName + ": " + output.bindingPropertyName);
                      }
                      else {
                          outputs.push(propName);
                      }
                  }
                  else if (a instanceof _angular_core.HostBinding) {
                      var hostBinding = a;
                      if (hostBinding.hostPropertyName) {
                          host[("[" + hostBinding.hostPropertyName + "]")] = propName;
                      }
                      else {
                          host[("[" + propName + "]")] = propName;
                      }
                  }
                  else if (a instanceof _angular_core.HostListener) {
                      var hostListener = a;
                      var args = hostListener.args || [];
                      host[("(" + hostListener.eventName + ")")] = propName + "(" + args.join(',') + ")";
                  }
                  else if (a instanceof _angular_core.Query) {
                      queries[propName] = a;
                  }
              });
          });
          return this._merge(dm, inputs, outputs, host, queries, directiveType);
      };
      DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [null, def])[1].trim(); };
      DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, directiveType) {
          var _this = this;
          var mergedInputs = inputs;
          if (directive.inputs) {
              var inputNames_1 = directive.inputs.map(function (def) { return _this._extractPublicName(def); });
              inputs.forEach(function (inputDef) {
                  var publicName = _this._extractPublicName(inputDef);
                  if (inputNames_1.indexOf(publicName) > -1) {
                      throw new Error("Input '" + publicName + "' defined multiple times in '" + stringify(directiveType) + "'");
                  }
              });
              mergedInputs.unshift.apply(mergedInputs, directive.inputs);
          }
          var mergedOutputs = outputs;
          if (directive.outputs) {
              var outputNames_1 = directive.outputs.map(function (def) { return _this._extractPublicName(def); });
              outputs.forEach(function (outputDef) {
                  var publicName = _this._extractPublicName(outputDef);
                  if (outputNames_1.indexOf(publicName) > -1) {
                      throw new Error("Output event '" + publicName + "' defined multiple times in '" + stringify(directiveType) + "'");
                  }
              });
              mergedOutputs.unshift.apply(mergedOutputs, directive.outputs);
          }
          var mergedHost = directive.host ? StringMapWrapper.merge(directive.host, host) : host;
          var mergedQueries = directive.queries ? StringMapWrapper.merge(directive.queries, queries) : queries;
          if (directive instanceof _angular_core.Component) {
              return new _angular_core.Component({
                  selector: directive.selector,
                  inputs: mergedInputs,
                  outputs: mergedOutputs,
                  host: mergedHost,
                  exportAs: directive.exportAs,
                  moduleId: directive.moduleId,
                  queries: mergedQueries,
                  changeDetection: directive.changeDetection,
                  providers: directive.providers,
                  viewProviders: directive.viewProviders,
                  entryComponents: directive.entryComponents,
                  template: directive.template,
                  templateUrl: directive.templateUrl,
                  styles: directive.styles,
                  styleUrls: directive.styleUrls,
                  encapsulation: directive.encapsulation,
                  animations: directive.animations,
                  interpolation: directive.interpolation
              });
          }
          else {
              return new _angular_core.Directive({
                  selector: directive.selector,
                  inputs: mergedInputs,
                  outputs: mergedOutputs,
                  host: mergedHost,
                  exportAs: directive.exportAs,
                  queries: mergedQueries,
                  providers: directive.providers
              });
          }
      };
      DirectiveResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      DirectiveResolver.ctorParameters = [
          { type: ReflectorReader, },
      ];
      return DirectiveResolver;
  }());
  function isDirectiveMetadata(type) {
      return type instanceof _angular_core.Directive;
  }

  var LIFECYCLE_INTERFACES = MapWrapper.createFromPairs([
      [LifecycleHooks.OnInit, _angular_core.OnInit],
      [LifecycleHooks.OnDestroy, _angular_core.OnDestroy],
      [LifecycleHooks.DoCheck, _angular_core.DoCheck],
      [LifecycleHooks.OnChanges, _angular_core.OnChanges],
      [LifecycleHooks.AfterContentInit, _angular_core.AfterContentInit],
      [LifecycleHooks.AfterContentChecked, _angular_core.AfterContentChecked],
      [LifecycleHooks.AfterViewInit, _angular_core.AfterViewInit],
      [LifecycleHooks.AfterViewChecked, _angular_core.AfterViewChecked],
  ]);
  var LIFECYCLE_PROPS = MapWrapper.createFromPairs([
      [LifecycleHooks.OnInit, 'ngOnInit'],
      [LifecycleHooks.OnDestroy, 'ngOnDestroy'],
      [LifecycleHooks.DoCheck, 'ngDoCheck'],
      [LifecycleHooks.OnChanges, 'ngOnChanges'],
      [LifecycleHooks.AfterContentInit, 'ngAfterContentInit'],
      [LifecycleHooks.AfterContentChecked, 'ngAfterContentChecked'],
      [LifecycleHooks.AfterViewInit, 'ngAfterViewInit'],
      [LifecycleHooks.AfterViewChecked, 'ngAfterViewChecked'],
  ]);
  function hasLifecycleHook(hook, token) {
      var lcInterface = LIFECYCLE_INTERFACES.get(hook);
      var lcProp = LIFECYCLE_PROPS.get(hook);
      return reflector.hasLifecycleHook(token, lcInterface, lcProp);
  }

  function _isNgModuleMetadata(obj) {
      return obj instanceof _angular_core.NgModule;
  }
  /**
   * Resolves types to {@link NgModule}.
   */
  var NgModuleResolver = (function () {
      function NgModuleResolver(_reflector) {
          if (_reflector === void 0) { _reflector = reflector; }
          this._reflector = _reflector;
      }
      NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          var ngModuleMeta = this._reflector.annotations(type).find(_isNgModuleMetadata);
          if (isPresent(ngModuleMeta)) {
              return ngModuleMeta;
          }
          else {
              if (throwIfNotFound) {
                  throw new Error("No NgModule metadata found for '" + stringify(type) + "'.");
              }
              return null;
          }
      };
      NgModuleResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      NgModuleResolver.ctorParameters = [
          { type: ReflectorReader, },
      ];
      return NgModuleResolver;
  }());

  function _isPipeMetadata(type) {
      return type instanceof _angular_core.Pipe;
  }
  /**
   * Resolve a `Type` for {@link Pipe}.
   *
   * This interface can be overridden by the application developer to create custom behavior.
   *
   * See {@link Compiler}
   */
  var PipeResolver = (function () {
      function PipeResolver(_reflector) {
          if (_reflector === void 0) { _reflector = reflector; }
          this._reflector = _reflector;
      }
      /**
       * Return {@link Pipe} for a given `Type`.
       */
      PipeResolver.prototype.resolve = function (type, throwIfNotFound) {
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          var metas = this._reflector.annotations(_angular_core.resolveForwardRef(type));
          if (isPresent(metas)) {
              var annotation = metas.find(_isPipeMetadata);
              if (isPresent(annotation)) {
                  return annotation;
              }
          }
          if (throwIfNotFound) {
              throw new Error("No Pipe decorator found on " + stringify(type));
          }
          return null;
      };
      PipeResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      PipeResolver.ctorParameters = [
          { type: ReflectorReader, },
      ];
      return PipeResolver;
  }());

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$15 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var CompileMetadataResolver = (function () {
      function CompileMetadataResolver(_ngModuleResolver, _directiveResolver, _pipeResolver, _schemaRegistry, _reflector) {
          if (_reflector === void 0) { _reflector = reflector; }
          this._ngModuleResolver = _ngModuleResolver;
          this._directiveResolver = _directiveResolver;
          this._pipeResolver = _pipeResolver;
          this._schemaRegistry = _schemaRegistry;
          this._reflector = _reflector;
          this._directiveCache = new Map();
          this._pipeCache = new Map();
          this._ngModuleCache = new Map();
          this._ngModuleOfTypes = new Map();
          this._anonymousTypes = new Map();
          this._anonymousTypeIndex = 0;
      }
      CompileMetadataResolver.prototype.sanitizeTokenName = function (token) {
          var identifier = stringify(token);
          if (identifier.indexOf('(') >= 0) {
              // case: anonymous functions!
              var found = this._anonymousTypes.get(token);
              if (!found) {
                  this._anonymousTypes.set(token, this._anonymousTypeIndex++);
                  found = this._anonymousTypes.get(token);
              }
              identifier = "anonymous_token_" + found + "_";
          }
          return sanitizeIdentifier(identifier);
      };
      CompileMetadataResolver.prototype.clearCacheFor = function (type) {
          this._directiveCache.delete(type);
          this._pipeCache.delete(type);
          this._ngModuleOfTypes.delete(type);
          // Clear all of the NgModule as they contain transitive information!
          this._ngModuleCache.clear();
      };
      CompileMetadataResolver.prototype.clearCache = function () {
          this._directiveCache.clear();
          this._pipeCache.clear();
          this._ngModuleCache.clear();
          this._ngModuleOfTypes.clear();
      };
      CompileMetadataResolver.prototype.getAnimationEntryMetadata = function (entry) {
          var _this = this;
          var defs = entry.definitions.map(function (def) { return _this.getAnimationStateMetadata(def); });
          return new CompileAnimationEntryMetadata(entry.name, defs);
      };
      CompileMetadataResolver.prototype.getAnimationStateMetadata = function (value) {
          if (value instanceof _angular_core.AnimationStateDeclarationMetadata) {
              var styles = this.getAnimationStyleMetadata(value.styles);
              return new CompileAnimationStateDeclarationMetadata(value.stateNameExpr, styles);
          }
          if (value instanceof _angular_core.AnimationStateTransitionMetadata) {
              return new CompileAnimationStateTransitionMetadata(value.stateChangeExpr, this.getAnimationMetadata(value.steps));
          }
          return null;
      };
      CompileMetadataResolver.prototype.getAnimationStyleMetadata = function (value) {
          return new CompileAnimationStyleMetadata(value.offset, value.styles);
      };
      CompileMetadataResolver.prototype.getAnimationMetadata = function (value) {
          var _this = this;
          if (value instanceof _angular_core.AnimationStyleMetadata) {
              return this.getAnimationStyleMetadata(value);
          }
          if (value instanceof _angular_core.AnimationKeyframesSequenceMetadata) {
              return new CompileAnimationKeyframesSequenceMetadata(value.steps.map(function (entry) { return _this.getAnimationStyleMetadata(entry); }));
          }
          if (value instanceof _angular_core.AnimationAnimateMetadata) {
              var animateData = this
                  .getAnimationMetadata(value.styles);
              return new CompileAnimationAnimateMetadata(value.timings, animateData);
          }
          if (value instanceof _angular_core.AnimationWithStepsMetadata) {
              var steps = value.steps.map(function (step) { return _this.getAnimationMetadata(step); });
              if (value instanceof _angular_core.AnimationGroupMetadata) {
                  return new CompileAnimationGroupMetadata(steps);
              }
              return new CompileAnimationSequenceMetadata(steps);
          }
          return null;
      };
      CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType, throwIfNotFound) {
          var _this = this;
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          directiveType = _angular_core.resolveForwardRef(directiveType);
          var meta = this._directiveCache.get(directiveType);
          if (!meta) {
              var dirMeta = this._directiveResolver.resolve(directiveType, throwIfNotFound);
              if (!dirMeta) {
                  return null;
              }
              var templateMeta = null;
              var changeDetectionStrategy = null;
              var viewProviders = [];
              var moduleUrl = staticTypeModuleUrl(directiveType);
              var entryComponentMetadata = [];
              var selector = dirMeta.selector;
              if (dirMeta instanceof _angular_core.Component) {
                  // Component
                  assertArrayOfStrings('styles', dirMeta.styles);
                  assertArrayOfStrings('styleUrls', dirMeta.styleUrls);
                  assertInterpolationSymbols('interpolation', dirMeta.interpolation);
                  var animations = dirMeta.animations ?
                      dirMeta.animations.map(function (e) { return _this.getAnimationEntryMetadata(e); }) :
                      null;
                  templateMeta = new CompileTemplateMetadata({
                      encapsulation: dirMeta.encapsulation,
                      template: dirMeta.template,
                      templateUrl: dirMeta.templateUrl,
                      styles: dirMeta.styles,
                      styleUrls: dirMeta.styleUrls,
                      animations: animations,
                      interpolation: dirMeta.interpolation
                  });
                  changeDetectionStrategy = dirMeta.changeDetection;
                  if (dirMeta.viewProviders) {
                      viewProviders = this.getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, "viewProviders for \"" + stringify(directiveType) + "\"");
                  }
                  moduleUrl = componentModuleUrl(this._reflector, directiveType, dirMeta);
                  if (dirMeta.entryComponents) {
                      entryComponentMetadata =
                          flattenArray(dirMeta.entryComponents)
                              .map(function (type) { return _this.getTypeMetadata(type, staticTypeModuleUrl(type)); })
                              .concat(entryComponentMetadata);
                  }
                  if (!selector) {
                      selector = this._schemaRegistry.getDefaultComponentElementName();
                  }
              }
              else {
                  // Directive
                  if (!selector) {
                      throw new Error("Directive " + stringify(directiveType) + " has no selector, please add it!");
                  }
              }
              var providers = [];
              if (isPresent(dirMeta.providers)) {
                  providers = this.getProvidersMetadata(dirMeta.providers, entryComponentMetadata, "providers for \"" + stringify(directiveType) + "\"");
              }
              var queries = [];
              var viewQueries = [];
              if (isPresent(dirMeta.queries)) {
                  queries = this.getQueriesMetadata(dirMeta.queries, false, directiveType);
                  viewQueries = this.getQueriesMetadata(dirMeta.queries, true, directiveType);
              }
              meta = CompileDirectiveMetadata.create({
                  selector: selector,
                  exportAs: dirMeta.exportAs,
                  isComponent: !!templateMeta,
                  type: this.getTypeMetadata(directiveType, moduleUrl),
                  template: templateMeta,
                  changeDetection: changeDetectionStrategy,
                  inputs: dirMeta.inputs,
                  outputs: dirMeta.outputs,
                  host: dirMeta.host,
                  providers: providers,
                  viewProviders: viewProviders,
                  queries: queries,
                  viewQueries: viewQueries,
                  entryComponents: entryComponentMetadata
              });
              this._directiveCache.set(directiveType, meta);
          }
          return meta;
      };
      CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound) {
          var _this = this;
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          moduleType = _angular_core.resolveForwardRef(moduleType);
          var compileMeta = this._ngModuleCache.get(moduleType);
          if (!compileMeta) {
              var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);
              if (!meta) {
                  return null;
              }
              var declaredDirectives_1 = [];
              var exportedDirectives_1 = [];
              var declaredPipes_1 = [];
              var exportedPipes_1 = [];
              var importedModules_1 = [];
              var exportedModules_1 = [];
              var providers_1 = [];
              var entryComponents_1 = [];
              var bootstrapComponents = [];
              var schemas = [];
              if (meta.imports) {
                  flattenArray(meta.imports).forEach(function (importedType) {
                      var importedModuleType;
                      if (isValidType(importedType)) {
                          importedModuleType = importedType;
                      }
                      else if (importedType && importedType.ngModule) {
                          var moduleWithProviders = importedType;
                          importedModuleType = moduleWithProviders.ngModule;
                          if (moduleWithProviders.providers) {
                              providers_1.push.apply(providers_1, _this.getProvidersMetadata(moduleWithProviders.providers, entryComponents_1, "provider for the NgModule '" + stringify(importedModuleType) + "'"));
                          }
                      }
                      if (importedModuleType) {
                          var importedMeta = _this.getNgModuleMetadata(importedModuleType, false);
                          if (importedMeta === null) {
                              throw new Error("Unexpected " + _this._getTypeDescriptor(importedType) + " '" + stringify(importedType) + "' imported by the module '" + stringify(moduleType) + "'");
                          }
                          importedModules_1.push(importedMeta);
                      }
                      else {
                          throw new Error("Unexpected value '" + stringify(importedType) + "' imported by the module '" + stringify(moduleType) + "'");
                      }
                  });
              }
              if (meta.exports) {
                  flattenArray(meta.exports).forEach(function (exportedType) {
                      if (!isValidType(exportedType)) {
                          throw new Error("Unexpected value '" + stringify(exportedType) + "' exported by the module '" + stringify(moduleType) + "'");
                      }
                      var exportedDirMeta;
                      var exportedPipeMeta;
                      var exportedModuleMeta;
                      if (exportedDirMeta = _this.getDirectiveMetadata(exportedType, false)) {
                          exportedDirectives_1.push(exportedDirMeta);
                      }
                      else if (exportedPipeMeta = _this.getPipeMetadata(exportedType, false)) {
                          exportedPipes_1.push(exportedPipeMeta);
                      }
                      else if (exportedModuleMeta = _this.getNgModuleMetadata(exportedType, false)) {
                          exportedModules_1.push(exportedModuleMeta);
                      }
                      else {
                          throw new Error("Unexpected " + _this._getTypeDescriptor(exportedType) + " '" + stringify(exportedType) + "' exported by the module '" + stringify(moduleType) + "'");
                      }
                  });
              }
              // Note: This will be modified later, so we rely on
              // getting a new instance every time!
              var transitiveModule_1 = this._getTransitiveNgModuleMetadata(importedModules_1, exportedModules_1);
              if (meta.declarations) {
                  flattenArray(meta.declarations).forEach(function (declaredType) {
                      if (!isValidType(declaredType)) {
                          throw new Error("Unexpected value '" + stringify(declaredType) + "' declared by the module '" + stringify(moduleType) + "'");
                      }
                      var declaredDirMeta;
                      var declaredPipeMeta;
                      if (declaredDirMeta = _this.getDirectiveMetadata(declaredType, false)) {
                          _this._addDirectiveToModule(declaredDirMeta, moduleType, transitiveModule_1, declaredDirectives_1, true);
                      }
                      else if (declaredPipeMeta = _this.getPipeMetadata(declaredType, false)) {
                          _this._addPipeToModule(declaredPipeMeta, moduleType, transitiveModule_1, declaredPipes_1, true);
                      }
                      else {
                          throw new Error("Unexpected " + _this._getTypeDescriptor(declaredType) + " '" + stringify(declaredType) + "' declared by the module '" + stringify(moduleType) + "'");
                      }
                  });
              }
              // The providers of the module have to go last
              // so that they overwrite any other provider we already added.
              if (meta.providers) {
                  providers_1.push.apply(providers_1, this.getProvidersMetadata(meta.providers, entryComponents_1, "provider for the NgModule '" + stringify(moduleType) + "'"));
              }
              if (meta.entryComponents) {
                  entryComponents_1.push.apply(entryComponents_1, flattenArray(meta.entryComponents)
                      .map(function (type) { return _this.getTypeMetadata(type, staticTypeModuleUrl(type)); }));
              }
              if (meta.bootstrap) {
                  var typeMetadata = flattenArray(meta.bootstrap).map(function (type) {
                      if (!isValidType(type)) {
                          throw new Error("Unexpected value '" + stringify(type) + "' used in the bootstrap property of module '" + stringify(moduleType) + "'");
                      }
                      return _this.getTypeMetadata(type, staticTypeModuleUrl(type));
                  });
                  bootstrapComponents.push.apply(bootstrapComponents, typeMetadata);
              }
              entryComponents_1.push.apply(entryComponents_1, bootstrapComponents);
              if (meta.schemas) {
                  schemas.push.apply(schemas, flattenArray(meta.schemas));
              }
              (_a = transitiveModule_1.entryComponents).push.apply(_a, entryComponents_1);
              (_b = transitiveModule_1.providers).push.apply(_b, providers_1);
              compileMeta = new CompileNgModuleMetadata({
                  type: this.getTypeMetadata(moduleType, staticTypeModuleUrl(moduleType)),
                  providers: providers_1,
                  entryComponents: entryComponents_1,
                  bootstrapComponents: bootstrapComponents,
                  schemas: schemas,
                  declaredDirectives: declaredDirectives_1,
                  exportedDirectives: exportedDirectives_1,
                  declaredPipes: declaredPipes_1,
                  exportedPipes: exportedPipes_1,
                  importedModules: importedModules_1,
                  exportedModules: exportedModules_1,
                  transitiveModule: transitiveModule_1,
                  id: meta.id,
              });
              transitiveModule_1.modules.push(compileMeta);
              this._verifyModule(compileMeta);
              this._ngModuleCache.set(moduleType, compileMeta);
          }
          return compileMeta;
          var _a, _b;
      };
      CompileMetadataResolver.prototype._verifyModule = function (moduleMeta) {
          moduleMeta.exportedDirectives.forEach(function (dirMeta) {
              if (!moduleMeta.transitiveModule.directivesSet.has(dirMeta.type.reference)) {
                  throw new Error("Can't export directive " + stringify(dirMeta.type.reference) + " from " + stringify(moduleMeta.type.reference) + " as it was neither declared nor imported!");
              }
          });
          moduleMeta.exportedPipes.forEach(function (pipeMeta) {
              if (!moduleMeta.transitiveModule.pipesSet.has(pipeMeta.type.reference)) {
                  throw new Error("Can't export pipe " + stringify(pipeMeta.type.reference) + " from " + stringify(moduleMeta.type.reference) + " as it was neither declared nor imported!");
              }
          });
      };
      CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {
          if (this._directiveResolver.resolve(type, false) !== null) {
              return 'directive';
          }
          if (this._pipeResolver.resolve(type, false) !== null) {
              return 'pipe';
          }
          if (this._ngModuleResolver.resolve(type, false) !== null) {
              return 'module';
          }
          if (type.provide) {
              return 'provider';
          }
          return 'value';
      };
      CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {
          var oldModule = this._ngModuleOfTypes.get(type);
          if (oldModule && oldModule !== moduleType) {
              throw new Error(("Type " + stringify(type) + " is part of the declarations of 2 modules: " + stringify(oldModule) + " and " + stringify(moduleType) + "! ") +
                  ("Please consider moving " + stringify(type) + " to a higher module that imports " + stringify(oldModule) + " and " + stringify(moduleType) + ". ") +
                  ("You can also create a new NgModule that exports and includes " + stringify(type) + " then import that NgModule in " + stringify(oldModule) + " and " + stringify(moduleType) + "."));
          }
          this._ngModuleOfTypes.set(type, moduleType);
      };
      CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {
          // collect `providers` / `entryComponents` from all imported and all exported modules
          var transitiveModules = getTransitiveModules(importedModules.concat(exportedModules), true);
          var providers = flattenArray(transitiveModules.map(function (ngModule) { return ngModule.providers; }));
          var entryComponents = flattenArray(transitiveModules.map(function (ngModule) { return ngModule.entryComponents; }));
          var transitiveExportedModules = getTransitiveModules(importedModules, false);
          var directives = flattenArray(transitiveExportedModules.map(function (ngModule) { return ngModule.exportedDirectives; }));
          var pipes = flattenArray(transitiveExportedModules.map(function (ngModule) { return ngModule.exportedPipes; }));
          return new TransitiveCompileNgModuleMetadata(transitiveModules, providers, entryComponents, directives, pipes);
      };
      CompileMetadataResolver.prototype._addDirectiveToModule = function (dirMeta, moduleType, transitiveModule, declaredDirectives, force) {
          if (force === void 0) { force = false; }
          if (force || !transitiveModule.directivesSet.has(dirMeta.type.reference)) {
              transitiveModule.directivesSet.add(dirMeta.type.reference);
              transitiveModule.directives.push(dirMeta);
              declaredDirectives.push(dirMeta);
              this._addTypeToModule(dirMeta.type.reference, moduleType);
              return true;
          }
          return false;
      };
      CompileMetadataResolver.prototype._addPipeToModule = function (pipeMeta, moduleType, transitiveModule, declaredPipes, force) {
          if (force === void 0) { force = false; }
          if (force || !transitiveModule.pipesSet.has(pipeMeta.type.reference)) {
              transitiveModule.pipesSet.add(pipeMeta.type.reference);
              transitiveModule.pipes.push(pipeMeta);
              declaredPipes.push(pipeMeta);
              this._addTypeToModule(pipeMeta.type.reference, moduleType);
              return true;
          }
          return false;
      };
      CompileMetadataResolver.prototype.getTypeMetadata = function (type, moduleUrl, dependencies) {
          if (dependencies === void 0) { dependencies = null; }
          type = _angular_core.resolveForwardRef(type);
          return new CompileTypeMetadata({
              name: this.sanitizeTokenName(type),
              moduleUrl: moduleUrl,
              reference: type,
              diDeps: this.getDependenciesMetadata(type, dependencies),
              lifecycleHooks: LIFECYCLE_HOOKS_VALUES.filter(function (hook) { return hasLifecycleHook(hook, type); }),
          });
      };
      CompileMetadataResolver.prototype.getFactoryMetadata = function (factory, moduleUrl, dependencies) {
          if (dependencies === void 0) { dependencies = null; }
          factory = _angular_core.resolveForwardRef(factory);
          return new CompileFactoryMetadata({
              name: this.sanitizeTokenName(factory),
              moduleUrl: moduleUrl,
              reference: factory,
              diDeps: this.getDependenciesMetadata(factory, dependencies)
          });
      };
      CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType, throwIfNotFound) {
          if (throwIfNotFound === void 0) { throwIfNotFound = true; }
          pipeType = _angular_core.resolveForwardRef(pipeType);
          var meta = this._pipeCache.get(pipeType);
          if (!meta) {
              var pipeMeta = this._pipeResolver.resolve(pipeType, throwIfNotFound);
              if (!pipeMeta) {
                  return null;
              }
              meta = new CompilePipeMetadata({
                  type: this.getTypeMetadata(pipeType, staticTypeModuleUrl(pipeType)),
                  name: pipeMeta.name,
                  pure: pipeMeta.pure
              });
              this._pipeCache.set(pipeType, meta);
          }
          return meta;
      };
      CompileMetadataResolver.prototype.getDependenciesMetadata = function (typeOrFunc, dependencies) {
          var _this = this;
          var hasUnknownDeps = false;
          var params = dependencies || this._reflector.parameters(typeOrFunc) || [];
          var dependenciesMetadata = params.map(function (param) {
              var isAttribute = false;
              var isHost = false;
              var isSelf = false;
              var isSkipSelf = false;
              var isOptional = false;
              var query = null;
              var viewQuery = null;
              var token = null;
              if (Array.isArray(param)) {
                  param.forEach(function (paramEntry) {
                      if (paramEntry instanceof _angular_core.Host) {
                          isHost = true;
                      }
                      else if (paramEntry instanceof _angular_core.Self) {
                          isSelf = true;
                      }
                      else if (paramEntry instanceof _angular_core.SkipSelf) {
                          isSkipSelf = true;
                      }
                      else if (paramEntry instanceof _angular_core.Optional) {
                          isOptional = true;
                      }
                      else if (paramEntry instanceof _angular_core.Attribute) {
                          isAttribute = true;
                          token = paramEntry.attributeName;
                      }
                      else if (paramEntry instanceof _angular_core.Query) {
                          if (paramEntry.isViewQuery) {
                              viewQuery = paramEntry;
                          }
                          else {
                              query = paramEntry;
                          }
                      }
                      else if (paramEntry instanceof _angular_core.Inject) {
                          token = paramEntry.token;
                      }
                      else if (isValidType(paramEntry) && isBlank(token)) {
                          token = paramEntry;
                      }
                  });
              }
              else {
                  token = param;
              }
              if (isBlank(token)) {
                  hasUnknownDeps = true;
                  return null;
              }
              return new CompileDiDependencyMetadata({
                  isAttribute: isAttribute,
                  isHost: isHost,
                  isSelf: isSelf,
                  isSkipSelf: isSkipSelf,
                  isOptional: isOptional,
                  query: query ? _this.getQueryMetadata(query, null, typeOrFunc) : null,
                  viewQuery: viewQuery ? _this.getQueryMetadata(viewQuery, null, typeOrFunc) : null,
                  token: _this.getTokenMetadata(token)
              });
          });
          if (hasUnknownDeps) {
              var depsTokens = dependenciesMetadata.map(function (dep) { return dep ? stringify(dep.token) : '?'; }).join(', ');
              throw new Error("Can't resolve all parameters for " + stringify(typeOrFunc) + ": (" + depsTokens + ").");
          }
          return dependenciesMetadata;
      };
      CompileMetadataResolver.prototype.getTokenMetadata = function (token) {
          token = _angular_core.resolveForwardRef(token);
          var compileToken;
          if (isString(token)) {
              compileToken = new CompileTokenMetadata({ value: token });
          }
          else {
              compileToken = new CompileTokenMetadata({
                  identifier: new CompileIdentifierMetadata({
                      reference: token,
                      name: this.sanitizeTokenName(token),
                      moduleUrl: staticTypeModuleUrl(token)
                  })
              });
          }
          return compileToken;
      };
      CompileMetadataResolver.prototype.getProvidersMetadata = function (providers, targetEntryComponents, debugInfo) {
          var _this = this;
          var compileProviders = [];
          providers.forEach(function (provider, providerIdx) {
              provider = _angular_core.resolveForwardRef(provider);
              if (provider && typeof provider == 'object' && provider.hasOwnProperty('provide')) {
                  provider = new ProviderMeta(provider.provide, provider);
              }
              var compileProvider;
              if (Array.isArray(provider)) {
                  compileProvider = _this.getProvidersMetadata(provider, targetEntryComponents, debugInfo);
              }
              else if (provider instanceof ProviderMeta) {
                  var tokenMeta = _this.getTokenMetadata(provider.token);
                  if (tokenMeta.reference ===
                      resolveIdentifierToken(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS).reference) {
                      targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(provider));
                  }
                  else {
                      compileProvider = _this.getProviderMetadata(provider);
                  }
              }
              else if (isValidType(provider)) {
                  compileProvider = _this.getTypeMetadata(provider, staticTypeModuleUrl(provider));
              }
              else {
                  var providersInfo = providers.reduce(function (soFar, seenProvider, seenProviderIdx) {
                      if (seenProviderIdx < providerIdx) {
                          soFar.push("" + stringify(seenProvider));
                      }
                      else if (seenProviderIdx == providerIdx) {
                          soFar.push("?" + stringify(seenProvider) + "?");
                      }
                      else if (seenProviderIdx == providerIdx + 1) {
                          soFar.push('...');
                      }
                      return soFar;
                  }, [])
                      .join(', ');
                  throw new Error("Invalid " + (debugInfo ? debugInfo : 'provider') + " - only instances of Provider and Type are allowed, got: [" + providersInfo + "]");
              }
              if (compileProvider) {
                  compileProviders.push(compileProvider);
              }
          });
          return compileProviders;
      };
      CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider) {
          var _this = this;
          var components = [];
          var collectedIdentifiers = [];
          if (provider.useFactory || provider.useExisting || provider.useClass) {
              throw new Error("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!");
          }
          if (!provider.multi) {
              throw new Error("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!");
          }
          convertToCompileValue(provider.useValue, collectedIdentifiers);
          collectedIdentifiers.forEach(function (identifier) {
              var dirMeta = _this.getDirectiveMetadata(identifier.reference, false);
              if (dirMeta) {
                  components.push(dirMeta.type);
              }
          });
          return components;
      };
      CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {
          var compileDeps;
          var compileTypeMetadata = null;
          var compileFactoryMetadata = null;
          if (provider.useClass) {
              compileTypeMetadata = this.getTypeMetadata(provider.useClass, staticTypeModuleUrl(provider.useClass), provider.dependencies);
              compileDeps = compileTypeMetadata.diDeps;
          }
          else if (provider.useFactory) {
              compileFactoryMetadata = this.getFactoryMetadata(provider.useFactory, staticTypeModuleUrl(provider.useFactory), provider.dependencies);
              compileDeps = compileFactoryMetadata.diDeps;
          }
          return new CompileProviderMetadata({
              token: this.getTokenMetadata(provider.token),
              useClass: compileTypeMetadata,
              useValue: convertToCompileValue(provider.useValue, []),
              useFactory: compileFactoryMetadata,
              useExisting: provider.useExisting ? this.getTokenMetadata(provider.useExisting) : null,
              deps: compileDeps,
              multi: provider.multi
          });
      };
      CompileMetadataResolver.prototype.getQueriesMetadata = function (queries, isViewQuery, directiveType) {
          var _this = this;
          var res = [];
          Object.keys(queries).forEach(function (propertyName) {
              var query = queries[propertyName];
              if (query.isViewQuery === isViewQuery) {
                  res.push(_this.getQueryMetadata(query, propertyName, directiveType));
              }
          });
          return res;
      };
      CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\s*,\s*/); };
      CompileMetadataResolver.prototype.getQueryMetadata = function (q, propertyName, typeOrFunc) {
          var _this = this;
          var selectors;
          if (typeof q.selector === 'string') {
              selectors = this._queryVarBindings(q.selector).map(function (varName) { return _this.getTokenMetadata(varName); });
          }
          else {
              if (!q.selector) {
                  throw new Error("Can't construct a query for the property \"" + propertyName + "\" of \"" + stringify(typeOrFunc) + "\" since the query selector wasn't defined.");
              }
              selectors = [this.getTokenMetadata(q.selector)];
          }
          return new CompileQueryMetadata({
              selectors: selectors,
              first: q.first,
              descendants: q.descendants, propertyName: propertyName,
              read: q.read ? this.getTokenMetadata(q.read) : null
          });
      };
      CompileMetadataResolver.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      CompileMetadataResolver.ctorParameters = [
          { type: NgModuleResolver, },
          { type: DirectiveResolver, },
          { type: PipeResolver, },
          { type: ElementSchemaRegistry, },
          { type: ReflectorReader, },
      ];
      return CompileMetadataResolver;
  }());
  function getTransitiveModules(modules, includeImports, targetModules, visitedModules) {
      if (targetModules === void 0) { targetModules = []; }
      if (visitedModules === void 0) { visitedModules = new Set(); }
      modules.forEach(function (ngModule) {
          if (!visitedModules.has(ngModule.type.reference)) {
              visitedModules.add(ngModule.type.reference);
              var nestedModules = includeImports ?
                  ngModule.importedModules.concat(ngModule.exportedModules) :
                  ngModule.exportedModules;
              getTransitiveModules(nestedModules, includeImports, targetModules, visitedModules);
              // Add after recursing so imported/exported modules are before the module itself.
              // This is important for overwriting providers of imported modules!
              targetModules.push(ngModule);
          }
      });
      return targetModules;
  }
  function flattenArray(tree, out) {
      if (out === void 0) { out = []; }
      if (tree) {
          for (var i = 0; i < tree.length; i++) {
              var item = _angular_core.resolveForwardRef(tree[i]);
              if (Array.isArray(item)) {
                  flattenArray(item, out);
              }
              else {
                  out.push(item);
              }
          }
      }
      return out;
  }
  function isValidType(value) {
      return isStaticSymbol(value) || (value instanceof _angular_core.Type);
  }
  function staticTypeModuleUrl(value) {
      return isStaticSymbol(value) ? value.filePath : null;
  }
  function componentModuleUrl(reflector, type, cmpMetadata) {
      if (isStaticSymbol(type)) {
          return staticTypeModuleUrl(type);
      }
      var moduleId = cmpMetadata.moduleId;
      if (typeof moduleId === 'string') {
          var scheme = getUrlScheme(moduleId);
          return scheme ? moduleId : "package:" + moduleId + MODULE_SUFFIX;
      }
      else if (moduleId !== null && moduleId !== void 0) {
          throw new Error(("moduleId should be a string in \"" + stringify(type) + "\". See https://goo.gl/wIDDiL for more information.\n") +
              "If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.");
      }
      return reflector.importUri(type);
  }
  function convertToCompileValue(value, targetIdentifiers) {
      return visitValue(value, new _CompileValueConverter(), targetIdentifiers);
  }
  var _CompileValueConverter = (function (_super) {
      __extends$15(_CompileValueConverter, _super);
      function _CompileValueConverter() {
          _super.apply(this, arguments);
      }
      _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {
          var identifier;
          if (isStaticSymbol(value)) {
              identifier = new CompileIdentifierMetadata({ name: value.name, moduleUrl: value.filePath, reference: value });
          }
          else {
              identifier = new CompileIdentifierMetadata({ reference: value });
          }
          targetIdentifiers.push(identifier);
          return identifier;
      };
      return _CompileValueConverter;
  }(ValueTransformer));

  var ComponentFactoryDependency$1 = (function () {
      function ComponentFactoryDependency(comp, placeholder) {
          this.comp = comp;
          this.placeholder = placeholder;
      }
      return ComponentFactoryDependency;
  }());
  var NgModuleCompileResult = (function () {
      function NgModuleCompileResult(statements, ngModuleFactoryVar, dependencies) {
          this.statements = statements;
          this.ngModuleFactoryVar = ngModuleFactoryVar;
          this.dependencies = dependencies;
      }
      return NgModuleCompileResult;
  }());
  var NgModuleCompiler = (function () {
      function NgModuleCompiler() {
      }
      NgModuleCompiler.prototype.compile = function (ngModuleMeta, extraProviders) {
          var sourceFileName = isPresent(ngModuleMeta.type.moduleUrl) ?
              "in NgModule " + ngModuleMeta.type.name + " in " + ngModuleMeta.type.moduleUrl :
              "in NgModule " + ngModuleMeta.type.name;
          var sourceFile = new ParseSourceFile('', sourceFileName);
          var sourceSpan = new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));
          var deps = [];
          var bootstrapComponentFactories = [];
          var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents.map(function (entryComponent) {
              var id = new CompileIdentifierMetadata({ name: entryComponent.name });
              if (ngModuleMeta.bootstrapComponents.indexOf(entryComponent) > -1) {
                  bootstrapComponentFactories.push(id);
              }
              deps.push(new ComponentFactoryDependency$1(entryComponent, id));
              return id;
          });
          var builder = new _InjectorBuilder(ngModuleMeta, entryComponentFactories, bootstrapComponentFactories, sourceSpan);
          var providerParser = new NgModuleProviderAnalyzer(ngModuleMeta, extraProviders, sourceSpan);
          providerParser.parse().forEach(function (provider) { return builder.addProvider(provider); });
          var injectorClass = builder.build();
          var ngModuleFactoryVar = ngModuleMeta.type.name + "NgFactory";
          var ngModuleFactoryStmt = variable(ngModuleFactoryVar)
              .set(importExpr(resolveIdentifier(Identifiers.NgModuleFactory))
              .instantiate([variable(injectorClass.name), importExpr(ngModuleMeta.type)], importType(resolveIdentifier(Identifiers.NgModuleFactory), [importType(ngModuleMeta.type)], [TypeModifier.Const])))
              .toDeclStmt(null, [StmtModifier.Final]);
          var stmts = [injectorClass, ngModuleFactoryStmt];
          if (ngModuleMeta.id) {
              var registerFactoryStmt = importExpr(resolveIdentifier(Identifiers.RegisterModuleFactoryFn))
                  .callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)])
                  .toStmt();
              stmts.push(registerFactoryStmt);
          }
          return new NgModuleCompileResult(stmts, ngModuleFactoryVar, deps);
      };
      NgModuleCompiler.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      NgModuleCompiler.ctorParameters = [];
      return NgModuleCompiler;
  }());
  var _InjectorBuilder = (function () {
      function _InjectorBuilder(_ngModuleMeta, _entryComponentFactories, _bootstrapComponentFactories, _sourceSpan) {
          this._ngModuleMeta = _ngModuleMeta;
          this._entryComponentFactories = _entryComponentFactories;
          this._bootstrapComponentFactories = _bootstrapComponentFactories;
          this._sourceSpan = _sourceSpan;
          this._tokens = [];
          this._instances = new Map();
          this._fields = [];
          this._createStmts = [];
          this._destroyStmts = [];
          this._getters = [];
      }
      _InjectorBuilder.prototype.addProvider = function (resolvedProvider) {
          var _this = this;
          var providerValueExpressions = resolvedProvider.providers.map(function (provider) { return _this._getProviderValue(provider); });
          var propName = "_" + resolvedProvider.token.name + "_" + this._instances.size;
          var instance = this._createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager);
          if (resolvedProvider.lifecycleHooks.indexOf(LifecycleHooks.OnDestroy) !== -1) {
              this._destroyStmts.push(instance.callMethod('ngOnDestroy', []).toStmt());
          }
          this._tokens.push(resolvedProvider.token);
          this._instances.set(resolvedProvider.token.reference, instance);
      };
      _InjectorBuilder.prototype.build = function () {
          var _this = this;
          var getMethodStmts = this._tokens.map(function (token) {
              var providerExpr = _this._instances.get(token.reference);
              return new IfStmt(InjectMethodVars$1.token.identical(createDiTokenExpression(token)), [new ReturnStatement(providerExpr)]);
          });
          var methods = [
              new ClassMethod('createInternal', [], this._createStmts.concat(new ReturnStatement(this._instances.get(this._ngModuleMeta.type.reference))), importType(this._ngModuleMeta.type)),
              new ClassMethod('getInternal', [
                  new FnParam(InjectMethodVars$1.token.name, DYNAMIC_TYPE),
                  new FnParam(InjectMethodVars$1.notFoundResult.name, DYNAMIC_TYPE)
              ], getMethodStmts.concat([new ReturnStatement(InjectMethodVars$1.notFoundResult)]), DYNAMIC_TYPE),
              new ClassMethod('destroyInternal', [], this._destroyStmts),
          ];
          var ctor = new ClassMethod(null, [new FnParam(InjectorProps.parent.name, importType(resolveIdentifier(Identifiers.Injector)))], [SUPER_EXPR
                  .callFn([
                  variable(InjectorProps.parent.name),
                  literalArr(this._entryComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); })),
                  literalArr(this._bootstrapComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); }))
              ])
                  .toStmt()]);
          var injClassName = this._ngModuleMeta.type.name + "Injector";
          return new ClassStmt(injClassName, importExpr(resolveIdentifier(Identifiers.NgModuleInjector), [importType(this._ngModuleMeta.type)]), this._fields, this._getters, ctor, methods);
      };
      _InjectorBuilder.prototype._getProviderValue = function (provider) {
          var _this = this;
          var result;
          if (isPresent(provider.useExisting)) {
              result = this._getDependency(new CompileDiDependencyMetadata({ token: provider.useExisting }));
          }
          else if (isPresent(provider.useFactory)) {
              var deps = isPresent(provider.deps) ? provider.deps : provider.useFactory.diDeps;
              var depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });
              result = importExpr(provider.useFactory).callFn(depsExpr);
          }
          else if (isPresent(provider.useClass)) {
              var deps = isPresent(provider.deps) ? provider.deps : provider.useClass.diDeps;
              var depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });
              result =
                  importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));
          }
          else {
              result = convertValueToOutputAst(provider.useValue);
          }
          return result;
      };
      _InjectorBuilder.prototype._createProviderProperty = function (propName, provider, providerValueExpressions, isMulti, isEager) {
          var resolvedProviderValueExpr;
          var type;
          if (isMulti) {
              resolvedProviderValueExpr = literalArr(providerValueExpressions);
              type = new ArrayType(DYNAMIC_TYPE);
          }
          else {
              resolvedProviderValueExpr = providerValueExpressions[0];
              type = providerValueExpressions[0].type;
          }
          if (!type) {
              type = DYNAMIC_TYPE;
          }
          if (isEager) {
              this._fields.push(new ClassField(propName, type));
              this._createStmts.push(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());
          }
          else {
              var internalField = "_" + propName;
              this._fields.push(new ClassField(internalField, type));
              // Note: Equals is important for JS so that it also checks the undefined case!
              var getterStmts = [
                  new IfStmt(THIS_EXPR.prop(internalField).isBlank(), [THIS_EXPR.prop(internalField).set(resolvedProviderValueExpr).toStmt()]),
                  new ReturnStatement(THIS_EXPR.prop(internalField))
              ];
              this._getters.push(new ClassGetter(propName, getterStmts, type));
          }
          return THIS_EXPR.prop(propName);
      };
      _InjectorBuilder.prototype._getDependency = function (dep) {
          var result = null;
          if (dep.isValue) {
              result = literal(dep.value);
          }
          if (!dep.isSkipSelf) {
              if (dep.token &&
                  (dep.token.reference === resolveIdentifierToken(Identifiers.Injector).reference ||
                      dep.token.reference ===
                          resolveIdentifierToken(Identifiers.ComponentFactoryResolver).reference)) {
                  result = THIS_EXPR;
              }
              if (!result) {
                  result = this._instances.get(dep.token.reference);
              }
          }
          if (!result) {
              var args = [createDiTokenExpression(dep.token)];
              if (dep.isOptional) {
                  args.push(NULL_EXPR);
              }
              result = InjectorProps.parent.callMethod('get', args);
          }
          return result;
      };
      return _InjectorBuilder;
  }());
  var InjectorProps = (function () {
      function InjectorProps() {
      }
      InjectorProps.parent = THIS_EXPR.prop('parent');
      return InjectorProps;
  }());
  var InjectMethodVars$1 = (function () {
      function InjectMethodVars() {
      }
      InjectMethodVars.token = variable('token');
      InjectMethodVars.notFoundResult = variable('notFoundResult');
      return InjectMethodVars;
  }());

  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
  var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
  var CATCH_ERROR_VAR$2 = variable('error');
  var CATCH_STACK_VAR$2 = variable('stack');
  var _EmittedLine = (function () {
      function _EmittedLine(indent) {
          this.indent = indent;
          this.parts = [];
      }
      return _EmittedLine;
  }());
  var EmitterVisitorContext = (function () {
      function EmitterVisitorContext(_exportedVars, _indent) {
          this._exportedVars = _exportedVars;
          this._indent = _indent;
          this._classes = [];
          this._lines = [new _EmittedLine(_indent)];
      }
      EmitterVisitorContext.createRoot = function (exportedVars) {
          return new EmitterVisitorContext(exportedVars, 0);
      };
      Object.defineProperty(EmitterVisitorContext.prototype, "_currentLine", {
          get: function () { return this._lines[this._lines.length - 1]; },
          enumerable: true,
          configurable: true
      });
      EmitterVisitorContext.prototype.isExportedVar = function (varName) { return this._exportedVars.indexOf(varName) !== -1; };
      EmitterVisitorContext.prototype.println = function (lastPart) {
          if (lastPart === void 0) { lastPart = ''; }
          this.print(lastPart, true);
      };
      EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };
      EmitterVisitorContext.prototype.print = function (part, newLine) {
          if (newLine === void 0) { newLine = false; }
          if (part.length > 0) {
              this._currentLine.parts.push(part);
          }
          if (newLine) {
              this._lines.push(new _EmittedLine(this._indent));
          }
      };
      EmitterVisitorContext.prototype.removeEmptyLastLine = function () {
          if (this.lineIsEmpty()) {
              this._lines.pop();
          }
      };
      EmitterVisitorContext.prototype.incIndent = function () {
          this._indent++;
          this._currentLine.indent = this._indent;
      };
      EmitterVisitorContext.prototype.decIndent = function () {
          this._indent--;
          this._currentLine.indent = this._indent;
      };
      EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };
      EmitterVisitorContext.prototype.popClass = function () { return this._classes.pop(); };
      Object.defineProperty(EmitterVisitorContext.prototype, "currentClass", {
          get: function () {
              return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
          },
          enumerable: true,
          configurable: true
      });
      EmitterVisitorContext.prototype.toSource = function () {
          var lines = this._lines;
          if (lines[lines.length - 1].parts.length === 0) {
              lines = lines.slice(0, lines.length - 1);
          }
          return lines
              .map(function (line) {
              if (line.parts.length > 0) {
                  return _createIndent(line.indent) + line.parts.join('');
              }
              else {
                  return '';
              }
          })
              .join('\n');
      };
      return EmitterVisitorContext;
  }());
  var AbstractEmitterVisitor = (function () {
      function AbstractEmitterVisitor(_escapeDollarInStrings) {
          this._escapeDollarInStrings = _escapeDollarInStrings;
      }
      AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {
          stmt.expr.visitExpression(this, ctx);
          ctx.println(';');
          return null;
      };
      AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {
          ctx.print("return ");
          stmt.value.visitExpression(this, ctx);
          ctx.println(';');
          return null;
      };
      AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {
          ctx.print("if (");
          stmt.condition.visitExpression(this, ctx);
          ctx.print(") {");
          var hasElseCase = isPresent(stmt.falseCase) && stmt.falseCase.length > 0;
          if (stmt.trueCase.length <= 1 && !hasElseCase) {
              ctx.print(" ");
              this.visitAllStatements(stmt.trueCase, ctx);
              ctx.removeEmptyLastLine();
              ctx.print(" ");
          }
          else {
              ctx.println();
              ctx.incIndent();
              this.visitAllStatements(stmt.trueCase, ctx);
              ctx.decIndent();
              if (hasElseCase) {
                  ctx.println("} else {");
                  ctx.incIndent();
                  this.visitAllStatements(stmt.falseCase, ctx);
                  ctx.decIndent();
              }
          }
          ctx.println("}");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {
          ctx.print("throw ");
          stmt.error.visitExpression(this, ctx);
          ctx.println(";");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {
          var lines = stmt.comment.split('\n');
          lines.forEach(function (line) { ctx.println("// " + line); });
          return null;
      };
      AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {
          var lineWasEmpty = ctx.lineIsEmpty();
          if (!lineWasEmpty) {
              ctx.print('(');
          }
          ctx.print(expr.name + " = ");
          expr.value.visitExpression(this, ctx);
          if (!lineWasEmpty) {
              ctx.print(')');
          }
          return null;
      };
      AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {
          var lineWasEmpty = ctx.lineIsEmpty();
          if (!lineWasEmpty) {
              ctx.print('(');
          }
          expr.receiver.visitExpression(this, ctx);
          ctx.print("[");
          expr.index.visitExpression(this, ctx);
          ctx.print("] = ");
          expr.value.visitExpression(this, ctx);
          if (!lineWasEmpty) {
              ctx.print(')');
          }
          return null;
      };
      AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {
          var lineWasEmpty = ctx.lineIsEmpty();
          if (!lineWasEmpty) {
              ctx.print('(');
          }
          expr.receiver.visitExpression(this, ctx);
          ctx.print("." + expr.name + " = ");
          expr.value.visitExpression(this, ctx);
          if (!lineWasEmpty) {
              ctx.print(')');
          }
          return null;
      };
      AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {
          expr.receiver.visitExpression(this, ctx);
          var name = expr.name;
          if (isPresent(expr.builtin)) {
              name = this.getBuiltinMethodName(expr.builtin);
              if (isBlank(name)) {
                  // some builtins just mean to skip the call.
                  return null;
              }
          }
          ctx.print("." + name + "(");
          this.visitAllExpressions(expr.args, ctx, ",");
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
          expr.fn.visitExpression(this, ctx);
          ctx.print("(");
          this.visitAllExpressions(expr.args, ctx, ',');
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
          var varName = ast.name;
          if (isPresent(ast.builtin)) {
              switch (ast.builtin) {
                  case BuiltinVar.Super:
                      varName = 'super';
                      break;
                  case BuiltinVar.This:
                      varName = 'this';
                      break;
                  case BuiltinVar.CatchError:
                      varName = CATCH_ERROR_VAR$2.name;
                      break;
                  case BuiltinVar.CatchStack:
                      varName = CATCH_STACK_VAR$2.name;
                      break;
                  default:
                      throw new Error("Unknown builtin variable " + ast.builtin);
              }
          }
          ctx.print(varName);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {
          ctx.print("new ");
          ast.classExpr.visitExpression(this, ctx);
          ctx.print("(");
          this.visitAllExpressions(ast.args, ctx, ',');
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx, absentValue) {
          if (absentValue === void 0) { absentValue = 'null'; }
          var value = ast.value;
          if (isString(value)) {
              ctx.print(escapeIdentifier(value, this._escapeDollarInStrings));
          }
          else if (isBlank(value)) {
              ctx.print(absentValue);
          }
          else {
              ctx.print("" + value);
          }
          return null;
      };
      AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {
          ctx.print("(");
          ast.condition.visitExpression(this, ctx);
          ctx.print('? ');
          ast.trueCase.visitExpression(this, ctx);
          ctx.print(': ');
          ast.falseCase.visitExpression(this, ctx);
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {
          ctx.print('!');
          ast.condition.visitExpression(this, ctx);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
          var opStr;
          switch (ast.operator) {
              case BinaryOperator.Equals:
                  opStr = '==';
                  break;
              case BinaryOperator.Identical:
                  opStr = '===';
                  break;
              case BinaryOperator.NotEquals:
                  opStr = '!=';
                  break;
              case BinaryOperator.NotIdentical:
                  opStr = '!==';
                  break;
              case BinaryOperator.And:
                  opStr = '&&';
                  break;
              case BinaryOperator.Or:
                  opStr = '||';
                  break;
              case BinaryOperator.Plus:
                  opStr = '+';
                  break;
              case BinaryOperator.Minus:
                  opStr = '-';
                  break;
              case BinaryOperator.Divide:
                  opStr = '/';
                  break;
              case BinaryOperator.Multiply:
                  opStr = '*';
                  break;
              case BinaryOperator.Modulo:
                  opStr = '%';
                  break;
              case BinaryOperator.Lower:
                  opStr = '<';
                  break;
              case BinaryOperator.LowerEquals:
                  opStr = '<=';
                  break;
              case BinaryOperator.Bigger:
                  opStr = '>';
                  break;
              case BinaryOperator.BiggerEquals:
                  opStr = '>=';
                  break;
              default:
                  throw new Error("Unknown operator " + ast.operator);
          }
          ctx.print("(");
          ast.lhs.visitExpression(this, ctx);
          ctx.print(" " + opStr + " ");
          ast.rhs.visitExpression(this, ctx);
          ctx.print(")");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {
          ast.receiver.visitExpression(this, ctx);
          ctx.print(".");
          ctx.print(ast.name);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {
          ast.receiver.visitExpression(this, ctx);
          ctx.print("[");
          ast.index.visitExpression(this, ctx);
          ctx.print("]");
          return null;
      };
      AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {
          var useNewLine = ast.entries.length > 1;
          ctx.print("[", useNewLine);
          ctx.incIndent();
          this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);
          ctx.decIndent();
          ctx.print("]", useNewLine);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {
          var _this = this;
          var useNewLine = ast.entries.length > 1;
          ctx.print("{", useNewLine);
          ctx.incIndent();
          this.visitAllObjects(function (entry /** TODO #9100 */) {
              ctx.print(escapeIdentifier(entry[0], _this._escapeDollarInStrings, false) + ": ");
              entry[1].visitExpression(_this, ctx);
          }, ast.entries, ctx, ',', useNewLine);
          ctx.decIndent();
          ctx.print("}", useNewLine);
          return null;
      };
      AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator, newLine) {
          var _this = this;
          if (newLine === void 0) { newLine = false; }
          this.visitAllObjects(function (expr /** TODO #9100 */) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator, newLine);
      };
      AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator, newLine) {
          if (newLine === void 0) { newLine = false; }
          for (var i = 0; i < expressions.length; i++) {
              if (i > 0) {
                  ctx.print(separator, newLine);
              }
              handler(expressions[i]);
          }
          if (newLine) {
              ctx.println();
          }
      };
      AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {
          var _this = this;
          statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });
      };
      return AbstractEmitterVisitor;
  }());
  function escapeIdentifier(input, escapeDollar, alwaysQuote) {
      if (alwaysQuote === void 0) { alwaysQuote = true; }
      if (isBlank(input)) {
          return null;
      }
      var body = StringWrapper.replaceAllMapped(input, _SINGLE_QUOTE_ESCAPE_STRING_RE, function (match /** TODO #9100 */) {
          if (match[0] == '$') {
              return escapeDollar ? '\\$' : '$';
          }
          else if (match[0] == '\n') {
              return '\\n';
          }
          else if (match[0] == '\r') {
              return '\\r';
          }
          else {
              return "\\" + match[0];
          }
      });
      var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
      return requiresQuotes ? "'" + body + "'" : body;
  }
  function _createIndent(count) {
      var res = '';
      for (var i = 0; i < count; i++) {
          res += '  ';
      }
      return res;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$16 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var _debugModuleUrl = 'asset://debug/lib';
  function debugOutputAstAsTypeScript(ast) {
      var converter = new _TsEmitterVisitor(_debugModuleUrl);
      var ctx = EmitterVisitorContext.createRoot([]);
      var asts;
      if (isArray(ast)) {
          asts = ast;
      }
      else {
          asts = [ast];
      }
      asts.forEach(function (ast) {
          if (ast instanceof Statement) {
              ast.visitStatement(converter, ctx);
          }
          else if (ast instanceof Expression) {
              ast.visitExpression(converter, ctx);
          }
          else if (ast instanceof Type$1) {
              ast.visitType(converter, ctx);
          }
          else {
              throw new Error("Don't know how to print debug info for " + ast);
          }
      });
      return ctx.toSource();
  }
  var TypeScriptEmitter = (function () {
      function TypeScriptEmitter(_importGenerator) {
          this._importGenerator = _importGenerator;
      }
      TypeScriptEmitter.prototype.emitStatements = function (moduleUrl, stmts, exportedVars) {
          var _this = this;
          var converter = new _TsEmitterVisitor(moduleUrl);
          var ctx = EmitterVisitorContext.createRoot(exportedVars);
          converter.visitAllStatements(stmts, ctx);
          var srcParts = [];
          converter.importsWithPrefixes.forEach(function (prefix, importedModuleUrl) {
              // Note: can't write the real word for import as it screws up system.js auto detection...
              srcParts.push("imp" +
                  ("ort * as " + prefix + " from '" + _this._importGenerator.getImportPath(moduleUrl, importedModuleUrl) + "';"));
          });
          srcParts.push(ctx.toSource());
          return srcParts.join('\n');
      };
      return TypeScriptEmitter;
  }());
  var _TsEmitterVisitor = (function (_super) {
      __extends$16(_TsEmitterVisitor, _super);
      function _TsEmitterVisitor(_moduleUrl) {
          _super.call(this, false);
          this._moduleUrl = _moduleUrl;
          this.importsWithPrefixes = new Map();
      }
      _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {
          if (defaultType === void 0) { defaultType = 'any'; }
          if (isPresent(t)) {
              t.visitType(this, ctx);
          }
          else {
              ctx.print(defaultType);
          }
      };
      _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {
          _super.prototype.visitLiteralExpr.call(this, ast, ctx, '(null as any)');
      };
      _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
          this._visitIdentifier(ast.value, ast.typeParams, ctx);
          return null;
      };
      _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
          if (ctx.isExportedVar(stmt.name)) {
              ctx.print("export ");
          }
          if (stmt.hasModifier(StmtModifier.Final)) {
              ctx.print("const");
          }
          else {
              ctx.print("var");
          }
          ctx.print(" " + stmt.name + ":");
          this.visitType(stmt.type, ctx);
          ctx.print(" = ");
          stmt.value.visitExpression(this, ctx);
          ctx.println(";");
          return null;
      };
      _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
          ctx.print("(<");
          ast.type.visitType(this, ctx);
          ctx.print(">");
          ast.value.visitExpression(this, ctx);
          ctx.print(")");
          return null;
      };
      _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
          var _this = this;
          ctx.pushClass(stmt);
          if (ctx.isExportedVar(stmt.name)) {
              ctx.print("export ");
          }
          ctx.print("class " + stmt.name);
          if (isPresent(stmt.parent)) {
              ctx.print(" extends ");
              stmt.parent.visitExpression(this, ctx);
          }
          ctx.println(" {");
          ctx.incIndent();
          stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });
          if (isPresent(stmt.constructorMethod)) {
              this._visitClassConstructor(stmt, ctx);
          }
          stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });
          stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });
          ctx.decIndent();
          ctx.println("}");
          ctx.popClass();
          return null;
      };
      _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {
          if (field.hasModifier(StmtModifier.Private)) {
              // comment out as a workaround for #10967
              ctx.print("/*private*/ ");
          }
          ctx.print(field.name);
          ctx.print(':');
          this.visitType(field.type, ctx);
          ctx.println(";");
      };
      _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {
          if (getter.hasModifier(StmtModifier.Private)) {
              ctx.print("private ");
          }
          ctx.print("get " + getter.name + "()");
          ctx.print(':');
          this.visitType(getter.type, ctx);
          ctx.println(" {");
          ctx.incIndent();
          this.visitAllStatements(getter.body, ctx);
          ctx.decIndent();
          ctx.println("}");
      };
      _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
          ctx.print("constructor(");
          this._visitParams(stmt.constructorMethod.params, ctx);
          ctx.println(") {");
          ctx.incIndent();
          this.visitAllStatements(stmt.constructorMethod.body, ctx);
          ctx.decIndent();
          ctx.println("}");
      };
      _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {
          if (method.hasModifier(StmtModifier.Private)) {
              ctx.print("private ");
          }
          ctx.print(method.name + "(");
          this._visitParams(method.params, ctx);
          ctx.print("):");
          this.visitType(method.type, ctx, 'void');
          ctx.println(" {");
          ctx.incIndent();
          this.visitAllStatements(method.body, ctx);
          ctx.decIndent();
          ctx.println("}");
      };
      _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
          ctx.print("(");
          this._visitParams(ast.params, ctx);
          ctx.print("):");
          this.visitType(ast.type, ctx, 'void');
          ctx.println(" => {");
          ctx.incIndent();
          this.visitAllStatements(ast.statements, ctx);
          ctx.decIndent();
          ctx.print("}");
          return null;
      };
      _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
          if (ctx.isExportedVar(stmt.name)) {
              ctx.print("export ");
          }
          ctx.print("function " + stmt.name + "(");
          this._visitParams(stmt.params, ctx);
          ctx.print("):");
          this.visitType(stmt.type, ctx, 'void');
          ctx.println(" {");
          ctx.incIndent();
          this.visitAllStatements(stmt.statements, ctx);
          ctx.decIndent();
          ctx.println("}");
          return null;
      };
      _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
          ctx.println("try {");
          ctx.incIndent();
          this.visitAllStatements(stmt.bodyStmts, ctx);
          ctx.decIndent();
          ctx.println("} catch (" + CATCH_ERROR_VAR$2.name + ") {");
          ctx.incIndent();
          var catchStmts = [CATCH_STACK_VAR$2.set(CATCH_ERROR_VAR$2.prop('stack')).toDeclStmt(null, [
                  StmtModifier.Final
              ])].concat(stmt.catchStmts);
          this.visitAllStatements(catchStmts, ctx);
          ctx.decIndent();
          ctx.println("}");
          return null;
      };
      _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {
          var typeStr;
          switch (type.name) {
              case BuiltinTypeName.Bool:
                  typeStr = 'boolean';
                  break;
              case BuiltinTypeName.Dynamic:
                  typeStr = 'any';
                  break;
              case BuiltinTypeName.Function:
                  typeStr = 'Function';
                  break;
              case BuiltinTypeName.Number:
                  typeStr = 'number';
                  break;
              case BuiltinTypeName.Int:
                  typeStr = 'number';
                  break;
              case BuiltinTypeName.String:
                  typeStr = 'string';
                  break;
              default:
                  throw new Error("Unsupported builtin type " + type.name);
          }
          ctx.print(typeStr);
          return null;
      };
      _TsEmitterVisitor.prototype.visitExternalType = function (ast, ctx) {
          this._visitIdentifier(ast.value, ast.typeParams, ctx);
          return null;
      };
      _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {
          this.visitType(type.of, ctx);
          ctx.print("[]");
          return null;
      };
      _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {
          ctx.print("{[key: string]:");
          this.visitType(type.valueType, ctx);
          ctx.print("}");
          return null;
      };
      _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
          var name;
          switch (method) {
              case BuiltinMethod.ConcatArray:
                  name = 'concat';
                  break;
              case BuiltinMethod.SubscribeObservable:
                  name = 'subscribe';
                  break;
              case BuiltinMethod.Bind:
                  name = 'bind';
                  break;
              default:
                  throw new Error("Unknown builtin method: " + method);
          }
          return name;
      };
      _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {
          var _this = this;
          this.visitAllObjects(function (param /** TODO #9100 */) {
              ctx.print(param.name);
              ctx.print(':');
              _this.visitType(param.type, ctx);
          }, params, ctx, ',');
      };
      _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {
          var _this = this;
          if (isBlank(value.name)) {
              throw new Error("Internal error: unknown identifier " + value);
          }
          if (isPresent(value.moduleUrl) && value.moduleUrl != this._moduleUrl) {
              var prefix = this.importsWithPrefixes.get(value.moduleUrl);
              if (isBlank(prefix)) {
                  prefix = "import" + this.importsWithPrefixes.size;
                  this.importsWithPrefixes.set(value.moduleUrl, prefix);
              }
              ctx.print(prefix + ".");
          }
          if (value.reference && value.reference.members) {
              ctx.print(value.reference.name);
              ctx.print('.');
              ctx.print(value.reference.members.join('.'));
          }
          else {
              ctx.print(value.name);
          }
          if (isPresent(typeParams) && typeParams.length > 0) {
              ctx.print("<");
              this.visitAllObjects(function (type /** TODO #9100 */) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');
              ctx.print(">");
          }
      };
      return _TsEmitterVisitor;
  }(AbstractEmitterVisitor));

  function interpretStatements(statements, resultVar) {
      var stmtsWithReturn = statements.concat([new ReturnStatement(variable(resultVar))]);
      var ctx = new _ExecutionContext(null, null, null, new Map());
      var visitor = new StatementInterpreter();
      var result = visitor.visitAllStatements(stmtsWithReturn, ctx);
      return isPresent(result) ? result.value : null;
  }
  function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
      var childCtx = ctx.createChildWihtLocalVars();
      for (var i = 0; i < varNames.length; i++) {
          childCtx.vars.set(varNames[i], varValues[i]);
      }
      var result = visitor.visitAllStatements(statements, childCtx);
      return isPresent(result) ? result.value : null;
  }
  var _ExecutionContext = (function () {
      function _ExecutionContext(parent, instance, className, vars) {
          this.parent = parent;
          this.instance = instance;
          this.className = className;
          this.vars = vars;
      }
      _ExecutionContext.prototype.createChildWihtLocalVars = function () {
          return new _ExecutionContext(this, this.instance, this.className, new Map());
      };
      return _ExecutionContext;
  }());
  var ReturnValue = (function () {
      function ReturnValue(value) {
          this.value = value;
      }
      return ReturnValue;
  }());
  function createDynamicClass(_classStmt, _ctx, _visitor) {
      var propertyDescriptors = {};
      _classStmt.getters.forEach(function (getter) {
          // Note: use `function` instead of arrow function to capture `this`
          propertyDescriptors[getter.name] = {
              configurable: false,
              get: function () {
                  var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
                  return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);
              }
          };
      });
      _classStmt.methods.forEach(function (method) {
          var paramNames = method.params.map(function (param) { return param.name; });
          // Note: use `function` instead of arrow function to capture `this`
          propertyDescriptors[method.name] = {
              writable: false,
              configurable: false,
              value: function () {
                  var args = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                      args[_i - 0] = arguments[_i];
                  }
                  var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
                  return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);
              }
          };
      });
      var ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });
      // Note: use `function` instead of arrow function to capture `this`
      var ctor = function () {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i - 0] = arguments[_i];
          }
          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
          _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });
          _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);
      };
      var superClass = _classStmt.parent.visitExpression(_visitor, _ctx);
      ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);
      return ctor;
  }
  var StatementInterpreter = (function () {
      function StatementInterpreter() {
      }
      StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };
      StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {
          ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));
          return null;
      };
      StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {
          var value = expr.value.visitExpression(this, ctx);
          var currCtx = ctx;
          while (currCtx != null) {
              if (currCtx.vars.has(expr.name)) {
                  currCtx.vars.set(expr.name, value);
                  return value;
              }
              currCtx = currCtx.parent;
          }
          throw new Error("Not declared variable " + expr.name);
      };
      StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {
          var varName = ast.name;
          if (isPresent(ast.builtin)) {
              switch (ast.builtin) {
                  case BuiltinVar.Super:
                      return ctx.instance.__proto__;
                  case BuiltinVar.This:
                      return ctx.instance;
                  case BuiltinVar.CatchError:
                      varName = CATCH_ERROR_VAR$1;
                      break;
                  case BuiltinVar.CatchStack:
                      varName = CATCH_STACK_VAR$1;
                      break;
                  default:
                      throw new Error("Unknown builtin variable " + ast.builtin);
              }
          }
          var currCtx = ctx;
          while (currCtx != null) {
              if (currCtx.vars.has(varName)) {
                  return currCtx.vars.get(varName);
              }
              currCtx = currCtx.parent;
          }
          throw new Error("Not declared variable " + varName);
      };
      StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {
          var receiver = expr.receiver.visitExpression(this, ctx);
          var index = expr.index.visitExpression(this, ctx);
          var value = expr.value.visitExpression(this, ctx);
          receiver[index] = value;
          return value;
      };
      StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {
          var receiver = expr.receiver.visitExpression(this, ctx);
          var value = expr.value.visitExpression(this, ctx);
          receiver[expr.name] = value;
          return value;
      };
      StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {
          var receiver = expr.receiver.visitExpression(this, ctx);
          var args = this.visitAllExpressions(expr.args, ctx);
          var result;
          if (isPresent(expr.builtin)) {
              switch (expr.builtin) {
                  case BuiltinMethod.ConcatArray:
                      result = ListWrapper.concat(receiver, args[0]);
                      break;
                  case BuiltinMethod.SubscribeObservable:
                      result = receiver.subscribe({ next: args[0] });
                      break;
                  case BuiltinMethod.Bind:
                      result = receiver.bind(args[0]);
                      break;
                  default:
                      throw new Error("Unknown builtin method " + expr.builtin);
              }
          }
          else {
              result = receiver[expr.name].apply(receiver, args);
          }
          return result;
      };
      StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {
          var args = this.visitAllExpressions(stmt.args, ctx);
          var fnExpr = stmt.fn;
          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
              ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);
              return null;
          }
          else {
              var fn = stmt.fn.visitExpression(this, ctx);
              return fn.apply(null, args);
          }
      };
      StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {
          return new ReturnValue(stmt.value.visitExpression(this, ctx));
      };
      StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {
          var clazz = createDynamicClass(stmt, ctx, this);
          ctx.vars.set(stmt.name, clazz);
          return null;
      };
      StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {
          return stmt.expr.visitExpression(this, ctx);
      };
      StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {
          var condition = stmt.condition.visitExpression(this, ctx);
          if (condition) {
              return this.visitAllStatements(stmt.trueCase, ctx);
          }
          else if (isPresent(stmt.falseCase)) {
              return this.visitAllStatements(stmt.falseCase, ctx);
          }
          return null;
      };
      StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {
          try {
              return this.visitAllStatements(stmt.bodyStmts, ctx);
          }
          catch (e) {
              var childCtx = ctx.createChildWihtLocalVars();
              childCtx.vars.set(CATCH_ERROR_VAR$1, e);
              childCtx.vars.set(CATCH_STACK_VAR$1, e.stack);
              return this.visitAllStatements(stmt.catchStmts, childCtx);
          }
      };
      StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {
          throw stmt.error.visitExpression(this, ctx);
      };
      StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };
      StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {
          var args = this.visitAllExpressions(ast.args, ctx);
          var clazz = ast.classExpr.visitExpression(this, ctx);
          return new (clazz.bind.apply(clazz, [void 0].concat(args)))();
      };
      StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };
      StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {
          return ast.value.reference;
      };
      StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {
          if (ast.condition.visitExpression(this, ctx)) {
              return ast.trueCase.visitExpression(this, ctx);
          }
          else if (isPresent(ast.falseCase)) {
              return ast.falseCase.visitExpression(this, ctx);
          }
          return null;
      };
      StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {
          return !ast.condition.visitExpression(this, ctx);
      };
      StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {
          return ast.value.visitExpression(this, ctx);
      };
      StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {
          var paramNames = ast.params.map(function (param) { return param.name; });
          return _declareFn(paramNames, ast.statements, ctx, this);
      };
      StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
          var paramNames = stmt.params.map(function (param) { return param.name; });
          ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
          return null;
      };
      StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {
          var _this = this;
          var lhs = function () { return ast.lhs.visitExpression(_this, ctx); };
          var rhs = function () { return ast.rhs.visitExpression(_this, ctx); };
          switch (ast.operator) {
              case BinaryOperator.Equals:
                  return lhs() == rhs();
              case BinaryOperator.Identical:
                  return lhs() === rhs();
              case BinaryOperator.NotEquals:
                  return lhs() != rhs();
              case BinaryOperator.NotIdentical:
                  return lhs() !== rhs();
              case BinaryOperator.And:
                  return lhs() && rhs();
              case BinaryOperator.Or:
                  return lhs() || rhs();
              case BinaryOperator.Plus:
                  return lhs() + rhs();
              case BinaryOperator.Minus:
                  return lhs() - rhs();
              case BinaryOperator.Divide:
                  return lhs() / rhs();
              case BinaryOperator.Multiply:
                  return lhs() * rhs();
              case BinaryOperator.Modulo:
                  return lhs() % rhs();
              case BinaryOperator.Lower:
                  return lhs() < rhs();
              case BinaryOperator.LowerEquals:
                  return lhs() <= rhs();
              case BinaryOperator.Bigger:
                  return lhs() > rhs();
              case BinaryOperator.BiggerEquals:
                  return lhs() >= rhs();
              default:
                  throw new Error("Unknown operator " + ast.operator);
          }
      };
      StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {
          var result;
          var receiver = ast.receiver.visitExpression(this, ctx);
          result = receiver[ast.name];
          return result;
      };
      StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {
          var receiver = ast.receiver.visitExpression(this, ctx);
          var prop = ast.index.visitExpression(this, ctx);
          return receiver[prop];
      };
      StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {
          return this.visitAllExpressions(ast.entries, ctx);
      };
      StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {
          var _this = this;
          var result = {};
          ast.entries.forEach(function (entry) { return result[entry[0]] =
              entry[1].visitExpression(_this, ctx); });
          return result;
      };
      StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {
          var _this = this;
          return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });
      };
      StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {
          for (var i = 0; i < statements.length; i++) {
              var stmt = statements[i];
              var val = stmt.visitStatement(this, ctx);
              if (val instanceof ReturnValue) {
                  return val;
              }
          }
          return null;
      };
      return StatementInterpreter;
  }());
  function _declareFn(varNames, statements, ctx, visitor) {
      return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i - 0] = arguments[_i];
          }
          return _executeFunctionStatements(varNames, args, statements, ctx, visitor);
      };
  }
  var CATCH_ERROR_VAR$1 = 'error';
  var CATCH_STACK_VAR$1 = 'stack';

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$18 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var AbstractJsEmitterVisitor = (function (_super) {
      __extends$18(AbstractJsEmitterVisitor, _super);
      function AbstractJsEmitterVisitor() {
          _super.call(this, false);
      }
      AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {
          var _this = this;
          ctx.pushClass(stmt);
          this._visitClassConstructor(stmt, ctx);
          if (isPresent(stmt.parent)) {
              ctx.print(stmt.name + ".prototype = Object.create(");
              stmt.parent.visitExpression(this, ctx);
              ctx.println(".prototype);");
          }
          stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });
          stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });
          ctx.popClass();
          return null;
      };
      AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {
          ctx.print("function " + stmt.name + "(");
          if (isPresent(stmt.constructorMethod)) {
              this._visitParams(stmt.constructorMethod.params, ctx);
          }
          ctx.println(") {");
          ctx.incIndent();
          if (isPresent(stmt.constructorMethod)) {
              if (stmt.constructorMethod.body.length > 0) {
                  ctx.println("var self = this;");
                  this.visitAllStatements(stmt.constructorMethod.body, ctx);
              }
          }
          ctx.decIndent();
          ctx.println("}");
      };
      AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {
          ctx.println("Object.defineProperty(" + stmt.name + ".prototype, '" + getter.name + "', { get: function() {");
          ctx.incIndent();
          if (getter.body.length > 0) {
              ctx.println("var self = this;");
              this.visitAllStatements(getter.body, ctx);
          }
          ctx.decIndent();
          ctx.println("}});");
      };
      AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {
          ctx.print(stmt.name + ".prototype." + method.name + " = function(");
          this._visitParams(method.params, ctx);
          ctx.println(") {");
          ctx.incIndent();
          if (method.body.length > 0) {
              ctx.println("var self = this;");
              this.visitAllStatements(method.body, ctx);
          }
          ctx.decIndent();
          ctx.println("};");
      };
      AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {
          if (ast.builtin === BuiltinVar.This) {
              ctx.print('self');
          }
          else if (ast.builtin === BuiltinVar.Super) {
              throw new Error("'super' needs to be handled at a parent ast node, not at the variable level!");
          }
          else {
              _super.prototype.visitReadVarExpr.call(this, ast, ctx);
          }
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {
          ctx.print("var " + stmt.name + " = ");
          stmt.value.visitExpression(this, ctx);
          ctx.println(";");
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {
          ast.value.visitExpression(this, ctx);
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {
          var fnExpr = expr.fn;
          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
              ctx.currentClass.parent.visitExpression(this, ctx);
              ctx.print(".call(this");
              if (expr.args.length > 0) {
                  ctx.print(", ");
                  this.visitAllExpressions(expr.args, ctx, ',');
              }
              ctx.print(")");
          }
          else {
              _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);
          }
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {
          ctx.print("function(");
          this._visitParams(ast.params, ctx);
          ctx.println(") {");
          ctx.incIndent();
          this.visitAllStatements(ast.statements, ctx);
          ctx.decIndent();
          ctx.print("}");
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {
          ctx.print("function " + stmt.name + "(");
          this._visitParams(stmt.params, ctx);
          ctx.println(") {");
          ctx.incIndent();
          this.visitAllStatements(stmt.statements, ctx);
          ctx.decIndent();
          ctx.println("}");
          return null;
      };
      AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {
          ctx.println("try {");
          ctx.incIndent();
          this.visitAllStatements(stmt.bodyStmts, ctx);
          ctx.decIndent();
          ctx.println("} catch (" + CATCH_ERROR_VAR$2.name + ") {");
          ctx.incIndent();
          var catchStmts = [CATCH_STACK_VAR$2.set(CATCH_ERROR_VAR$2.prop('stack')).toDeclStmt(null, [
                  StmtModifier.Final
              ])].concat(stmt.catchStmts);
          this.visitAllStatements(catchStmts, ctx);
          ctx.decIndent();
          ctx.println("}");
          return null;
      };
      AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {
          this.visitAllObjects(function (param /** TODO #9100 */) { return ctx.print(param.name); }, params, ctx, ',');
      };
      AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {
          var name;
          switch (method) {
              case BuiltinMethod.ConcatArray:
                  name = 'concat';
                  break;
              case BuiltinMethod.SubscribeObservable:
                  name = 'subscribe';
                  break;
              case BuiltinMethod.Bind:
                  name = 'bind';
                  break;
              default:
                  throw new Error("Unknown builtin method: " + method);
          }
          return name;
      };
      return AbstractJsEmitterVisitor;
  }(AbstractEmitterVisitor));

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$17 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  function jitStatements(sourceUrl, statements, resultVar) {
      var converter = new JitEmitterVisitor();
      var ctx = EmitterVisitorContext.createRoot([resultVar]);
      converter.visitAllStatements(statements, ctx);
      return evalExpression(sourceUrl, resultVar, ctx.toSource(), converter.getArgs());
  }
  var JitEmitterVisitor = (function (_super) {
      __extends$17(JitEmitterVisitor, _super);
      function JitEmitterVisitor() {
          _super.apply(this, arguments);
          this._evalArgNames = [];
          this._evalArgValues = [];
      }
      JitEmitterVisitor.prototype.getArgs = function () {
          var result = {};
          for (var i = 0; i < this._evalArgNames.length; i++) {
              result[this._evalArgNames[i]] = this._evalArgValues[i];
          }
          return result;
      };
      JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {
          var value = ast.value.reference;
          var id = this._evalArgValues.indexOf(value);
          if (id === -1) {
              id = this._evalArgValues.length;
              this._evalArgValues.push(value);
              var name = isPresent(ast.value.name) ? sanitizeIdentifier(ast.value.name) : 'val';
              this._evalArgNames.push(sanitizeIdentifier("jit_" + name + id));
          }
          ctx.print(this._evalArgNames[id]);
          return null;
      };
      return JitEmitterVisitor;
  }(AbstractJsEmitterVisitor));

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * This file is a port of shadowCSS from webcomponents.js to TypeScript.
   *
   * Please make sure to keep to edits in sync with the source file.
   *
   * Source:
   * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
   *
   * The original file level comment is reproduced below
   */
  /*
    This is a limited shim for ShadowDOM css styling.
    https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

    The intention here is to support only the styling features which can be
    relatively simply implemented. The goal is to allow users to avoid the
    most obvious pitfalls and do so without compromising performance significantly.
    For ShadowDOM styling that's not covered here, a set of best practices
    can be provided that should allow users to accomplish more complex styling.

    The following is a list of specific ShadowDOM styling features and a brief
    discussion of the approach used to shim.

    Shimmed features:

    * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
    element using the :host rule. To shim this feature, the :host styles are
    reformatted and prefixed with a given scope name and promoted to a
    document level stylesheet.
    For example, given a scope name of .foo, a rule like this:

      :host {
          background: red;
        }
      }

    becomes:

      .foo {
        background: red;
      }

    * encapsulation: Styles defined within ShadowDOM, apply only to
    dom inside the ShadowDOM. Polymer uses one of two techniques to implement
    this feature.

    By default, rules are prefixed with the host element tag name
    as a descendant selector. This ensures styling does not leak out of the 'top'
    of the element's ShadowDOM. For example,

    div {
        font-weight: bold;
      }

    becomes:

    x-foo div {
        font-weight: bold;
      }

    becomes:


    Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
    selectors are scoped by adding an attribute selector suffix to each
    simple selector that contains the host element tag name. Each element
    in the element's ShadowDOM template is also given the scope attribute.
    Thus, these rules match only elements that have the scope attribute.
    For example, given a scope name of x-foo, a rule like this:

      div {
        font-weight: bold;
      }

    becomes:

      div[x-foo] {
        font-weight: bold;
      }

    Note that elements that are dynamically added to a scope must have the scope
    selector added to them manually.

    * upper/lower bound encapsulation: Styles which are defined outside a
    shadowRoot should not cross the ShadowDOM boundary and should not apply
    inside a shadowRoot.

    This styling behavior is not emulated. Some possible ways to do this that
    were rejected due to complexity and/or performance concerns include: (1) reset
    every possible property for every possible selector for a given scope name;
    (2) re-implement css in javascript.

    As an alternative, users should make sure to use selectors
    specific to the scope in which they are working.

    * ::distributed: This behavior is not emulated. It's often not necessary
    to style the contents of a specific insertion point and instead, descendants
    of the host element can be styled selectively. Users can also create an
    extra node around an insertion point and style that node's contents
    via descendent selectors. For example, with a shadowRoot like this:

      <style>
        ::content(div) {
          background: red;
        }
      </style>
      <content></content>

    could become:

      <style>
        / *@polyfill .content-container div * /
        ::content(div) {
          background: red;
        }
      </style>
      <div class="content-container">
        <content></content>
      </div>

    Note the use of @polyfill in the comment above a ShadowDOM specific style
    declaration. This is a directive to the styling shim to use the selector
    in comments in lieu of the next selector when running under polyfill.
  */
  var ShadowCss = (function () {
      function ShadowCss() {
          this.strictStyling = true;
      }
      /*
      * Shim some cssText with the given selector. Returns cssText that can
      * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
      *
      * When strictStyling is true:
      * - selector is the attribute added to all elements inside the host,
      * - hostSelector is the attribute added to the host itself.
      */
      ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {
          if (hostSelector === void 0) { hostSelector = ''; }
          var sourceMappingUrl = extractSourceMappingUrl(cssText);
          cssText = stripComments(cssText);
          cssText = this._insertDirectives(cssText);
          return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;
      };
      ShadowCss.prototype._insertDirectives = function (cssText) {
          cssText = this._insertPolyfillDirectivesInCssText(cssText);
          return this._insertPolyfillRulesInCssText(cssText);
      };
      /*
       * Process styles to convert native ShadowDOM rules that will trip
       * up the css parser; we rely on decorating the stylesheet with inert rules.
       *
       * For example, we convert this rule:
       *
       * polyfill-next-selector { content: ':host menu-item'; }
       * ::content menu-item {
       *
       * to this:
       *
       * scopeName menu-item {
       *
      **/
      ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {
          // Difference with webcomponents.js: does not handle comments
          return cssText.replace(_cssContentNextSelectorRe, function () {
              var m = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  m[_i - 0] = arguments[_i];
              }
              return m[2] + '{';
          });
      };
      /*
       * Process styles to add rules which will only apply under the polyfill
       *
       * For example, we convert this rule:
       *
       * polyfill-rule {
       *   content: ':host menu-item';
       * ...
       * }
       *
       * to this:
       *
       * scopeName menu-item {...}
       *
      **/
      ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {
          // Difference with webcomponents.js: does not handle comments
          return cssText.replace(_cssContentRuleRe, function () {
              var m = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  m[_i - 0] = arguments[_i];
              }
              var rule = m[0].replace(m[1], '').replace(m[2], '');
              return m[4] + rule;
          });
      };
      /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
       *
       *  .foo {... }
       *
       *  and converts this to
       *
       *  scopeName .foo { ... }
      */
      ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {
          var unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
          // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
          cssText = this._insertPolyfillHostInCssText(cssText);
          cssText = this._convertColonHost(cssText);
          cssText = this._convertColonHostContext(cssText);
          cssText = this._convertShadowDOMSelectors(cssText);
          if (scopeSelector) {
              cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
          }
          cssText = cssText + '\n' + unscopedRules;
          return cssText.trim();
      };
      /*
       * Process styles to add rules which will only apply under the polyfill
       * and do not process via CSSOM. (CSSOM is destructive to rules on rare
       * occasions, e.g. -webkit-calc on Safari.)
       * For example, we convert this rule:
       *
       * @polyfill-unscoped-rule {
       *   content: 'menu-item';
       * ... }
       *
       * to this:
       *
       * menu-item {...}
       *
      **/
      ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {
          // Difference with webcomponents.js: does not handle comments
          var r = '';
          var m;
          _cssContentUnscopedRuleRe.lastIndex = 0;
          while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
              var rule = m[0].replace(m[2], '').replace(m[1], m[4]);
              r += rule + '\n\n';
          }
          return r;
      };
      /*
       * convert a rule like :host(.foo) > .bar { }
       *
       * to
       *
       * .foo<scopeName> > .bar
      */
      ShadowCss.prototype._convertColonHost = function (cssText) {
          return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
      };
      /*
       * convert a rule like :host-context(.foo) > .bar { }
       *
       * to
       *
       * .foo<scopeName> > .bar, .foo scopeName > .bar { }
       *
       * and
       *
       * :host-context(.foo:host) .bar { ... }
       *
       * to
       *
       * .foo<scopeName> .bar { ... }
      */
      ShadowCss.prototype._convertColonHostContext = function (cssText) {
          return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
      };
      ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {
          // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
          return cssText.replace(regExp, function () {
              var m = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  m[_i - 0] = arguments[_i];
              }
              if (m[2]) {
                  var parts = m[2].split(',');
                  var r = [];
                  for (var i = 0; i < parts.length; i++) {
                      var p = parts[i].trim();
                      if (!p)
                          break;
                      r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                  }
                  return r.join(',');
              }
              else {
                  return _polyfillHostNoCombinator + m[3];
              }
          });
      };
      ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {
          if (part.indexOf(_polyfillHost) > -1) {
              return this._colonHostPartReplacer(host, part, suffix);
          }
          else {
              return host + part + suffix + ', ' + part + ' ' + host + suffix;
          }
      };
      ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {
          return host + part.replace(_polyfillHost, '') + suffix;
      };
      /*
       * Convert combinators like ::shadow and pseudo-elements like ::content
       * by replacing with space.
      */
      ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {
          return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);
      };
      // change a selector like 'div' to 'name div'
      ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {
          var _this = this;
          return processRules(cssText, function (rule) {
              var selector = rule.selector;
              var content = rule.content;
              if (rule.selector[0] != '@') {
                  selector =
                      _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);
              }
              else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
                  rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
                  content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);
              }
              return new CssRule(selector, content);
          });
      };
      ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {
          var _this = this;
          return selector.split(',')
              .map(function (part) { return part.trim().split(_shadowDeepSelectors); })
              .map(function (deepParts) {
              var shallowPart = deepParts[0], otherParts = deepParts.slice(1);
              var applyScope = function (shallowPart) {
                  if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {
                      return strict ?
                          _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
                          _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
                  }
                  else {
                      return shallowPart;
                  }
              };
              return [applyScope(shallowPart)].concat(otherParts).join(' ');
          })
              .join(', ');
      };
      ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {
          var re = this._makeScopeMatcher(scopeSelector);
          return !re.test(selector);
      };
      ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {
          var lre = /\[/g;
          var rre = /\]/g;
          scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
          return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
      };
      ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {
          // Difference from webcomponents.js: scopeSelector could not be an array
          return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
      };
      // scope via name and [is=name]
      ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {
          // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
          _polyfillHostRe.lastIndex = 0;
          if (_polyfillHostRe.test(selector)) {
              var replaceBy_1 = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
              return selector.replace(_polyfillHostNoCombinatorRe, function (hnc, selector) { return selector + replaceBy_1; })
                  .replace(_polyfillHostRe, replaceBy_1 + ' ');
          }
          return scopeSelector + ' ' + selector;
      };
      // return a selector with [name] suffix on each simple selector
      // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
      ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {
          var _this = this;
          var isRe = /\[is=([^\]]*)\]/g;
          scopeSelector = scopeSelector.replace(isRe, function (_) {
              var parts = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                  parts[_i - 1] = arguments[_i];
              }
              return parts[0];
          });
          var attrName = '[' + scopeSelector + ']';
          var _scopeSelectorPart = function (p) {
              var scopedP = p.trim();
              if (!scopedP) {
                  return '';
              }
              if (p.indexOf(_polyfillHostNoCombinator) > -1) {
                  scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
              }
              else {
                  // remove :host since it should be unnecessary
                  var t = p.replace(_polyfillHostRe, '');
                  if (t.length > 0) {
                      var matches = t.match(/([^:]*)(:*)(.*)/);
                      if (matches !== null) {
                          scopedP = matches[1] + attrName + matches[2] + matches[3];
                      }
                  }
              }
              return scopedP;
          };
          var attrSelectorIndex = 0;
          var attrSelectors = [];
          // replace attribute selectors with placeholders to avoid issue with white space being treated
          // as separator
          selector = selector.replace(/\[[^\]]*\]/g, function (attrSelector) {
              var replaceBy = "__attr_sel_" + attrSelectorIndex + "__";
              attrSelectors.push(attrSelector);
              attrSelectorIndex++;
              return replaceBy;
          });
          var scopedSelector = '';
          var startIndex = 0;
          var res;
          var sep = /( |>|\+|~(?!=))\s*/g;
          var scopeAfter = selector.indexOf(_polyfillHostNoCombinator);
          while ((res = sep.exec(selector)) !== null) {
              var separator = res[1];
              var part = selector.slice(startIndex, res.index).trim();
              // if a selector appears before :host-context it should not be shimmed as it
              // matches on ancestor elements and not on elements in the host's shadow
              var scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;
              scopedSelector += scopedPart + " " + separator + " ";
              startIndex = sep.lastIndex;
          }
          scopedSelector += _scopeSelectorPart(selector.substring(startIndex));
          // replace the placeholders with their original values
          return scopedSelector.replace(/__attr_sel_(\d+)__/g, function (ph, index) { return attrSelectors[+index]; });
      };
      ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {
          return selector.replace(_colonHostContextRe, _polyfillHostContext)
              .replace(_colonHostRe, _polyfillHost);
      };
      return ShadowCss;
  }());
  var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
  var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  var _polyfillHost = '-shadowcsshost';
  // note: :host-context pre-processed to -shadowcsshostcontext.
  var _polyfillHostContext = '-shadowcsscontext';
  var _parenSuffix = ')(?:\\((' +
      '(?:\\([^)(]*\\)|[^)(]*)+?' +
      ')\\))?([^,{]*)';
  var _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
  var _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
  var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
  var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
  var _shadowDOMSelectorsRe = [
      /::shadow/g,
      /::content/g,
      // Deprecated selectors
      /\/shadow-deep\//g,
      /\/shadow\//g,
  ];
  var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)/g;
  var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
  var _polyfillHostRe = /-shadowcsshost/gim;
  var _colonHostRe = /:host/gim;
  var _colonHostContextRe = /:host-context/gim;
  var _commentRe = /\/\*\s*[\s\S]*?\*\//g;
  function stripComments(input) {
      return input.replace(_commentRe, '');
  }
  // all comments except inline source mapping
  var _sourceMappingUrlRe = /\/\*\s*#\s*sourceMappingURL=[\s\S]+?\*\//;
  function extractSourceMappingUrl(input) {
      var matcher = input.match(_sourceMappingUrlRe);
      return matcher ? matcher[0] : '';
  }
  var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
  var _curlyRe = /([{}])/g;
  var OPEN_CURLY = '{';
  var CLOSE_CURLY = '}';
  var BLOCK_PLACEHOLDER = '%BLOCK%';
  var CssRule = (function () {
      function CssRule(selector, content) {
          this.selector = selector;
          this.content = content;
      }
      return CssRule;
  }());
  function processRules(input, ruleCallback) {
      var inputWithEscapedBlocks = escapeBlocks(input);
      var nextBlockIndex = 0;
      return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {
          var m = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              m[_i - 0] = arguments[_i];
          }
          var selector = m[2];
          var content = '';
          var suffix = m[4];
          var contentPrefix = '';
          if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
              content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
              suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
              contentPrefix = '{';
          }
          var rule = ruleCallback(new CssRule(selector, content));
          return "" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;
      });
  }
  var StringWithEscapedBlocks = (function () {
      function StringWithEscapedBlocks(escapedString, blocks) {
          this.escapedString = escapedString;
          this.blocks = blocks;
      }
      return StringWithEscapedBlocks;
  }());
  function escapeBlocks(input) {
      var inputParts = input.split(_curlyRe);
      var resultParts = [];
      var escapedBlocks = [];
      var bracketCount = 0;
      var currentBlockParts = [];
      for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {
          var part = inputParts[partIndex];
          if (part == CLOSE_CURLY) {
              bracketCount--;
          }
          if (bracketCount > 0) {
              currentBlockParts.push(part);
          }
          else {
              if (currentBlockParts.length > 0) {
                  escapedBlocks.push(currentBlockParts.join(''));
                  resultParts.push(BLOCK_PLACEHOLDER);
                  currentBlockParts = [];
              }
              resultParts.push(part);
          }
          if (part == OPEN_CURLY) {
              bracketCount++;
          }
      }
      if (currentBlockParts.length > 0) {
          escapedBlocks.push(currentBlockParts.join(''));
          resultParts.push(BLOCK_PLACEHOLDER);
      }
      return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
  }

  var COMPONENT_VARIABLE = '%COMP%';
  var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
  var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
  var StylesCompileDependency = (function () {
      function StylesCompileDependency(moduleUrl, isShimmed, valuePlaceholder) {
          this.moduleUrl = moduleUrl;
          this.isShimmed = isShimmed;
          this.valuePlaceholder = valuePlaceholder;
      }
      return StylesCompileDependency;
  }());
  var StylesCompileResult = (function () {
      function StylesCompileResult(componentStylesheet, externalStylesheets) {
          this.componentStylesheet = componentStylesheet;
          this.externalStylesheets = externalStylesheets;
      }
      return StylesCompileResult;
  }());
  var CompiledStylesheet = (function () {
      function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {
          this.statements = statements;
          this.stylesVar = stylesVar;
          this.dependencies = dependencies;
          this.isShimmed = isShimmed;
          this.meta = meta;
      }
      return CompiledStylesheet;
  }());
  var StyleCompiler = (function () {
      function StyleCompiler(_urlResolver) {
          this._urlResolver = _urlResolver;
          this._shadowCss = new ShadowCss();
      }
      StyleCompiler.prototype.compileComponent = function (comp) {
          var _this = this;
          var externalStylesheets = [];
          var componentStylesheet = this._compileStyles(comp, new CompileStylesheetMetadata({
              styles: comp.template.styles,
              styleUrls: comp.template.styleUrls,
              moduleUrl: comp.type.moduleUrl
          }), true);
          comp.template.externalStylesheets.forEach(function (stylesheetMeta) {
              var compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);
              externalStylesheets.push(compiledStylesheet);
          });
          return new StylesCompileResult(componentStylesheet, externalStylesheets);
      };
      StyleCompiler.prototype._compileStyles = function (comp, stylesheet, isComponentStylesheet) {
          var _this = this;
          var shim = comp.template.encapsulation === _angular_core.ViewEncapsulation.Emulated;
          var styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });
          var dependencies = [];
          for (var i = 0; i < stylesheet.styleUrls.length; i++) {
              var identifier = new CompileIdentifierMetadata({ name: getStylesVarName(null) });
              dependencies.push(new StylesCompileDependency(stylesheet.styleUrls[i], shim, identifier));
              styleExpressions.push(new ExternalExpr(identifier));
          }
          // styles variable contains plain strings and arrays of other styles arrays (recursive),
          // so we set its type to dynamic.
          var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);
          var stmt = variable(stylesVar)
              .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))
              .toDeclStmt(null, [StmtModifier.Final]);
          return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);
      };
      StyleCompiler.prototype._shimIfNeeded = function (style, shim) {
          return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
      };
      StyleCompiler.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      StyleCompiler.ctorParameters = [
          { type: UrlResolver, },
      ];
      return StyleCompiler;
  }());
  function getStylesVarName(component) {
      var result = "styles";
      if (component) {
          result += "_" + component.type.name;
      }
      return result;
  }

  /**
   * An internal module of the Angular compiler that begins with component types,
   * extracts templates, and eventually produces a compiled version of the component
   * ready for linking into an application.
   *
   * @security  When compiling templates at runtime, you must ensure that the entire template comes
   * from a trusted source. Attacker-controlled data introduced by a template could expose your
   * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).
   */
  var RuntimeCompiler = (function () {
      function RuntimeCompiler(_injector, _metadataResolver, _templateNormalizer, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _compilerConfig) {
          this._injector = _injector;
          this._metadataResolver = _metadataResolver;
          this._templateNormalizer = _templateNormalizer;
          this._templateParser = _templateParser;
          this._styleCompiler = _styleCompiler;
          this._viewCompiler = _viewCompiler;
          this._ngModuleCompiler = _ngModuleCompiler;
          this._compilerConfig = _compilerConfig;
          this._compiledTemplateCache = new Map();
          this._compiledHostTemplateCache = new Map();
          this._compiledNgModuleCache = new Map();
          this._animationParser = new AnimationParser();
          this._animationCompiler = new AnimationCompiler();
      }
      Object.defineProperty(RuntimeCompiler.prototype, "injector", {
          get: function () { return this._injector; },
          enumerable: true,
          configurable: true
      });
      RuntimeCompiler.prototype.compileModuleSync = function (moduleType) {
          return this._compileModuleAndComponents(moduleType, true).syncResult;
      };
      RuntimeCompiler.prototype.compileModuleAsync = function (moduleType) {
          return this._compileModuleAndComponents(moduleType, false).asyncResult;
      };
      RuntimeCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
          return this._compileModuleAndAllComponents(moduleType, true).syncResult;
      };
      RuntimeCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
          return this._compileModuleAndAllComponents(moduleType, false).asyncResult;
      };
      RuntimeCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {
          var componentPromise = this._compileComponents(moduleType, isSync);
          var ngModuleFactory = this._compileModule(moduleType);
          return new SyncAsyncResult(ngModuleFactory, componentPromise.then(function () { return ngModuleFactory; }));
      };
      RuntimeCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {
          var _this = this;
          var componentPromise = this._compileComponents(moduleType, isSync);
          var ngModuleFactory = this._compileModule(moduleType);
          var moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType);
          var componentFactories = [];
          var templates = new Set();
          moduleMeta.transitiveModule.modules.forEach(function (moduleMeta) {
              moduleMeta.declaredDirectives.forEach(function (dirMeta) {
                  if (dirMeta.isComponent) {
                      var template = _this._createCompiledHostTemplate(dirMeta.type.reference);
                      templates.add(template);
                      componentFactories.push(template.proxyComponentFactory);
                  }
              });
          });
          var syncResult = new _angular_core.ModuleWithComponentFactories(ngModuleFactory, componentFactories);
          // Note: host components themselves can always be compiled synchronously as they have an
          // inline template. However, we still need to wait for the components that they
          // reference to be loaded / compiled.
          var compile = function () {
              templates.forEach(function (template) { _this._compileTemplate(template); });
              return syncResult;
          };
          var asyncResult = isSync ? Promise.resolve(compile()) : componentPromise.then(compile);
          return new SyncAsyncResult(syncResult, asyncResult);
      };
      RuntimeCompiler.prototype._compileModule = function (moduleType) {
          var _this = this;
          var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);
          if (!ngModuleFactory) {
              var moduleMeta_1 = this._metadataResolver.getNgModuleMetadata(moduleType);
              // Always provide a bound Compiler
              var extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(_angular_core.Compiler, { useFactory: function () { return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference); } }))];
              var compileResult = this._ngModuleCompiler.compile(moduleMeta_1, extraProviders);
              compileResult.dependencies.forEach(function (dep) {
                  dep.placeholder.reference =
                      _this._assertComponentKnown(dep.comp.reference, true).proxyComponentFactory;
                  dep.placeholder.name = "compFactory_" + dep.comp.name;
              });
              if (!this._compilerConfig.useJit) {
                  ngModuleFactory =
                      interpretStatements(compileResult.statements, compileResult.ngModuleFactoryVar);
              }
              else {
                  ngModuleFactory = jitStatements(moduleMeta_1.type.name + ".ngfactory.js", compileResult.statements, compileResult.ngModuleFactoryVar);
              }
              this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);
          }
          return ngModuleFactory;
      };
      /**
       * @internal
       */
      RuntimeCompiler.prototype._compileComponents = function (mainModule, isSync) {
          var _this = this;
          var templates = new Set();
          var loadingPromises = [];
          var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);
          ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {
              localModuleMeta.declaredDirectives.forEach(function (dirMeta) {
                  if (dirMeta.isComponent) {
                      templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));
                      dirMeta.entryComponents.forEach(function (entryComponentType) {
                          templates.add(_this._createCompiledHostTemplate(entryComponentType.reference));
                      });
                  }
              });
              localModuleMeta.entryComponents.forEach(function (entryComponentType) {
                  templates.add(_this._createCompiledHostTemplate(entryComponentType.reference));
                  // TODO: what about entryComponents of entryComponents?
              });
          });
          templates.forEach(function (template) {
              if (template.loading) {
                  if (isSync) {
                      throw new ComponentStillLoadingError(template.compType.reference);
                  }
                  else {
                      loadingPromises.push(template.loading);
                  }
              }
          });
          var compile = function () { templates.forEach(function (template) { _this._compileTemplate(template); }); };
          if (isSync) {
              compile();
              return Promise.resolve(null);
          }
          else {
              return Promise.all(loadingPromises).then(compile);
          }
      };
      RuntimeCompiler.prototype.clearCacheFor = function (type) {
          this._compiledNgModuleCache.delete(type);
          this._metadataResolver.clearCacheFor(type);
          this._compiledHostTemplateCache.delete(type);
          var compiledTemplate = this._compiledTemplateCache.get(type);
          if (compiledTemplate) {
              this._templateNormalizer.clearCacheFor(compiledTemplate.normalizedCompMeta);
              this._compiledTemplateCache.delete(type);
          }
      };
      RuntimeCompiler.prototype.clearCache = function () {
          this._metadataResolver.clearCache();
          this._compiledTemplateCache.clear();
          this._compiledHostTemplateCache.clear();
          this._templateNormalizer.clearCache();
          this._compiledNgModuleCache.clear();
      };
      RuntimeCompiler.prototype._createCompiledHostTemplate = function (compType) {
          var compiledTemplate = this._compiledHostTemplateCache.get(compType);
          if (!compiledTemplate) {
              var compMeta = this._metadataResolver.getDirectiveMetadata(compType);
              assertComponent(compMeta);
              var hostMeta = createHostComponentMeta(compMeta);
              compiledTemplate = new CompiledTemplate(true, compMeta.selector, compMeta.type, [compMeta], [], [], this._templateNormalizer.normalizeDirective(hostMeta));
              this._compiledHostTemplateCache.set(compType, compiledTemplate);
          }
          return compiledTemplate;
      };
      RuntimeCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {
          var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);
          if (!compiledTemplate) {
              assertComponent(compMeta);
              compiledTemplate = new CompiledTemplate(false, compMeta.selector, compMeta.type, ngModule.transitiveModule.directives, ngModule.transitiveModule.pipes, ngModule.schemas, this._templateNormalizer.normalizeDirective(compMeta));
              this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);
          }
          return compiledTemplate;
      };
      RuntimeCompiler.prototype._assertComponentKnown = function (compType, isHost) {
          var compiledTemplate = isHost ? this._compiledHostTemplateCache.get(compType) :
              this._compiledTemplateCache.get(compType);
          if (!compiledTemplate) {
              if (isHost) {
                  throw new Error("Illegal state: Compiled view for component " + stringify(compType) + " does not exist!");
              }
              else {
                  throw new Error("Component " + stringify(compType) + " is not part of any NgModule or the module has not been imported into your module.");
              }
          }
          return compiledTemplate;
      };
      RuntimeCompiler.prototype._assertComponentLoaded = function (compType, isHost) {
          var compiledTemplate = this._assertComponentKnown(compType, isHost);
          if (compiledTemplate.loading) {
              throw new Error("Illegal state: CompiledTemplate for " + stringify(compType) + " (isHost: " + isHost + ") is still loading!");
          }
          return compiledTemplate;
      };
      RuntimeCompiler.prototype._compileTemplate = function (template) {
          var _this = this;
          if (template.isCompiled) {
              return;
          }
          var compMeta = template.normalizedCompMeta;
          var externalStylesheetsByModuleUrl = new Map();
          var stylesCompileResult = this._styleCompiler.compileComponent(compMeta);
          stylesCompileResult.externalStylesheets.forEach(function (r) { externalStylesheetsByModuleUrl.set(r.meta.moduleUrl, r); });
          this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);
          var viewCompMetas = template.viewComponentTypes.map(function (compType) { return _this._assertComponentLoaded(compType, false).normalizedCompMeta; });
          var parsedAnimations = this._animationParser.parseComponent(compMeta);
          var parsedTemplate = this._templateParser.parse(compMeta, compMeta.template.template, template.viewDirectives.concat(viewCompMetas), template.viewPipes, template.schemas, compMeta.type.name);
          var compiledAnimations = this._animationCompiler.compile(compMeta.type.name, parsedAnimations);
          var compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(stylesCompileResult.componentStylesheet.stylesVar), template.viewPipes, compiledAnimations);
          compileResult.dependencies.forEach(function (dep) {
              var depTemplate;
              if (dep instanceof ViewFactoryDependency) {
                  var vfd = dep;
                  depTemplate = _this._assertComponentLoaded(vfd.comp.reference, false);
                  vfd.placeholder.reference = depTemplate.proxyViewFactory;
                  vfd.placeholder.name = "viewFactory_" + vfd.comp.name;
              }
              else if (dep instanceof ComponentFactoryDependency) {
                  var cfd = dep;
                  depTemplate = _this._assertComponentLoaded(cfd.comp.reference, true);
                  cfd.placeholder.reference = depTemplate.proxyComponentFactory;
                  cfd.placeholder.name = "compFactory_" + cfd.comp.name;
              }
          });
          var statements = stylesCompileResult.componentStylesheet.statements.concat(compileResult.statements);
          compiledAnimations.forEach(function (entry) { entry.statements.forEach(function (statement) { statements.push(statement); }); });
          var factory;
          if (!this._compilerConfig.useJit) {
              factory = interpretStatements(statements, compileResult.viewFactoryVar);
          }
          else {
              factory = jitStatements("" + template.compType.name + (template.isHost ? '_Host' : '') + ".ngfactory.js", statements, compileResult.viewFactoryVar);
          }
          template.compiled(factory);
      };
      RuntimeCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {
          var _this = this;
          result.dependencies.forEach(function (dep, i) {
              var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);
              var nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);
              dep.valuePlaceholder.reference = nestedStylesArr;
              dep.valuePlaceholder.name = "importedStyles" + i;
          });
      };
      RuntimeCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {
          this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
          if (!this._compilerConfig.useJit) {
              return interpretStatements(result.statements, result.stylesVar);
          }
          else {
              return jitStatements(result.meta.moduleUrl + ".css.js", result.statements, result.stylesVar);
          }
      };
      RuntimeCompiler.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      RuntimeCompiler.ctorParameters = [
          { type: _angular_core.Injector, },
          { type: CompileMetadataResolver, },
          { type: DirectiveNormalizer, },
          { type: TemplateParser, },
          { type: StyleCompiler, },
          { type: ViewCompiler, },
          { type: NgModuleCompiler, },
          { type: CompilerConfig, },
      ];
      return RuntimeCompiler;
  }());
  var CompiledTemplate = (function () {
      function CompiledTemplate(isHost, selector, compType, viewDirectivesAndComponents, viewPipes, schemas, _normalizeResult) {
          var _this = this;
          this.isHost = isHost;
          this.compType = compType;
          this.viewPipes = viewPipes;
          this.schemas = schemas;
          this._viewFactory = null;
          this.loading = null;
          this._normalizedCompMeta = null;
          this.isCompiled = false;
          this.isCompiledWithDeps = false;
          this.viewComponentTypes = [];
          this.viewDirectives = [];
          viewDirectivesAndComponents.forEach(function (dirMeta) {
              if (dirMeta.isComponent) {
                  _this.viewComponentTypes.push(dirMeta.type.reference);
              }
              else {
                  _this.viewDirectives.push(dirMeta);
              }
          });
          this.proxyViewFactory = function () {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i - 0] = arguments[_i];
              }
              if (!_this._viewFactory) {
                  throw new Error("Illegal state: CompiledTemplate for " + stringify(_this.compType) + " is not compiled yet!");
              }
              return _this._viewFactory.apply(null, args);
          };
          this.proxyComponentFactory = isHost ?
              new _angular_core.ComponentFactory(selector, this.proxyViewFactory, compType.reference) :
              null;
          if (_normalizeResult.syncResult) {
              this._normalizedCompMeta = _normalizeResult.syncResult;
          }
          else {
              this.loading = _normalizeResult.asyncResult.then(function (normalizedCompMeta) {
                  _this._normalizedCompMeta = normalizedCompMeta;
                  _this.loading = null;
              });
          }
      }
      Object.defineProperty(CompiledTemplate.prototype, "normalizedCompMeta", {
          get: function () {
              if (this.loading) {
                  throw new Error("Template is still loading for " + this.compType.name + "!");
              }
              return this._normalizedCompMeta;
          },
          enumerable: true,
          configurable: true
      });
      CompiledTemplate.prototype.compiled = function (viewFactory) {
          this._viewFactory = viewFactory;
          this.isCompiled = true;
      };
      CompiledTemplate.prototype.depsCompiled = function () { this.isCompiledWithDeps = true; };
      return CompiledTemplate;
  }());
  function assertComponent(meta) {
      if (!meta.isComponent) {
          throw new Error("Could not compile '" + meta.type.name + "' because it is not a component.");
      }
  }
  /**
   * Implements `Compiler` by delegating to the RuntimeCompiler using a known module.
   */
  var ModuleBoundCompiler = (function () {
      function ModuleBoundCompiler(_delegate, _ngModule) {
          this._delegate = _delegate;
          this._ngModule = _ngModule;
      }
      Object.defineProperty(ModuleBoundCompiler.prototype, "_injector", {
          get: function () { return this._delegate.injector; },
          enumerable: true,
          configurable: true
      });
      ModuleBoundCompiler.prototype.compileModuleSync = function (moduleType) {
          return this._delegate.compileModuleSync(moduleType);
      };
      ModuleBoundCompiler.prototype.compileModuleAsync = function (moduleType) {
          return this._delegate.compileModuleAsync(moduleType);
      };
      ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
          return this._delegate.compileModuleAndAllComponentsSync(moduleType);
      };
      ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
          return this._delegate.compileModuleAndAllComponentsAsync(moduleType);
      };
      /**
       * Clears all caches
       */
      ModuleBoundCompiler.prototype.clearCache = function () { this._delegate.clearCache(); };
      /**
       * Clears the cache for the given component/ngModule.
       */
      ModuleBoundCompiler.prototype.clearCacheFor = function (type) { this._delegate.clearCacheFor(type); };
      return ModuleBoundCompiler;
  }());

  // =================================================================================================
  // =================================================================================================
  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
  // =================================================================================================
  // =================================================================================================
  //
  //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
  //                               Reach out to mprobst for details.
  //
  // =================================================================================================
  /** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */
  var SECURITY_SCHEMA = {};
  function registerContext(ctx, specs) {
      for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {
          var spec = specs_1[_i];
          SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
      }
  }
  // Case is insignificant below, all element and attribute names are lower-cased for lookup.
  registerContext(_angular_core.SecurityContext.HTML, [
      'iframe|srcdoc',
      '*|innerHTML',
      '*|outerHTML',
  ]);
  registerContext(_angular_core.SecurityContext.STYLE, ['*|style']);
  // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
  registerContext(_angular_core.SecurityContext.URL, [
      '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',
      'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',
      'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',
      'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',
  ]);
  registerContext(_angular_core.SecurityContext.RESOURCE_URL, [
      'applet|code',
      'applet|codebase',
      'base|href',
      'embed|src',
      'frame|src',
      'head|profile',
      'html|manifest',
      'iframe|src',
      'link|href',
      'media|src',
      'object|codebase',
      'object|data',
      'script|src',
  ]);

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var __extends$19 = (this && this.__extends) || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  var BOOLEAN = 'boolean';
  var NUMBER = 'number';
  var STRING = 'string';
  var OBJECT = 'object';
  /**
   * This array represents the DOM schema. It encodes inheritance, properties, and events.
   *
   * ## Overview
   *
   * Each line represents one kind of element. The `element_inheritance` and properties are joined
   * using `element_inheritance|properties` syntax.
   *
   * ## Element Inheritance
   *
   * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
   * Here the individual elements are separated by `,` (commas). Every element in the list
   * has identical properties.
   *
   * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
   * specified then `""` (blank) element is assumed.
   *
   * NOTE: The blank element inherits from root `[Element]` element, the super element of all
   * elements.
   *
   * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
   *
   * ## Properties
   *
   * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
   * by a special character designating its type:
   *
   * - (no prefix): property is a string.
   * - `*`: property represents an event.
   * - `!`: property is a boolean.
   * - `#`: property is a number.
   * - `%`: property is an object.
   *
   * ## Query
   *
   * The class creates an internal squas representation which allows to easily answer the query of
   * if a given property exist on a given element.
   *
   * NOTE: We don't yet support querying for types or events.
   * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
   *       see dom_element_schema_registry_spec.ts
   */
  // =================================================================================================
  // =================================================================================================
  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
  // =================================================================================================
  // =================================================================================================
  //
  //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
  //
  // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
  // dom_security_schema.ts. Reach out to mprobst & rjamet for details.
  //
  // =================================================================================================
  var SCHEMA = [
      '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop',
      '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',
      'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',
      'media^[HTMLElement]|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,%srcObject,#volume',
      ':svg:^[HTMLElement]|*abort,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
      ':svg:graphics^:svg:|',
      ':svg:animation^:svg:|*begin,*end,*repeat',
      ':svg:geometry^:svg:|',
      ':svg:componentTransferFunction^:svg:|',
      ':svg:gradient^:svg:|',
      ':svg:textContent^:svg:graphics|',
      ':svg:textPositioning^:svg:textContent|',
      'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',
      'area^[HTMLElement]|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,search,shape,target,username',
      'audio^media|',
      'br^[HTMLElement]|clear',
      'base^[HTMLElement]|href,target',
      'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
      'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
      'canvas^[HTMLElement]|#height,#width',
      'content^[HTMLElement]|select',
      'dl^[HTMLElement]|!compact',
      'datalist^[HTMLElement]|',
      'details^[HTMLElement]|!open',
      'dialog^[HTMLElement]|!open,returnValue',
      'dir^[HTMLElement]|!compact',
      'div^[HTMLElement]|align',
      'embed^[HTMLElement]|align,height,name,src,type,width',
      'fieldset^[HTMLElement]|!disabled,name',
      'font^[HTMLElement]|color,face,size',
      'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
      'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
      'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
      'hr^[HTMLElement]|align,color,!noShade,size,width',
      'head^[HTMLElement]|',
      'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',
      'html^[HTMLElement]|version',
      'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',
      'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',
      'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
      'keygen^[HTMLElement]|!autofocus,challenge,!disabled,keytype,name',
      'li^[HTMLElement]|type,#value',
      'label^[HTMLElement]|htmlFor',
      'legend^[HTMLElement]|align',
      'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type',
      'map^[HTMLElement]|name',
      'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
      'menu^[HTMLElement]|!compact',
      'meta^[HTMLElement]|content,httpEquiv,name,scheme',
      'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',
      'ins,del^[HTMLElement]|cite,dateTime',
      'ol^[HTMLElement]|!compact,!reversed,#start,type',
      'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
      'optgroup^[HTMLElement]|!disabled,label',
      'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',
      'output^[HTMLElement]|defaultValue,%htmlFor,name,value',
      'p^[HTMLElement]|align',
      'param^[HTMLElement]|name,type,value,valueType',
      'picture^[HTMLElement]|',
      'pre^[HTMLElement]|#width',
      'progress^[HTMLElement]|#max,#value',
      'q,blockquote,cite^[HTMLElement]|',
      'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
      'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
      'shadow^[HTMLElement]|',
      'source^[HTMLElement]|media,sizes,src,srcset,type',
      'span^[HTMLElement]|',
      'style^[HTMLElement]|!disabled,media,type',
      'caption^[HTMLElement]|align',
      'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
      'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',
      'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
      'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',
      'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',
      'template^[HTMLElement]|',
      'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
      'title^[HTMLElement]|text',
      'track^[HTMLElement]|!default,kind,label,src,srclang',
      'ul^[HTMLElement]|!compact,type',
      'unknown^[HTMLElement]|',
      'video^media|#height,poster,#width',
      ':svg:a^:svg:graphics|',
      ':svg:animate^:svg:animation|',
      ':svg:animateMotion^:svg:animation|',
      ':svg:animateTransform^:svg:animation|',
      ':svg:circle^:svg:geometry|',
      ':svg:clipPath^:svg:graphics|',
      ':svg:cursor^:svg:|',
      ':svg:defs^:svg:graphics|',
      ':svg:desc^:svg:|',
      ':svg:discard^:svg:|',
      ':svg:ellipse^:svg:geometry|',
      ':svg:feBlend^:svg:|',
      ':svg:feColorMatrix^:svg:|',
      ':svg:feComponentTransfer^:svg:|',
      ':svg:feComposite^:svg:|',
      ':svg:feConvolveMatrix^:svg:|',
      ':svg:feDiffuseLighting^:svg:|',
      ':svg:feDisplacementMap^:svg:|',
      ':svg:feDistantLight^:svg:|',
      ':svg:feDropShadow^:svg:|',
      ':svg:feFlood^:svg:|',
      ':svg:feFuncA^:svg:componentTransferFunction|',
      ':svg:feFuncB^:svg:componentTransferFunction|',
      ':svg:feFuncG^:svg:componentTransferFunction|',
      ':svg:feFuncR^:svg:componentTransferFunction|',
      ':svg:feGaussianBlur^:svg:|',
      ':svg:feImage^:svg:|',
      ':svg:feMerge^:svg:|',
      ':svg:feMergeNode^:svg:|',
      ':svg:feMorphology^:svg:|',
      ':svg:feOffset^:svg:|',
      ':svg:fePointLight^:svg:|',
      ':svg:feSpecularLighting^:svg:|',
      ':svg:feSpotLight^:svg:|',
      ':svg:feTile^:svg:|',
      ':svg:feTurbulence^:svg:|',
      ':svg:filter^:svg:|',
      ':svg:foreignObject^:svg:graphics|',
      ':svg:g^:svg:graphics|',
      ':svg:image^:svg:graphics|',
      ':svg:line^:svg:geometry|',
      ':svg:linearGradient^:svg:gradient|',
      ':svg:mpath^:svg:|',
      ':svg:marker^:svg:|',
      ':svg:mask^:svg:|',
      ':svg:metadata^:svg:|',
      ':svg:path^:svg:geometry|',
      ':svg:pattern^:svg:|',
      ':svg:polygon^:svg:geometry|',
      ':svg:polyline^:svg:geometry|',
      ':svg:radialGradient^:svg:gradient|',
      ':svg:rect^:svg:geometry|',
      ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',
      ':svg:script^:svg:|type',
      ':svg:set^:svg:animation|',
      ':svg:stop^:svg:|',
      ':svg:style^:svg:|!disabled,media,title,type',
      ':svg:switch^:svg:graphics|',
      ':svg:symbol^:svg:|',
      ':svg:tspan^:svg:textPositioning|',
      ':svg:text^:svg:textPositioning|',
      ':svg:textPath^:svg:textContent|',
      ':svg:title^:svg:|',
      ':svg:use^:svg:graphics|',
      ':svg:view^:svg:|#zoomAndPan',
      'data^[HTMLElement]|value',
      'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',
      'summary^[HTMLElement]|',
      'time^[HTMLElement]|dateTime',
  ];
  var _ATTR_TO_PROP = {
      'class': 'className',
      'formaction': 'formAction',
      'innerHtml': 'innerHTML',
      'readonly': 'readOnly',
      'tabindex': 'tabIndex',
  };
  var DomElementSchemaRegistry = (function (_super) {
      __extends$19(DomElementSchemaRegistry, _super);
      function DomElementSchemaRegistry() {
          var _this = this;
          _super.call(this);
          this._schema = {};
          SCHEMA.forEach(function (encodedType) {
              var type = {};
              var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];
              var properties = strProperties.split(',');
              var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];
              typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });
              var superType = superName && _this._schema[superName.toLowerCase()];
              if (superType) {
                  Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });
              }
              properties.forEach(function (property) {
                  if (property.length > 0) {
                      switch (property[0]) {
                          case '*':
                              // We don't yet support events.
                              // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
                              // will
                              // almost certainly introduce bad XSS vulnerabilities.
                              // type[property.substring(1)] = EVENT;
                              break;
                          case '!':
                              type[property.substring(1)] = BOOLEAN;
                              break;
                          case '#':
                              type[property.substring(1)] = NUMBER;
                              break;
                          case '%':
                              type[property.substring(1)] = OBJECT;
                              break;
                          default:
                              type[property] = STRING;
                      }
                  }
              });
          });
      }
      DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {
          if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {
              return true;
          }
          if (tagName.indexOf('-') > -1) {
              if (tagName === 'ng-container' || tagName === 'ng-content') {
                  return false;
              }
              if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {
                  // Can't tell now as we don't know which properties a custom element will get
                  // once it is instantiated
                  return true;
              }
          }
          var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
          return !!elementProperties[propName];
      };
      DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {
          if (schemaMetas.some(function (schema) { return schema.name === _angular_core.NO_ERRORS_SCHEMA.name; })) {
              return true;
          }
          if (tagName.indexOf('-') > -1) {
              if (tagName === 'ng-container' || tagName === 'ng-content') {
                  return true;
              }
              if (schemaMetas.some(function (schema) { return schema.name === _angular_core.CUSTOM_ELEMENTS_SCHEMA.name; })) {
                  // Allow any custom elements
                  return true;
              }
          }
          return !!this._schema[tagName.toLowerCase()];
      };
      /**
       * securityContext returns the security context for the given property on the given DOM tag.
       *
       * Tag and property name are statically known and cannot change at runtime, i.e. it is not
       * possible to bind a value into a changing attribute or tag name.
       *
       * The filtering is white list based. All attributes in the schema above are assumed to have the
       * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
       * attack vectors are assigned their appropriate context.
       */
      DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName) {
          // Make sure comparisons are case insensitive, so that case differences between attribute and
          // property names do not have a security impact.
          tagName = tagName.toLowerCase();
          propName = propName.toLowerCase();
          var ctx = SECURITY_SCHEMA[tagName + '|' + propName];
          if (ctx) {
              return ctx;
          }
          ctx = SECURITY_SCHEMA['*|' + propName];
          return ctx ? ctx : _angular_core.SecurityContext.NONE;
      };
      DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };
      DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };
      DomElementSchemaRegistry.prototype.validateProperty = function (name) {
          if (name.toLowerCase().startsWith('on')) {
              var msg = ("Binding to event property '" + name + "' is disallowed for security reasons, ") +
                  ("please use (" + name.slice(2) + ")=...") +
                  ("\nIf '" + name + "' is a directive input, make sure the directive is imported by the") +
                  " current module.";
              return { error: true, msg: msg };
          }
          else {
              return { error: false };
          }
      };
      DomElementSchemaRegistry.prototype.validateAttribute = function (name) {
          if (name.toLowerCase().startsWith('on')) {
              var msg = ("Binding to event attribute '" + name + "' is disallowed for security reasons, ") +
                  ("please use (" + name.slice(2) + ")=...");
              return { error: true, msg: msg };
          }
          else {
              return { error: false };
          }
      };
      DomElementSchemaRegistry.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      DomElementSchemaRegistry.ctorParameters = [];
      return DomElementSchemaRegistry;
  }(ElementSchemaRegistry));

  var _NO_RESOURCE_LOADER = {
      get: function (url) {
          throw new Error("No ResourceLoader implementation has been provided. Can't read the url \"" + url + "\"");
      }
  };
  /**
   * A set of providers that provide `RuntimeCompiler` and its dependencies to use for
   * template compilation.
   */
  var COMPILER_PROVIDERS = [
      { provide: Reflector, useValue: reflector },
      { provide: ReflectorReader, useExisting: Reflector },
      { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },
      Console,
      Lexer,
      Parser,
      HtmlParser,
      {
          provide: I18NHtmlParser,
          useFactory: function (parser, translations, format) {
              return new I18NHtmlParser(parser, translations, format);
          },
          deps: [
              HtmlParser,
              [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS)],
              [new _angular_core.Optional(), new _angular_core.Inject(_angular_core.TRANSLATIONS_FORMAT)],
          ]
      },
      TemplateParser,
      DirectiveNormalizer,
      CompileMetadataResolver,
      DEFAULT_PACKAGE_URL_PROVIDER,
      StyleCompiler,
      ViewCompiler,
      NgModuleCompiler,
      { provide: CompilerConfig, useValue: new CompilerConfig() },
      RuntimeCompiler,
      { provide: _angular_core.Compiler, useExisting: RuntimeCompiler },
      DomElementSchemaRegistry,
      { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },
      UrlResolver,
      DirectiveResolver,
      PipeResolver,
      NgModuleResolver
  ];
  var RuntimeCompilerFactory = (function () {
      function RuntimeCompilerFactory(defaultOptions) {
          this._defaultOptions = [{
                  useDebug: _angular_core.isDevMode(),
                  useJit: true,
                  defaultEncapsulation: _angular_core.ViewEncapsulation.Emulated
              }].concat(defaultOptions);
      }
      RuntimeCompilerFactory.prototype.createCompiler = function (options) {
          if (options === void 0) { options = []; }
          var mergedOptions = _mergeOptions(this._defaultOptions.concat(options));
          var injector = _angular_core.ReflectiveInjector.resolveAndCreate([
              COMPILER_PROVIDERS, {
                  provide: CompilerConfig,
                  useFactory: function () {
                      return new CompilerConfig({
                          // let explicit values from the compiler options overwrite options
                          // from the app providers. E.g. important for the testing platform.
                          genDebugInfo: mergedOptions.useDebug,
                          // let explicit values from the compiler options overwrite options
                          // from the app providers
                          useJit: mergedOptions.useJit,
                          // let explicit values from the compiler options overwrite options
                          // from the app providers
                          defaultEncapsulation: mergedOptions.defaultEncapsulation,
                          logBindingUpdate: mergedOptions.useDebug
                      });
                  },
                  deps: []
              },
              mergedOptions.providers
          ]);
          return injector.get(_angular_core.Compiler);
      };
      RuntimeCompilerFactory.decorators = [
          { type: _angular_core.Injectable },
      ];
      /** @nocollapse */
      RuntimeCompilerFactory.ctorParameters = [
          { type: Array, decorators: [{ type: _angular_core.Inject, args: [_angular_core.COMPILER_OPTIONS,] },] },
      ];
      return RuntimeCompilerFactory;
  }());
  function _initReflector() {
      reflector.reflectionCapabilities = new ReflectionCapabilities();
  }
  /**
   * A platform that included corePlatform and the compiler.
   *
   * @experimental
   */
  var platformCoreDynamic = _angular_core.createPlatformFactory(_angular_core.platformCore, 'coreDynamic', [
      { provide: _angular_core.COMPILER_OPTIONS, useValue: {}, multi: true },
      { provide: _angular_core.CompilerFactory, useClass: RuntimeCompilerFactory },
      { provide: _angular_core.PLATFORM_INITIALIZER, useValue: _initReflector, multi: true },
  ]);
  function _mergeOptions(optionsArr) {
      return {
          useDebug: _lastDefined(optionsArr.map(function (options) { return options.useDebug; })),
          useJit: _lastDefined(optionsArr.map(function (options) { return options.useJit; })),
          defaultEncapsulation: _lastDefined(optionsArr.map(function (options) { return options.defaultEncapsulation; })),
          providers: _mergeArrays(optionsArr.map(function (options) { return options.providers; }))
      };
  }
  function _lastDefined(args) {
      for (var i = args.length - 1; i >= 0; i--) {
          if (args[i] !== undefined) {
              return args[i];
          }
      }
      return undefined;
  }
  function _mergeArrays(parts) {
      var result = [];
      parts.forEach(function (part) { return part && result.push.apply(result, part); });
      return result;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // asset:<package-name>/<realm>/<path-to-module>
  var _ASSET_URL_RE = /asset:([^\/]+)\/([^\/]+)\/(.+)/;
  /**
   * Interface that defines how import statements should be generated.
   */
  var ImportGenerator = (function () {
      function ImportGenerator() {
      }
      ImportGenerator.parseAssetUrl = function (url) { return AssetUrl.parse(url); };
      return ImportGenerator;
  }());
  var AssetUrl = (function () {
      function AssetUrl(packageName, firstLevelDir, modulePath) {
          this.packageName = packageName;
          this.firstLevelDir = firstLevelDir;
          this.modulePath = modulePath;
      }
      AssetUrl.parse = function (url, allowNonMatching) {
          if (allowNonMatching === void 0) { allowNonMatching = true; }
          var match = url.match(_ASSET_URL_RE);
          if (match !== null) {
              return new AssetUrl(match[1], match[2], match[3]);
          }
          if (allowNonMatching) {
              return null;
          }
          throw new Error("Url " + url + " is not a valid asset: url");
      };
      return AssetUrl;
  }());

  var __compiler_private__ = {
      SelectorMatcher: SelectorMatcher,
      CssSelector: CssSelector,
      AssetUrl: AssetUrl,
      ImportGenerator: ImportGenerator,
      CompileMetadataResolver: CompileMetadataResolver,
      HtmlParser: HtmlParser,
      InterpolationConfig: InterpolationConfig,
      DirectiveNormalizer: DirectiveNormalizer,
      Lexer: Lexer,
      Parser: Parser,
      ParseLocation: ParseLocation,
      ParseError: ParseError,
      ParseErrorLevel: ParseErrorLevel,
      ParseSourceFile: ParseSourceFile,
      ParseSourceSpan: ParseSourceSpan,
      TemplateParser: TemplateParser,
      DomElementSchemaRegistry: DomElementSchemaRegistry,
      StyleCompiler: StyleCompiler,
      ViewCompiler: ViewCompiler,
      NgModuleCompiler: NgModuleCompiler,
      TypeScriptEmitter: TypeScriptEmitter
  };

  exports.COMPILER_PROVIDERS = COMPILER_PROVIDERS;
  exports.CompileDiDependencyMetadata = CompileDiDependencyMetadata;
  exports.CompileDirectiveMetadata = CompileDirectiveMetadata;
  exports.CompileFactoryMetadata = CompileFactoryMetadata;
  exports.CompileIdentifierMetadata = CompileIdentifierMetadata;
  exports.CompileMetadataWithIdentifier = CompileMetadataWithIdentifier;
  exports.CompilePipeMetadata = CompilePipeMetadata;
  exports.CompileProviderMetadata = CompileProviderMetadata;
  exports.CompileQueryMetadata = CompileQueryMetadata;
  exports.CompileTemplateMetadata = CompileTemplateMetadata;
  exports.CompileTokenMetadata = CompileTokenMetadata;
  exports.CompileTypeMetadata = CompileTypeMetadata;
  exports.CompilerConfig = CompilerConfig;
  exports.DEFAULT_PACKAGE_URL_PROVIDER = DEFAULT_PACKAGE_URL_PROVIDER;
  exports.DirectiveResolver = DirectiveResolver;
  exports.NgModuleResolver = NgModuleResolver;
  exports.OfflineCompiler = OfflineCompiler;
  exports.PipeResolver = PipeResolver;
  exports.RenderTypes = RenderTypes;
  exports.ResourceLoader = ResourceLoader;
  exports.RuntimeCompiler = RuntimeCompiler;
  exports.SourceModule = SourceModule;
  exports.TEMPLATE_TRANSFORMS = TEMPLATE_TRANSFORMS;
  exports.UrlResolver = UrlResolver;
  exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;
  exports.platformCoreDynamic = platformCoreDynamic;
  exports.DEFAULT_INTERPOLATION_CONFIG = DEFAULT_INTERPOLATION_CONFIG;
  exports.InterpolationConfig = InterpolationConfig;
  exports.ElementSchemaRegistry = ElementSchemaRegistry;
  exports.I18NHtmlParser = I18NHtmlParser;
  exports.MessageBundle = MessageBundle;
  exports.Xliff = Xliff;
  exports.Xmb = Xmb;
  exports.Xtb = Xtb;
  exports.TextAst = TextAst;
  exports.BoundTextAst = BoundTextAst;
  exports.AttrAst = AttrAst;
  exports.BoundElementPropertyAst = BoundElementPropertyAst;
  exports.BoundEventAst = BoundEventAst;
  exports.ReferenceAst = ReferenceAst;
  exports.VariableAst = VariableAst;
  exports.ElementAst = ElementAst;
  exports.EmbeddedTemplateAst = EmbeddedTemplateAst;
  exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;
  exports.DirectiveAst = DirectiveAst;
  exports.ProviderAst = ProviderAst;
  exports.NgContentAst = NgContentAst;
  exports.templateVisitAll = templateVisitAll;
  exports.__compiler_private__ = __compiler_private__;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@angular/core":3}],3:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.0.2
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/Subject'), require('rxjs/Observable')) :
    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Subject', 'rxjs/Observable'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.Rx,global.Rx));
}(this, function (exports,rxjs_Subject,rxjs_Observable) { 'use strict';

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = self;
        }
        else {
            globalScope = global;
        }
    }
    else {
        globalScope = window;
    }
    function scheduleMicroTask(fn) {
        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var global$1 = globalScope;
    function getTypeNameForDebugging(type) {
        return type['name'] || typeof type;
    }
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    global$1.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }
    function isString(obj) {
        return typeof obj === 'string';
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    function isArray(obj) {
        return Array.isArray(obj);
    }
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return token.overriddenName;
        }
        if (token.name) {
            return token.name;
        }
        var res = token.toString();
        var newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    var StringWrapper = (function () {
        function StringWrapper() {
        }
        StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
        StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
        StringWrapper.split = function (s, regExp) { return s.split(regExp); };
        StringWrapper.equals = function (s, s2) { return s === s2; };
        StringWrapper.stripLeft = function (s, charVal) {
            if (s && s.length) {
                var pos = 0;
                for (var i = 0; i < s.length; i++) {
                    if (s[i] != charVal)
                        break;
                    pos++;
                }
                s = s.substring(pos);
            }
            return s;
        };
        StringWrapper.stripRight = function (s, charVal) {
            if (s && s.length) {
                var pos = s.length;
                for (var i = s.length - 1; i >= 0; i--) {
                    if (s[i] != charVal)
                        break;
                    pos--;
                }
                s = s.substring(0, pos);
            }
            return s;
        };
        StringWrapper.replace = function (s, from, replace) {
            return s.replace(from, replace);
        };
        StringWrapper.replaceAll = function (s, from, replace) {
            return s.replace(from, replace);
        };
        StringWrapper.slice = function (s, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return s.slice(from, to === null ? undefined : to);
        };
        StringWrapper.replaceAllMapped = function (s, from, cb) {
            return s.replace(from, function () {
                var matches = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    matches[_i - 0] = arguments[_i];
                }
                // Remove offset & string from the result array
                matches.splice(-2, 2);
                // The callback receives match, p1, ..., pn
                return cb(matches);
            });
        };
        StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
        StringWrapper.compare = function (a, b) {
            if (a < b) {
                return -1;
            }
            else if (a > b) {
                return 1;
            }
            else {
                return 0;
            }
        };
        return StringWrapper;
    }());
    var NumberWrapper = (function () {
        function NumberWrapper() {
        }
        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
        NumberWrapper.equal = function (a, b) { return a === b; };
        NumberWrapper.parseIntAutoRadix = function (text) {
            var result = parseInt(text);
            if (isNaN(result)) {
                throw new Error('Invalid integer literal when parsing ' + text);
            }
            return result;
        };
        NumberWrapper.parseInt = function (text, radix) {
            if (radix == 10) {
                if (/^(\-|\+)?[0-9]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else if (radix == 16) {
                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else {
                var result = parseInt(text, radix);
                if (!isNaN(result)) {
                    return result;
                }
            }
            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
        };
        Object.defineProperty(NumberWrapper, "NaN", {
            get: function () { return NaN; },
            enumerable: true,
            configurable: true
        });
        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
        NumberWrapper.isNaN = function (value) { return isNaN(value); };
        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
        return NumberWrapper;
    }());
    // JS has NaN !== NaN
    function looseIdentical(a, b) {
        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
    }
    // JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
    function getMapKey(value) {
        return value;
    }
    function isJsObject(o) {
        return o !== null && (typeof o === 'function' || typeof o === 'object');
    }
    function print(obj) {
        console.log(obj);
    }
    function warn(obj) {
        console.warn(obj);
    }
    var _symbolIterator = null;
    function getSymbolIterator() {
        if (isBlank(_symbolIterator)) {
            if (isPresent(globalScope.Symbol) && isPresent(Symbol.iterator)) {
                _symbolIterator = Symbol.iterator;
            }
            else {
                // es6-shim specific logic
                var keys = Object.getOwnPropertyNames(Map.prototype);
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (key !== 'entries' && key !== 'size' &&
                        Map.prototype[key] === Map.prototype['entries']) {
                        _symbolIterator = key;
                    }
                }
            }
        }
        return _symbolIterator;
    }
    function isPrimitive(obj) {
        return !isJsObject(obj);
    }

    var _nextClassId = 0;
    function extractAnnotation(annotation) {
        if (isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
            // it is a decorator, extract annotation
            annotation = annotation.annotation;
        }
        return annotation;
    }
    function applyParams(fnOrArray, key) {
        if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
            fnOrArray === Number || fnOrArray === Array) {
            throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
        }
        if (isFunction(fnOrArray)) {
            return fnOrArray;
        }
        else if (fnOrArray instanceof Array) {
            var annotations = fnOrArray;
            var annoLength = annotations.length - 1;
            var fn = fnOrArray[annoLength];
            if (!isFunction(fn)) {
                throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
            }
            if (annoLength != fn.length) {
                throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
            }
            var paramsAnnotations = [];
            for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
                var paramAnnotations = [];
                paramsAnnotations.push(paramAnnotations);
                var annotation = annotations[i];
                if (annotation instanceof Array) {
                    for (var j = 0; j < annotation.length; j++) {
                        paramAnnotations.push(extractAnnotation(annotation[j]));
                    }
                }
                else if (isFunction(annotation)) {
                    paramAnnotations.push(extractAnnotation(annotation));
                }
                else {
                    paramAnnotations.push(annotation);
                }
            }
            Reflect.defineMetadata('parameters', paramsAnnotations, fn);
            return fn;
        }
        else {
            throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
        }
    }
    /**
     * Provides a way for expressing ES6 classes with parameter annotations in ES5.
     *
     * ## Basic Example
     *
     * ```
     * var Greeter = ng.Class({
     *   constructor: function(name) {
     *     this.name = name;
     *   },
     *
     *   greet: function() {
     *     alert('Hello ' + this.name + '!');
     *   }
     * });
     * ```
     *
     * is equivalent to ES6:
     *
     * ```
     * class Greeter {
     *   constructor(name) {
     *     this.name = name;
     *   }
     *
     *   greet() {
     *     alert('Hello ' + this.name + '!');
     *   }
     * }
     * ```
     *
     * or equivalent to ES5:
     *
     * ```
     * var Greeter = function (name) {
     *   this.name = name;
     * }
     *
     * Greeter.prototype.greet = function () {
     *   alert('Hello ' + this.name + '!');
     * }
     * ```
     *
     * ### Example with parameter annotations
     *
     * ```
     * var MyService = ng.Class({
     *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
     *     ...
     *   }]
     * });
     * ```
     *
     * is equivalent to ES6:
     *
     * ```
     * class MyService {
     *   constructor(name: string, @Query() queryList: QueryList) {
     *     ...
     *   }
     * }
     * ```
     *
     * ### Example with inheritance
     *
     * ```
     * var Shape = ng.Class({
     *   constructor: (color) {
     *     this.color = color;
     *   }
     * });
     *
     * var Square = ng.Class({
     *   extends: Shape,
     *   constructor: function(color, size) {
     *     Shape.call(this, color);
     *     this.size = size;
     *   }
     * });
     * ```
     * @stable
     */
    function Class(clsDef) {
        var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
        var proto = constructor.prototype;
        if (clsDef.hasOwnProperty('extends')) {
            if (isFunction(clsDef.extends)) {
                constructor.prototype = proto =
                    Object.create(clsDef.extends.prototype);
            }
            else {
                throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
            }
        }
        for (var key in clsDef) {
            if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
                proto[key] = applyParams(clsDef[key], key);
            }
        }
        if (this && this.annotations instanceof Array) {
            Reflect.defineMetadata('annotations', this.annotations, constructor);
        }
        var constructorName = constructor['name'];
        if (!constructorName || constructorName === 'constructor') {
            constructor['overriddenName'] = "class" + _nextClassId++;
        }
        return constructor;
    }
    var Reflect = global$1.Reflect;
    function makeDecorator(name, props, parentClass, chainFn) {
        if (chainFn === void 0) { chainFn = null; }
        var metaCtor = makeMetadataCtor([props]);
        function DecoratorFactory(objOrType) {
            if (!(Reflect && Reflect.getMetadata)) {
                throw 'reflect-metadata shim is required when using class decorators';
            }
            if (this instanceof DecoratorFactory) {
                metaCtor.call(this, objOrType);
                return this;
            }
            else {
                var annotationInstance_1 = new DecoratorFactory(objOrType);
                var chainAnnotation = isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
                chainAnnotation.push(annotationInstance_1);
                var TypeDecorator = function TypeDecorator(cls) {
                    var annotations = Reflect.getOwnMetadata('annotations', cls) || [];
                    annotations.push(annotationInstance_1);
                    Reflect.defineMetadata('annotations', annotations, cls);
                    return cls;
                };
                TypeDecorator.annotations = chainAnnotation;
                TypeDecorator.Class = Class;
                if (chainFn)
                    chainFn(TypeDecorator);
                return TypeDecorator;
            }
        }
        if (parentClass) {
            DecoratorFactory.prototype = Object.create(parentClass.prototype);
        }
        DecoratorFactory.prototype.toString = function () { return ("@" + name); };
        DecoratorFactory.annotationCls = DecoratorFactory;
        return DecoratorFactory;
    }
    function makeMetadataCtor(props) {
        function ctor() {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            props.forEach(function (prop, i) {
                var argVal = args[i];
                if (Array.isArray(prop)) {
                    // plain parameter
                    var val = !argVal || argVal === undefined ? prop[1] : argVal;
                    _this[prop[0]] = val;
                }
                else {
                    for (var propName in prop) {
                        var val = !argVal || argVal[propName] === undefined ? prop[propName] : argVal[propName];
                        _this[propName] = val;
                    }
                }
            });
        }
        return ctor;
    }
    function makeParamDecorator(name, props, parentClass) {
        var metaCtor = makeMetadataCtor(props);
        function ParamDecoratorFactory() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (this instanceof ParamDecoratorFactory) {
                metaCtor.apply(this, args);
                return this;
            }
            var annotationInstance = new ((_a = ParamDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();
            ParamDecorator.annotation = annotationInstance;
            return ParamDecorator;
            function ParamDecorator(cls, unusedKey, index) {
                var parameters = Reflect.getMetadata('parameters', cls) || [];
                // there might be gaps if some in between parameters do not have annotations.
                // we pad with nulls.
                while (parameters.length <= index) {
                    parameters.push(null);
                }
                parameters[index] = parameters[index] || [];
                var annotationsForParam = parameters[index];
                annotationsForParam.push(annotationInstance);
                Reflect.defineMetadata('parameters', parameters, cls);
                return cls;
            }
            var _a;
        }
        if (parentClass) {
            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
        }
        ParamDecoratorFactory.prototype.toString = function () { return ("@" + name); };
        ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
        return ParamDecoratorFactory;
    }
    function makePropDecorator(name, props, parentClass) {
        var metaCtor = makeMetadataCtor(props);
        function PropDecoratorFactory() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (this instanceof PropDecoratorFactory) {
                metaCtor.apply(this, args);
                return this;
            }
            else {
                var decoratorInstance = new ((_a = PropDecoratorFactory).bind.apply(_a, [void 0].concat(args)))();
                return function PropDecorator(target, name) {
                    var meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};
                    meta[name] = meta[name] || [];
                    meta[name].unshift(decoratorInstance);
                    Reflect.defineMetadata('propMetadata', meta, target.constructor);
                };
            }
            var _a;
        }
        if (parentClass) {
            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
        }
        PropDecoratorFactory.prototype.toString = function () { return ("@" + name); };
        PropDecoratorFactory.annotationCls = PropDecoratorFactory;
        return PropDecoratorFactory;
    }

    /**
     * Inject decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Inject = makeParamDecorator('Inject', [['token', undefined]]);
    /**
     * Optional decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Optional = makeParamDecorator('Optional', []);
    /**
     * Injectable decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Injectable = makeParamDecorator('Injectable', []);
    /**
     * Self decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Self = makeParamDecorator('Self', []);
    /**
     * SkipSelf decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var SkipSelf = makeParamDecorator('SkipSelf', []);
    /**
     * Host decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Host = makeParamDecorator('Host', []);

    /**
     * Creates a token that can be used in a DI Provider.
     *
     * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
     *
     * ```typescript
     * var t = new OpaqueToken("value");
     *
     * var injector = Injector.resolveAndCreate([
     *   {provide: t, useValue: "bindingValue"}
     * ]);
     *
     * expect(injector.get(t)).toEqual("bindingValue");
     * ```
     *
     * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
     * caused by multiple providers using the same string as two different tokens.
     *
     * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
     * error messages.
     * @stable
     */
    // so that metadata is gathered for this class
    var OpaqueToken = (function () {
        function OpaqueToken(_desc) {
            this._desc = _desc;
        }
        OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
        OpaqueToken.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        OpaqueToken.ctorParameters = [
            null,
        ];
        return OpaqueToken;
    }());

    /**
     * This token can be used to create a virtual provider that will populate the
     * `entryComponents` fields of components and ng modules based on its `useValue`.
     * All components that are referenced in the `useValue` value (either directly
     * or in a nested array or map) will be added to the `entryComponents` property.
     *
     * ### Example
     * The following example shows how the router can populate the `entryComponents`
     * field of an NgModule based on the router configuration which refers
     * to components.
     *
     * ```typescript
     * // helper function inside the router
     * function provideRoutes(routes) {
     *   return [
     *     {provide: ROUTES, useValue: routes},
     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
     *   ];
     * }
     *
     * // user code
     * let routes = [
     *   {path: '/root', component: RootComp},
     *   {path: '/teams', component: TeamsComp}
     * ];
     *
     * @NgModule({
     *   providers: [provideRoutes(routes)]
     * })
     * class ModuleWithRoutes {}
     * ```
     *
     * @experimental
     */
    var ANALYZE_FOR_ENTRY_COMPONENTS = new OpaqueToken('AnalyzeForEntryComponents');
    /**
     * Attribute decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Attribute = makeParamDecorator('Attribute', [['attributeName', undefined]]);
    /**
     * Base class for query metadata.
     *
     * See {@link ContentChildren}, {@link ContentChild}, {@link ViewChildren}, {@link ViewChild} for
     * more information.
     *
     * @stable
     */
    var Query = (function () {
        function Query() {
        }
        return Query;
    }());
    /**
     * ContentChildren decorator and metadata.
     *
     *  @stable
     *  @Annotation
     */
    var ContentChildren = makePropDecorator('ContentChildren', [
        ['selector', undefined], {
            first: false,
            isViewQuery: false,
            descendants: false,
            read: undefined,
        }
    ], Query);
    /**
     * @whatItDoes Configures a content query.
     *
     * @howToUse
     *
     * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ContentChild to get the first element or the directive matching the selector from the
     * content DOM. If the content DOM changes, and a new child matches the selector,
     * the property will be updated.
     *
     * Content queries are set before the `ngAfterContentInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **read** - read a different token from the queried element.
     *
     * Let's look at an example:
     *
     * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    var ContentChild = makePropDecorator('ContentChild', [
        ['selector', undefined], {
            first: true,
            isViewQuery: false,
            descendants: true,
            read: undefined,
        }
    ], Query);
    /**
     * @whatItDoes Configures a view query.
     *
     * @howToUse
     *
     * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ViewChildren to get the {@link QueryList} of elements or directives from the
     * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,
     * and the changes observable of the query list will emit a new value.
     *
     * View queries are set before the `ngAfterViewInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **read** - read a different token from the queried elements.
     *
     * Let's look at an example:
     *
     * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    var ViewChildren = makePropDecorator('ViewChildren', [
        ['selector', undefined], {
            first: false,
            isViewQuery: true,
            descendants: true,
            read: undefined,
        }
    ], Query);
    /**
     * ViewChild decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var ViewChild = makePropDecorator('ViewChild', [
        ['selector', undefined], {
            first: true,
            isViewQuery: true,
            descendants: true,
            read: undefined,
        }
    ], Query);

    /**
     * Describes within the change detector which strategy will be used the next time change
     * detection is triggered.
     * @stable
     */
    exports.ChangeDetectionStrategy;
    (function (ChangeDetectionStrategy) {
        /**
         * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
         */
        ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
        /**
         * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
         */
        ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
    })(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
    /**
     * Describes the status of the detector.
     */
    var ChangeDetectorStatus;
    (function (ChangeDetectorStatus) {
        /**
         * `CheckedOnce` means that after calling detectChanges the mode of the change detector
         * will become `Checked`.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["CheckOnce"] = 0] = "CheckOnce";
        /**
         * `Checked` means that the change detector should be skipped until its mode changes to
         * `CheckOnce`.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Checked"] = 1] = "Checked";
        /**
         * `CheckAlways` means that after calling detectChanges the mode of the change detector
         * will remain `CheckAlways`.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["CheckAlways"] = 2] = "CheckAlways";
        /**
         * `Detached` means that the change detector sub tree is not a part of the main tree and
         * should be skipped.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Detached"] = 3] = "Detached";
        /**
         * `Errored` means that the change detector encountered an error checking a binding
         * or calling a directive lifecycle method and is now in an inconsistent state. Change
         * detectors in this state will no longer detect changes.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Errored"] = 4] = "Errored";
        /**
         * `Destroyed` means that the change detector is destroyed.
         */
        ChangeDetectorStatus[ChangeDetectorStatus["Destroyed"] = 5] = "Destroyed";
    })(ChangeDetectorStatus || (ChangeDetectorStatus = {}));
    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
        return isBlank(changeDetectionStrategy) ||
            changeDetectionStrategy === exports.ChangeDetectionStrategy.Default;
    }

    /**
     * Directive decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Directive = makeDecorator('Directive', {
        selector: undefined,
        inputs: undefined,
        outputs: undefined,
        host: undefined,
        providers: undefined,
        exportAs: undefined,
        queries: undefined
    });
    /**
     * Component decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Component = makeDecorator('Component', {
        selector: undefined,
        inputs: undefined,
        outputs: undefined,
        host: undefined,
        exportAs: undefined,
        moduleId: undefined,
        providers: undefined,
        viewProviders: undefined,
        changeDetection: exports.ChangeDetectionStrategy.Default,
        queries: undefined,
        templateUrl: undefined,
        template: undefined,
        styleUrls: undefined,
        styles: undefined,
        animations: undefined,
        encapsulation: undefined,
        interpolation: undefined,
        entryComponents: undefined
    }, Directive);
    /**
     * Pipe decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Pipe = makeDecorator('Pipe', {
        name: undefined,
        pure: true,
    });
    /**
     * Input decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Input = makePropDecorator('Input', [['bindingPropertyName', undefined]]);
    /**
     * Output decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var Output = makePropDecorator('Output', [['bindingPropertyName', undefined]]);
    /**
     * HostBinding decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var HostBinding = makePropDecorator('HostBinding', [['hostPropertyName', undefined]]);
    /**
     * HostBinding decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var HostListener = makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @stable
     */
    var LifecycleHooks;
    (function (LifecycleHooks) {
        LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
        LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
        LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
        LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
        LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
        LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
        LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
        LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
    })(LifecycleHooks || (LifecycleHooks = {}));
    var LIFECYCLE_HOOKS_VALUES = [
        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
        LifecycleHooks.AfterViewChecked
    ];
    /**
     * @whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
     *
     * @description
     * `ngOnChanges` is called right after the data-bound properties have been checked and before view
     * and content children are checked if at least one of them has changed.
     * The `changes` parameter contains the changed properties.
     *
     * See {@linkDocs guide/lifecycle-hooks#onchanges "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var OnChanges = (function () {
        function OnChanges() {
        }
        return OnChanges;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called after data-bound properties of a directive are
     * initialized.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
     *
     * @description
     * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
     * first time, and before any of its children have been checked. It is invoked only once when the
     * directive is instantiated.
     *
     * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var OnInit = (function () {
        function OnInit() {
        }
        return OnInit;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
     *
     * @description
     * `ngDoCheck` gets called to check the changes in the directives in addition to the default
     * algorithm. The default change detection algorithm looks for differences by comparing
     * bound-property values by reference across change detection runs.
     *
     * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to
     * changes on the same input, as `ngOnChanges` will continue to be called when the default change
     * detector detects changes.
     *
     * See {@link KeyValueDiffers} and {@link IterableDiffers} for implementing custom dirty checking
     * for collections.
     *
     * See {@linkDocs guide/lifecycle-hooks#docheck "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var DoCheck = (function () {
        function DoCheck() {
        }
        return DoCheck;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called when a directive or pipe is destroyed.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
     *
     * @description
     * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
     * instance is destroyed.
     *
     * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var OnDestroy = (function () {
        function OnDestroy() {
        }
        return OnDestroy;
    }());
    /**
     *
     * @whatItDoes Lifecycle hook that is called after a directive's content has been fully
     * initialized.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
     *
     * @description
     * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var AfterContentInit = (function () {
        function AfterContentInit() {
        }
        return AfterContentInit;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called after every check of a directive's content.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
     *
     * @description
     * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var AfterContentChecked = (function () {
        function AfterContentChecked() {
        }
        return AfterContentChecked;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called after a component's view has been fully
     * initialized.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
     *
     * @description
     * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var AfterViewInit = (function () {
        function AfterViewInit() {
        }
        return AfterViewInit;
    }());
    /**
     * @whatItDoes Lifecycle hook that is called after every check of a component's view.
     * @howToUse
     * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
     *
     * @description
     * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
     *
     * @stable
     */
    var AfterViewChecked = (function () {
        function AfterViewChecked() {
        }
        return AfterViewChecked;
    }());

    /**
     * Defines a schema that will allow:
     * - any non-Angular elements with a `-` in their name,
     * - any properties on elements with a `-` in their name which is the common rule for custom
     * elements.
     *
     * @stable
     */
    var CUSTOM_ELEMENTS_SCHEMA = {
        name: 'custom-elements'
    };
    /**
     * Defines a schema that will allow any property on any element.
     *
     * @experimental
     */
    var NO_ERRORS_SCHEMA = {
        name: 'no-errors-schema'
    };
    /**
     * NgModule decorator and metadata.
     *
     * @stable
     * @Annotation
     */
    var NgModule = makeDecorator('NgModule', {
        providers: undefined,
        declarations: undefined,
        imports: undefined,
        exports: undefined,
        entryComponents: undefined,
        bootstrap: undefined,
        schemas: undefined,
        id: undefined,
    });

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Defines template and style encapsulation options available for Component's {@link Component}.
     *
     * See {@link ViewMetadata#encapsulation}.
     * @stable
     */
    exports.ViewEncapsulation;
    (function (ViewEncapsulation) {
        /**
         * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
         * Element and pre-processing the style rules provided via
         * {@link ViewMetadata#styles} or {@link ViewMetadata#stylesUrls}, and adding the new Host Element
         * attribute to all selectors.
         *
         * This is the default option.
         */
        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
        /**
         * Use the native encapsulation mechanism of the renderer.
         *
         * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
         * creating a ShadowRoot for Component's Host Element.
         */
        ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
        /**
         * Don't provide any template or style encapsulation.
         */
        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
    })(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
    /**
     * Metadata properties available for configuring Views.
     *
     * For details on the `@Component` annotation, see {@link Component}.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   selector: 'greet',
     *   template: 'Hello {{name}}!',
     * })
     * class Greet {
     *   name: string;
     *
     *   constructor() {
     *     this.name = 'World';
     *   }
     * }
     * ```
     *
     * @deprecated Use Component instead.
     *
     * {@link Component}
     */
    var ViewMetadata = (function () {
        function ViewMetadata(_a) {
            var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;
            this.templateUrl = templateUrl;
            this.template = template;
            this.styleUrls = styleUrls;
            this.styles = styles;
            this.encapsulation = encapsulation;
            this.animations = animations;
            this.interpolation = interpolation;
        }
        return ViewMetadata;
    }());

    /**
     * Allows to refer to references which are not yet defined.
     *
     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
     * DI is declared,
     * but not yet defined. It is also used when the `token` which we use when creating a query is not
     * yet defined.
     *
     * ### Example
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
     * @experimental
     */
    function forwardRef(forwardRefFn) {
        forwardRefFn.__forward_ref__ = forwardRef;
        forwardRefFn.toString = function () { return stringify(this()); };
        return forwardRefFn;
    }
    /**
     * Lazily retrieves the reference value from a forwardRef.
     *
     * Acts as the identity function when given a non-forward-ref value.
     *
     * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
     *
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
     *
     * See: {@link forwardRef}
     * @experimental
     */
    function resolveForwardRef(type) {
        if (isFunction(type) && type.hasOwnProperty('__forward_ref__') &&
            type.__forward_ref__ === forwardRef) {
            return type();
        }
        else {
            return type;
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    function unimplemented() {
        throw new Error('unimplemented');
    }
    /**
     * @stable
     */
    var BaseError = (function (_super) {
        __extends(BaseError, _super);
        function BaseError(message) {
            // Errors don't use current this, instead they create a new instance.
            // We have to do forward all of our api to the nativeInstance.
            var nativeError = _super.call(this, message);
            this._nativeError = nativeError;
        }
        Object.defineProperty(BaseError.prototype, "message", {
            get: function () { return this._nativeError.message; },
            set: function (message) { this._nativeError.message = message; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "name", {
            get: function () { return this._nativeError.name; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseError.prototype, "stack", {
            get: function () { return this._nativeError.stack; },
            set: function (value) { this._nativeError.stack = value; },
            enumerable: true,
            configurable: true
        });
        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
        return BaseError;
    }(Error));
    /**
     * @stable
     */
    var WrappedError = (function (_super) {
        __extends(WrappedError, _super);
        function WrappedError(message, error) {
            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
            this.originalError = error;
        }
        Object.defineProperty(WrappedError.prototype, "stack", {
            get: function () {
                return (this.originalError instanceof Error ? this.originalError : this._nativeError)
                    .stack;
            },
            enumerable: true,
            configurable: true
        });
        return WrappedError;
    }(BaseError));

    var _THROW_IF_NOT_FOUND = new Object();
    var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    var _NullInjector = (function () {
        function _NullInjector() {
        }
        _NullInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }
            if (notFoundValue === _THROW_IF_NOT_FOUND) {
                throw new Error("No provider for " + stringify(token) + "!");
            }
            return notFoundValue;
        };
        return _NullInjector;
    }());
    /**
     * @whatItDoes Injector interface
     * @howToUse
     * ```
     * const injector: Injector = ...;
     * injector.get(...);
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/injector_spec.ts region='Injector'}
     *
     * `Injector` returns itself when given `Injector` as a token:
     * {@example core/di/ts/injector_spec.ts region='injectInjector'}
     *
     * @stable
     */
    var Injector = (function () {
        function Injector() {
        }
        /**
         * Retrieves an instance from the injector based on the provided token.
         * If not found:
         * - Throws {@link NoProviderError} if no `notFoundValue` that is not equal to
         * Injector.THROW_IF_NOT_FOUND is given
         * - Returns the `notFoundValue` otherwise
         */
        Injector.prototype.get = function (token, notFoundValue) { return unimplemented(); };
        Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
        Injector.NULL = new _NullInjector();
        return Injector;
    }());

    // Safari and Internet Explorer do not support the iterable parameter to the
    // Map constructor.  We work around that by manually adding the items.
    var createMapFromPairs = (function () {
        try {
            if (new Map([[1, 2]]).size === 1) {
                return function createMapFromPairs(pairs) { return new Map(pairs); };
            }
        }
        catch (e) {
        }
        return function createMapAndPopulateFromPairs(pairs) {
            var map = new Map();
            for (var i = 0; i < pairs.length; i++) {
                var pair = pairs[i];
                map.set(pair[0], pair[1]);
            }
            return map;
        };
    })();
    var _clearValues = (function () {
        if ((new Map()).keys().next) {
            return function _clearValues(m) {
                var keyIterator = m.keys();
                var k;
                while (!((k = keyIterator.next()).done)) {
                    m.set(k.value, null);
                }
            };
        }
        else {
            return function _clearValuesWithForeEach(m) {
                m.forEach(function (v, k) { m.set(k, null); });
            };
        }
    })();
    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
    var _arrayFromMap = (function () {
        try {
            if ((new Map()).values().next) {
                return function createArrayFromMap(m, getValues) {
                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
                };
            }
        }
        catch (e) {
        }
        return function createArrayFromMapWithForeach(m, getValues) {
            var res = new Array(m.size), i = 0;
            m.forEach(function (v, k) {
                res[i] = getValues ? v : k;
                i++;
            });
            return res;
        };
    })();
    var MapWrapper = (function () {
        function MapWrapper() {
        }
        MapWrapper.createFromStringMap = function (stringMap) {
            var result = new Map();
            for (var prop in stringMap) {
                result.set(prop, stringMap[prop]);
            }
            return result;
        };
        MapWrapper.toStringMap = function (m) {
            var r = {};
            m.forEach(function (v, k) { return r[k] = v; });
            return r;
        };
        MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };
        MapWrapper.iterable = function (m) { return m; };
        MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
        MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
        return MapWrapper;
    }());
    /**
     * Wraps Javascript Objects
     */
    var StringMapWrapper = (function () {
        function StringMapWrapper() {
        }
        StringMapWrapper.merge = function (m1, m2) {
            var m = {};
            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
                var k = _a[_i];
                m[k] = m1[k];
            }
            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
                var k = _c[_b];
                m[k] = m2[k];
            }
            return m;
        };
        StringMapWrapper.equals = function (m1, m2) {
            var k1 = Object.keys(m1);
            var k2 = Object.keys(m2);
            if (k1.length != k2.length) {
                return false;
            }
            for (var i = 0; i < k1.length; i++) {
                var key = k1[i];
                if (m1[key] !== m2[key]) {
                    return false;
                }
            }
            return true;
        };
        return StringMapWrapper;
    }());
    var ListWrapper = (function () {
        function ListWrapper() {
        }
        // JS has no way to express a statically fixed size list, but dart does so we
        // keep both methods.
        ListWrapper.createFixedSize = function (size) { return new Array(size); };
        ListWrapper.createGrowableSize = function (size) { return new Array(size); };
        ListWrapper.clone = function (array) { return array.slice(0); };
        ListWrapper.forEachWithIndex = function (array, fn) {
            for (var i = 0; i < array.length; i++) {
                fn(array[i], i);
            }
        };
        ListWrapper.first = function (array) {
            if (!array)
                return null;
            return array[0];
        };
        ListWrapper.last = function (array) {
            if (!array || array.length == 0)
                return null;
            return array[array.length - 1];
        };
        ListWrapper.indexOf = function (array, value, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            return array.indexOf(value, startIndex);
        };
        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
        ListWrapper.reversed = function (array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
        };
        ListWrapper.concat = function (a, b) { return a.concat(b); };
        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
        ListWrapper.removeAt = function (list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
        };
        ListWrapper.removeAll = function (list, items) {
            for (var i = 0; i < items.length; ++i) {
                var index = list.indexOf(items[i]);
                list.splice(index, 1);
            }
        };
        ListWrapper.remove = function (list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
                return true;
            }
            return false;
        };
        ListWrapper.clear = function (list) { list.length = 0; };
        ListWrapper.isEmpty = function (list) { return list.length == 0; };
        ListWrapper.fill = function (list, value, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = null; }
            list.fill(value, start, end === null ? list.length : end);
        };
        ListWrapper.equals = function (a, b) {
            if (a.length != b.length)
                return false;
            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        };
        ListWrapper.slice = function (l, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return l.slice(from, to === null ? undefined : to);
        };
        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
        ListWrapper.sort = function (l, compareFn) {
            if (isPresent(compareFn)) {
                l.sort(compareFn);
            }
            else {
                l.sort();
            }
        };
        ListWrapper.toString = function (l) { return l.toString(); };
        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
        ListWrapper.maximum = function (list, predicate) {
            if (list.length == 0) {
                return null;
            }
            var solution = null;
            var maxValue = -Infinity;
            for (var index = 0; index < list.length; index++) {
                var candidate = list[index];
                if (isBlank(candidate)) {
                    continue;
                }
                var candidateValue = predicate(candidate);
                if (candidateValue > maxValue) {
                    solution = candidate;
                    maxValue = candidateValue;
                }
            }
            return solution;
        };
        ListWrapper.flatten = function (list) {
            var target = [];
            _flattenArray(list, target);
            return target;
        };
        ListWrapper.addAll = function (list, source) {
            for (var i = 0; i < source.length; i++) {
                list.push(source[i]);
            }
        };
        return ListWrapper;
    }());
    function _flattenArray(source, target) {
        if (isPresent(source)) {
            for (var i = 0; i < source.length; i++) {
                var item = source[i];
                if (isArray(item)) {
                    _flattenArray(item, target);
                }
                else {
                    target.push(item);
                }
            }
        }
        return target;
    }
    function isListLikeIterable(obj) {
        if (!isJsObject(obj))
            return false;
        return isArray(obj) ||
            (!(obj instanceof Map) &&
                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
    }
    function areIterablesEqual(a, b, comparator) {
        var iterator1 = a[getSymbolIterator()]();
        var iterator2 = b[getSymbolIterator()]();
        while (true) {
            var item1 = iterator1.next();
            var item2 = iterator2.next();
            if (item1.done && item2.done)
                return true;
            if (item1.done || item2.done)
                return false;
            if (!comparator(item1.value, item2.value))
                return false;
        }
    }
    function iterateListLike(obj, fn) {
        if (isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
                fn(obj[i]);
            }
        }
        else {
            var iterator = obj[getSymbolIterator()]();
            var item;
            while (!((item = iterator.next()).done)) {
                fn(item.value);
            }
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    function findFirstClosedCycle(keys) {
        var res = [];
        for (var i = 0; i < keys.length; ++i) {
            if (ListWrapper.contains(res, keys[i])) {
                res.push(keys[i]);
                return res;
            }
            res.push(keys[i]);
        }
        return res;
    }
    function constructResolvingPath(keys) {
        if (keys.length > 1) {
            var reversed = findFirstClosedCycle(ListWrapper.reversed(keys));
            var tokenStrs = reversed.map(function (k) { return stringify(k.token); });
            return ' (' + tokenStrs.join(' -> ') + ')';
        }
        return '';
    }
    /**
     * Base class for all errors arising from misconfigured providers.
     * @stable
     */
    var AbstractProviderError = (function (_super) {
        __extends$1(AbstractProviderError, _super);
        function AbstractProviderError(injector, key, constructResolvingMessage) {
            _super.call(this, 'DI Error');
            this.keys = [key];
            this.injectors = [injector];
            this.constructResolvingMessage = constructResolvingMessage;
            this.message = this.constructResolvingMessage(this.keys);
        }
        AbstractProviderError.prototype.addKey = function (injector, key) {
            this.injectors.push(injector);
            this.keys.push(key);
            this.message = this.constructResolvingMessage(this.keys);
        };
        return AbstractProviderError;
    }(BaseError));
    /**
     * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the
     * {@link Injector} does not have a {@link Provider} for the given key.
     *
     * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
     *
     * ```typescript
     * class A {
     *   constructor(b:B) {}
     * }
     *
     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
     * ```
     * @stable
     */
    var NoProviderError = (function (_super) {
        __extends$1(NoProviderError, _super);
        function NoProviderError(injector, key) {
            _super.call(this, injector, key, function (keys) {
                var first = stringify(ListWrapper.first(keys).token);
                return "No provider for " + first + "!" + constructResolvingPath(keys);
            });
        }
        return NoProviderError;
    }(AbstractProviderError));
    /**
     * Thrown when dependencies form a cycle.
     *
     * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
     *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
     * ]);
     *
     * expect(() => injector.get("one")).toThrowError();
     * ```
     *
     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
     * @stable
     */
    var CyclicDependencyError = (function (_super) {
        __extends$1(CyclicDependencyError, _super);
        function CyclicDependencyError(injector, key) {
            _super.call(this, injector, key, function (keys) {
                return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
            });
        }
        return CyclicDependencyError;
    }(AbstractProviderError));
    /**
     * Thrown when a constructing type returns with an Error.
     *
     * The `InstantiationError` class contains the original error plus the dependency graph which caused
     * this object to be instantiated.
     *
     * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
     *
     * ```typescript
     * class A {
     *   constructor() {
     *     throw new Error('message');
     *   }
     * }
     *
     * var injector = Injector.resolveAndCreate([A]);

     * try {
     *   injector.get(A);
     * } catch (e) {
     *   expect(e instanceof InstantiationError).toBe(true);
     *   expect(e.originalException.message).toEqual("message");
     *   expect(e.originalStack).toBeDefined();
     * }
     * ```
     * @stable
     */
    var InstantiationError = (function (_super) {
        __extends$1(InstantiationError, _super);
        function InstantiationError(injector, originalException, originalStack, key) {
            _super.call(this, 'DI Error', originalException);
            this.keys = [key];
            this.injectors = [injector];
        }
        InstantiationError.prototype.addKey = function (injector, key) {
            this.injectors.push(injector);
            this.keys.push(key);
        };
        Object.defineProperty(InstantiationError.prototype, "message", {
            get: function () {
                var first = stringify(ListWrapper.first(this.keys).token);
                return this.originalError.message + ": Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InstantiationError.prototype, "causeKey", {
            get: function () { return this.keys[0]; },
            enumerable: true,
            configurable: true
        });
        return InstantiationError;
    }(WrappedError));
    /**
     * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}
     * creation.
     *
     * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
     *
     * ```typescript
     * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
     * ```
     * @stable
     */
    var InvalidProviderError = (function (_super) {
        __extends$1(InvalidProviderError, _super);
        function InvalidProviderError(provider) {
            _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
        }
        return InvalidProviderError;
    }(BaseError));
    /**
     * Thrown when the class has no annotation information.
     *
     * Lack of annotation information prevents the {@link Injector} from determining which dependencies
     * need to be injected into the constructor.
     *
     * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
     *
     * ```typescript
     * class A {
     *   constructor(b) {}
     * }
     *
     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
     * ```
     *
     * This error is also thrown when the class not marked with {@link Injectable} has parameter types.
     *
     * ```typescript
     * class B {}
     *
     * class A {
     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
     * }
     *
     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
     * ```
     * @stable
     */
    var NoAnnotationError = (function (_super) {
        __extends$1(NoAnnotationError, _super);
        function NoAnnotationError(typeOrFunc, params) {
            _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
        }
        NoAnnotationError._genMessage = function (typeOrFunc, params) {
            var signature = [];
            for (var i = 0, ii = params.length; i < ii; i++) {
                var parameter = params[i];
                if (!parameter || parameter.length == 0) {
                    signature.push('?');
                }
                else {
                    signature.push(parameter.map(stringify).join(' '));
                }
            }
            return 'Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' +
                signature.join(', ') + '). ' +
                'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
                stringify(typeOrFunc) + '\' is decorated with Injectable.';
        };
        return NoAnnotationError;
    }(BaseError));
    /**
     * Thrown when getting an object by index.
     *
     * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
     *
     * ```typescript
     * class A {}
     *
     * var injector = Injector.resolveAndCreate([A]);
     *
     * expect(() => injector.getAt(100)).toThrowError();
     * ```
     * @stable
     */
    var OutOfBoundsError = (function (_super) {
        __extends$1(OutOfBoundsError, _super);
        function OutOfBoundsError(index) {
            _super.call(this, "Index " + index + " is out-of-bounds.");
        }
        return OutOfBoundsError;
    }(BaseError));
    // TODO: add a working example after alpha38 is released
    /**
     * Thrown when a multi provider and a regular provider are bound to the same token.
     *
     * ### Example
     *
     * ```typescript
     * expect(() => Injector.resolveAndCreate([
     *   { provide: "Strings", useValue: "string1", multi: true},
     *   { provide: "Strings", useValue: "string2", multi: false}
     * ])).toThrowError();
     * ```
     */
    var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
        __extends$1(MixingMultiProvidersWithRegularProvidersError, _super);
        function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
            _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +
                provider2.toString());
        }
        return MixingMultiProvidersWithRegularProvidersError;
    }(BaseError));

    /**
     * A unique object used for retrieving items from the {@link ReflectiveInjector}.
     *
     * Keys have:
     * - a system-wide unique `id`.
     * - a `token`.
     *
     * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
     * the
     * injector to store created objects in a more efficient way.
     *
     * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
     * resolving
     * providers.
     * @experimental
     */
    var ReflectiveKey = (function () {
        /**
         * Private
         */
        function ReflectiveKey(token, id) {
            this.token = token;
            this.id = id;
            if (!token) {
                throw new Error('Token must be defined!');
            }
        }
        Object.defineProperty(ReflectiveKey.prototype, "displayName", {
            /**
             * Returns a stringified token.
             */
            get: function () { return stringify(this.token); },
            enumerable: true,
            configurable: true
        });
        /**
         * Retrieves a `Key` for a token.
         */
        ReflectiveKey.get = function (token) {
            return _globalKeyRegistry.get(resolveForwardRef(token));
        };
        Object.defineProperty(ReflectiveKey, "numberOfKeys", {
            /**
             * @returns the number of keys registered in the system.
             */
            get: function () { return _globalKeyRegistry.numberOfKeys; },
            enumerable: true,
            configurable: true
        });
        return ReflectiveKey;
    }());
    /**
     * @internal
     */
    var KeyRegistry = (function () {
        function KeyRegistry() {
            this._allKeys = new Map();
        }
        KeyRegistry.prototype.get = function (token) {
            if (token instanceof ReflectiveKey)
                return token;
            if (this._allKeys.has(token)) {
                return this._allKeys.get(token);
            }
            var newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
            this._allKeys.set(token, newKey);
            return newKey;
        };
        Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
            get: function () { return this._allKeys.size; },
            enumerable: true,
            configurable: true
        });
        return KeyRegistry;
    }());
    var _globalKeyRegistry = new KeyRegistry();

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @whatItDoes Represents a type that a Component or other object is instances of.
     *
     * @description
     *
     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
     * the `MyCustomComponent` constructor function.
     *
     * @stable
     */
    var Type = Function;

    var ReflectionCapabilities = (function () {
        function ReflectionCapabilities(reflect) {
            this._reflect = reflect || global$1.Reflect;
        }
        ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
        ReflectionCapabilities.prototype.factory = function (t) {
            var prototype = t.prototype;
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                var instance = Object.create(prototype);
                t.apply(instance, args);
                return instance;
            };
        };
        /** @internal */
        ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes /** TODO #9100 */, paramAnnotations /** TODO #9100 */) {
            var result;
            if (typeof paramTypes === 'undefined') {
                result = new Array(paramAnnotations.length);
            }
            else {
                result = new Array(paramTypes.length);
            }
            for (var i = 0; i < result.length; i++) {
                // TS outputs Object for parameters without types, while Traceur omits
                // the annotations. For now we preserve the Traceur behavior to aid
                // migration, but this can be revisited.
                if (typeof paramTypes === 'undefined') {
                    result[i] = [];
                }
                else if (paramTypes[i] != Object) {
                    result[i] = [paramTypes[i]];
                }
                else {
                    result[i] = [];
                }
                if (isPresent(paramAnnotations) && isPresent(paramAnnotations[i])) {
                    result[i] = result[i].concat(paramAnnotations[i]);
                }
            }
            return result;
        };
        ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {
            // Prefer the direct API.
            if (isPresent(typeOrFunc.parameters)) {
                return typeOrFunc.parameters;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (isPresent(typeOrFunc.ctorParameters)) {
                var ctorParameters = typeOrFunc.ctorParameters;
                var paramTypes_1 = ctorParameters.map(function (ctorParam /** TODO #9100 */) { return ctorParam && ctorParam.type; });
                var paramAnnotations_1 = ctorParameters.map(function (ctorParam /** TODO #9100 */) {
                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
                });
                return this._zipTypesAndAnnotations(paramTypes_1, paramAnnotations_1);
            }
            // API for metadata created by invoking the decorators.
            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
                var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
                var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
                if (isPresent(paramTypes) || isPresent(paramAnnotations)) {
                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
                }
            }
            // The array has to be filled with `undefined` because holes would be skipped by `some`
            var parameters = new Array(typeOrFunc.length);
            parameters.fill(undefined);
            return parameters;
        };
        ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
            // Prefer the direct API.
            if (isPresent(typeOrFunc.annotations)) {
                var annotations = typeOrFunc.annotations;
                if (isFunction(annotations) && annotations.annotations) {
                    annotations = annotations.annotations;
                }
                return annotations;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (isPresent(typeOrFunc.decorators)) {
                return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
            }
            // API for metadata created by invoking the decorators.
            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
                var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
                if (isPresent(annotations))
                    return annotations;
            }
            return [];
        };
        ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
            // Prefer the direct API.
            if (isPresent(typeOrFunc.propMetadata)) {
                var propMetadata = typeOrFunc.propMetadata;
                if (isFunction(propMetadata) && propMetadata.propMetadata) {
                    propMetadata = propMetadata.propMetadata;
                }
                return propMetadata;
            }
            // API of tsickle for lowering decorators to properties on the class.
            if (isPresent(typeOrFunc.propDecorators)) {
                var propDecorators_1 = typeOrFunc.propDecorators;
                var propMetadata_1 = {};
                Object.keys(propDecorators_1).forEach(function (prop) {
                    propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
                });
                return propMetadata_1;
            }
            // API for metadata created by invoking the decorators.
            if (isPresent(this._reflect) && isPresent(this._reflect.getMetadata)) {
                var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
                if (isPresent(propMetadata))
                    return propMetadata;
            }
            return {};
        };
        // Note: JavaScript does not support to query for interfaces during runtime.
        // However, we can't throw here as the reflector will always call this method
        // when asked for a lifecycle interface as this is what we check in Dart.
        ReflectionCapabilities.prototype.interfaces = function (type) { return []; };
        ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcInterface, lcProperty) {
            if (!(type instanceof Type))
                return false;
            var proto = type.prototype;
            return !!proto[lcProperty];
        };
        ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
        ReflectionCapabilities.prototype.setter = function (name) {
            return new Function('o', 'v', 'return o.' + name + ' = v;');
        };
        ReflectionCapabilities.prototype.method = function (name) {
            var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
            return new Function('o', 'args', functionBody);
        };
        // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
        ReflectionCapabilities.prototype.importUri = function (type) {
            // StaticSymbol
            if (typeof type === 'object' && type['filePath']) {
                return type['filePath'];
            }
            // Runtime type
            return "./" + stringify(type);
        };
        ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { return runtime; };
        ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };
        return ReflectionCapabilities;
    }());
    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
        if (!decoratorInvocations) {
            return [];
        }
        return decoratorInvocations.map(function (decoratorInvocation) {
            var decoratorType = decoratorInvocation.type;
            var annotationCls = decoratorType.annotationCls;
            var annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
            return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();
        });
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Provides read-only access to reflection data about symbols. Used internally by Angular
     * to power dependency injection and compilation.
     */
    var ReflectorReader = (function () {
        function ReflectorReader() {
        }
        return ReflectorReader;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$2 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Provides access to reflection data about symbols. Used internally by Angular
     * to power dependency injection and compilation.
     */
    var Reflector = (function (_super) {
        __extends$2(Reflector, _super);
        function Reflector(reflectionCapabilities) {
            _super.call(this);
            this.reflectionCapabilities = reflectionCapabilities;
            /** @internal */
            this._injectableInfo = new Map();
            /** @internal */
            this._getters = new Map();
            /** @internal */
            this._setters = new Map();
            /** @internal */
            this._methods = new Map();
            /** @internal */
            this._usedKeys = null;
        }
        Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
        Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };
        /**
         * Causes `this` reflector to track keys used to access
         * {@link ReflectionInfo} objects.
         */
        Reflector.prototype.trackUsage = function () { this._usedKeys = new Set(); };
        /**
         * Lists types for which reflection information was not requested since
         * {@link #trackUsage} was called. This list could later be audited as
         * potential dead code.
         */
        Reflector.prototype.listUnusedKeys = function () {
            var _this = this;
            if (this._usedKeys == null) {
                throw new Error('Usage tracking is disabled');
            }
            var allTypes = MapWrapper.keys(this._injectableInfo);
            return allTypes.filter(function (key) { return !_this._usedKeys.has(key); });
        };
        Reflector.prototype.registerFunction = function (func, funcInfo) {
            this._injectableInfo.set(func, funcInfo);
        };
        Reflector.prototype.registerType = function (type, typeInfo) {
            this._injectableInfo.set(type, typeInfo);
        };
        Reflector.prototype.registerGetters = function (getters) { _mergeMaps(this._getters, getters); };
        Reflector.prototype.registerSetters = function (setters) { _mergeMaps(this._setters, setters); };
        Reflector.prototype.registerMethods = function (methods) { _mergeMaps(this._methods, methods); };
        Reflector.prototype.factory = function (type) {
            if (this._containsReflectionInfo(type)) {
                var res = this._getReflectionInfo(type).factory;
                return isPresent(res) ? res : null;
            }
            else {
                return this.reflectionCapabilities.factory(type);
            }
        };
        Reflector.prototype.parameters = function (typeOrFunc) {
            if (this._injectableInfo.has(typeOrFunc)) {
                var res = this._getReflectionInfo(typeOrFunc).parameters;
                return isPresent(res) ? res : [];
            }
            else {
                return this.reflectionCapabilities.parameters(typeOrFunc);
            }
        };
        Reflector.prototype.annotations = function (typeOrFunc) {
            if (this._injectableInfo.has(typeOrFunc)) {
                var res = this._getReflectionInfo(typeOrFunc).annotations;
                return isPresent(res) ? res : [];
            }
            else {
                return this.reflectionCapabilities.annotations(typeOrFunc);
            }
        };
        Reflector.prototype.propMetadata = function (typeOrFunc) {
            if (this._injectableInfo.has(typeOrFunc)) {
                var res = this._getReflectionInfo(typeOrFunc).propMetadata;
                return isPresent(res) ? res : {};
            }
            else {
                return this.reflectionCapabilities.propMetadata(typeOrFunc);
            }
        };
        Reflector.prototype.interfaces = function (type) {
            if (this._injectableInfo.has(type)) {
                var res = this._getReflectionInfo(type).interfaces;
                return isPresent(res) ? res : [];
            }
            else {
                return this.reflectionCapabilities.interfaces(type);
            }
        };
        Reflector.prototype.hasLifecycleHook = function (type, lcInterface, lcProperty) {
            var interfaces = this.interfaces(type);
            if (interfaces.indexOf(lcInterface) !== -1) {
                return true;
            }
            else {
                return this.reflectionCapabilities.hasLifecycleHook(type, lcInterface, lcProperty);
            }
        };
        Reflector.prototype.getter = function (name) {
            if (this._getters.has(name)) {
                return this._getters.get(name);
            }
            else {
                return this.reflectionCapabilities.getter(name);
            }
        };
        Reflector.prototype.setter = function (name) {
            if (this._setters.has(name)) {
                return this._setters.get(name);
            }
            else {
                return this.reflectionCapabilities.setter(name);
            }
        };
        Reflector.prototype.method = function (name) {
            if (this._methods.has(name)) {
                return this._methods.get(name);
            }
            else {
                return this.reflectionCapabilities.method(name);
            }
        };
        /** @internal */
        Reflector.prototype._getReflectionInfo = function (typeOrFunc) {
            if (isPresent(this._usedKeys)) {
                this._usedKeys.add(typeOrFunc);
            }
            return this._injectableInfo.get(typeOrFunc);
        };
        /** @internal */
        Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { return this._injectableInfo.has(typeOrFunc); };
        Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
        Reflector.prototype.resolveIdentifier = function (name, moduleUrl, runtime) {
            return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, runtime);
        };
        Reflector.prototype.resolveEnum = function (identifier, name) {
            return this.reflectionCapabilities.resolveEnum(identifier, name);
        };
        return Reflector;
    }(ReflectorReader));
    function _mergeMaps(target, config) {
        Object.keys(config).forEach(function (k) { target.set(k, config[k]); });
    }

    /**
     * The {@link Reflector} used internally in Angular to access metadata
     * about symbols.
     */
    var reflector = new Reflector(new ReflectionCapabilities());

    /**
     * `Dependency` is used by the framework to extend DI.
     * This is internal to Angular and should not be used directly.
     */
    var ReflectiveDependency = (function () {
        function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
            this.key = key;
            this.optional = optional;
            this.lowerBoundVisibility = lowerBoundVisibility;
            this.upperBoundVisibility = upperBoundVisibility;
            this.properties = properties;
        }
        ReflectiveDependency.fromKey = function (key) {
            return new ReflectiveDependency(key, false, null, null, []);
        };
        return ReflectiveDependency;
    }());
    var _EMPTY_LIST = [];
    var ResolvedReflectiveProvider_ = (function () {
        function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
            this.key = key;
            this.resolvedFactories = resolvedFactories;
            this.multiProvider = multiProvider;
        }
        Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
            get: function () { return this.resolvedFactories[0]; },
            enumerable: true,
            configurable: true
        });
        return ResolvedReflectiveProvider_;
    }());
    /**
     * An internal resolved representation of a factory function created by resolving {@link
     * Provider}.
     * @experimental
     */
    var ResolvedReflectiveFactory = (function () {
        function ResolvedReflectiveFactory(
            /**
             * Factory function which can return an instance of an object represented by a key.
             */
            factory,
            /**
             * Arguments (dependencies) to the `factory` function.
             */
            dependencies) {
            this.factory = factory;
            this.dependencies = dependencies;
        }
        return ResolvedReflectiveFactory;
    }());
    /**
     * Resolve a single provider.
     */
    function resolveReflectiveFactory(provider) {
        var factoryFn;
        var resolvedDeps;
        if (isPresent(provider.useClass)) {
            var useClass = resolveForwardRef(provider.useClass);
            factoryFn = reflector.factory(useClass);
            resolvedDeps = _dependenciesFor(useClass);
        }
        else if (isPresent(provider.useExisting)) {
            factoryFn = function (aliasInstance) { return aliasInstance; };
            resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
        }
        else if (isPresent(provider.useFactory)) {
            factoryFn = provider.useFactory;
            resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
        }
        else {
            factoryFn = function () { return provider.useValue; };
            resolvedDeps = _EMPTY_LIST;
        }
        return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
    }
    /**
     * Converts the {@link Provider} into {@link ResolvedProvider}.
     *
     * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains
     * convenience provider syntax.
     */
    function resolveReflectiveProvider(provider) {
        return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);
    }
    /**
     * Resolve a list of Providers.
     */
    function resolveReflectiveProviders(providers) {
        var normalized = _normalizeProviders(providers, []);
        var resolved = normalized.map(resolveReflectiveProvider);
        return MapWrapper.values(mergeResolvedReflectiveProviders(resolved, new Map()));
    }
    /**
     * Merges a list of ResolvedProviders into a list where
     * each key is contained exactly once and multi providers
     * have been merged.
     */
    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
        for (var i = 0; i < providers.length; i++) {
            var provider = providers[i];
            var existing = normalizedProvidersMap.get(provider.key.id);
            if (isPresent(existing)) {
                if (provider.multiProvider !== existing.multiProvider) {
                    throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);
                }
                if (provider.multiProvider) {
                    for (var j = 0; j < provider.resolvedFactories.length; j++) {
                        existing.resolvedFactories.push(provider.resolvedFactories[j]);
                    }
                }
                else {
                    normalizedProvidersMap.set(provider.key.id, provider);
                }
            }
            else {
                var resolvedProvider;
                if (provider.multiProvider) {
                    resolvedProvider = new ResolvedReflectiveProvider_(provider.key, ListWrapper.clone(provider.resolvedFactories), provider.multiProvider);
                }
                else {
                    resolvedProvider = provider;
                }
                normalizedProvidersMap.set(provider.key.id, resolvedProvider);
            }
        }
        return normalizedProvidersMap;
    }
    function _normalizeProviders(providers, res) {
        providers.forEach(function (b) {
            if (b instanceof Type) {
                res.push({ provide: b, useClass: b });
            }
            else if (b && typeof b == 'object' && b.provide !== undefined) {
                res.push(b);
            }
            else if (b instanceof Array) {
                _normalizeProviders(b, res);
            }
            else {
                throw new InvalidProviderError(b);
            }
        });
        return res;
    }
    function constructDependencies(typeOrFunc, dependencies) {
        if (!dependencies) {
            return _dependenciesFor(typeOrFunc);
        }
        else {
            var params = dependencies.map(function (t) { return [t]; });
            return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params); });
        }
    }
    function _dependenciesFor(typeOrFunc) {
        var params = reflector.parameters(typeOrFunc);
        if (!params)
            return [];
        if (params.some(isBlank)) {
            throw new NoAnnotationError(typeOrFunc, params);
        }
        return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
    }
    function _extractToken(typeOrFunc /** TODO #9100 */, metadata /** TODO #9100 */ /*any[] | any*/, params) {
        var depProps = [];
        var token = null;
        var optional = false;
        if (!isArray(metadata)) {
            if (metadata instanceof Inject) {
                return _createDependency(metadata.token, optional, null, null, depProps);
            }
            else {
                return _createDependency(metadata, optional, null, null, depProps);
            }
        }
        var lowerBoundVisibility = null;
        var upperBoundVisibility = null;
        for (var i = 0; i < metadata.length; ++i) {
            var paramMetadata = metadata[i];
            if (paramMetadata instanceof Type) {
                token = paramMetadata;
            }
            else if (paramMetadata instanceof Inject) {
                token = paramMetadata.token;
            }
            else if (paramMetadata instanceof Optional) {
                optional = true;
            }
            else if (paramMetadata instanceof Self) {
                upperBoundVisibility = paramMetadata;
            }
            else if (paramMetadata instanceof Host) {
                upperBoundVisibility = paramMetadata;
            }
            else if (paramMetadata instanceof SkipSelf) {
                lowerBoundVisibility = paramMetadata;
            }
        }
        token = resolveForwardRef(token);
        if (isPresent(token)) {
            return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
        }
        else {
            throw new NoAnnotationError(typeOrFunc, params);
        }
    }
    function _createDependency(token /** TODO #9100 */, optional /** TODO #9100 */, lowerBoundVisibility /** TODO #9100 */, upperBoundVisibility /** TODO #9100 */, depProps /** TODO #9100 */) {
        return new ReflectiveDependency(ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
    }

    // avoid unused import when Type union types are erased
    // Threshold for the dynamic version
    var _MAX_CONSTRUCTION_COUNTER = 10;
    var UNDEFINED = new Object();
    var ReflectiveProtoInjectorInlineStrategy = (function () {
        function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
            this.provider0 = null;
            this.provider1 = null;
            this.provider2 = null;
            this.provider3 = null;
            this.provider4 = null;
            this.provider5 = null;
            this.provider6 = null;
            this.provider7 = null;
            this.provider8 = null;
            this.provider9 = null;
            this.keyId0 = null;
            this.keyId1 = null;
            this.keyId2 = null;
            this.keyId3 = null;
            this.keyId4 = null;
            this.keyId5 = null;
            this.keyId6 = null;
            this.keyId7 = null;
            this.keyId8 = null;
            this.keyId9 = null;
            var length = providers.length;
            if (length > 0) {
                this.provider0 = providers[0];
                this.keyId0 = providers[0].key.id;
            }
            if (length > 1) {
                this.provider1 = providers[1];
                this.keyId1 = providers[1].key.id;
            }
            if (length > 2) {
                this.provider2 = providers[2];
                this.keyId2 = providers[2].key.id;
            }
            if (length > 3) {
                this.provider3 = providers[3];
                this.keyId3 = providers[3].key.id;
            }
            if (length > 4) {
                this.provider4 = providers[4];
                this.keyId4 = providers[4].key.id;
            }
            if (length > 5) {
                this.provider5 = providers[5];
                this.keyId5 = providers[5].key.id;
            }
            if (length > 6) {
                this.provider6 = providers[6];
                this.keyId6 = providers[6].key.id;
            }
            if (length > 7) {
                this.provider7 = providers[7];
                this.keyId7 = providers[7].key.id;
            }
            if (length > 8) {
                this.provider8 = providers[8];
                this.keyId8 = providers[8].key.id;
            }
            if (length > 9) {
                this.provider9 = providers[9];
                this.keyId9 = providers[9].key.id;
            }
        }
        ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
            if (index == 0)
                return this.provider0;
            if (index == 1)
                return this.provider1;
            if (index == 2)
                return this.provider2;
            if (index == 3)
                return this.provider3;
            if (index == 4)
                return this.provider4;
            if (index == 5)
                return this.provider5;
            if (index == 6)
                return this.provider6;
            if (index == 7)
                return this.provider7;
            if (index == 8)
                return this.provider8;
            if (index == 9)
                return this.provider9;
            throw new OutOfBoundsError(index);
        };
        ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
            return new ReflectiveInjectorInlineStrategy(injector, this);
        };
        return ReflectiveProtoInjectorInlineStrategy;
    }());
    var ReflectiveProtoInjectorDynamicStrategy = (function () {
        function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
            this.providers = providers;
            var len = providers.length;
            this.keyIds = new Array(len);
            for (var i = 0; i < len; i++) {
                this.keyIds[i] = providers[i].key.id;
            }
        }
        ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
            if (index < 0 || index >= this.providers.length) {
                throw new OutOfBoundsError(index);
            }
            return this.providers[index];
        };
        ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
            return new ReflectiveInjectorDynamicStrategy(this, ei);
        };
        return ReflectiveProtoInjectorDynamicStrategy;
    }());
    var ReflectiveProtoInjector = (function () {
        function ReflectiveProtoInjector(providers) {
            this.numberOfProviders = providers.length;
            this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?
                new ReflectiveProtoInjectorDynamicStrategy(this, providers) :
                new ReflectiveProtoInjectorInlineStrategy(this, providers);
        }
        ReflectiveProtoInjector.fromResolvedProviders = function (providers) {
            return new ReflectiveProtoInjector(providers);
        };
        ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {
            return this._strategy.getProviderAtIndex(index);
        };
        return ReflectiveProtoInjector;
    }());
    var ReflectiveInjectorInlineStrategy = (function () {
        function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
            this.injector = injector;
            this.protoStrategy = protoStrategy;
            this.obj0 = UNDEFINED;
            this.obj1 = UNDEFINED;
            this.obj2 = UNDEFINED;
            this.obj3 = UNDEFINED;
            this.obj4 = UNDEFINED;
            this.obj5 = UNDEFINED;
            this.obj6 = UNDEFINED;
            this.obj7 = UNDEFINED;
            this.obj8 = UNDEFINED;
            this.obj9 = UNDEFINED;
        }
        ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
        ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {
            return this.injector._new(provider);
        };
        ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {
            var p = this.protoStrategy;
            var inj = this.injector;
            if (p.keyId0 === keyId) {
                if (this.obj0 === UNDEFINED) {
                    this.obj0 = inj._new(p.provider0);
                }
                return this.obj0;
            }
            if (p.keyId1 === keyId) {
                if (this.obj1 === UNDEFINED) {
                    this.obj1 = inj._new(p.provider1);
                }
                return this.obj1;
            }
            if (p.keyId2 === keyId) {
                if (this.obj2 === UNDEFINED) {
                    this.obj2 = inj._new(p.provider2);
                }
                return this.obj2;
            }
            if (p.keyId3 === keyId) {
                if (this.obj3 === UNDEFINED) {
                    this.obj3 = inj._new(p.provider3);
                }
                return this.obj3;
            }
            if (p.keyId4 === keyId) {
                if (this.obj4 === UNDEFINED) {
                    this.obj4 = inj._new(p.provider4);
                }
                return this.obj4;
            }
            if (p.keyId5 === keyId) {
                if (this.obj5 === UNDEFINED) {
                    this.obj5 = inj._new(p.provider5);
                }
                return this.obj5;
            }
            if (p.keyId6 === keyId) {
                if (this.obj6 === UNDEFINED) {
                    this.obj6 = inj._new(p.provider6);
                }
                return this.obj6;
            }
            if (p.keyId7 === keyId) {
                if (this.obj7 === UNDEFINED) {
                    this.obj7 = inj._new(p.provider7);
                }
                return this.obj7;
            }
            if (p.keyId8 === keyId) {
                if (this.obj8 === UNDEFINED) {
                    this.obj8 = inj._new(p.provider8);
                }
                return this.obj8;
            }
            if (p.keyId9 === keyId) {
                if (this.obj9 === UNDEFINED) {
                    this.obj9 = inj._new(p.provider9);
                }
                return this.obj9;
            }
            return UNDEFINED;
        };
        ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
            if (index == 0)
                return this.obj0;
            if (index == 1)
                return this.obj1;
            if (index == 2)
                return this.obj2;
            if (index == 3)
                return this.obj3;
            if (index == 4)
                return this.obj4;
            if (index == 5)
                return this.obj5;
            if (index == 6)
                return this.obj6;
            if (index == 7)
                return this.obj7;
            if (index == 8)
                return this.obj8;
            if (index == 9)
                return this.obj9;
            throw new OutOfBoundsError(index);
        };
        ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
        return ReflectiveInjectorInlineStrategy;
    }());
    var ReflectiveInjectorDynamicStrategy = (function () {
        function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
            this.protoStrategy = protoStrategy;
            this.injector = injector;
            this.objs = new Array(protoStrategy.providers.length);
            ListWrapper.fill(this.objs, UNDEFINED);
        }
        ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
        ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {
            return this.injector._new(provider);
        };
        ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {
            var p = this.protoStrategy;
            for (var i = 0; i < p.keyIds.length; i++) {
                if (p.keyIds[i] === keyId) {
                    if (this.objs[i] === UNDEFINED) {
                        this.objs[i] = this.injector._new(p.providers[i]);
                    }
                    return this.objs[i];
                }
            }
            return UNDEFINED;
        };
        ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
            if (index < 0 || index >= this.objs.length) {
                throw new OutOfBoundsError(index);
            }
            return this.objs[index];
        };
        ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
        return ReflectiveInjectorDynamicStrategy;
    }());
    /**
     * A ReflectiveDependency injection container used for instantiating objects and resolving
     * dependencies.
     *
     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
     * constructor dependencies.
     *
     * In typical use, application code asks for the dependencies in the constructor and they are
     * resolved by the `Injector`.
     *
     * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
     *
     * The following example creates an `Injector` configured to create `Engine` and `Car`.
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
     * var car = injector.get(Car);
     * expect(car instanceof Car).toBe(true);
     * expect(car.engine instanceof Engine).toBe(true);
     * ```
     *
     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
     * resolve all of the object's dependencies automatically.
     *
     * @stable
     */
    var ReflectiveInjector = (function () {
        function ReflectiveInjector() {
        }
        /**
         * Turns an array of provider definitions into an array of resolved providers.
         *
         * A resolution is a process of flattening multiple nested arrays and converting individual
         * providers into an array of {@link ResolvedReflectiveProvider}s.
         *
         * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
         *
         * expect(providers.length).toEqual(2);
         *
         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
         * expect(providers[0].key.displayName).toBe("Car");
         * expect(providers[0].dependencies.length).toEqual(1);
         * expect(providers[0].factory).toBeDefined();
         *
         * expect(providers[1].key.displayName).toBe("Engine");
         * });
         * ```
         *
         * See {@link ReflectiveInjector#fromResolvedProviders} for more info.
         */
        ReflectiveInjector.resolve = function (providers) {
            return resolveReflectiveProviders(providers);
        };
        /**
         * Resolves an array of providers and creates an injector from those providers.
         *
         * The passed-in providers can be an array of `Type`, {@link Provider},
         * or a recursive array of more providers.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
         * expect(injector.get(Car) instanceof Car).toBe(true);
         * ```
         *
         * This function is slower than the corresponding `fromResolvedProviders`
         * because it needs to resolve the passed-in providers first.
         * See {@link Injector#resolve} and {@link Injector#fromResolvedProviders}.
         */
        ReflectiveInjector.resolveAndCreate = function (providers, parent) {
            if (parent === void 0) { parent = null; }
            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
        };
        /**
         * Creates an injector from previously resolved providers.
         *
         * This API is the recommended way to construct injectors in performance-sensitive parts.
         *
         * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var providers = ReflectiveInjector.resolve([Car, Engine]);
         * var injector = ReflectiveInjector.fromResolvedProviders(providers);
         * expect(injector.get(Car) instanceof Car).toBe(true);
         * ```
         * @experimental
         */
        ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
            if (parent === void 0) { parent = null; }
            return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
        };
        Object.defineProperty(ReflectiveInjector.prototype, "parent", {
            /**
             * Parent of this injector.
             *
             * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
             * -->
             *
             * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
             *
             * ```typescript
             * var parent = ReflectiveInjector.resolveAndCreate([]);
             * var child = parent.resolveAndCreateChild([]);
             * expect(child.parent).toBe(parent);
             * ```
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        /**
         * Resolves an array of providers and creates a child injector from those providers.
         *
         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
         * -->
         *
         * The passed-in providers can be an array of `Type`, {@link Provider},
         * or a recursive array of more providers.
         *
         * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
         *
         * ```typescript
         * class ParentProvider {}
         * class ChildProvider {}
         *
         * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
         * var child = parent.resolveAndCreateChild([ChildProvider]);
         *
         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
         * ```
         *
         * This function is slower than the corresponding `createChildFromResolved`
         * because it needs to resolve the passed-in providers first.
         * See {@link Injector#resolve} and {@link Injector#createChildFromResolved}.
         */
        ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { return unimplemented(); };
        /**
         * Creates a child injector from previously resolved providers.
         *
         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
         * -->
         *
         * This API is the recommended way to construct injectors in performance-sensitive parts.
         *
         * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
         *
         * ```typescript
         * class ParentProvider {}
         * class ChildProvider {}
         *
         * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
         * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
         *
         * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
         * var child = parent.createChildFromResolved(childProviders);
         *
         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
         * ```
         */
        ReflectiveInjector.prototype.createChildFromResolved = function (providers) {
            return unimplemented();
        };
        /**
         * Resolves a provider and instantiates an object in the context of the injector.
         *
         * The created object does not get cached by the injector.
         *
         * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
         *
         * var car = injector.resolveAndInstantiate(Car);
         * expect(car.engine).toBe(injector.get(Engine));
         * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
         * ```
         */
        ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return unimplemented(); };
        /**
         * Instantiates an object using a resolved provider in the context of the injector.
         *
         * The created object does not get cached by the injector.
         *
         * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
         *
         * ```typescript
         * @Injectable()
         * class Engine {
         * }
         *
         * @Injectable()
         * class Car {
         *   constructor(public engine:Engine) {}
         * }
         *
         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
         * var carProvider = ReflectiveInjector.resolve([Car])[0];
         * var car = injector.instantiateResolved(carProvider);
         * expect(car.engine).toBe(injector.get(Engine));
         * expect(car).not.toBe(injector.instantiateResolved(carProvider));
         * ```
         */
        ReflectiveInjector.prototype.instantiateResolved = function (provider) { return unimplemented(); };
        return ReflectiveInjector;
    }());
    var ReflectiveInjector_ = (function () {
        /**
         * Private
         */
        function ReflectiveInjector_(_proto /* ProtoInjector */, _parent) {
            if (_parent === void 0) { _parent = null; }
            /** @internal */
            this._constructionCounter = 0;
            this._proto = _proto;
            this._parent = _parent;
            this._strategy = _proto._strategy.createInjectorStrategy(this);
        }
        ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            return this._getByKey(ReflectiveKey.get(token), null, null, notFoundValue);
        };
        ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
        Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
            get: function () { return this._parent; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
            /**
             * @internal
             * Internal. Do not use.
             * We return `any` not to export the InjectorStrategy type.
             */
            get: function () { return this._strategy; },
            enumerable: true,
            configurable: true
        });
        ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
            var ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
            return this.createChildFromResolved(ResolvedReflectiveProviders);
        };
        ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
            var proto = new ReflectiveProtoInjector(providers);
            var inj = new ReflectiveInjector_(proto);
            inj._parent = this;
            return inj;
        };
        ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
        };
        ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
            return this._instantiateProvider(provider);
        };
        /** @internal */
        ReflectiveInjector_.prototype._new = function (provider) {
            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
                throw new CyclicDependencyError(this, provider.key);
            }
            return this._instantiateProvider(provider);
        };
        ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
            if (provider.multiProvider) {
                var res = new Array(provider.resolvedFactories.length);
                for (var i = 0; i < provider.resolvedFactories.length; ++i) {
                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
                }
                return res;
            }
            else {
                return this._instantiate(provider, provider.resolvedFactories[0]);
            }
        };
        ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {
            var factory = ResolvedReflectiveFactory.factory;
            var deps = ResolvedReflectiveFactory.dependencies;
            var length = deps.length;
            var d0;
            var d1;
            var d2;
            var d3;
            var d4;
            var d5;
            var d6;
            var d7;
            var d8;
            var d9;
            var d10;
            var d11;
            var d12;
            var d13;
            var d14;
            var d15;
            var d16;
            var d17;
            var d18;
            var d19;
            try {
                d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
                d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
                d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
                d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
                d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
                d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
                d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
                d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
                d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
                d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
                d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
                d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
                d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
                d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
                d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
                d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
                d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
                d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
                d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
                d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
            }
            catch (e) {
                if (e instanceof AbstractProviderError || e instanceof InstantiationError) {
                    e.addKey(this, provider.key);
                }
                throw e;
            }
            var obj;
            try {
                switch (length) {
                    case 0:
                        obj = factory();
                        break;
                    case 1:
                        obj = factory(d0);
                        break;
                    case 2:
                        obj = factory(d0, d1);
                        break;
                    case 3:
                        obj = factory(d0, d1, d2);
                        break;
                    case 4:
                        obj = factory(d0, d1, d2, d3);
                        break;
                    case 5:
                        obj = factory(d0, d1, d2, d3, d4);
                        break;
                    case 6:
                        obj = factory(d0, d1, d2, d3, d4, d5);
                        break;
                    case 7:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6);
                        break;
                    case 8:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
                        break;
                    case 9:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
                        break;
                    case 10:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
                        break;
                    case 11:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
                        break;
                    case 12:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
                        break;
                    case 13:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
                        break;
                    case 14:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
                        break;
                    case 15:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
                        break;
                    case 16:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
                        break;
                    case 17:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
                        break;
                    case 18:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
                        break;
                    case 19:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
                        break;
                    case 20:
                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
                        break;
                    default:
                        throw new Error("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
                }
            }
            catch (e) {
                throw new InstantiationError(this, e, e.stack, provider.key);
            }
            return obj;
        };
        ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {
            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : THROW_IF_NOT_FOUND);
        };
        ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
            if (key === INJECTOR_KEY) {
                return this;
            }
            if (upperBoundVisibility instanceof Self) {
                return this._getByKeySelf(key, notFoundValue);
            }
            else {
                return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
            }
        };
        /** @internal */
        ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
            if (notFoundValue !== THROW_IF_NOT_FOUND) {
                return notFoundValue;
            }
            else {
                throw new NoProviderError(this, key);
            }
        };
        /** @internal */
        ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
            var obj = this._strategy.getObjByKeyId(key.id);
            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
        };
        /** @internal */
        ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {
            var inj;
            if (lowerBoundVisibility instanceof SkipSelf) {
                inj = this._parent;
            }
            else {
                inj = this;
            }
            while (inj instanceof ReflectiveInjector_) {
                var inj_ = inj;
                var obj = inj_._strategy.getObjByKeyId(key.id);
                if (obj !== UNDEFINED)
                    return obj;
                inj = inj_._parent;
            }
            if (inj !== null) {
                return inj.get(key.token, notFoundValue);
            }
            else {
                return this._throwOrNull(key, notFoundValue);
            }
        };
        Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
            get: function () {
                var providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
                    .join(', ');
                return "ReflectiveInjector(providers: [" + providers + "])";
            },
            enumerable: true,
            configurable: true
        });
        ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
        return ReflectiveInjector_;
    }());
    var INJECTOR_KEY = ReflectiveKey.get(Injector);
    function _mapProviders(injector, fn) {
        var res = new Array(injector._proto.numberOfProviders);
        for (var i = 0; i < injector._proto.numberOfProviders; ++i) {
            res[i] = fn(injector._proto.getProviderAtIndex(i));
        }
        return res;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @whatItDoes Provides a hook for centralized exception handling.
     *
     * @description
     *
     * The default implementation of `ErrorHandler` prints error messages to the `console`. To
     * intercept error handling, write a custom exception handler that replaces this default as
     * appropriate for your app.
     *
     * ### Example
     *
     * ```
     * class MyErrorHandler implements ErrorHandler {
     *   handleError(error) {
     *     // do something with the exception
     *   }
     * }
     *
     * @NgModule({
     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
     * })
     * class MyModule {}
     * ```
     *
     * @stable
     */
    var ErrorHandler = (function () {
        function ErrorHandler(rethrowError) {
            if (rethrowError === void 0) { rethrowError = true; }
            /**
             * @internal
             */
            this._console = console;
            this.rethrowError = rethrowError;
        }
        ErrorHandler.prototype.handleError = function (error) {
            var originalError = this._findOriginalError(error);
            var originalStack = this._findOriginalStack(error);
            var context = this._findContext(error);
            this._console.error("EXCEPTION: " + this._extractMessage(error));
            if (originalError) {
                this._console.error("ORIGINAL EXCEPTION: " + this._extractMessage(originalError));
            }
            if (originalStack) {
                this._console.error('ORIGINAL STACKTRACE:');
                this._console.error(originalStack);
            }
            if (context) {
                this._console.error('ERROR CONTEXT:');
                this._console.error(context);
            }
            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
            // when an error happens. If we do not rethrow, bootstrap will always succeed.
            if (this.rethrowError)
                throw error;
        };
        /** @internal */
        ErrorHandler.prototype._extractMessage = function (error) {
            return error instanceof Error ? error.message : error.toString();
        };
        /** @internal */
        ErrorHandler.prototype._findContext = function (error) {
            if (error) {
                return error.context ? error.context :
                    this._findContext(error.originalError);
            }
            return null;
        };
        /** @internal */
        ErrorHandler.prototype._findOriginalError = function (error) {
            var e = error.originalError;
            while (e && e.originalError) {
                e = e.originalError;
            }
            return e;
        };
        /** @internal */
        ErrorHandler.prototype._findOriginalStack = function (error) {
            if (!(error instanceof Error))
                return null;
            var e = error;
            var stack = e.stack;
            while (e instanceof Error && e.originalError) {
                e = e.originalError;
                if (e instanceof Error && e.stack) {
                    stack = e.stack;
                }
            }
            return stack;
        };
        return ErrorHandler;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isPromise(obj) {
        // allow any Promise/A+ compliant thenable.
        // It's up to the caller to ensure that obj.then conforms to the spec
        return !!obj && typeof obj.then === 'function';
    }

    /**
     * A function that will be executed when an application is initialized.
     * @experimental
     */
    var APP_INITIALIZER = new OpaqueToken('Application Initializer');
    /**
     * A class that reflects the state of running {@link APP_INITIALIZER}s.
     *
     * @experimental
     */
    var ApplicationInitStatus = (function () {
        function ApplicationInitStatus(appInits) {
            var _this = this;
            this._done = false;
            var asyncInitPromises = [];
            if (appInits) {
                for (var i = 0; i < appInits.length; i++) {
                    var initResult = appInits[i]();
                    if (isPromise(initResult)) {
                        asyncInitPromises.push(initResult);
                    }
                }
            }
            this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });
            if (asyncInitPromises.length === 0) {
                this._done = true;
            }
        }
        Object.defineProperty(ApplicationInitStatus.prototype, "done", {
            get: function () { return this._done; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
            get: function () { return this._donePromise; },
            enumerable: true,
            configurable: true
        });
        ApplicationInitStatus.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        ApplicationInitStatus.ctorParameters = [
            { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },
        ];
        return ApplicationInitStatus;
    }());

    /**
     * A DI Token representing a unique string id assigned to the application by Angular and used
     * primarily for prefixing application attributes and CSS styles when
     * {@link ViewEncapsulation#Emulated} is being used.
     *
     * If you need to avoid randomly generated value to be used as an application id, you can provide
     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
     * using this token.
     * @experimental
     */
    var APP_ID = new OpaqueToken('AppId');
    function _appIdRandomProviderFactory() {
        return "" + _randomChar() + _randomChar() + _randomChar();
    }
    /**
     * Providers that will generate a random APP_ID_TOKEN.
     * @experimental
     */
    var APP_ID_RANDOM_PROVIDER = {
        provide: APP_ID,
        useFactory: _appIdRandomProviderFactory,
        deps: [],
    };
    function _randomChar() {
        return StringWrapper.fromCharCode(97 + Math.floor(Math.random() * 25));
    }
    /**
     * A function that will be executed when a platform is initialized.
     * @experimental
     */
    var PLATFORM_INITIALIZER = new OpaqueToken('Platform Initializer');
    /**
     * All callbacks provided via this token will be called for every component that is bootstrapped.
     * Signature of the callback:
     *
     * `(componentRef: ComponentRef) => void`.
     *
     * @experimental
     */
    var APP_BOOTSTRAP_LISTENER = new OpaqueToken('appBootstrapListener');
    /**
     * A token which indicates the root directory of the application
     * @experimental
     */
    var PACKAGE_ROOT_URL = new OpaqueToken('Application Packages Root URL');

    var Console = (function () {
        function Console() {
        }
        Console.prototype.log = function (message) { print(message); };
        // Note: for reporting errors use `DOM.logError()` as it is platform specific
        Console.prototype.warn = function (message) { warn(message); };
        Console.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        Console.ctorParameters = [];
        return Console;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$4 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Indicates that a component is still being loaded in a synchronous compile.
     *
     * @stable
     */
    var ComponentStillLoadingError = (function (_super) {
        __extends$4(ComponentStillLoadingError, _super);
        function ComponentStillLoadingError(compType) {
            _super.call(this, "Can't compile synchronously as " + stringify(compType) + " is still being loaded!");
            this.compType = compType;
        }
        return ComponentStillLoadingError;
    }(BaseError));
    /**
     * Combination of NgModuleFactory and ComponentFactorys.
     *
     * @experimental
     */
    var ModuleWithComponentFactories = (function () {
        function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
            this.ngModuleFactory = ngModuleFactory;
            this.componentFactories = componentFactories;
        }
        return ModuleWithComponentFactories;
    }());
    function _throwError() {
        throw new Error("Runtime compiler is not loaded");
    }
    /**
     * Low-level service for running the angular compiler during runtime
     * to create {@link ComponentFactory}s, which
     * can later be used to create and render a Component instance.
     *
     * Each `@NgModule` provides an own `Compiler` to its injector,
     * that will use the directives/pipes of the ng module for compilation
     * of components.
     * @stable
     */
    var Compiler = (function () {
        function Compiler() {
        }
        /**
         * Compiles the given NgModule and all of its components. All templates of the components listed
         * in `entryComponents`
         * have to be inlined. Otherwise throws a {@link ComponentStillLoadingError}.
         */
        Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };
        /**
         * Compiles the given NgModule and all of its components
         */
        Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };
        /**
         * Same as {@link compileModuleSync} but also creates ComponentFactories for all components.
         */
        Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
            throw _throwError();
        };
        /**
         * Same as {@link compileModuleAsync} but also creates ComponentFactories for all components.
         */
        Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
            throw _throwError();
        };
        /**
         * Clears all caches.
         */
        Compiler.prototype.clearCache = function () { };
        /**
         * Clears the cache for the given component/ngModule.
         */
        Compiler.prototype.clearCacheFor = function (type) { };
        return Compiler;
    }());
    /**
     * Token to provide CompilerOptions in the platform injector.
     *
     * @experimental
     */
    var COMPILER_OPTIONS = new OpaqueToken('compilerOptions');
    /**
     * A factory for creating a Compiler
     *
     * @experimental
     */
    var CompilerFactory = (function () {
        function CompilerFactory() {
        }
        return CompilerFactory;
    }());

    var DefaultIterableDifferFactory = (function () {
        function DefaultIterableDifferFactory() {
        }
        DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };
        DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
            return new DefaultIterableDiffer(trackByFn);
        };
        return DefaultIterableDifferFactory;
    }());
    var trackByIdentity = function (index, item) { return item; };
    /**
     * @stable
     */
    var DefaultIterableDiffer = (function () {
        function DefaultIterableDiffer(_trackByFn) {
            this._trackByFn = _trackByFn;
            this._length = null;
            this._collection = null;
            // Keeps track of the used records at any point in time (during & across `_check()` calls)
            this._linkedRecords = null;
            // Keeps track of the removed records at any point in time during `_check()` calls.
            this._unlinkedRecords = null;
            this._previousItHead = null;
            this._itHead = null;
            this._itTail = null;
            this._additionsHead = null;
            this._additionsTail = null;
            this._movesHead = null;
            this._movesTail = null;
            this._removalsHead = null;
            this._removalsTail = null;
            // Keeps track of records where custom track by is the same, but item identity has changed
            this._identityChangesHead = null;
            this._identityChangesTail = null;
            this._trackByFn = isPresent(this._trackByFn) ? this._trackByFn : trackByIdentity;
        }
        Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
            get: function () { return this._collection; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
            get: function () { return this._length; },
            enumerable: true,
            configurable: true
        });
        DefaultIterableDiffer.prototype.forEachItem = function (fn) {
            var record;
            for (record = this._itHead; record !== null; record = record._next) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachOperation = function (fn) {
            var nextIt = this._itHead;
            var nextRemove = this._removalsHead;
            var addRemoveOffset = 0;
            var moveOffsets = null;
            while (nextIt || nextRemove) {
                // Figure out which is the next record to process
                // Order: remove, add, move
                var record = !nextRemove ||
                    nextIt &&
                        nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
                    nextIt :
                    nextRemove;
                var adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
                var currentIndex = record.currentIndex;
                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
                if (record === nextRemove) {
                    addRemoveOffset--;
                    nextRemove = nextRemove._nextRemoved;
                }
                else {
                    nextIt = nextIt._next;
                    if (record.previousIndex == null) {
                        addRemoveOffset++;
                    }
                    else {
                        // INVARIANT:  currentIndex < previousIndex
                        if (!moveOffsets)
                            moveOffsets = [];
                        var localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
                        var localCurrentIndex = currentIndex - addRemoveOffset;
                        if (localMovePreviousIndex != localCurrentIndex) {
                            for (var i = 0; i < localMovePreviousIndex; i++) {
                                var offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
                                var index = offset + i;
                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                                    moveOffsets[i] = offset + 1;
                                }
                            }
                            var previousIndex = record.previousIndex;
                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
                        }
                    }
                }
                if (adjPreviousIndex !== currentIndex) {
                    fn(record, adjPreviousIndex, currentIndex);
                }
            }
        };
        DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
            var record;
            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
            var record;
            for (record = this._movesHead; record !== null; record = record._nextMoved) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
            var record;
            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
                fn(record);
            }
        };
        DefaultIterableDiffer.prototype.diff = function (collection) {
            if (isBlank(collection))
                collection = [];
            if (!isListLikeIterable(collection)) {
                throw new Error("Error trying to diff '" + collection + "'");
            }
            if (this.check(collection)) {
                return this;
            }
            else {
                return null;
            }
        };
        DefaultIterableDiffer.prototype.onDestroy = function () { };
        // todo(vicb): optim for UnmodifiableListView (frozen arrays)
        DefaultIterableDiffer.prototype.check = function (collection) {
            var _this = this;
            this._reset();
            var record = this._itHead;
            var mayBeDirty = false;
            var index;
            var item;
            var itemTrackBy;
            if (isArray(collection)) {
                var list = collection;
                this._length = collection.length;
                for (index = 0; index < this._length; index++) {
                    item = list[index];
                    itemTrackBy = this._trackByFn(index, item);
                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
                        record = this._mismatch(record, item, itemTrackBy, index);
                        mayBeDirty = true;
                    }
                    else {
                        if (mayBeDirty) {
                            // TODO(misko): can we limit this to duplicates only?
                            record = this._verifyReinsertion(record, item, itemTrackBy, index);
                        }
                        if (!looseIdentical(record.item, item))
                            this._addIdentityChange(record, item);
                    }
                    record = record._next;
                }
            }
            else {
                index = 0;
                iterateListLike(collection, function (item /** TODO #9100 */) {
                    itemTrackBy = _this._trackByFn(index, item);
                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
                        record = _this._mismatch(record, item, itemTrackBy, index);
                        mayBeDirty = true;
                    }
                    else {
                        if (mayBeDirty) {
                            // TODO(misko): can we limit this to duplicates only?
                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);
                        }
                        if (!looseIdentical(record.item, item))
                            _this._addIdentityChange(record, item);
                    }
                    record = record._next;
                    index++;
                });
                this._length = index;
            }
            this._truncate(record);
            this._collection = collection;
            return this.isDirty;
        };
        Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
            /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
             * changes.
             */
            get: function () {
                return this._additionsHead !== null || this._movesHead !== null ||
                    this._removalsHead !== null || this._identityChangesHead !== null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Reset the state of the change objects to show no changes. This means set previousKey to
         * currentKey, and clear all of the queues (additions, moves, removals).
         * Set the previousIndexes of moved and added items to their currentIndexes
         * Reset the list of additions, moves and removals
         *
         * @internal
         */
        DefaultIterableDiffer.prototype._reset = function () {
            if (this.isDirty) {
                var record;
                var nextRecord;
                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                    record._nextPrevious = record._next;
                }
                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                    record.previousIndex = record.currentIndex;
                }
                this._additionsHead = this._additionsTail = null;
                for (record = this._movesHead; record !== null; record = nextRecord) {
                    record.previousIndex = record.currentIndex;
                    nextRecord = record._nextMoved;
                }
                this._movesHead = this._movesTail = null;
                this._removalsHead = this._removalsTail = null;
                this._identityChangesHead = this._identityChangesTail = null;
            }
        };
        /**
         * This is the core function which handles differences between collections.
         *
         * - `record` is the record which we saw at this position last time. If null then it is a new
         *   item.
         * - `item` is the current item in the collection
         * - `index` is the position of the item in the collection
         *
         * @internal
         */
        DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
            // The previous record after which we will append the current one.
            var previousRecord;
            if (record === null) {
                previousRecord = this._itTail;
            }
            else {
                previousRecord = record._prev;
                // Remove the record from the collection since we know it does not match the item.
                this._remove(record);
            }
            // Attempt to see if we have seen the item before.
            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
            if (record !== null) {
                // We have seen this before, we need to move it forward in the collection.
                // But first we need to check if identity changed, so we can update in view if necessary
                if (!looseIdentical(record.item, item))
                    this._addIdentityChange(record, item);
                this._moveAfter(record, previousRecord, index);
            }
            else {
                // Never seen it, check evicted list.
                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
                if (record !== null) {
                    // It is an item which we have evicted earlier: reinsert it back into the list.
                    // But first we need to check if identity changed, so we can update in view if necessary
                    if (!looseIdentical(record.item, item))
                        this._addIdentityChange(record, item);
                    this._reinsertAfter(record, previousRecord, index);
                }
                else {
                    // It is a new item: add it.
                    record =
                        this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
                }
            }
            return record;
        };
        /**
         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
         *
         * Use case: `[a, a]` => `[b, a, a]`
         *
         * If we did not have this check then the insertion of `b` would:
         *   1) evict first `a`
         *   2) insert `b` at `0` index.
         *   3) leave `a` at index `1` as is. <-- this is wrong!
         *   3) reinsert `a` at index 2. <-- this is wrong!
         *
         * The correct behavior is:
         *   1) evict first `a`
         *   2) insert `b` at `0` index.
         *   3) reinsert `a` at index 1.
         *   3) move `a` at from `1` to `2`.
         *
         *
         * Double check that we have not evicted a duplicate item. We need to check if the item type may
         * have already been removed:
         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
         * at the end.
         *
         * @internal
         */
        DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
            var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
            if (reinsertRecord !== null) {
                record = this._reinsertAfter(reinsertRecord, record._prev, index);
            }
            else if (record.currentIndex != index) {
                record.currentIndex = index;
                this._addToMoves(record, index);
            }
            return record;
        };
        /**
         * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
         *
         * - `record` The first excess {@link CollectionChangeRecord}.
         *
         * @internal
         */
        DefaultIterableDiffer.prototype._truncate = function (record) {
            // Anything after that needs to be removed;
            while (record !== null) {
                var nextRecord = record._next;
                this._addToRemovals(this._unlink(record));
                record = nextRecord;
            }
            if (this._unlinkedRecords !== null) {
                this._unlinkedRecords.clear();
            }
            if (this._additionsTail !== null) {
                this._additionsTail._nextAdded = null;
            }
            if (this._movesTail !== null) {
                this._movesTail._nextMoved = null;
            }
            if (this._itTail !== null) {
                this._itTail._next = null;
            }
            if (this._removalsTail !== null) {
                this._removalsTail._nextRemoved = null;
            }
            if (this._identityChangesTail !== null) {
                this._identityChangesTail._nextIdentityChange = null;
            }
        };
        /** @internal */
        DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
            if (this._unlinkedRecords !== null) {
                this._unlinkedRecords.remove(record);
            }
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
                this._removalsHead = next;
            }
            else {
                prev._nextRemoved = next;
            }
            if (next === null) {
                this._removalsTail = prev;
            }
            else {
                next._prevRemoved = prev;
            }
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
            this._unlink(record);
            this._insertAfter(record, prevRecord, index);
            this._addToMoves(record, index);
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
            this._insertAfter(record, prevRecord, index);
            if (this._additionsTail === null) {
                // todo(vicb)
                // assert(this._additionsHead === null);
                this._additionsTail = this._additionsHead = record;
            }
            else {
                // todo(vicb)
                // assert(_additionsTail._nextAdded === null);
                // assert(record._nextAdded === null);
                this._additionsTail = this._additionsTail._nextAdded = record;
            }
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
            // todo(vicb)
            // assert(record != prevRecord);
            // assert(record._next === null);
            // assert(record._prev === null);
            var next = prevRecord === null ? this._itHead : prevRecord._next;
            // todo(vicb)
            // assert(next != record);
            // assert(prevRecord != record);
            record._next = next;
            record._prev = prevRecord;
            if (next === null) {
                this._itTail = record;
            }
            else {
                next._prev = record;
            }
            if (prevRecord === null) {
                this._itHead = record;
            }
            else {
                prevRecord._next = record;
            }
            if (this._linkedRecords === null) {
                this._linkedRecords = new _DuplicateMap();
            }
            this._linkedRecords.put(record);
            record.currentIndex = index;
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._remove = function (record) {
            return this._addToRemovals(this._unlink(record));
        };
        /** @internal */
        DefaultIterableDiffer.prototype._unlink = function (record) {
            if (this._linkedRecords !== null) {
                this._linkedRecords.remove(record);
            }
            var prev = record._prev;
            var next = record._next;
            // todo(vicb)
            // assert((record._prev = null) === null);
            // assert((record._next = null) === null);
            if (prev === null) {
                this._itHead = next;
            }
            else {
                prev._next = next;
            }
            if (next === null) {
                this._itTail = prev;
            }
            else {
                next._prev = prev;
            }
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
            // todo(vicb)
            // assert(record._nextMoved === null);
            if (record.previousIndex === toIndex) {
                return record;
            }
            if (this._movesTail === null) {
                // todo(vicb)
                // assert(_movesHead === null);
                this._movesTail = this._movesHead = record;
            }
            else {
                // todo(vicb)
                // assert(_movesTail._nextMoved === null);
                this._movesTail = this._movesTail._nextMoved = record;
            }
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._addToRemovals = function (record) {
            if (this._unlinkedRecords === null) {
                this._unlinkedRecords = new _DuplicateMap();
            }
            this._unlinkedRecords.put(record);
            record.currentIndex = null;
            record._nextRemoved = null;
            if (this._removalsTail === null) {
                // todo(vicb)
                // assert(_removalsHead === null);
                this._removalsTail = this._removalsHead = record;
                record._prevRemoved = null;
            }
            else {
                // todo(vicb)
                // assert(_removalsTail._nextRemoved === null);
                // assert(record._nextRemoved === null);
                record._prevRemoved = this._removalsTail;
                this._removalsTail = this._removalsTail._nextRemoved = record;
            }
            return record;
        };
        /** @internal */
        DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
            record.item = item;
            if (this._identityChangesTail === null) {
                this._identityChangesTail = this._identityChangesHead = record;
            }
            else {
                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
            }
            return record;
        };
        DefaultIterableDiffer.prototype.toString = function () {
            var list = [];
            this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });
            var previous = [];
            this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });
            var additions = [];
            this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });
            var moves = [];
            this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });
            var removals = [];
            this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });
            var identityChanges = [];
            this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });
            return 'collection: ' + list.join(', ') + '\n' +
                'previous: ' + previous.join(', ') + '\n' +
                'additions: ' + additions.join(', ') + '\n' +
                'moves: ' + moves.join(', ') + '\n' +
                'removals: ' + removals.join(', ') + '\n' +
                'identityChanges: ' + identityChanges.join(', ') + '\n';
        };
        return DefaultIterableDiffer;
    }());
    /**
     * @stable
     */
    var CollectionChangeRecord = (function () {
        function CollectionChangeRecord(item, trackById) {
            this.item = item;
            this.trackById = trackById;
            this.currentIndex = null;
            this.previousIndex = null;
            /** @internal */
            this._nextPrevious = null;
            /** @internal */
            this._prev = null;
            /** @internal */
            this._next = null;
            /** @internal */
            this._prevDup = null;
            /** @internal */
            this._nextDup = null;
            /** @internal */
            this._prevRemoved = null;
            /** @internal */
            this._nextRemoved = null;
            /** @internal */
            this._nextAdded = null;
            /** @internal */
            this._nextMoved = null;
            /** @internal */
            this._nextIdentityChange = null;
        }
        CollectionChangeRecord.prototype.toString = function () {
            return this.previousIndex === this.currentIndex ? stringify(this.item) :
                stringify(this.item) + '[' +
                    stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
        };
        return CollectionChangeRecord;
    }());
    // A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item
    var _DuplicateItemRecordList = (function () {
        function _DuplicateItemRecordList() {
            /** @internal */
            this._head = null;
            /** @internal */
            this._tail = null;
        }
        /**
         * Append the record to the list of duplicates.
         *
         * Note: by design all records in the list of duplicates hold the same value in record.item.
         */
        _DuplicateItemRecordList.prototype.add = function (record) {
            if (this._head === null) {
                this._head = this._tail = record;
                record._nextDup = null;
                record._prevDup = null;
            }
            else {
                // todo(vicb)
                // assert(record.item ==  _head.item ||
                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
                this._tail._nextDup = record;
                record._prevDup = this._tail;
                record._nextDup = null;
                this._tail = record;
            }
        };
        // Returns a CollectionChangeRecord having CollectionChangeRecord.trackById == trackById and
        // CollectionChangeRecord.currentIndex >= afterIndex
        _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
            var record;
            for (record = this._head; record !== null; record = record._nextDup) {
                if ((afterIndex === null || afterIndex < record.currentIndex) &&
                    looseIdentical(record.trackById, trackById)) {
                    return record;
                }
            }
            return null;
        };
        /**
         * Remove one {@link CollectionChangeRecord} from the list of duplicates.
         *
         * Returns whether the list of duplicates is empty.
         */
        _DuplicateItemRecordList.prototype.remove = function (record) {
            // todo(vicb)
            // assert(() {
            //  // verify that the record being removed is in the list.
            //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
            //    if (identical(cursor, record)) return true;
            //  }
            //  return false;
            //});
            var prev = record._prevDup;
            var next = record._nextDup;
            if (prev === null) {
                this._head = next;
            }
            else {
                prev._nextDup = next;
            }
            if (next === null) {
                this._tail = prev;
            }
            else {
                next._prevDup = prev;
            }
            return this._head === null;
        };
        return _DuplicateItemRecordList;
    }());
    var _DuplicateMap = (function () {
        function _DuplicateMap() {
            this.map = new Map();
        }
        _DuplicateMap.prototype.put = function (record) {
            // todo(vicb) handle corner cases
            var key = getMapKey(record.trackById);
            var duplicates = this.map.get(key);
            if (!isPresent(duplicates)) {
                duplicates = new _DuplicateItemRecordList();
                this.map.set(key, duplicates);
            }
            duplicates.add(record);
        };
        /**
         * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
         * have already iterated over, we use the afterIndex to pretend it is not there.
         *
         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
         * have any more `a`s needs to return the last `a` not the first or second.
         */
        _DuplicateMap.prototype.get = function (trackById, afterIndex) {
            if (afterIndex === void 0) { afterIndex = null; }
            var key = getMapKey(trackById);
            var recordList = this.map.get(key);
            return recordList ? recordList.get(trackById, afterIndex) : null;
        };
        /**
         * Removes a {@link CollectionChangeRecord} from the list of duplicates.
         *
         * The list of duplicates also is removed from the map if it gets empty.
         */
        _DuplicateMap.prototype.remove = function (record) {
            var key = getMapKey(record.trackById);
            // todo(vicb)
            // assert(this.map.containsKey(key));
            var recordList = this.map.get(key);
            // Remove the list of duplicates when it gets empty
            if (recordList.remove(record)) {
                this.map.delete(key);
            }
            return record;
        };
        Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
            get: function () { return this.map.size === 0; },
            enumerable: true,
            configurable: true
        });
        _DuplicateMap.prototype.clear = function () { this.map.clear(); };
        _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };
        return _DuplicateMap;
    }());
    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
        var previousIndex = item.previousIndex;
        if (previousIndex === null)
            return previousIndex;
        var moveOffset = 0;
        if (moveOffsets && previousIndex < moveOffsets.length) {
            moveOffset = moveOffsets[previousIndex];
        }
        return previousIndex + addRemoveOffset + moveOffset;
    }

    var DefaultKeyValueDifferFactory = (function () {
        function DefaultKeyValueDifferFactory() {
        }
        DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };
        DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
        return DefaultKeyValueDifferFactory;
    }());
    var DefaultKeyValueDiffer = (function () {
        function DefaultKeyValueDiffer() {
            this._records = new Map();
            this._mapHead = null;
            this._previousMapHead = null;
            this._changesHead = null;
            this._changesTail = null;
            this._additionsHead = null;
            this._additionsTail = null;
            this._removalsHead = null;
            this._removalsTail = null;
        }
        Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
            get: function () {
                return this._additionsHead !== null || this._changesHead !== null ||
                    this._removalsHead !== null;
            },
            enumerable: true,
            configurable: true
        });
        DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
            var record;
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
            var record;
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
            var record;
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
            var record;
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                fn(record);
            }
        };
        DefaultKeyValueDiffer.prototype.diff = function (map) {
            if (!map) {
                map = new Map();
            }
            else if (!(map instanceof Map || isJsObject(map))) {
                throw new Error("Error trying to diff '" + map + "'");
            }
            return this.check(map) ? this : null;
        };
        DefaultKeyValueDiffer.prototype.onDestroy = function () { };
        DefaultKeyValueDiffer.prototype.check = function (map) {
            var _this = this;
            this._reset();
            var records = this._records;
            var oldSeqRecord = this._mapHead;
            var lastOldSeqRecord = null;
            var lastNewSeqRecord = null;
            var seqChanged = false;
            this._forEach(map, function (value, key) {
                var newSeqRecord;
                if (oldSeqRecord && key === oldSeqRecord.key) {
                    newSeqRecord = oldSeqRecord;
                    _this._maybeAddToChanges(newSeqRecord, value);
                }
                else {
                    seqChanged = true;
                    if (oldSeqRecord !== null) {
                        _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
                        _this._addToRemovals(oldSeqRecord);
                    }
                    if (records.has(key)) {
                        newSeqRecord = records.get(key);
                        _this._maybeAddToChanges(newSeqRecord, value);
                    }
                    else {
                        newSeqRecord = new KeyValueChangeRecord(key);
                        records.set(key, newSeqRecord);
                        newSeqRecord.currentValue = value;
                        _this._addToAdditions(newSeqRecord);
                    }
                }
                if (seqChanged) {
                    if (_this._isInRemovals(newSeqRecord)) {
                        _this._removeFromRemovals(newSeqRecord);
                    }
                    if (lastNewSeqRecord == null) {
                        _this._mapHead = newSeqRecord;
                    }
                    else {
                        lastNewSeqRecord._next = newSeqRecord;
                    }
                }
                lastOldSeqRecord = oldSeqRecord;
                lastNewSeqRecord = newSeqRecord;
                oldSeqRecord = oldSeqRecord && oldSeqRecord._next;
            });
            this._truncate(lastOldSeqRecord, oldSeqRecord);
            return this.isDirty;
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._reset = function () {
            if (this.isDirty) {
                var record = void 0;
                // Record the state of the mapping
                for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
                    record._nextPrevious = record._next;
                }
                for (record = this._changesHead; record !== null; record = record._nextChanged) {
                    record.previousValue = record.currentValue;
                }
                for (record = this._additionsHead; record != null; record = record._nextAdded) {
                    record.previousValue = record.currentValue;
                }
                this._changesHead = this._changesTail = null;
                this._additionsHead = this._additionsTail = null;
                this._removalsHead = this._removalsTail = null;
            }
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
            while (record !== null) {
                if (lastRecord === null) {
                    this._mapHead = null;
                }
                else {
                    lastRecord._next = null;
                }
                var nextRecord = record._next;
                this._addToRemovals(record);
                lastRecord = record;
                record = nextRecord;
            }
            for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
                rec.previousValue = rec.currentValue;
                rec.currentValue = null;
                this._records.delete(rec.key);
            }
        };
        DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {
            if (!looseIdentical(newValue, record.currentValue)) {
                record.previousValue = record.currentValue;
                record.currentValue = newValue;
                this._addToChanges(record);
            }
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
            return record === this._removalsHead || record._nextRemoved !== null ||
                record._prevRemoved !== null;
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
            if (this._removalsHead === null) {
                this._removalsHead = this._removalsTail = record;
            }
            else {
                this._removalsTail._nextRemoved = record;
                record._prevRemoved = this._removalsTail;
                this._removalsTail = record;
            }
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
            var next = record._next;
            if (prev === null) {
                this._mapHead = next;
            }
            else {
                prev._next = next;
            }
            record._next = null;
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
            var prev = record._prevRemoved;
            var next = record._nextRemoved;
            if (prev === null) {
                this._removalsHead = next;
            }
            else {
                prev._nextRemoved = next;
            }
            if (next === null) {
                this._removalsTail = prev;
            }
            else {
                next._prevRemoved = prev;
            }
            record._prevRemoved = record._nextRemoved = null;
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
            if (this._additionsHead === null) {
                this._additionsHead = this._additionsTail = record;
            }
            else {
                this._additionsTail._nextAdded = record;
                this._additionsTail = record;
            }
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
            if (this._changesHead === null) {
                this._changesHead = this._changesTail = record;
            }
            else {
                this._changesTail._nextChanged = record;
                this._changesTail = record;
            }
        };
        DefaultKeyValueDiffer.prototype.toString = function () {
            var items = [];
            var previous = [];
            var changes = [];
            var additions = [];
            var removals = [];
            var record;
            for (record = this._mapHead; record !== null; record = record._next) {
                items.push(stringify(record));
            }
            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
                previous.push(stringify(record));
            }
            for (record = this._changesHead; record !== null; record = record._nextChanged) {
                changes.push(stringify(record));
            }
            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                additions.push(stringify(record));
            }
            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
                removals.push(stringify(record));
            }
            return 'map: ' + items.join(', ') + '\n' +
                'previous: ' + previous.join(', ') + '\n' +
                'additions: ' + additions.join(', ') + '\n' +
                'changes: ' + changes.join(', ') + '\n' +
                'removals: ' + removals.join(', ') + '\n';
        };
        /** @internal */
        DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
            if (obj instanceof Map) {
                obj.forEach(fn);
            }
            else {
                Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });
            }
        };
        return DefaultKeyValueDiffer;
    }());
    /**
     * @stable
     */
    var KeyValueChangeRecord = (function () {
        function KeyValueChangeRecord(key) {
            this.key = key;
            this.previousValue = null;
            this.currentValue = null;
            /** @internal */
            this._nextPrevious = null;
            /** @internal */
            this._next = null;
            /** @internal */
            this._nextAdded = null;
            /** @internal */
            this._nextRemoved = null;
            /** @internal */
            this._prevRemoved = null;
            /** @internal */
            this._nextChanged = null;
        }
        KeyValueChangeRecord.prototype.toString = function () {
            return looseIdentical(this.previousValue, this.currentValue) ?
                stringify(this.key) :
                (stringify(this.key) + '[' + stringify(this.previousValue) + '->' +
                    stringify(this.currentValue) + ']');
        };
        return KeyValueChangeRecord;
    }());

    /**
     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
     * @stable
     */
    var IterableDiffers = (function () {
        function IterableDiffers(factories) {
            this.factories = factories;
        }
        IterableDiffers.create = function (factories, parent) {
            if (isPresent(parent)) {
                var copied = ListWrapper.clone(parent.factories);
                factories = factories.concat(copied);
                return new IterableDiffers(factories);
            }
            else {
                return new IterableDiffers(factories);
            }
        };
        /**
         * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
         * inherited {@link IterableDiffers} instance with the provided factories and return a new
         * {@link IterableDiffers} instance.
         *
         * The following example shows how to extend an existing list of factories,
               * which will only be applied to the injector for this component and its children.
               * This step is all that's required to make a new {@link IterableDiffer} available.
         *
         * ### Example
         *
         * ```
         * @Component({
         *   viewProviders: [
         *     IterableDiffers.extend([new ImmutableListDiffer()])
         *   ]
         * })
         * ```
         */
        IterableDiffers.extend = function (factories) {
            return {
                provide: IterableDiffers,
                useFactory: function (parent) {
                    if (!parent) {
                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
                        // to
                        // bootstrap(), which would override default pipes instead of extending them.
                        throw new Error('Cannot extend IterableDiffers without a parent injector');
                    }
                    return IterableDiffers.create(factories, parent);
                },
                // Dependency technically isn't optional, but we can provide a better error message this way.
                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
            };
        };
        IterableDiffers.prototype.find = function (iterable) {
            var factory = this.factories.find(function (f) { return f.supports(iterable); });
            if (isPresent(factory)) {
                return factory;
            }
            else {
                throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
            }
        };
        return IterableDiffers;
    }());

    /**
     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
     * @stable
     */
    var KeyValueDiffers = (function () {
        function KeyValueDiffers(factories) {
            this.factories = factories;
        }
        KeyValueDiffers.create = function (factories, parent) {
            if (isPresent(parent)) {
                var copied = ListWrapper.clone(parent.factories);
                factories = factories.concat(copied);
                return new KeyValueDiffers(factories);
            }
            else {
                return new KeyValueDiffers(factories);
            }
        };
        /**
         * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
         * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
         * {@link KeyValueDiffers} instance.
         *
         * The following example shows how to extend an existing list of factories,
               * which will only be applied to the injector for this component and its children.
               * This step is all that's required to make a new {@link KeyValueDiffer} available.
         *
         * ### Example
         *
         * ```
         * @Component({
         *   viewProviders: [
         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
         *   ]
         * })
         * ```
         */
        KeyValueDiffers.extend = function (factories) {
            return {
                provide: KeyValueDiffers,
                useFactory: function (parent) {
                    if (!parent) {
                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
                        // to
                        // bootstrap(), which would override default pipes instead of extending them.
                        throw new Error('Cannot extend KeyValueDiffers without a parent injector');
                    }
                    return KeyValueDiffers.create(factories, parent);
                },
                // Dependency technically isn't optional, but we can provide a better error message this way.
                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
            };
        };
        KeyValueDiffers.prototype.find = function (kv) {
            var factory = this.factories.find(function (f) { return f.supports(kv); });
            if (isPresent(factory)) {
                return factory;
            }
            else {
                throw new Error("Cannot find a differ supporting object '" + kv + "'");
            }
        };
        return KeyValueDiffers;
    }());

    var UNINITIALIZED = {
        toString: function () { return 'CD_INIT_VALUE'; }
    };
    function devModeEqual(a, b) {
        if (isListLikeIterable(a) && isListLikeIterable(b)) {
            return areIterablesEqual(a, b, devModeEqual);
        }
        else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {
            return true;
        }
        else {
            return looseIdentical(a, b);
        }
    }
    /**
     * Indicates that the result of a {@link Pipe} transformation has changed even though the
     * reference
     * has not changed.
     *
     * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
     *
     * Example:
     *
     * ```
     * if (this._latestValue === this._latestReturnedValue) {
     *    return this._latestReturnedValue;
     *  } else {
     *    this._latestReturnedValue = this._latestValue;
     *    return WrappedValue.wrap(this._latestValue); // this will force update
     *  }
     * ```
     * @stable
     */
    var WrappedValue = (function () {
        function WrappedValue(wrapped) {
            this.wrapped = wrapped;
        }
        WrappedValue.wrap = function (value) { return new WrappedValue(value); };
        return WrappedValue;
    }());
    /**
     * Helper class for unwrapping WrappedValue s
     */
    var ValueUnwrapper = (function () {
        function ValueUnwrapper() {
            this.hasWrappedValue = false;
        }
        ValueUnwrapper.prototype.unwrap = function (value) {
            if (value instanceof WrappedValue) {
                this.hasWrappedValue = true;
                return value.wrapped;
            }
            return value;
        };
        ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
        return ValueUnwrapper;
    }());
    /**
     * Represents a basic change from a previous to a new value.
     * @stable
     */
    var SimpleChange = (function () {
        function SimpleChange(previousValue, currentValue) {
            this.previousValue = previousValue;
            this.currentValue = currentValue;
        }
        /**
         * Check whether the new value is the first value assigned.
         */
        SimpleChange.prototype.isFirstChange = function () { return this.previousValue === UNINITIALIZED; };
        return SimpleChange;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @stable
     */
    var ChangeDetectorRef = (function () {
        function ChangeDetectorRef() {
        }
        return ChangeDetectorRef;
    }());

    /**
     * Structural diffing for `Object`s and `Map`s.
     */
    var keyValDiff = [new DefaultKeyValueDifferFactory()];
    /**
     * Structural diffing for `Iterable` types such as `Array`s.
     */
    var iterableDiff = [new DefaultIterableDifferFactory()];
    var defaultIterableDiffers = new IterableDiffers(iterableDiff);
    var defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);

    /**
     * @experimental
     */
    // TODO (matsko): add typing for the animation function
    var RenderComponentType = (function () {
        function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
            this.id = id;
            this.templateUrl = templateUrl;
            this.slotCount = slotCount;
            this.encapsulation = encapsulation;
            this.styles = styles;
            this.animations = animations;
        }
        return RenderComponentType;
    }());
    var RenderDebugInfo = (function () {
        function RenderDebugInfo() {
        }
        Object.defineProperty(RenderDebugInfo.prototype, "injector", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "component", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "references", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "context", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderDebugInfo.prototype, "source", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return RenderDebugInfo;
    }());
    /**
     * @experimental
     */
    var Renderer = (function () {
        function Renderer() {
        }
        return Renderer;
    }());
    /**
     * Injectable service that provides a low-level interface for modifying the UI.
     *
     * Use this service to bypass Angular's templating and make custom UI changes that can't be
     * expressed declaratively. For example if you need to set a property or an attribute whose name is
     * not statically known, use {@link #setElementProperty} or {@link #setElementAttribute}
     * respectively.
     *
     * If you are implementing a custom renderer, you must implement this interface.
     *
     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
     * @experimental
     */
    var RootRenderer = (function () {
        function RootRenderer() {
        }
        return RootRenderer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
     * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
     * handled.
     *
     * See DomSanitizer for more details on security in Angular applications.
     *
     * @stable
     */
    exports.SecurityContext;
    (function (SecurityContext) {
        SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
        SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
        SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
        SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
        SecurityContext[SecurityContext["URL"] = 4] = "URL";
        SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(exports.SecurityContext || (exports.SecurityContext = {}));
    /**
     * Sanitizer is used by the views to sanitize potentially dangerous values.
     *
     * @stable
     */
    var Sanitizer = (function () {
        function Sanitizer() {
        }
        return Sanitizer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around a native element inside of a View.
     *
     * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
     * element.
     *
     * @security Permitting direct access to the DOM can make your application more vulnerable to
     * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
     * [Security Guide](http://g.co/ng/security).
     *
     * @stable
     */
    // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
    // i.e. users have to ask for what they need. With that, we can build better analysis tools
    // and could do better codegen in the future.
    var ElementRef = (function () {
        function ElementRef(nativeElement) {
            this.nativeElement = nativeElement;
        }
        return ElementRef;
    }());

    var trace;
    var events;
    function detectWTF() {
        var wtf = global$1['wtf'];
        if (wtf) {
            trace = wtf['trace'];
            if (trace) {
                events = trace['events'];
                return true;
            }
        }
        return false;
    }
    function createScope(signature, flags) {
        if (flags === void 0) { flags = null; }
        return events.createScope(signature, flags);
    }
    function leave(scope, returnValue) {
        trace.leaveScope(scope, returnValue);
        return returnValue;
    }
    function startTimeRange(rangeType, action) {
        return trace.beginTimeRange(rangeType, action);
    }
    function endTimeRange(range) {
        trace.endTimeRange(range);
    }

    /**
     * True if WTF is enabled.
     */
    var wtfEnabled = detectWTF();
    function noopScope(arg0, arg1) {
        return null;
    }
    /**
     * Create trace scope.
     *
     * Scopes must be strictly nested and are analogous to stack frames, but
     * do not have to follow the stack frames. Instead it is recommended that they follow logical
     * nesting. You may want to use
     * [Event
     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
     * as they are defined in WTF.
     *
     * Used to mark scope entry. The return value is used to leave the scope.
     *
     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
     *
     *     someMethod() {
     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
     *        // DO SOME WORK HERE
     *        return wtfLeave(s, 123); // Return value 123
     *     }
     *
     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
     * negatively impact the performance of your application. For this reason we recommend that
     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
     * exception, will produce incorrect trace, but presence of exception signifies logic error which
     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
     * an exception is expected during normal execution while profiling.
     *
     * @experimental
     */
    var wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };
    /**
     * Used to mark end of Scope.
     *
     * - `scope` to end.
     * - `returnValue` (optional) to be passed to the WTF.
     *
     * Returns the `returnValue for easy chaining.
     * @experimental
     */
    var wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };
    /**
     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
     * enabled.
     *
     *     someMethod() {
     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
     *        var future = new Future.delay(5).then((_) {
     *          wtfEndTimeRange(s);
     *        });
     *     }
     * @experimental
     */
    var wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };
    /**
     * Ends a async time range operation.
     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
     * enabled.
     * @experimental
     */
    var wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };

    /**
     * Represents a container where one or more Views can be attached.
     *
     * The container can contain two kinds of Views. Host Views, created by instantiating a
     * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
     * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
     *
     * The location of the View Container within the containing View is specified by the Anchor
     * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
     * have a single View Container.
     *
     * Root elements of Views attached to this container become siblings of the Anchor Element in
     * the Rendered View.
     *
     * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
     * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
     * @stable
     */
    var ViewContainerRef = (function () {
        function ViewContainerRef() {
        }
        Object.defineProperty(ViewContainerRef.prototype, "element", {
            /**
             * Anchor element that specifies the location of this container in the containing View.
             * <!-- TODO: rename to anchorElement -->
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef.prototype, "injector", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef.prototype, "length", {
            /**
             * Returns the number of Views currently attached to this container.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        return ViewContainerRef;
    }());
    var ViewContainerRef_ = (function () {
        function ViewContainerRef_(_element) {
            this._element = _element;
            /** @internal */
            this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');
            /** @internal */
            this._insertScope = wtfCreateScope('ViewContainerRef#insert()');
            /** @internal */
            this._removeScope = wtfCreateScope('ViewContainerRef#remove()');
            /** @internal */
            this._detachScope = wtfCreateScope('ViewContainerRef#detach()');
        }
        ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };
        Object.defineProperty(ViewContainerRef_.prototype, "length", {
            get: function () {
                var views = this._element.nestedViews;
                return isPresent(views) ? views.length : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef_.prototype, "element", {
            get: function () { return this._element.elementRef; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef_.prototype, "injector", {
            get: function () { return this._element.injector; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
            get: function () { return this._element.parentInjector; },
            enumerable: true,
            configurable: true
        });
        // TODO(rado): profile and decide whether bounds checks should be added
        // to the methods below.
        ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
            if (context === void 0) { context = null; }
            if (index === void 0) { index = -1; }
            var viewRef = templateRef.createEmbeddedView(context);
            this.insert(viewRef, index);
            return viewRef;
        };
        ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {
            if (index === void 0) { index = -1; }
            if (injector === void 0) { injector = null; }
            if (projectableNodes === void 0) { projectableNodes = null; }
            var s = this._createComponentInContainerScope();
            var contextInjector = isPresent(injector) ? injector : this._element.parentInjector;
            var componentRef = componentFactory.create(contextInjector, projectableNodes);
            this.insert(componentRef.hostView, index);
            return wtfLeave(s, componentRef);
        };
        // TODO(i): refactor insert+remove into move
        ViewContainerRef_.prototype.insert = function (viewRef, index) {
            if (index === void 0) { index = -1; }
            var s = this._insertScope();
            if (index == -1)
                index = this.length;
            var viewRef_ = viewRef;
            this._element.attachView(viewRef_.internalView, index);
            return wtfLeave(s, viewRef_);
        };
        ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {
            var s = this._insertScope();
            if (currentIndex == -1)
                return;
            var viewRef_ = viewRef;
            this._element.moveView(viewRef_.internalView, currentIndex);
            return wtfLeave(s, viewRef_);
        };
        ViewContainerRef_.prototype.indexOf = function (viewRef) {
            return ListWrapper.indexOf(this._element.nestedViews, viewRef.internalView);
        };
        // TODO(i): rename to destroy
        ViewContainerRef_.prototype.remove = function (index) {
            if (index === void 0) { index = -1; }
            var s = this._removeScope();
            if (index == -1)
                index = this.length - 1;
            var view = this._element.detachView(index);
            view.destroy();
            // view is intentionally not returned to the client.
            wtfLeave(s);
        };
        // TODO(i): refactor insert+remove into move
        ViewContainerRef_.prototype.detach = function (index) {
            if (index === void 0) { index = -1; }
            var s = this._detachScope();
            if (index == -1)
                index = this.length - 1;
            var view = this._element.detachView(index);
            return wtfLeave(s, view.ref);
        };
        ViewContainerRef_.prototype.clear = function () {
            for (var i = this.length - 1; i >= 0; i--) {
                this.remove(i);
            }
        };
        return ViewContainerRef_;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var ViewType;
    (function (ViewType) {
        // A view that contains the host element with bound component directive.
        // Contains a COMPONENT view
        ViewType[ViewType["HOST"] = 0] = "HOST";
        // The view of the component
        // Can contain 0 to n EMBEDDED views
        ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
        // A view that is embedded into another View via a <template> element
        // inside of a COMPONENT view
        ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
    })(ViewType || (ViewType = {}));

    /**
     * An AppElement is created for elements that have a ViewContainerRef,
     * a nested component or a <template> element to keep data around
     * that is needed for later instantiations.
     */
    var AppElement = (function () {
        function AppElement(index, parentIndex, parentView, nativeElement) {
            this.index = index;
            this.parentIndex = parentIndex;
            this.parentView = parentView;
            this.nativeElement = nativeElement;
            this.nestedViews = null;
            this.componentView = null;
        }
        Object.defineProperty(AppElement.prototype, "elementRef", {
            get: function () { return new ElementRef(this.nativeElement); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppElement.prototype, "vcRef", {
            get: function () { return new ViewContainerRef_(this); },
            enumerable: true,
            configurable: true
        });
        AppElement.prototype.initComponent = function (component, componentConstructorViewQueries, view) {
            this.component = component;
            this.componentConstructorViewQueries = componentConstructorViewQueries;
            this.componentView = view;
        };
        Object.defineProperty(AppElement.prototype, "parentInjector", {
            get: function () { return this.parentView.injector(this.parentIndex); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppElement.prototype, "injector", {
            get: function () { return this.parentView.injector(this.index); },
            enumerable: true,
            configurable: true
        });
        AppElement.prototype.mapNestedViews = function (nestedViewClass, callback) {
            var result = [];
            if (isPresent(this.nestedViews)) {
                this.nestedViews.forEach(function (nestedView) {
                    if (nestedView.clazz === nestedViewClass) {
                        result.push(callback(nestedView));
                    }
                });
            }
            return result;
        };
        AppElement.prototype.moveView = function (view, currentIndex) {
            var previousIndex = this.nestedViews.indexOf(view);
            if (view.type === ViewType.COMPONENT) {
                throw new Error("Component views can't be moved!");
            }
            var nestedViews = this.nestedViews;
            if (nestedViews == null) {
                nestedViews = [];
                this.nestedViews = nestedViews;
            }
            ListWrapper.removeAt(nestedViews, previousIndex);
            ListWrapper.insert(nestedViews, currentIndex, view);
            var refRenderNode;
            if (currentIndex > 0) {
                var prevView = nestedViews[currentIndex - 1];
                refRenderNode = prevView.lastRootNode;
            }
            else {
                refRenderNode = this.nativeElement;
            }
            if (isPresent(refRenderNode)) {
                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
            }
            view.markContentChildAsMoved(this);
        };
        AppElement.prototype.attachView = function (view, viewIndex) {
            if (view.type === ViewType.COMPONENT) {
                throw new Error("Component views can't be moved!");
            }
            var nestedViews = this.nestedViews;
            if (nestedViews == null) {
                nestedViews = [];
                this.nestedViews = nestedViews;
            }
            ListWrapper.insert(nestedViews, viewIndex, view);
            var refRenderNode;
            if (viewIndex > 0) {
                var prevView = nestedViews[viewIndex - 1];
                refRenderNode = prevView.lastRootNode;
            }
            else {
                refRenderNode = this.nativeElement;
            }
            if (isPresent(refRenderNode)) {
                view.renderer.attachViewAfter(refRenderNode, view.flatRootNodes);
            }
            view.addToContentChildren(this);
        };
        AppElement.prototype.detachView = function (viewIndex) {
            var view = ListWrapper.removeAt(this.nestedViews, viewIndex);
            if (view.type === ViewType.COMPONENT) {
                throw new Error("Component views can't be moved!");
            }
            view.detach();
            view.removeFromContentChildren(this);
            return view;
        };
        return AppElement;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$6 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An error thrown if application changes model breaking the top-down data flow.
     *
     * This exception is only thrown in dev mode.
     *
     * <!-- TODO: Add a link once the dev mode option is configurable -->
     *
     * ### Example
     *
     * ```typescript
     * @Component({
     *   selector: 'parent',
     *   template: '<child [prop]="parentProp"></child>',
     * })
     * class Parent {
     *   parentProp = 'init';
     * }
     *
     * @Directive({selector: 'child', inputs: ['prop']})
     * class Child {
     *   constructor(public parent: Parent) {}
     *
     *   set prop(v) {
     *     // this updates the parent property, which is disallowed during change detection
     *     // this will result in ExpressionChangedAfterItHasBeenCheckedError
     *     this.parent.parentProp = 'updated';
     *   }
     * }
     * ```
     * @stable
     */
    var ExpressionChangedAfterItHasBeenCheckedError = (function (_super) {
        __extends$6(ExpressionChangedAfterItHasBeenCheckedError, _super);
        function ExpressionChangedAfterItHasBeenCheckedError(oldValue, currValue) {
            var msg = "Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
            if (oldValue === UNINITIALIZED) {
                msg +=
                    " It seems like the view has been created after its parent and its children have been dirty checked." +
                        " Has it been created in a change detection hook ?";
            }
            _super.call(this, msg);
        }
        return ExpressionChangedAfterItHasBeenCheckedError;
    }(BaseError));
    /**
     * Thrown when an exception was raised during view creation, change detection or destruction.
     *
     * This error wraps the original exception to attach additional contextual information that can
     * be useful for debugging.
     * @stable
     */
    var ViewWrappedError = (function (_super) {
        __extends$6(ViewWrappedError, _super);
        function ViewWrappedError(originalError, context) {
            _super.call(this, "Error in " + context.source, originalError);
            this.context = context;
        }
        return ViewWrappedError;
    }(WrappedError));
    /**
     * Thrown when a destroyed view is used.
     *
     * This error indicates a bug in the framework.
     *
     * This is an internal Angular error.
     * @stable
     */
    var ViewDestroyedError = (function (_super) {
        __extends$6(ViewDestroyedError, _super);
        function ViewDestroyedError(details) {
            _super.call(this, "Attempt to use a destroyed view: " + details);
        }
        return ViewDestroyedError;
    }(BaseError));

    var ViewUtils = (function () {
        function ViewUtils(_renderer, _appId, sanitizer) {
            this._renderer = _renderer;
            this._appId = _appId;
            this._nextCompTypeId = 0;
            this.sanitizer = sanitizer;
        }
        /**
         * Used by the generated code
         */
        // TODO (matsko): add typing for the animation function
        ViewUtils.prototype.createRenderComponentType = function (templateUrl, slotCount, encapsulation, styles, animations) {
            return new RenderComponentType(this._appId + "-" + this._nextCompTypeId++, templateUrl, slotCount, encapsulation, styles, animations);
        };
        /** @internal */
        ViewUtils.prototype.renderComponent = function (renderComponentType) {
            return this._renderer.renderComponent(renderComponentType);
        };
        ViewUtils.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        ViewUtils.ctorParameters = [
            { type: RootRenderer, },
            { type: undefined, decorators: [{ type: Inject, args: [APP_ID,] },] },
            { type: Sanitizer, },
        ];
        return ViewUtils;
    }());
    function flattenNestedViewRenderNodes(nodes) {
        return _flattenNestedViewRenderNodes(nodes, []);
    }
    function _flattenNestedViewRenderNodes(nodes, renderNodes) {
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (node instanceof AppElement) {
                var appEl = node;
                renderNodes.push(appEl.nativeElement);
                if (isPresent(appEl.nestedViews)) {
                    for (var k = 0; k < appEl.nestedViews.length; k++) {
                        _flattenNestedViewRenderNodes(appEl.nestedViews[k].rootNodesOrAppElements, renderNodes);
                    }
                }
            }
            else {
                renderNodes.push(node);
            }
        }
        return renderNodes;
    }
    var EMPTY_ARR = [];
    function ensureSlotCount(projectableNodes, expectedSlotCount) {
        var res;
        if (!projectableNodes) {
            res = EMPTY_ARR;
        }
        else if (projectableNodes.length < expectedSlotCount) {
            var givenSlotCount = projectableNodes.length;
            res = new Array(expectedSlotCount);
            for (var i = 0; i < expectedSlotCount; i++) {
                res[i] = (i < givenSlotCount) ? projectableNodes[i] : EMPTY_ARR;
            }
        }
        else {
            res = projectableNodes;
        }
        return res;
    }
    var MAX_INTERPOLATION_VALUES = 9;
    function interpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
        switch (valueCount) {
            case 1:
                return c0 + _toStringWithNull(a1) + c1;
            case 2:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
            case 3:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3;
            case 4:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4;
            case 5:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
            case 6:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
            case 7:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                    c6 + _toStringWithNull(a7) + c7;
            case 8:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
            case 9:
                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
            default:
                throw new Error("Does not support more than 9 expressions");
        }
    }
    function _toStringWithNull(v) {
        return v != null ? v.toString() : '';
    }
    function checkBinding(throwOnChange, oldValue, newValue) {
        if (throwOnChange) {
            if (!devModeEqual(oldValue, newValue)) {
                throw new ExpressionChangedAfterItHasBeenCheckedError(oldValue, newValue);
            }
            return false;
        }
        else {
            return !looseIdentical(oldValue, newValue);
        }
    }
    function castByValue(input, value) {
        return input;
    }
    var EMPTY_ARRAY = [];
    var EMPTY_MAP = {};
    function pureProxy1(fn) {
        var result;
        var v0 = UNINITIALIZED;
        return function (p0) {
            if (!looseIdentical(v0, p0)) {
                v0 = p0;
                result = fn(p0);
            }
            return result;
        };
    }
    function pureProxy2(fn) {
        var result;
        var v0 = UNINITIALIZED;
        var v1 = UNINITIALIZED;
        return function (p0, p1) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {
                v0 = p0;
                v1 = p1;
                result = fn(p0, p1);
            }
            return result;
        };
    }
    function pureProxy3(fn) {
        var result;
        var v0 = UNINITIALIZED;
        var v1 = UNINITIALIZED;
        var v2 = UNINITIALIZED;
        return function (p0, p1, p2) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                result = fn(p0, p1, p2);
            }
            return result;
        };
    }
    function pureProxy4(fn) {
        var result;
        var v0, v1, v2, v3;
        v0 = v1 = v2 = v3 = UNINITIALIZED;
        return function (p0, p1, p2, p3) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                result = fn(p0, p1, p2, p3);
            }
            return result;
        };
    }
    function pureProxy5(fn) {
        var result;
        var v0, v1, v2, v3, v4;
        v0 = v1 = v2 = v3 = v4 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                result = fn(p0, p1, p2, p3, p4);
            }
            return result;
        };
    }
    function pureProxy6(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5;
        v0 = v1 = v2 = v3 = v4 = v5 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                result = fn(p0, p1, p2, p3, p4, p5);
            }
            return result;
        };
    }
    function pureProxy7(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5, v6;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                result = fn(p0, p1, p2, p3, p4, p5, p6);
            }
            return result;
        };
    }
    function pureProxy8(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5, v6, v7;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6, p7) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                v7 = p7;
                result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
            }
            return result;
        };
    }
    function pureProxy9(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5, v6, v7, v8;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                v7 = p7;
                v8 = p8;
                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
            }
            return result;
        };
    }
    function pureProxy10(fn) {
        var result;
        var v0, v1, v2, v3, v4, v5, v6, v7, v8, v9;
        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = UNINITIALIZED;
        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) ||
                !looseIdentical(v9, p9)) {
                v0 = p0;
                v1 = p1;
                v2 = p2;
                v3 = p3;
                v4 = p4;
                v5 = p5;
                v6 = p6;
                v7 = p7;
                v8 = p8;
                v9 = p9;
                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
            }
            return result;
        };
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$5 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Represents an instance of a Component created via a {@link ComponentFactory}.
     *
     * `ComponentRef` provides access to the Component Instance as well other objects related to this
     * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
     * method.
     * @stable
     */
    var ComponentRef = (function () {
        function ComponentRef() {
        }
        Object.defineProperty(ComponentRef.prototype, "location", {
            /**
             * Location of the Host Element of this Component Instance.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef.prototype, "injector", {
            /**
             * The injector on which the component instance exists.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef.prototype, "instance", {
            /**
             * The instance of the Component.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef.prototype, "hostView", {
            /**
             * The {@link ViewRef} of the Host View of this Component instance.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
            /**
             * The {@link ChangeDetectorRef} of the Component instance.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef.prototype, "componentType", {
            /**
             * The component type.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return ComponentRef;
    }());
    var ComponentRef_ = (function (_super) {
        __extends$5(ComponentRef_, _super);
        function ComponentRef_(_hostElement, _componentType) {
            _super.call(this);
            this._hostElement = _hostElement;
            this._componentType = _componentType;
        }
        Object.defineProperty(ComponentRef_.prototype, "location", {
            get: function () { return this._hostElement.elementRef; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef_.prototype, "injector", {
            get: function () { return this._hostElement.injector; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ComponentRef_.prototype, "instance", {
            get: function () { return this._hostElement.component; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef_.prototype, "hostView", {
            get: function () { return this._hostElement.parentView.ref; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
            get: function () { return this._hostElement.parentView.ref; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ComponentRef_.prototype, "componentType", {
            get: function () { return this._componentType; },
            enumerable: true,
            configurable: true
        });
        ComponentRef_.prototype.destroy = function () { this._hostElement.parentView.destroy(); };
        ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };
        return ComponentRef_;
    }(ComponentRef));
    /**
     * @experimental
     */
    var EMPTY_CONTEXT = new Object();
    /**
     * @stable
     */
    var ComponentFactory = (function () {
        function ComponentFactory(selector, _viewFactory, _componentType) {
            this.selector = selector;
            this._viewFactory = _viewFactory;
            this._componentType = _componentType;
        }
        Object.defineProperty(ComponentFactory.prototype, "componentType", {
            get: function () { return this._componentType; },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates a new component.
         */
        ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {
            if (projectableNodes === void 0) { projectableNodes = null; }
            if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }
            var vu = injector.get(ViewUtils);
            if (!projectableNodes) {
                projectableNodes = [];
            }
            // Note: Host views don't need a declarationAppElement!
            var hostView = this._viewFactory(vu, injector, null);
            var hostElement = hostView.create(EMPTY_CONTEXT, projectableNodes, rootSelectorOrNode);
            return new ComponentRef_(hostElement, this._componentType);
        };
        return ComponentFactory;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$7 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @stable
     */
    var NoComponentFactoryError = (function (_super) {
        __extends$7(NoComponentFactoryError, _super);
        function NoComponentFactoryError(component) {
            _super.call(this, "No component factory found for " + stringify(component));
            this.component = component;
        }
        return NoComponentFactoryError;
    }(BaseError));
    var _NullComponentFactoryResolver = (function () {
        function _NullComponentFactoryResolver() {
        }
        _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
            throw new NoComponentFactoryError(component);
        };
        return _NullComponentFactoryResolver;
    }());
    /**
     * @stable
     */
    var ComponentFactoryResolver = (function () {
        function ComponentFactoryResolver() {
        }
        ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
        return ComponentFactoryResolver;
    }());
    var CodegenComponentFactoryResolver = (function () {
        function CodegenComponentFactoryResolver(factories, _parent) {
            this._parent = _parent;
            this._factories = new Map();
            for (var i = 0; i < factories.length; i++) {
                var factory = factories[i];
                this._factories.set(factory.componentType, factory);
            }
        }
        CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
            var result = this._factories.get(component);
            if (!result) {
                result = this._parent.resolveComponentFactory(component);
            }
            return result;
        };
        return CodegenComponentFactoryResolver;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$8 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Use by directives and components to emit custom Events.
     *
     * ### Examples
     *
     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
     * title gets clicked:
     *
     * ```
     * @Component({
     *   selector: 'zippy',
     *   template: `
     *   <div class="zippy">
     *     <div (click)="toggle()">Toggle</div>
     *     <div [hidden]="!visible">
     *       <ng-content></ng-content>
     *     </div>
     *  </div>`})
     * export class Zippy {
     *   visible: boolean = true;
     *   @Output() open: EventEmitter<any> = new EventEmitter();
     *   @Output() close: EventEmitter<any> = new EventEmitter();
     *
     *   toggle() {
     *     this.visible = !this.visible;
     *     if (this.visible) {
     *       this.open.emit(null);
     *     } else {
     *       this.close.emit(null);
     *     }
     *   }
     * }
     * ```
     *
     * The events payload can be accessed by the parameter `$event` on the components output event
     * handler:
     *
     * ```
     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
     * ```
     *
     * Uses Rx.Observable but provides an adapter to make it work as specified here:
     * https://github.com/jhusain/observable-spec
     *
     * Once a reference implementation of the spec is available, switch to it.
     * @stable
     */
    var EventEmitter = (function (_super) {
        __extends$8(EventEmitter, _super);
        /**
         * Creates an instance of [EventEmitter], which depending on [isAsync],
         * delivers events synchronously or asynchronously.
         */
        function EventEmitter(isAsync) {
            if (isAsync === void 0) { isAsync = false; }
            _super.call(this);
            this.__isAsync = isAsync;
        }
        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
            var schedulerFn;
            var errorFn = function (err) { return null; };
            var completeFn = function () { return null; };
            if (generatorOrNext && typeof generatorOrNext === 'object') {
                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
                    setTimeout(function () { return generatorOrNext.next(value); });
                } : function (value /** TODO #9100 */) { generatorOrNext.next(value); };
                if (generatorOrNext.error) {
                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
                        function (err) { generatorOrNext.error(err); };
                }
                if (generatorOrNext.complete) {
                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
                        function () { generatorOrNext.complete(); };
                }
            }
            else {
                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {
                    setTimeout(function () { return generatorOrNext(value); });
                } : function (value /** TODO #9100 */) { generatorOrNext(value); };
                if (error) {
                    errorFn =
                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
                }
                if (complete) {
                    completeFn =
                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
                }
            }
            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
        };
        return EventEmitter;
    }(rxjs_Subject.Subject));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var NgZoneImpl = (function () {
        function NgZoneImpl(_a) {
            var _this = this;
            var trace = _a.trace, onEnter = _a.onEnter, onLeave = _a.onLeave, setMicrotask = _a.setMicrotask, setMacrotask = _a.setMacrotask, onError = _a.onError;
            this.onEnter = onEnter;
            this.onLeave = onLeave;
            this.setMicrotask = setMicrotask;
            this.setMacrotask = setMacrotask;
            this.onError = onError;
            if (typeof Zone == 'undefined') {
                throw new Error('Angular requires Zone.js prolyfill.');
            }
            Zone.assertZonePatched();
            this.outer = this.inner = Zone.current;
            if (Zone['wtfZoneSpec']) {
                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
            }
            if (trace && Zone['longStackTraceZoneSpec']) {
                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
            }
            this.inner = this.inner.fork({
                name: 'angular',
                properties: { 'isAngularZone': true },
                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
                    try {
                        _this.onEnter();
                        return delegate.invokeTask(target, task, applyThis, applyArgs);
                    }
                    finally {
                        _this.onLeave();
                    }
                },
                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
                    try {
                        _this.onEnter();
                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
                    }
                    finally {
                        _this.onLeave();
                    }
                },
                onHasTask: function (delegate, current, target, hasTaskState) {
                    delegate.hasTask(target, hasTaskState);
                    if (current === target) {
                        // We are only interested in hasTask events which originate from our zone
                        // (A child hasTask event is not interesting to us)
                        if (hasTaskState.change == 'microTask') {
                            _this.setMicrotask(hasTaskState.microTask);
                        }
                        else if (hasTaskState.change == 'macroTask') {
                            _this.setMacrotask(hasTaskState.macroTask);
                        }
                    }
                },
                onHandleError: function (delegate, current, target, error) {
                    delegate.handleError(target, error);
                    _this.onError(error);
                    return false;
                }
            });
        }
        NgZoneImpl.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
        NgZoneImpl.prototype.runInner = function (fn) { return this.inner.run(fn); };
        ;
        NgZoneImpl.prototype.runInnerGuarded = function (fn) { return this.inner.runGuarded(fn); };
        ;
        NgZoneImpl.prototype.runOuter = function (fn) { return this.outer.run(fn); };
        ;
        return NgZoneImpl;
    }());

    /**
     * An injectable service for executing work inside or outside of the Angular zone.
     *
     * The most common use of this service is to optimize performance when starting a work consisting of
     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
     * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
     * can reenter the Angular zone via {@link #run}.
     *
     * <!-- TODO: add/fix links to:
     *   - docs explaining zones and the use of zones in Angular and change-detection
     *   - link to runOutsideAngular/run (throughout this file!)
     *   -->
     *
     * ### Example ([live demo](http://plnkr.co/edit/lY9m8HLy7z06vDoUaSN2?p=preview))
     * ```
     * import {Component, View, NgZone} from '@angular/core';
     * import {NgIf} from '@angular/common';
     *
     * @Component({
     *   selector: 'ng-zone-demo'.
     *   template: `
     *     <h2>Demo: NgZone</h2>
     *
     *     <p>Progress: {{progress}}%</p>
     *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
     *
     *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
     *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
     *   `,
     * })
     * export class NgZoneDemo {
     *   progress: number = 0;
     *   label: string;
     *
     *   constructor(private _ngZone: NgZone) {}
     *
     *   // Loop inside the Angular zone
     *   // so the UI DOES refresh after each setTimeout cycle
     *   processWithinAngularZone() {
     *     this.label = 'inside';
     *     this.progress = 0;
     *     this._increaseProgress(() => console.log('Inside Done!'));
     *   }
     *
     *   // Loop outside of the Angular zone
     *   // so the UI DOES NOT refresh after each setTimeout cycle
     *   processOutsideOfAngularZone() {
     *     this.label = 'outside';
     *     this.progress = 0;
     *     this._ngZone.runOutsideAngular(() => {
     *       this._increaseProgress(() => {
     *       // reenter the Angular zone and display done
     *       this._ngZone.run(() => {console.log('Outside Done!') });
     *     }}));
     *   }
     *
     *
     *   _increaseProgress(doneCallback: () => void) {
     *     this.progress += 1;
     *     console.log(`Current progress: ${this.progress}%`);
     *
     *     if (this.progress < 100) {
     *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
     *     } else {
     *       doneCallback();
     *     }
     *   }
     * }
     * ```
     * @experimental
     */
    var NgZone = (function () {
        function NgZone(_a) {
            var _this = this;
            var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
            this._hasPendingMicrotasks = false;
            this._hasPendingMacrotasks = false;
            /** @internal */
            this._isStable = true;
            /** @internal */
            this._nesting = 0;
            /** @internal */
            this._onUnstable = new EventEmitter(false);
            /** @internal */
            this._onMicrotaskEmpty = new EventEmitter(false);
            /** @internal */
            this._onStable = new EventEmitter(false);
            /** @internal */
            this._onErrorEvents = new EventEmitter(false);
            this._zoneImpl = new NgZoneImpl({
                trace: enableLongStackTrace,
                onEnter: function () {
                    // console.log('ZONE.enter', this._nesting, this._isStable);
                    _this._nesting++;
                    if (_this._isStable) {
                        _this._isStable = false;
                        _this._onUnstable.emit(null);
                    }
                },
                onLeave: function () {
                    _this._nesting--;
                    // console.log('ZONE.leave', this._nesting, this._isStable);
                    _this._checkStable();
                },
                setMicrotask: function (hasMicrotasks) {
                    _this._hasPendingMicrotasks = hasMicrotasks;
                    _this._checkStable();
                },
                setMacrotask: function (hasMacrotasks) { _this._hasPendingMacrotasks = hasMacrotasks; },
                onError: function (error) { return _this._onErrorEvents.emit(error); }
            });
        }
        NgZone.isInAngularZone = function () { return NgZoneImpl.isInAngularZone(); };
        NgZone.assertInAngularZone = function () {
            if (!NgZoneImpl.isInAngularZone()) {
                throw new Error('Expected to be in Angular Zone, but it is not!');
            }
        };
        NgZone.assertNotInAngularZone = function () {
            if (NgZoneImpl.isInAngularZone()) {
                throw new Error('Expected to not be in Angular Zone, but it is!');
            }
        };
        NgZone.prototype._checkStable = function () {
            var _this = this;
            if (this._nesting == 0) {
                if (!this._hasPendingMicrotasks && !this._isStable) {
                    try {
                        // console.log('ZONE.microtaskEmpty');
                        this._nesting++;
                        this._onMicrotaskEmpty.emit(null);
                    }
                    finally {
                        this._nesting--;
                        if (!this._hasPendingMicrotasks) {
                            try {
                                // console.log('ZONE.stable', this._nesting, this._isStable);
                                this.runOutsideAngular(function () { return _this._onStable.emit(null); });
                            }
                            finally {
                                this._isStable = true;
                            }
                        }
                    }
                }
            }
        };
        ;
        Object.defineProperty(NgZone.prototype, "onUnstable", {
            /**
             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
             */
            get: function () { return this._onUnstable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
            /**
             * Notifies when there is no more microtasks enqueue in the current VM Turn.
             * This is a hint for Angular to do change detection, which may enqueue more microtasks.
             * For this reason this event can fire multiple times per VM Turn.
             */
            get: function () { return this._onMicrotaskEmpty; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "onStable", {
            /**
             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
             * implies we are about to relinquish VM turn.
             * This event gets called just once.
             */
            get: function () { return this._onStable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "onError", {
            /**
             * Notify that an error has been delivered.
             */
            get: function () { return this._onErrorEvents; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "isStable", {
            /**
             * Whether there are no outstanding microtasks or microtasks.
             */
            get: function () { return this._isStable; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
            /**
             * Whether there are any outstanding microtasks.
             */
            get: function () { return this._hasPendingMicrotasks; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
            /**
             * Whether there are any outstanding microtasks.
             */
            get: function () { return this._hasPendingMacrotasks; },
            enumerable: true,
            configurable: true
        });
        /**
         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
         * the function.
         *
         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * within the Angular zone.
         *
         * If a synchronous error happens it will be rethrown and not reported via `onError`.
         */
        NgZone.prototype.run = function (fn) { return this._zoneImpl.runInner(fn); };
        /**
         * Same as #run, except that synchronous errors are caught and forwarded
         * via `onError` and not rethrown.
         */
        NgZone.prototype.runGuarded = function (fn) { return this._zoneImpl.runInnerGuarded(fn); };
        /**
         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
         * the function.
         *
         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * outside of the Angular zone.
         *
         * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
         */
        NgZone.prototype.runOutsideAngular = function (fn) { return this._zoneImpl.runOuter(fn); };
        return NgZone;
    }());

    /**
     * The Testability service provides testing hooks that can be accessed from
     * the browser and by services such as Protractor. Each bootstrapped Angular
     * application on the page will have an instance of Testability.
     * @experimental
     */
    var Testability = (function () {
        function Testability(_ngZone) {
            this._ngZone = _ngZone;
            /** @internal */
            this._pendingCount = 0;
            /** @internal */
            this._isZoneStable = true;
            /**
             * Whether any work was done since the last 'whenStable' callback. This is
             * useful to detect if this could have potentially destabilized another
             * component while it is stabilizing.
             * @internal
             */
            this._didWork = false;
            /** @internal */
            this._callbacks = [];
            this._watchAngularEvents();
        }
        /** @internal */
        Testability.prototype._watchAngularEvents = function () {
            var _this = this;
            this._ngZone.onUnstable.subscribe({
                next: function () {
                    _this._didWork = true;
                    _this._isZoneStable = false;
                }
            });
            this._ngZone.runOutsideAngular(function () {
                _this._ngZone.onStable.subscribe({
                    next: function () {
                        NgZone.assertNotInAngularZone();
                        scheduleMicroTask(function () {
                            _this._isZoneStable = true;
                            _this._runCallbacksIfReady();
                        });
                    }
                });
            });
        };
        Testability.prototype.increasePendingRequestCount = function () {
            this._pendingCount += 1;
            this._didWork = true;
            return this._pendingCount;
        };
        Testability.prototype.decreasePendingRequestCount = function () {
            this._pendingCount -= 1;
            if (this._pendingCount < 0) {
                throw new Error('pending async requests below zero');
            }
            this._runCallbacksIfReady();
            return this._pendingCount;
        };
        Testability.prototype.isStable = function () {
            return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
        };
        /** @internal */
        Testability.prototype._runCallbacksIfReady = function () {
            var _this = this;
            if (this.isStable()) {
                // Schedules the call backs in a new frame so that it is always async.
                scheduleMicroTask(function () {
                    while (_this._callbacks.length !== 0) {
                        (_this._callbacks.pop())(_this._didWork);
                    }
                    _this._didWork = false;
                });
            }
            else {
                // Not Ready
                this._didWork = true;
            }
        };
        Testability.prototype.whenStable = function (callback) {
            this._callbacks.push(callback);
            this._runCallbacksIfReady();
        };
        Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
        /** @deprecated use findProviders */
        Testability.prototype.findBindings = function (using, provider, exactMatch) {
            // TODO(juliemr): implement.
            return [];
        };
        Testability.prototype.findProviders = function (using, provider, exactMatch) {
            // TODO(juliemr): implement.
            return [];
        };
        Testability.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        Testability.ctorParameters = [
            { type: NgZone, },
        ];
        return Testability;
    }());
    /**
     * A global registry of {@link Testability} instances for specific elements.
     * @experimental
     */
    var TestabilityRegistry = (function () {
        function TestabilityRegistry() {
            /** @internal */
            this._applications = new Map();
            _testabilityGetter.addToWindow(this);
        }
        TestabilityRegistry.prototype.registerApplication = function (token, testability) {
            this._applications.set(token, testability);
        };
        TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };
        TestabilityRegistry.prototype.getAllTestabilities = function () { return MapWrapper.values(this._applications); };
        TestabilityRegistry.prototype.getAllRootElements = function () { return MapWrapper.keys(this._applications); };
        TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
            if (findInAncestors === void 0) { findInAncestors = true; }
            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
        };
        TestabilityRegistry.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        TestabilityRegistry.ctorParameters = [];
        return TestabilityRegistry;
    }());
    var _NoopGetTestability = (function () {
        function _NoopGetTestability() {
        }
        _NoopGetTestability.prototype.addToWindow = function (registry) { };
        _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
            return null;
        };
        return _NoopGetTestability;
    }());
    /**
     * Set the {@link GetTestability} implementation used by the Angular testing framework.
     * @experimental
     */
    function setTestabilityGetter(getter) {
        _testabilityGetter = getter;
    }
    var _testabilityGetter = new _NoopGetTestability();

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$3 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _devMode = true;
    var _runModeLocked = false;
    var _platform;
    /**
     * Disable Angular's development mode, which turns off assertions and other
     * checks within the framework.
     *
     * One important assertion this disables verifies that a change detection pass
     * does not result in additional changes to any bindings (also known as
     * unidirectional data flow).
     *
     * @stable
     */
    function enableProdMode() {
        if (_runModeLocked) {
            throw new Error('Cannot enable prod mode after platform setup.');
        }
        _devMode = false;
    }
    /**
     * Returns whether Angular is in development mode. After called once,
     * the value is locked and won't change any more.
     *
     * By default, this is true, unless a user calls `enableProdMode` before calling this.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function isDevMode() {
        _runModeLocked = true;
        return _devMode;
    }
    /**
     * Creates a platform.
     * Platforms have to be eagerly created via this function.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function createPlatform(injector) {
        if (_platform && !_platform.destroyed) {
            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
        }
        _platform = injector.get(PlatformRef);
        var inits = injector.get(PLATFORM_INITIALIZER, null);
        if (inits)
            inits.forEach(function (init) { return init(); });
        return _platform;
    }
    /**
     * Creates a factory for a platform
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function createPlatformFactory(parentPlaformFactory, name, providers) {
        if (providers === void 0) { providers = []; }
        var marker = new OpaqueToken("Platform: " + name);
        return function (extraProviders) {
            if (extraProviders === void 0) { extraProviders = []; }
            if (!getPlatform()) {
                if (parentPlaformFactory) {
                    parentPlaformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
                }
                else {
                    createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));
                }
            }
            return assertPlatform(marker);
        };
    }
    /**
     * Checks that there currently is a platform
     * which contains the given token as a provider.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function assertPlatform(requiredToken) {
        var platform = getPlatform();
        if (!platform) {
            throw new Error('No platform exists!');
        }
        if (!platform.injector.get(requiredToken, null)) {
            throw new Error('A platform with a different configuration has been created. Please destroy it first.');
        }
        return platform;
    }
    /**
     * Destroy the existing platform.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function destroyPlatform() {
        if (_platform && !_platform.destroyed) {
            _platform.destroy();
        }
    }
    /**
     * Returns the current platform.
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    function getPlatform() {
        return _platform && !_platform.destroyed ? _platform : null;
    }
    /**
     * The Angular platform is the entry point for Angular on a web page. Each page
     * has exactly one platform, and services (such as reflection) which are common
     * to every Angular application running on the page are bound in its scope.
     *
     * A page's platform is initialized implicitly when {@link bootstrap}() is called, or
     * explicitly by calling {@link createPlatform}().
     *
     * @stable
     */
    var PlatformRef = (function () {
        function PlatformRef() {
        }
        /**
         * Creates an instance of an `@NgModule` for the given platform
         * for offline compilation.
         *
         * ## Simple Example
         *
         * ```typescript
         * my_module.ts:
         *
         * @NgModule({
         *   imports: [BrowserModule]
         * })
         * class MyModule {}
         *
         * main.ts:
         * import {MyModuleNgFactory} from './my_module.ngfactory';
         * import {platformBrowser} from '@angular/platform-browser';
         *
         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
         * ```
         *
         * @experimental APIs related to application bootstrap are currently under review.
         */
        PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) {
            throw unimplemented();
        };
        /**
         * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
         *
         * ## Simple Example
         *
         * ```typescript
         * @NgModule({
         *   imports: [BrowserModule]
         * })
         * class MyModule {}
         *
         * let moduleRef = platformBrowser().bootstrapModule(MyModule);
         * ```
         * @stable
         */
        PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {
            if (compilerOptions === void 0) { compilerOptions = []; }
            throw unimplemented();
        };
        Object.defineProperty(PlatformRef.prototype, "injector", {
            /**
             * Retrieve the platform {@link Injector}, which is the parent injector for
             * every Angular application on the page and provides singleton providers.
             */
            get: function () { throw unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(PlatformRef.prototype, "destroyed", {
            get: function () { throw unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return PlatformRef;
    }());
    function _callAndReportToErrorHandler(errorHandler, callback) {
        try {
            var result = callback();
            if (isPromise(result)) {
                return result.catch(function (e) {
                    errorHandler.handleError(e);
                    // rethrow as the exception handler might not do it
                    throw e;
                });
            }
            return result;
        }
        catch (e) {
            errorHandler.handleError(e);
            // rethrow as the exception handler might not do it
            throw e;
        }
    }
    var PlatformRef_ = (function (_super) {
        __extends$3(PlatformRef_, _super);
        function PlatformRef_(_injector) {
            _super.call(this);
            this._injector = _injector;
            this._modules = [];
            this._destroyListeners = [];
            this._destroyed = false;
        }
        PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
        Object.defineProperty(PlatformRef_.prototype, "injector", {
            get: function () { return this._injector; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PlatformRef_.prototype, "destroyed", {
            get: function () { return this._destroyed; },
            enumerable: true,
            configurable: true
        });
        PlatformRef_.prototype.destroy = function () {
            if (this._destroyed) {
                throw new Error('The platform has already been destroyed!');
            }
            this._modules.slice().forEach(function (module) { return module.destroy(); });
            this._destroyListeners.forEach(function (listener) { return listener(); });
            this._destroyed = true;
        };
        PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {
            return this._bootstrapModuleFactoryWithZone(moduleFactory, null);
        };
        PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {
            var _this = this;
            // Note: We need to create the NgZone _before_ we instantiate the module,
            // as instantiating the module creates some providers eagerly.
            // So we create a mini parent injector that just contains the new NgZone and
            // pass that as parent to the NgModuleFactory.
            if (!ngZone)
                ngZone = new NgZone({ enableLongStackTrace: isDevMode() });
            // Attention: Don't use ApplicationRef.run here,
            // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
            return ngZone.run(function () {
                var ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);
                var moduleRef = moduleFactory.create(ngZoneInjector);
                var exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                if (!exceptionHandler) {
                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
                }
                moduleRef.onDestroy(function () { return ListWrapper.remove(_this._modules, moduleRef); });
                ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } });
                return _callAndReportToErrorHandler(exceptionHandler, function () {
                    var initStatus = moduleRef.injector.get(ApplicationInitStatus);
                    return initStatus.donePromise.then(function () {
                        _this._moduleDoBootstrap(moduleRef);
                        return moduleRef;
                    });
                });
            });
        };
        PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {
            if (compilerOptions === void 0) { compilerOptions = []; }
            return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);
        };
        PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone, componentFactoryCallback) {
            var _this = this;
            if (compilerOptions === void 0) { compilerOptions = []; }
            var compilerFactory = this.injector.get(CompilerFactory);
            var compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);
            // ugly internal api hack: generate host component factories for all declared components and
            // pass the factories into the callback - this is used by UpdateAdapter to get hold of all
            // factories.
            if (componentFactoryCallback) {
                return compiler.compileModuleAndAllComponentsAsync(moduleType)
                    .then(function (_a) {
                    var ngModuleFactory = _a.ngModuleFactory, componentFactories = _a.componentFactories;
                    componentFactoryCallback(componentFactories);
                    return _this._bootstrapModuleFactoryWithZone(ngModuleFactory, ngZone);
                });
            }
            return compiler.compileModuleAsync(moduleType)
                .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });
        };
        PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {
            var appRef = moduleRef.injector.get(ApplicationRef);
            if (moduleRef.bootstrapFactories.length > 0) {
                moduleRef.bootstrapFactories.forEach(function (compFactory) { return appRef.bootstrap(compFactory); });
            }
            else if (moduleRef.instance.ngDoBootstrap) {
                moduleRef.instance.ngDoBootstrap(appRef);
            }
            else {
                throw new Error(("The module " + stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ") +
                    "Please define one of these.");
            }
        };
        PlatformRef_.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        PlatformRef_.ctorParameters = [
            { type: Injector, },
        ];
        return PlatformRef_;
    }(PlatformRef));
    /**
     * A reference to an Angular application running on a page.
     *
     * For more about Angular applications, see the documentation for {@link bootstrap}.
     *
     * @stable
     */
    var ApplicationRef = (function () {
        function ApplicationRef() {
        }
        Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
            /**
             * Get a list of component types registered to this application.
             * This list is populated even before the component is created.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(ApplicationRef.prototype, "components", {
            /**
             * Get a list of components registered to this application.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        return ApplicationRef;
    }());
    var ApplicationRef_ = (function (_super) {
        __extends$3(ApplicationRef_, _super);
        function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {
            var _this = this;
            _super.call(this);
            this._zone = _zone;
            this._console = _console;
            this._injector = _injector;
            this._exceptionHandler = _exceptionHandler;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._initStatus = _initStatus;
            this._testabilityRegistry = _testabilityRegistry;
            this._testability = _testability;
            this._bootstrapListeners = [];
            this._rootComponents = [];
            this._rootComponentTypes = [];
            this._changeDetectorRefs = [];
            this._runningTick = false;
            this._enforceNoNewChanges = false;
            this._enforceNoNewChanges = isDevMode();
            this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });
        }
        ApplicationRef_.prototype.registerChangeDetector = function (changeDetector) {
            this._changeDetectorRefs.push(changeDetector);
        };
        ApplicationRef_.prototype.unregisterChangeDetector = function (changeDetector) {
            ListWrapper.remove(this._changeDetectorRefs, changeDetector);
        };
        ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {
            var _this = this;
            if (!this._initStatus.done) {
                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
            }
            var componentFactory;
            if (componentOrFactory instanceof ComponentFactory) {
                componentFactory = componentOrFactory;
            }
            else {
                componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
            }
            this._rootComponentTypes.push(componentFactory.componentType);
            var compRef = componentFactory.create(this._injector, [], componentFactory.selector);
            compRef.onDestroy(function () { _this._unloadComponent(compRef); });
            var testability = compRef.injector.get(Testability, null);
            if (testability) {
                compRef.injector.get(TestabilityRegistry)
                    .registerApplication(compRef.location.nativeElement, testability);
            }
            this._loadComponent(compRef);
            if (isDevMode()) {
                this._console.log("Angular 2 is running in the development mode. Call enableProdMode() to enable the production mode.");
            }
            return compRef;
        };
        /** @internal */
        ApplicationRef_.prototype._loadComponent = function (componentRef) {
            this._changeDetectorRefs.push(componentRef.changeDetectorRef);
            this.tick();
            this._rootComponents.push(componentRef);
            // Get the listeners lazily to prevent DI cycles.
            var listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, [])
                .concat(this._bootstrapListeners);
            listeners.forEach(function (listener) { return listener(componentRef); });
        };
        /** @internal */
        ApplicationRef_.prototype._unloadComponent = function (componentRef) {
            if (this._rootComponents.indexOf(componentRef) == -1) {
                return;
            }
            this.unregisterChangeDetector(componentRef.changeDetectorRef);
            ListWrapper.remove(this._rootComponents, componentRef);
        };
        ApplicationRef_.prototype.tick = function () {
            if (this._runningTick) {
                throw new Error('ApplicationRef.tick is called recursively');
            }
            var scope = ApplicationRef_._tickScope();
            try {
                this._runningTick = true;
                this._changeDetectorRefs.forEach(function (detector) { return detector.detectChanges(); });
                if (this._enforceNoNewChanges) {
                    this._changeDetectorRefs.forEach(function (detector) { return detector.checkNoChanges(); });
                }
            }
            finally {
                this._runningTick = false;
                wtfLeave(scope);
            }
        };
        ApplicationRef_.prototype.ngOnDestroy = function () {
            // TODO(alxhub): Dispose of the NgZone.
            this._rootComponents.slice().forEach(function (component) { return component.destroy(); });
        };
        Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
            get: function () { return this._rootComponentTypes; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ApplicationRef_.prototype, "components", {
            get: function () { return this._rootComponents; },
            enumerable: true,
            configurable: true
        });
        /** @internal */
        ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
        ApplicationRef_.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        ApplicationRef_.ctorParameters = [
            { type: NgZone, },
            { type: Console, },
            { type: Injector, },
            { type: ErrorHandler, },
            { type: ComponentFactoryResolver, },
            { type: ApplicationInitStatus, },
            { type: TestabilityRegistry, decorators: [{ type: Optional },] },
            { type: Testability, decorators: [{ type: Optional },] },
        ];
        return ApplicationRef_;
    }(ApplicationRef));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$9 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Represents an instance of an NgModule created via a {@link NgModuleFactory}.
     *
     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
     * NgModule Instance.
     *
     * @stable
     */
    var NgModuleRef = (function () {
        function NgModuleRef() {
        }
        Object.defineProperty(NgModuleRef.prototype, "injector", {
            /**
             * The injector that contains all of the providers of the NgModule.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgModuleRef.prototype, "componentFactoryResolver", {
            /**
             * The ComponentFactoryResolver to get hold of the ComponentFactories
             * declared in the `entryComponents` property of the module.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgModuleRef.prototype, "instance", {
            /**
             * The NgModule instance.
             */
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return NgModuleRef;
    }());
    /**
     * @experimental
     */
    var NgModuleFactory = (function () {
        function NgModuleFactory(_injectorClass, _moduleType) {
            this._injectorClass = _injectorClass;
            this._moduleType = _moduleType;
        }
        Object.defineProperty(NgModuleFactory.prototype, "moduleType", {
            get: function () { return this._moduleType; },
            enumerable: true,
            configurable: true
        });
        NgModuleFactory.prototype.create = function (parentInjector) {
            if (!parentInjector) {
                parentInjector = Injector.NULL;
            }
            var instance = new this._injectorClass(parentInjector);
            instance.create();
            return instance;
        };
        return NgModuleFactory;
    }());
    var _UNDEFINED = new Object();
    var NgModuleInjector = (function (_super) {
        __extends$9(NgModuleInjector, _super);
        function NgModuleInjector(parent, factories, bootstrapFactories) {
            _super.call(this, factories, parent.get(ComponentFactoryResolver, ComponentFactoryResolver.NULL));
            this.parent = parent;
            this.bootstrapFactories = bootstrapFactories;
            this._destroyListeners = [];
            this._destroyed = false;
        }
        NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };
        NgModuleInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            if (token === Injector || token === ComponentFactoryResolver) {
                return this;
            }
            var result = this.getInternal(token, _UNDEFINED);
            return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;
        };
        Object.defineProperty(NgModuleInjector.prototype, "injector", {
            get: function () { return this; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgModuleInjector.prototype, "componentFactoryResolver", {
            get: function () { return this; },
            enumerable: true,
            configurable: true
        });
        NgModuleInjector.prototype.destroy = function () {
            if (this._destroyed) {
                throw new Error("The ng module " + stringify(this.instance.constructor) + " has already been destroyed.");
            }
            this._destroyed = true;
            this.destroyInternal();
            this._destroyListeners.forEach(function (listener) { return listener(); });
        };
        NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
        return NgModuleInjector;
    }(CodegenComponentFactoryResolver));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Used to load ng module factories.
     * @stable
     */
    var NgModuleFactoryLoader = (function () {
        function NgModuleFactoryLoader() {
        }
        return NgModuleFactoryLoader;
    }());
    var moduleFactories = new Map();
    /**
     * Registers a loaded module. Should only be called from generated NgModuleFactory code.
     * @experimental
     */
    function registerModuleFactory(id, factory) {
        var existing = moduleFactories.get(id);
        if (existing) {
            throw new Error("Duplicate module registered for " + id + " - " + existing.moduleType.name + " vs " + factory.moduleType.name);
        }
        moduleFactories.set(id, factory);
    }
    /**
     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
     * cannot be found.
     * @experimental
     */
    function getModuleFactory(id) {
        var factory = moduleFactories.get(id);
        if (!factory)
            throw new Error("No module with ID " + id + " loaded");
        return factory;
    }

    /**
     * An unmodifiable list of items that Angular keeps up to date when the state
     * of the application changes.
     *
     * The type of object that {@link Query} and {@link ViewQueryMetadata} provide.
     *
     * Implements an iterable interface, therefore it can be used in both ES6
     * javascript `for (var i of items)` loops as well as in Angular templates with
     * `*ngFor="let i of myList"`.
     *
     * Changes can be observed by subscribing to the changes `Observable`.
     *
     * NOTE: In the future this class will implement an `Observable` interface.
     *
     * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
     * ```typescript
     * @Component({...})
     * class Container {
     *   @ViewChildren(Item) items:QueryList<Item>;
     * }
     * ```
     * @stable
     */
    var QueryList = (function () {
        function QueryList() {
            this._dirty = true;
            this._results = [];
            this._emitter = new EventEmitter();
        }
        Object.defineProperty(QueryList.prototype, "changes", {
            get: function () { return this._emitter; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList.prototype, "length", {
            get: function () { return this._results.length; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList.prototype, "first", {
            get: function () { return this._results[0]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList.prototype, "last", {
            get: function () { return this._results[this.length - 1]; },
            enumerable: true,
            configurable: true
        });
        /**
         * See
         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
         */
        QueryList.prototype.map = function (fn) { return this._results.map(fn); };
        /**
         * See
         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
         */
        QueryList.prototype.filter = function (fn) {
            return this._results.filter(fn);
        };
        /**
         * See
         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
         */
        QueryList.prototype.reduce = function (fn, init) {
            return this._results.reduce(fn, init);
        };
        /**
         * See
         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
         */
        QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
        /**
         * See
         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
         */
        QueryList.prototype.some = function (fn) {
            return this._results.some(fn);
        };
        QueryList.prototype.toArray = function () { return this._results.slice(); };
        QueryList.prototype[getSymbolIterator()] = function () { return this._results[getSymbolIterator()](); };
        QueryList.prototype.toString = function () { return this._results.toString(); };
        QueryList.prototype.reset = function (res) {
            this._results = ListWrapper.flatten(res);
            this._dirty = false;
        };
        QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
        /** internal */
        QueryList.prototype.setDirty = function () { this._dirty = true; };
        Object.defineProperty(QueryList.prototype, "dirty", {
            /** internal */
            get: function () { return this._dirty; },
            enumerable: true,
            configurable: true
        });
        return QueryList;
    }());

    var _SEPARATOR = '#';
    var FACTORY_CLASS_SUFFIX = 'NgFactory';
    /**
     * Configuration for SystemJsNgModuleLoader.
     * token.
     *
     * @experimental
     */
    var SystemJsNgModuleLoaderConfig = (function () {
        function SystemJsNgModuleLoaderConfig() {
        }
        return SystemJsNgModuleLoaderConfig;
    }());
    var DEFAULT_CONFIG = {
        factoryPathPrefix: '',
        factoryPathSuffix: '.ngfactory',
    };
    /**
     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
     * @experimental
     */
    var SystemJsNgModuleLoader = (function () {
        function SystemJsNgModuleLoader(_compiler, config) {
            this._compiler = _compiler;
            this._config = config || DEFAULT_CONFIG;
        }
        SystemJsNgModuleLoader.prototype.load = function (path) {
            var offlineMode = this._compiler instanceof Compiler;
            return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
        };
        SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
            var _this = this;
            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
            if (exportName === undefined)
                exportName = 'default';
            return System.import(module)
                .then(function (module) { return module[exportName]; })
                .then(function (type) { return checkNotEmpty(type, module, exportName); })
                .then(function (type) { return _this._compiler.compileModuleAsync(type); });
        };
        SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
            var factoryClassSuffix = FACTORY_CLASS_SUFFIX;
            if (exportName === undefined) {
                exportName = 'default';
                factoryClassSuffix = '';
            }
            return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
                .then(function (module) { return module[exportName + factoryClassSuffix]; })
                .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
        };
        SystemJsNgModuleLoader.decorators = [
            { type: Injectable },
        ];
        /** @nocollapse */
        SystemJsNgModuleLoader.ctorParameters = [
            { type: Compiler, },
            { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },
        ];
        return SystemJsNgModuleLoader;
    }());
    function checkNotEmpty(value, modulePath, exportName) {
        if (!value) {
            throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
        }
        return value;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$10 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Represents an Embedded Template that can be used to instantiate Embedded Views.
     *
     * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
     * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
     * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
     * `TemplateRef` from a Component or a Directive via {@link Query}.
     *
     * To instantiate Embedded Views based on a Template, use
     * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
     * View Container.
     * @stable
     */
    var TemplateRef = (function () {
        function TemplateRef() {
        }
        Object.defineProperty(TemplateRef.prototype, "elementRef", {
            /**
             * The location in the View where the Embedded View logically belongs to.
             *
             * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
             * inherit from the contexts of this location.
             *
             * Typically new Embedded Views are attached to the View Container of this location, but in
             * advanced use-cases, the View can be attached to a different container while keeping the
             * data-binding and injection context from the original location.
             *
             */
            // TODO(i): rename to anchor or location
            get: function () { return null; },
            enumerable: true,
            configurable: true
        });
        return TemplateRef;
    }());
    var TemplateRef_ = (function (_super) {
        __extends$10(TemplateRef_, _super);
        function TemplateRef_(_appElement, _viewFactory) {
            _super.call(this);
            this._appElement = _appElement;
            this._viewFactory = _viewFactory;
        }
        TemplateRef_.prototype.createEmbeddedView = function (context) {
            var view = this._viewFactory(this._appElement.parentView.viewUtils, this._appElement.parentInjector, this._appElement);
            view.create(context || {}, null, null);
            return view.ref;
        };
        Object.defineProperty(TemplateRef_.prototype, "elementRef", {
            get: function () { return this._appElement.elementRef; },
            enumerable: true,
            configurable: true
        });
        return TemplateRef_;
    }(TemplateRef));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var _queuedAnimations = [];
    /** @internal */
    function queueAnimation(player) {
        _queuedAnimations.push(player);
    }
    /** @internal */
    function triggerQueuedAnimations() {
        for (var i = 0; i < _queuedAnimations.length; i++) {
            var player = _queuedAnimations[i];
            player.play();
        }
        _queuedAnimations = [];
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$11 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @stable
     */
    var ViewRef = (function () {
        function ViewRef() {
        }
        Object.defineProperty(ViewRef.prototype, "destroyed", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        return ViewRef;
    }());
    /**
     * Represents an Angular View.
     *
     * <!-- TODO: move the next two paragraphs to the dev guide -->
     * A View is a fundamental building block of the application UI. It is the smallest grouping of
     * Elements which are created and destroyed together.
     *
     * Properties of elements in a View can change, but the structure (number and order) of elements in
     * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
     * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
     * <!-- /TODO -->
     *
     * ### Example
     *
     * Given this template...
     *
     * ```
     * Count: {{items.length}}
     * <ul>
     *   <li *ngFor="let  item of items">{{item}}</li>
     * </ul>
     * ```
     *
     * We have two {@link TemplateRef}s:
     *
     * Outer {@link TemplateRef}:
     * ```
     * Count: {{items.length}}
     * <ul>
     *   <template ngFor let-item [ngForOf]="items"></template>
     * </ul>
     * ```
     *
     * Inner {@link TemplateRef}:
     * ```
     *   <li>{{item}}</li>
     * ```
     *
     * Notice that the original template is broken down into two separate {@link TemplateRef}s.
     *
     * The outer/inner {@link TemplateRef}s are then assembled into views like so:
     *
     * ```
     * <!-- ViewRef: outer-0 -->
     * Count: 2
     * <ul>
     *   <template view-container-ref></template>
     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
     * </ul>
     * <!-- /ViewRef: outer-0 -->
     * ```
     * @experimental
     */
    var EmbeddedViewRef = (function (_super) {
        __extends$11(EmbeddedViewRef, _super);
        function EmbeddedViewRef() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(EmbeddedViewRef.prototype, "context", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
            get: function () { return unimplemented(); },
            enumerable: true,
            configurable: true
        });
        ;
        return EmbeddedViewRef;
    }(ViewRef));
    var ViewRef_ = (function () {
        function ViewRef_(_view) {
            this._view = _view;
            this._view = _view;
            this._originalMode = this._view.cdMode;
        }
        Object.defineProperty(ViewRef_.prototype, "internalView", {
            get: function () { return this._view; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewRef_.prototype, "rootNodes", {
            get: function () { return this._view.flatRootNodes; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewRef_.prototype, "context", {
            get: function () { return this._view.context; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewRef_.prototype, "destroyed", {
            get: function () { return this._view.destroyed; },
            enumerable: true,
            configurable: true
        });
        ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };
        ViewRef_.prototype.detach = function () { this._view.cdMode = ChangeDetectorStatus.Detached; };
        ViewRef_.prototype.detectChanges = function () {
            this._view.detectChanges(false);
            triggerQueuedAnimations();
        };
        ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };
        ViewRef_.prototype.reattach = function () {
            this._view.cdMode = this._originalMode;
            this.markForCheck();
        };
        ViewRef_.prototype.onDestroy = function (callback) { this._view.disposables.push(callback); };
        ViewRef_.prototype.destroy = function () { this._view.destroy(); };
        return ViewRef_;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$12 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var EventListener = (function () {
        function EventListener(name, callback) {
            this.name = name;
            this.callback = callback;
        }
        ;
        return EventListener;
    }());
    /**
     * @experimental All debugging apis are currently experimental.
     */
    var DebugNode = (function () {
        function DebugNode(nativeNode, parent, _debugInfo) {
            this._debugInfo = _debugInfo;
            this.nativeNode = nativeNode;
            if (isPresent(parent) && parent instanceof DebugElement) {
                parent.addChild(this);
            }
            else {
                this.parent = null;
            }
            this.listeners = [];
        }
        Object.defineProperty(DebugNode.prototype, "injector", {
            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.injector : null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "componentInstance", {
            get: function () {
                return isPresent(this._debugInfo) ? this._debugInfo.component : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "context", {
            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.context : null; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "references", {
            get: function () {
                return isPresent(this._debugInfo) ? this._debugInfo.references : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "providerTokens", {
            get: function () {
                return isPresent(this._debugInfo) ? this._debugInfo.providerTokens : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugNode.prototype, "source", {
            get: function () { return isPresent(this._debugInfo) ? this._debugInfo.source : null; },
            enumerable: true,
            configurable: true
        });
        return DebugNode;
    }());
    /**
     * @experimental All debugging apis are currently experimental.
     */
    var DebugElement = (function (_super) {
        __extends$12(DebugElement, _super);
        function DebugElement(nativeNode, parent, _debugInfo) {
            _super.call(this, nativeNode, parent, _debugInfo);
            this.properties = {};
            this.attributes = {};
            this.classes = {};
            this.styles = {};
            this.childNodes = [];
            this.nativeElement = nativeNode;
        }
        DebugElement.prototype.addChild = function (child) {
            if (isPresent(child)) {
                this.childNodes.push(child);
                child.parent = this;
            }
        };
        DebugElement.prototype.removeChild = function (child) {
            var childIndex = this.childNodes.indexOf(child);
            if (childIndex !== -1) {
                child.parent = null;
                this.childNodes.splice(childIndex, 1);
            }
        };
        DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
            var siblingIndex = this.childNodes.indexOf(child);
            if (siblingIndex !== -1) {
                var previousChildren = this.childNodes.slice(0, siblingIndex + 1);
                var nextChildren = this.childNodes.slice(siblingIndex + 1);
                this.childNodes =
                    ListWrapper.concat(ListWrapper.concat(previousChildren, newChildren), nextChildren);
                for (var i = 0; i < newChildren.length; ++i) {
                    var newChild = newChildren[i];
                    if (isPresent(newChild.parent)) {
                        newChild.parent.removeChild(newChild);
                    }
                    newChild.parent = this;
                }
            }
        };
        DebugElement.prototype.query = function (predicate) {
            var results = this.queryAll(predicate);
            return results.length > 0 ? results[0] : null;
        };
        DebugElement.prototype.queryAll = function (predicate) {
            var matches = [];
            _queryElementChildren(this, predicate, matches);
            return matches;
        };
        DebugElement.prototype.queryAllNodes = function (predicate) {
            var matches = [];
            _queryNodeChildren(this, predicate, matches);
            return matches;
        };
        Object.defineProperty(DebugElement.prototype, "children", {
            get: function () {
                var children = [];
                this.childNodes.forEach(function (node) {
                    if (node instanceof DebugElement) {
                        children.push(node);
                    }
                });
                return children;
            },
            enumerable: true,
            configurable: true
        });
        DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
            this.listeners.forEach(function (listener) {
                if (listener.name == eventName) {
                    listener.callback(eventObj);
                }
            });
        };
        return DebugElement;
    }(DebugNode));
    /**
     * @experimental
     */
    function asNativeElements(debugEls) {
        return debugEls.map(function (el) { return el.nativeElement; });
    }
    function _queryElementChildren(element, predicate, matches) {
        element.childNodes.forEach(function (node) {
            if (node instanceof DebugElement) {
                if (predicate(node)) {
                    matches.push(node);
                }
                _queryElementChildren(node, predicate, matches);
            }
        });
    }
    function _queryNodeChildren(parentNode, predicate, matches) {
        if (parentNode instanceof DebugElement) {
            parentNode.childNodes.forEach(function (node) {
                if (predicate(node)) {
                    matches.push(node);
                }
                if (node instanceof DebugElement) {
                    _queryNodeChildren(node, predicate, matches);
                }
            });
        }
    }
    // Need to keep the nodes in a global Map so that multiple angular apps are supported.
    var _nativeNodeToDebugNode = new Map();
    /**
     * @experimental
     */
    function getDebugNode(nativeNode) {
        return _nativeNodeToDebugNode.get(nativeNode);
    }
    function indexDebugNode(node) {
        _nativeNodeToDebugNode.set(node.nativeNode, node);
    }
    function removeDebugNodeFromIndex(node) {
        _nativeNodeToDebugNode.delete(node.nativeNode);
    }

    function _reflector() {
        return reflector;
    }
    var _CORE_PLATFORM_PROVIDERS = [
        PlatformRef_,
        { provide: PlatformRef, useExisting: PlatformRef_ },
        { provide: Reflector, useFactory: _reflector, deps: [] },
        { provide: ReflectorReader, useExisting: Reflector },
        TestabilityRegistry,
        Console,
    ];
    /**
     * This platform has to be included in any other platform
     *
     * @experimental
     */
    var platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);

    /**
     * @experimental i18n support is experimental.
     */
    var LOCALE_ID = new OpaqueToken('LocaleId');
    /**
     * @experimental i18n support is experimental.
     */
    var TRANSLATIONS = new OpaqueToken('Translations');
    /**
     * @experimental i18n support is experimental.
     */
    var TRANSLATIONS_FORMAT = new OpaqueToken('TranslationsFormat');

    function _iterableDiffersFactory() {
        return defaultIterableDiffers;
    }
    function _keyValueDiffersFactory() {
        return defaultKeyValueDiffers;
    }
    /**
     * This module includes the providers of @angular/core that are needed
     * to bootstrap components via `ApplicationRef`.
     *
     * @experimental
     */
    var ApplicationModule = (function () {
        function ApplicationModule() {
        }
        ApplicationModule.decorators = [
            { type: NgModule, args: [{
                        providers: [
                            ApplicationRef_,
                            { provide: ApplicationRef, useExisting: ApplicationRef_ },
                            ApplicationInitStatus,
                            Compiler,
                            APP_ID_RANDOM_PROVIDER,
                            ViewUtils,
                            { provide: IterableDiffers, useFactory: _iterableDiffersFactory },
                            { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },
                            { provide: LOCALE_ID, useValue: 'en-US' },
                        ]
                    },] },
        ];
        /** @nocollapse */
        ApplicationModule.ctorParameters = [];
        return ApplicationModule;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean
    var ANY_STATE = '*';
    var DEFAULT_STATE = '*';
    var EMPTY_STATE = 'void';

    var Math$1 = global$1.Math;

    var AnimationGroupPlayer = (function () {
        function AnimationGroupPlayer(_players) {
            var _this = this;
            this._players = _players;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._finished = false;
            this._started = false;
            this.parentPlayer = null;
            var count = 0;
            var total = this._players.length;
            if (total == 0) {
                scheduleMicroTask(function () { return _this._onFinish(); });
            }
            else {
                this._players.forEach(function (player) {
                    player.parentPlayer = _this;
                    player.onDone(function () {
                        if (++count >= total) {
                            _this._onFinish();
                        }
                    });
                });
            }
        }
        AnimationGroupPlayer.prototype._onFinish = function () {
            if (!this._finished) {
                this._finished = true;
                if (!isPresent(this.parentPlayer)) {
                    this.destroy();
                }
                this._onDoneFns.forEach(function (fn) { return fn(); });
                this._onDoneFns = [];
            }
        };
        AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
        AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
        AnimationGroupPlayer.prototype.play = function () {
            if (!isPresent(this.parentPlayer)) {
                this.init();
            }
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
                this._started = true;
            }
            this._players.forEach(function (player) { return player.play(); });
        };
        AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };
        AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };
        AnimationGroupPlayer.prototype.finish = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.finish(); });
        };
        AnimationGroupPlayer.prototype.destroy = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.destroy(); });
        };
        AnimationGroupPlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
        AnimationGroupPlayer.prototype.setPosition = function (p /** TODO #9100 */) {
            this._players.forEach(function (player) { player.setPosition(p); });
        };
        AnimationGroupPlayer.prototype.getPosition = function () {
            var min = 0;
            this._players.forEach(function (player) {
                var p = player.getPosition();
                min = Math$1.min(p, min);
            });
            return min;
        };
        return AnimationGroupPlayer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var AnimationKeyframe = (function () {
        function AnimationKeyframe(offset, styles) {
            this.offset = offset;
            this.styles = styles;
        }
        return AnimationKeyframe;
    }());

    /**
     * @experimental Animation support is experimental.
     */
    var AnimationPlayer = (function () {
        function AnimationPlayer() {
        }
        Object.defineProperty(AnimationPlayer.prototype, "parentPlayer", {
            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
            set: function (player) { throw new Error('NOT IMPLEMENTED: Base Class'); },
            enumerable: true,
            configurable: true
        });
        return AnimationPlayer;
    }());
    var NoOpAnimationPlayer = (function () {
        function NoOpAnimationPlayer() {
            var _this = this;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._started = false;
            this.parentPlayer = null;
            scheduleMicroTask(function () { return _this._onFinish(); });
        }
        /** @internal */
        NoOpAnimationPlayer.prototype._onFinish = function () {
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        };
        NoOpAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        NoOpAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        NoOpAnimationPlayer.prototype.hasStarted = function () { return this._started; };
        NoOpAnimationPlayer.prototype.init = function () { };
        NoOpAnimationPlayer.prototype.play = function () {
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
            }
            this._started = true;
        };
        NoOpAnimationPlayer.prototype.pause = function () { };
        NoOpAnimationPlayer.prototype.restart = function () { };
        NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };
        NoOpAnimationPlayer.prototype.destroy = function () { };
        NoOpAnimationPlayer.prototype.reset = function () { };
        NoOpAnimationPlayer.prototype.setPosition = function (p /** TODO #9100 */) { };
        NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };
        return NoOpAnimationPlayer;
    }());

    var AnimationSequencePlayer = (function () {
        function AnimationSequencePlayer(_players) {
            var _this = this;
            this._players = _players;
            this._currentIndex = 0;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._finished = false;
            this._started = false;
            this.parentPlayer = null;
            this._players.forEach(function (player) { player.parentPlayer = _this; });
            this._onNext(false);
        }
        AnimationSequencePlayer.prototype._onNext = function (start) {
            var _this = this;
            if (this._finished)
                return;
            if (this._players.length == 0) {
                this._activePlayer = new NoOpAnimationPlayer();
                scheduleMicroTask(function () { return _this._onFinish(); });
            }
            else if (this._currentIndex >= this._players.length) {
                this._activePlayer = new NoOpAnimationPlayer();
                this._onFinish();
            }
            else {
                var player = this._players[this._currentIndex++];
                player.onDone(function () { return _this._onNext(true); });
                this._activePlayer = player;
                if (start) {
                    player.play();
                }
            }
        };
        AnimationSequencePlayer.prototype._onFinish = function () {
            if (!this._finished) {
                this._finished = true;
                if (!isPresent(this.parentPlayer)) {
                    this.destroy();
                }
                this._onDoneFns.forEach(function (fn) { return fn(); });
                this._onDoneFns = [];
            }
        };
        AnimationSequencePlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
        AnimationSequencePlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        AnimationSequencePlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        AnimationSequencePlayer.prototype.hasStarted = function () { return this._started; };
        AnimationSequencePlayer.prototype.play = function () {
            if (!isPresent(this.parentPlayer)) {
                this.init();
            }
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
                this._started = true;
            }
            this._activePlayer.play();
        };
        AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };
        AnimationSequencePlayer.prototype.restart = function () {
            if (this._players.length > 0) {
                this.reset();
                this._players[0].restart();
            }
        };
        AnimationSequencePlayer.prototype.reset = function () { this._players.forEach(function (player) { return player.reset(); }); };
        AnimationSequencePlayer.prototype.finish = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.finish(); });
        };
        AnimationSequencePlayer.prototype.destroy = function () {
            this._onFinish();
            this._players.forEach(function (player) { return player.destroy(); });
        };
        AnimationSequencePlayer.prototype.setPosition = function (p /** TODO #9100 */) { this._players[0].setPosition(p); };
        AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };
        return AnimationSequencePlayer;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$13 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @experimental Animation support is experimental.
     */
    var AUTO_STYLE = '*';
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link trigger trigger
     * animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationEntryMetadata = (function () {
        function AnimationEntryMetadata(name, definitions) {
            this.name = name;
            this.definitions = definitions;
        }
        return AnimationEntryMetadata;
    }());
    /**
     * @experimental Animation support is experimental.
     */
    var AnimationStateMetadata = (function () {
        function AnimationStateMetadata() {
        }
        return AnimationStateMetadata;
    }());
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link state state animation
     * function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationStateDeclarationMetadata = (function (_super) {
        __extends$13(AnimationStateDeclarationMetadata, _super);
        function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
            _super.call(this);
            this.stateNameExpr = stateNameExpr;
            this.styles = styles;
        }
        return AnimationStateDeclarationMetadata;
    }(AnimationStateMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the
     * {@link transition transition animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationStateTransitionMetadata = (function (_super) {
        __extends$13(AnimationStateTransitionMetadata, _super);
        function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
            _super.call(this);
            this.stateChangeExpr = stateChangeExpr;
            this.steps = steps;
        }
        return AnimationStateTransitionMetadata;
    }(AnimationStateMetadata));
    /**
     * @experimental Animation support is experimental.
     */
    var AnimationMetadata = (function () {
        function AnimationMetadata() {
        }
        return AnimationMetadata;
    }());
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link keyframes keyframes
     * animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationKeyframesSequenceMetadata = (function (_super) {
        __extends$13(AnimationKeyframesSequenceMetadata, _super);
        function AnimationKeyframesSequenceMetadata(steps) {
            _super.call(this);
            this.steps = steps;
        }
        return AnimationKeyframesSequenceMetadata;
    }(AnimationMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link style style animation
     * function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationStyleMetadata = (function (_super) {
        __extends$13(AnimationStyleMetadata, _super);
        function AnimationStyleMetadata(styles, offset) {
            if (offset === void 0) { offset = null; }
            _super.call(this);
            this.styles = styles;
            this.offset = offset;
        }
        return AnimationStyleMetadata;
    }(AnimationMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link animate animate
     * animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationAnimateMetadata = (function (_super) {
        __extends$13(AnimationAnimateMetadata, _super);
        function AnimationAnimateMetadata(timings, styles) {
            _super.call(this);
            this.timings = timings;
            this.styles = styles;
        }
        return AnimationAnimateMetadata;
    }(AnimationMetadata));
    /**
     * @experimental Animation support is experimental.
     */
    var AnimationWithStepsMetadata = (function (_super) {
        __extends$13(AnimationWithStepsMetadata, _super);
        function AnimationWithStepsMetadata() {
            _super.call(this);
        }
        Object.defineProperty(AnimationWithStepsMetadata.prototype, "steps", {
            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
            enumerable: true,
            configurable: true
        });
        return AnimationWithStepsMetadata;
    }(AnimationMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link sequence sequence
     * animation function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationSequenceMetadata = (function (_super) {
        __extends$13(AnimationSequenceMetadata, _super);
        function AnimationSequenceMetadata(_steps) {
            _super.call(this);
            this._steps = _steps;
        }
        Object.defineProperty(AnimationSequenceMetadata.prototype, "steps", {
            get: function () { return this._steps; },
            enumerable: true,
            configurable: true
        });
        return AnimationSequenceMetadata;
    }(AnimationWithStepsMetadata));
    /**
     * Metadata representing the entry of animations.
     * Instances of this class are provided via the animation DSL when the {@link group group animation
     * function} is called.
     *
     * @experimental Animation support is experimental.
     */
    var AnimationGroupMetadata = (function (_super) {
        __extends$13(AnimationGroupMetadata, _super);
        function AnimationGroupMetadata(_steps) {
            _super.call(this);
            this._steps = _steps;
        }
        Object.defineProperty(AnimationGroupMetadata.prototype, "steps", {
            get: function () { return this._steps; },
            enumerable: true,
            configurable: true
        });
        return AnimationGroupMetadata;
    }(AnimationWithStepsMetadata));
    /**
     * `animate` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `animate` specifies an animation step that will apply the provided `styles` data for a given
     * amount of
     * time based on the provided `timing` expression value. Calls to `animate` are expected to be
     * used within {@link sequence an animation sequence}, {@link group group}, or {@link transition
     * transition}.
     *
     * ### Usage
     *
     * The `animate` function accepts two input parameters: `timing` and `styles`:
     *
     * - `timing` is a string based value that can be a combination of a duration with optional
     * delay and easing values. The format for the expression breaks down to `duration delay easing`
     * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
     * delay=100, easing=ease-out`.
     * If a numeric value is provided then that will be used as the `duration` value in millisecond
     * form.
     * - `styles` is the style input data which can either be a call to {@link style style} or {@link
     * keyframes keyframes}.
     * If left empty then the styles from the destination state will be collected and used (this is
     * useful when
     * describing an animation step that will complete an animation by {@link
     * transition#the-final-animate-call animating to the final state}).
     *
     * ```typescript
     * // various functions for specifying timing data
     * animate(500, style(...))
     * animate("1s", style(...))
     * animate("100ms 0.5s", style(...))
     * animate("5s ease", style(...))
     * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
     *
     * // either style() of keyframes() can be used
     * animate(500, style({ background: "red" }))
     * animate(500, keyframes([
     *   style({ background: "blue" })),
     *   style({ background: "red" }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function animate(timing, styles) {
        if (styles === void 0) { styles = null; }
        var stylesEntry = styles;
        if (!isPresent(stylesEntry)) {
            var EMPTY_STYLE = {};
            stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);
        }
        return new AnimationAnimateMetadata(timing, stylesEntry);
    }
    /**
     * `group` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `group` specifies a list of animation steps that are all run in parallel. Grouped animations
     * are useful when a series of styles must be animated/closed off
     * at different statrting/ending times.
     *
     * The `group` function can either be used within a {@link sequence sequence} or a {@link transition
     * transition}
     * and it will only continue to the next instruction once all of the inner animation steps
     * have completed.
     *
     * ### Usage
     *
     * The `steps` data that is passed into the `group` animation function can either consist
     * of {@link style style} or {@link animate animate} function calls. Each call to `style()` or
     * `animate()`
     * within a group will be executed instantly (use {@link keyframes keyframes} or a
     * {@link animate#usage animate() with a delay value} to offset styles to be applied at a later
     * time).
     *
     * ```typescript
     * group([
     *   animate("1s", { background: "black" }))
     *   animate("2s", { color: "white" }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function group(steps) {
        return new AnimationGroupMetadata(steps);
    }
    /**
     * `sequence` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used
     * by default when an array is passed as animation data into {@link transition transition}.)
     *
     * The `sequence` function can either be used within a {@link group group} or a {@link transition
     * transition}
     * and it will only continue to the next instruction once each of the inner animation steps
     * have completed.
     *
     * To perform animation styling in parallel with other animation steps then
     * have a look at the {@link group group} animation function.
     *
     * ### Usage
     *
     * The `steps` data that is passed into the `sequence` animation function can either consist
     * of {@link style style} or {@link animate animate} function calls. A call to `style()` will apply
     * the
     * provided styling data immediately while a call to `animate()` will apply its styling
     * data over a given time depending on its timing data.
     *
     * ```typescript
     * sequence([
     *   style({ opacity: 0 })),
     *   animate("1s", { opacity: 1 }))
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function sequence(steps) {
        return new AnimationSequenceMetadata(steps);
    }
    /**
     * `style` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `style` declares a key/value object containing CSS properties/styles that can then
     * be used for {@link state animation states}, within an {@link sequence animation sequence}, or as
     * styling data for both {@link animate animate} and {@link keyframes keyframes}.
     *
     * ### Usage
     *
     * `style` takes in a key/value string map as data and expects one or more CSS property/value
     * pairs to be defined.
     *
     * ```typescript
     * // string values are used for css properties
     * style({ background: "red", color: "blue" })
     *
     * // numerical (pixel) values are also supported
     * style({ width: 100, height: 0 })
     * ```
     *
     * #### Auto-styles (using `*`)
     *
     * When an asterix (`*`) character is used as a value then it will be detected from the element
     * being animated
     * and applied as animation data when the animation starts.
     *
     * This feature proves useful for a state depending on layout and/or environment factors; in such
     * cases
     * the styles are calculated just before the animation starts.
     *
     * ```typescript
     * // the steps below will animate from 0 to the
     * // actual height of the element
     * style({ height: 0 }),
     * animate("1s", style({ height: "*" }))
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function style(tokens) {
        var input;
        var offset = null;
        if (isString(tokens)) {
            input = [tokens];
        }
        else {
            if (isArray(tokens)) {
                input = tokens;
            }
            else {
                input = [tokens];
            }
            input.forEach(function (entry) {
                var entryOffset = entry['offset'];
                if (isPresent(entryOffset)) {
                    offset = offset == null ? parseFloat(entryOffset) : offset;
                }
            });
        }
        return new AnimationStyleMetadata(input, offset);
    }
    /**
     * `state` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `state` declares an animation state within the given trigger. When a state is
     * active within a component then its associated styles will persist on
     * the element that the trigger is attached to (even when the animation ends).
     *
     * To animate between states, have a look at the animation {@link transition transition}
     * DSL function. To register states to an animation trigger please have a look
     * at the {@link trigger trigger} function.
     *
     * #### The `void` state
     *
     * The `void` state value is a reserved word that angular uses to determine when the element is not
     * apart
     * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
     * associated element
     * is void).
     *
     * #### The `*` (default) state
     *
     * The `*` state (when styled) is a fallback state that will be used if
     * the state that is being animated is not declared within the trigger.
     *
     * ### Usage
     *
     * `state` will declare an animation state with its associated styles
     * within the given trigger.
     *
     * - `stateNameExpr` can be one or more state names separated by commas.
     * - `styles` refers to the {@link style styling data} that will be persisted on the element once
     * the state
     * has been reached.
     *
     * ```typescript
     * // "void" is a reserved name for a state and is used to represent
     * // the state in which an element is detached from from the application.
     * state("void", style({ height: 0 }))
     *
     * // user-defined states
     * state("closed", style({ height: 0 }))
     * state("open, visible", style({ height: "*" }))
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function state(stateNameExpr, styles) {
        return new AnimationStateDeclarationMetadata(stateNameExpr, styles);
    }
    /**
     * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `keyframes` specifies a collection of {@link style style} entries each optionally characterized
     * by an `offset` value.
     *
     * ### Usage
     *
     * The `keyframes` animation function is designed to be used alongside the {@link animate animate}
     * animation function. Instead of applying animations from where they are
     * currently to their destination, keyframes can describe how each style entry is applied
     * and at what point within the animation arc (much like CSS Keyframe Animations do).
     *
     * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at
     * what percentage of the animate time the styles will be applied.
     *
     * ```typescript
     * // the provided offset values describe when each backgroundColor value is applied.
     * animate("5s", keyframes([
     *   style({ backgroundColor: "red", offset: 0 }),
     *   style({ backgroundColor: "blue", offset: 0.2 }),
     *   style({ backgroundColor: "orange", offset: 0.3 }),
     *   style({ backgroundColor: "black", offset: 1 })
     * ]))
     * ```
     *
     * Alternatively, if there are no `offset` values used within the style entries then the offsets
     * will
     * be calculated automatically.
     *
     * ```typescript
     * animate("5s", keyframes([
     *   style({ backgroundColor: "red" }) // offset = 0
     *   style({ backgroundColor: "blue" }) // offset = 0.33
     *   style({ backgroundColor: "orange" }) // offset = 0.66
     *   style({ backgroundColor: "black" }) // offset = 1
     * ]))
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function keyframes(steps) {
        return new AnimationKeyframesSequenceMetadata(steps);
    }
    /**
     * `transition` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `transition` declares the {@link sequence sequence of animation steps} that will be run when the
     * provided
     * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`
     * which consists
     * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).
     *
     * Animation transitions are placed within an {@link trigger animation trigger}. For an transition
     * to animate to
     * a state value and persist its styles then one or more {@link state animation states} is expected
     * to be defined.
     *
     * ### Usage
     *
     * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
     * what the
     * previous state is and what the current state has become. In other words, if a transition is
     * defined that
     * matches the old/current state criteria then the associated animation will be triggered.
     *
     * ```typescript
     * // all transition/state changes are defined within an animation trigger
     * trigger("myAnimationTrigger", [
     *   // if a state is defined then its styles will be persisted when the
     *   // animation has fully completed itself
     *   state("on", style({ background: "green" })),
     *   state("off", style({ background: "grey" })),
     *
     *   // a transition animation that will be kicked off when the state value
     *   // bound to "myAnimationTrigger" changes from "on" to "off"
     *   transition("on => off", animate(500)),
     *
     *   // it is also possible to do run the same animation for both directions
     *   transition("on <=> off", animate(500)),
     *
     *   // or to define multiple states pairs separated by commas
     *   transition("on => off, off => void", animate(500)),
     *
     *   // this is a catch-all state change for when an element is inserted into
     *   // the page and the destination state is unknown
     *   transition("void => *", [
     *     style({ opacity: 0 }),
     *     animate(500)
     *   ]),
     *
     *   // this will capture a state change between any states
     *   transition("* => *", animate("1s 0s")),
     * ])
     * ```
     *
     * The template associated with this component will make use of the `myAnimationTrigger`
     * animation trigger by binding to an element within its template code.
     *
     * ```html
     * <!-- somewhere inside of my-component-tpl.html -->
     * <div [@myAnimationTrigger]="myStatusExp">...</div>
     * ```
     *
     * #### The final `animate` call
     *
     * If the final step within the transition steps is a call to `animate()` that **only**
     * uses a timing value with **no style data** then it will be automatically used as the final
     * animation
     * arc for the element to animate itself to the final state. This involves an automatic mix of
     * adding/removing CSS styles so that the element will be in the exact state it should be for the
     * applied state to be presented correctly.
     *
     * ```
     * // start off by hiding the element, but make sure that it animates properly to whatever state
     * // is currently active for "myAnimationTrigger"
     * transition("void => *", [
     *   style({ opacity: 0 }),
     *   animate(500)
     * ])
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function transition(stateChangeExpr, steps) {
        var animationData = isArray(steps) ? new AnimationSequenceMetadata(steps) :
            steps;
        return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);
    }
    /**
     * `trigger` is an animation-specific function that is designed to be used inside of Angular2's
     * animation
     * DSL language. If this information is new, please navigate to the
     * {@link Component#animations-anchor component animations metadata
     * page} to gain a better understanding of how animations in Angular2 are used.
     *
     * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link
     * transition transition}
     * entries that will be evaluated when the expression bound to the trigger changes.
     *
     * Triggers are registered within the component annotation data under the
     * {@link Component#animations-anchor animations section}. An animation trigger can
     * be placed on an element within a template by referencing the name of the
     * trigger followed by the expression value that the trigger is bound to
     * (in the form of `[@triggerName]="expression"`.
     *
     * ### Usage
     *
     * `trigger` will create an animation trigger reference based on the provided `name` value.
     * The provided `animation` value is expected to be an array consisting of {@link state state} and
     * {@link transition transition}
     * declarations.
     *
     * ```typescript
     * @Component({
     *   selector: 'my-component',
     *   templateUrl: 'my-component-tpl.html',
     *   animations: [
     *     trigger("myAnimationTrigger", [
     *       state(...),
     *       state(...),
     *       transition(...),
     *       transition(...)
     *     ])
     *   ]
     * })
     * class MyComponent {
     *   myStatusExp = "something";
     * }
     * ```
     *
     * The template associated with this component will make use of the `myAnimationTrigger`
     * animation trigger by binding to an element within its template code.
     *
     * ```html
     * <!-- somewhere inside of my-component-tpl.html -->
     * <div [@myAnimationTrigger]="myStatusExp">...</div>
     * ```
     *
     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
     *
     * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
     *
     * @experimental Animation support is experimental.
     */
    function trigger(name, animation) {
        return new AnimationEntryMetadata(name, animation);
    }

    function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {
        if (nullValue === void 0) { nullValue = null; }
        var finalStyles = {};
        Object.keys(newStyles).forEach(function (prop) {
            var value = newStyles[prop];
            finalStyles[prop] = value == AUTO_STYLE ? nullValue : value.toString();
        });
        Object.keys(previousStyles).forEach(function (prop) {
            if (!isPresent(finalStyles[prop])) {
                finalStyles[prop] = nullValue;
            }
        });
        return finalStyles;
    }
    function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
        var limit = keyframes.length - 1;
        var firstKeyframe = keyframes[0];
        // phase 1: copy all the styles from the first keyframe into the lookup map
        var flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
        var extraFirstKeyframeStyles = {};
        var hasExtraFirstStyles = false;
        Object.keys(collectedStyles).forEach(function (prop) {
            var value = collectedStyles[prop];
            // if the style is already defined in the first keyframe then
            // we do not replace it.
            if (!flatenedFirstKeyframeStyles[prop]) {
                flatenedFirstKeyframeStyles[prop] = value;
                extraFirstKeyframeStyles[prop] = value;
                hasExtraFirstStyles = true;
            }
        });
        var keyframeCollectedStyles = StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
        // phase 2: normalize the final keyframe
        var finalKeyframe = keyframes[limit];
        ListWrapper.insert(finalKeyframe.styles.styles, 0, finalStateStyles);
        var flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
        var extraFinalKeyframeStyles = {};
        var hasExtraFinalStyles = false;
        Object.keys(keyframeCollectedStyles).forEach(function (prop) {
            if (!isPresent(flatenedFinalKeyframeStyles[prop])) {
                extraFinalKeyframeStyles[prop] = AUTO_STYLE;
                hasExtraFinalStyles = true;
            }
        });
        if (hasExtraFinalStyles) {
            finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
        }
        Object.keys(flatenedFinalKeyframeStyles).forEach(function (prop) {
            if (!isPresent(flatenedFirstKeyframeStyles[prop])) {
                extraFirstKeyframeStyles[prop] = AUTO_STYLE;
                hasExtraFirstStyles = true;
            }
        });
        if (hasExtraFirstStyles) {
            firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
        }
        return keyframes;
    }
    function clearStyles(styles) {
        var finalStyles = {};
        Object.keys(styles).forEach(function (key) { finalStyles[key] = null; });
        return finalStyles;
    }
    function collectAndResolveStyles(collection, styles) {
        return styles.map(function (entry) {
            var stylesObj = {};
            Object.keys(entry).forEach(function (prop) {
                var value = entry[prop];
                if (value == FILL_STYLE_FLAG) {
                    value = collection[prop];
                    if (!isPresent(value)) {
                        value = AUTO_STYLE;
                    }
                }
                collection[prop] = value;
                stylesObj[prop] = value;
            });
            return stylesObj;
        });
    }
    function renderStyles(element, renderer, styles) {
        Object.keys(styles).forEach(function (prop) { renderer.setElementStyle(element, prop, styles[prop]); });
    }
    function flattenStyles(styles) {
        var finalStyles = {};
        styles.forEach(function (entry) {
            Object.keys(entry).forEach(function (prop) { finalStyles[prop] = entry[prop]; });
        });
        return finalStyles;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var AnimationStyles = (function () {
        function AnimationStyles(styles) {
            this.styles = styles;
        }
        return AnimationStyles;
    }());

    var DebugDomRootRenderer = (function () {
        function DebugDomRootRenderer(_delegate) {
            this._delegate = _delegate;
        }
        DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {
            return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
        };
        return DebugDomRootRenderer;
    }());
    var DebugDomRenderer = (function () {
        function DebugDomRenderer(_delegate) {
            this._delegate = _delegate;
        }
        DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
            var nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
            var debugEl = new DebugElement(nativeEl, null, debugInfo);
            indexDebugNode(debugEl);
            return nativeEl;
        };
        DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
            var nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
            var debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);
            debugEl.name = name;
            indexDebugNode(debugEl);
            return nativeEl;
        };
        DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };
        DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
            var comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
            var debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);
            indexDebugNode(debugEl);
            return comment;
        };
        DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
            var text = this._delegate.createText(parentElement, value, debugInfo);
            var debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);
            indexDebugNode(debugEl);
            return text;
        };
        DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {
            var debugParent = getDebugNode(parentElement);
            if (isPresent(debugParent) && debugParent instanceof DebugElement) {
                var debugElement_1 = debugParent;
                nodes.forEach(function (node) { debugElement_1.addChild(getDebugNode(node)); });
            }
            this._delegate.projectNodes(parentElement, nodes);
        };
        DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
            var debugNode = getDebugNode(node);
            if (isPresent(debugNode)) {
                var debugParent = debugNode.parent;
                if (viewRootNodes.length > 0 && isPresent(debugParent)) {
                    var debugViewRootNodes = [];
                    viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes.push(getDebugNode(rootNode)); });
                    debugParent.insertChildrenAfter(debugNode, debugViewRootNodes);
                }
            }
            this._delegate.attachViewAfter(node, viewRootNodes);
        };
        DebugDomRenderer.prototype.detachView = function (viewRootNodes) {
            viewRootNodes.forEach(function (node) {
                var debugNode = getDebugNode(node);
                if (isPresent(debugNode) && isPresent(debugNode.parent)) {
                    debugNode.parent.removeChild(debugNode);
                }
            });
            this._delegate.detachView(viewRootNodes);
        };
        DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
            viewAllNodes.forEach(function (node) { removeDebugNodeFromIndex(getDebugNode(node)); });
            this._delegate.destroyView(hostElement, viewAllNodes);
        };
        DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl)) {
                debugEl.listeners.push(new EventListener(name, callback));
            }
            return this._delegate.listen(renderElement, name, callback);
        };
        DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {
            return this._delegate.listenGlobal(target, name, callback);
        };
        DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.properties[propertyName] = propertyValue;
            }
            this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
        };
        DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.attributes[attributeName] = attributeValue;
            }
            this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
        };
        DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
            this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
        };
        DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.classes[className] = isAdd;
            }
            this._delegate.setElementClass(renderElement, className, isAdd);
        };
        DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
            var debugEl = getDebugNode(renderElement);
            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
                debugEl.styles[styleName] = styleValue;
            }
            this._delegate.setElementStyle(renderElement, styleName, styleValue);
        };
        DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
            this._delegate.invokeElementMethod(renderElement, methodName, args);
        };
        DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };
        DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
            return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing);
        };
        return DebugDomRenderer;
    }());

    var StaticNodeDebugInfo = (function () {
        function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
            this.providerTokens = providerTokens;
            this.componentToken = componentToken;
            this.refTokens = refTokens;
        }
        return StaticNodeDebugInfo;
    }());
    var DebugContext = (function () {
        function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
            this._view = _view;
            this._nodeIndex = _nodeIndex;
            this._tplRow = _tplRow;
            this._tplCol = _tplCol;
        }
        Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
            get: function () {
                return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "context", {
            get: function () { return this._view.context; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "component", {
            get: function () {
                var staticNodeInfo = this._staticNodeInfo;
                if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {
                    return this.injector.get(staticNodeInfo.componentToken);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
            get: function () {
                var componentView = this._view;
                while (isPresent(componentView.declarationAppElement) &&
                    componentView.type !== ViewType.COMPONENT) {
                    componentView = componentView.declarationAppElement.parentView;
                }
                return isPresent(componentView.declarationAppElement) ?
                    componentView.declarationAppElement.nativeElement :
                    null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "injector", {
            get: function () { return this._view.injector(this._nodeIndex); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "renderNode", {
            get: function () {
                if (isPresent(this._nodeIndex) && this._view.allNodes) {
                    return this._view.allNodes[this._nodeIndex];
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "providerTokens", {
            get: function () {
                var staticNodeInfo = this._staticNodeInfo;
                return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "source", {
            get: function () {
                return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugContext.prototype, "references", {
            get: function () {
                var _this = this;
                var varValues = {};
                var staticNodeInfo = this._staticNodeInfo;
                if (isPresent(staticNodeInfo)) {
                    var refs = staticNodeInfo.refTokens;
                    Object.keys(refs).forEach(function (refName) {
                        var refToken = refs[refName];
                        var varValue;
                        if (isBlank(refToken)) {
                            varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;
                        }
                        else {
                            varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
                        }
                        varValues[refName] = varValue;
                    });
                }
                return varValues;
            },
            enumerable: true,
            configurable: true
        });
        return DebugContext;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An instance of this class is returned as an event parameter when an animation
     * callback is captured for an animation either during the start or done phase.
     *
     * ```typescript
     * @Component({
     *   host: {
     *     '[@myAnimationTrigger]': 'someExpression',
     *     '(@myAnimationTrigger.start)': 'captureStartEvent($event)',
     *     '(@myAnimationTrigger.done)': 'captureDoneEvent($event)',
     *   },
     *   animations: [
     *     trigger("myAnimationTrigger", [
     *        // ...
     *     ])
     *   ]
     * })
     * class MyComponent {
     *   someExpression: any = false;
     *   captureStartEvent(event: AnimationTransitionEvent) {
     *     // the toState, fromState and totalTime data is accessible from the event variable
     *   }
     *
     *   captureDoneEvent(event: AnimationTransitionEvent) {
     *     // the toState, fromState and totalTime data is accessible from the event variable
     *   }
     * }
     * ```
     *
     * @experimental Animation support is experimental.
     */
    var AnimationTransitionEvent = (function () {
        function AnimationTransitionEvent(_a) {
            var fromState = _a.fromState, toState = _a.toState, totalTime = _a.totalTime;
            this.fromState = fromState;
            this.toState = toState;
            this.totalTime = totalTime;
        }
        return AnimationTransitionEvent;
    }());

    var ViewAnimationMap = (function () {
        function ViewAnimationMap() {
            this._map = new Map();
            this._allPlayers = [];
        }
        Object.defineProperty(ViewAnimationMap.prototype, "length", {
            get: function () { return this.getAllPlayers().length; },
            enumerable: true,
            configurable: true
        });
        ViewAnimationMap.prototype.find = function (element, animationName) {
            var playersByAnimation = this._map.get(element);
            if (isPresent(playersByAnimation)) {
                return playersByAnimation[animationName];
            }
        };
        ViewAnimationMap.prototype.findAllPlayersByElement = function (element) {
            var el = this._map.get(element);
            return el ? Object.keys(el).map(function (k) { return el[k]; }) : [];
        };
        ViewAnimationMap.prototype.set = function (element, animationName, player) {
            var playersByAnimation = this._map.get(element);
            if (!isPresent(playersByAnimation)) {
                playersByAnimation = {};
            }
            var existingEntry = playersByAnimation[animationName];
            if (isPresent(existingEntry)) {
                this.remove(element, animationName);
            }
            playersByAnimation[animationName] = player;
            this._allPlayers.push(player);
            this._map.set(element, playersByAnimation);
        };
        ViewAnimationMap.prototype.getAllPlayers = function () { return this._allPlayers; };
        ViewAnimationMap.prototype.remove = function (element, animationName) {
            var playersByAnimation = this._map.get(element);
            if (playersByAnimation) {
                var player = playersByAnimation[animationName];
                delete playersByAnimation[animationName];
                var index = this._allPlayers.indexOf(player);
                this._allPlayers.splice(index, 1);
                if (Object.keys(playersByAnimation).length === 0) {
                    this._map.delete(element);
                }
            }
        };
        return ViewAnimationMap;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$15 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _UNDEFINED$1 = new Object();
    var ElementInjector = (function (_super) {
        __extends$15(ElementInjector, _super);
        function ElementInjector(_view, _nodeIndex) {
            _super.call(this);
            this._view = _view;
            this._nodeIndex = _nodeIndex;
        }
        ElementInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            var result = _UNDEFINED$1;
            if (result === _UNDEFINED$1) {
                result = this._view.injectorGet(token, this._nodeIndex, _UNDEFINED$1);
            }
            if (result === _UNDEFINED$1) {
                result = this._view.parentInjector.get(token, notFoundValue);
            }
            return result;
        };
        return ElementInjector;
    }(Injector));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$14 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _scope_check = wtfCreateScope("AppView#check(ascii id)");
    /**
     * Cost of making objects: http://jsperf.com/instantiate-size-of-object
     *
     */
    var AppView = (function () {
        function AppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode) {
            this.clazz = clazz;
            this.componentType = componentType;
            this.type = type;
            this.viewUtils = viewUtils;
            this.parentInjector = parentInjector;
            this.declarationAppElement = declarationAppElement;
            this.cdMode = cdMode;
            this.contentChildren = [];
            this.viewChildren = [];
            this.viewContainerElement = null;
            this.numberOfChecks = 0;
            this.animationPlayers = new ViewAnimationMap();
            this._animationListeners = new Map();
            this.ref = new ViewRef_(this);
            if (type === ViewType.COMPONENT || type === ViewType.HOST) {
                this.renderer = viewUtils.renderComponent(componentType);
            }
            else {
                this.renderer = declarationAppElement.parentView.renderer;
            }
        }
        Object.defineProperty(AppView.prototype, "destroyed", {
            get: function () { return this.cdMode === ChangeDetectorStatus.Destroyed; },
            enumerable: true,
            configurable: true
        });
        AppView.prototype.cancelActiveAnimation = function (element, animationName, removeAllAnimations) {
            if (removeAllAnimations === void 0) { removeAllAnimations = false; }
            if (removeAllAnimations) {
                this.animationPlayers.findAllPlayersByElement(element).forEach(function (player) { return player.destroy(); });
            }
            else {
                var player = this.animationPlayers.find(element, animationName);
                if (isPresent(player)) {
                    player.destroy();
                }
            }
        };
        AppView.prototype.queueAnimation = function (element, animationName, player, totalTime, fromState, toState) {
            var _this = this;
            queueAnimation(player);
            var event = new AnimationTransitionEvent({ 'fromState': fromState, 'toState': toState, 'totalTime': totalTime });
            this.animationPlayers.set(element, animationName, player);
            player.onDone(function () {
                // TODO: make this into a datastructure for done|start
                _this.triggerAnimationOutput(element, animationName, 'done', event);
                _this.animationPlayers.remove(element, animationName);
            });
            player.onStart(function () { _this.triggerAnimationOutput(element, animationName, 'start', event); });
        };
        AppView.prototype.triggerAnimationOutput = function (element, animationName, phase, event) {
            var listeners = this._animationListeners.get(element);
            if (isPresent(listeners) && listeners.length) {
                for (var i = 0; i < listeners.length; i++) {
                    var listener = listeners[i];
                    // we check for both the name in addition to the phase in the event
                    // that there may be more than one @trigger on the same element
                    if (listener.eventName === animationName && listener.eventPhase === phase) {
                        listener.handler(event);
                        break;
                    }
                }
            }
        };
        AppView.prototype.registerAnimationOutput = function (element, eventName, eventPhase, eventHandler) {
            var animations = this._animationListeners.get(element);
            if (!isPresent(animations)) {
                this._animationListeners.set(element, animations = []);
            }
            animations.push(new _AnimationOutputHandler(eventName, eventPhase, eventHandler));
        };
        AppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
            this.context = context;
            var projectableNodes;
            switch (this.type) {
                case ViewType.COMPONENT:
                    projectableNodes = ensureSlotCount(givenProjectableNodes, this.componentType.slotCount);
                    break;
                case ViewType.EMBEDDED:
                    projectableNodes = this.declarationAppElement.parentView.projectableNodes;
                    break;
                case ViewType.HOST:
                    // Note: Don't ensure the slot count for the projectableNodes as we store
                    // them only for the contained component view (which will later check the slot count...)
                    projectableNodes = givenProjectableNodes;
                    break;
            }
            this._hasExternalHostElement = isPresent(rootSelectorOrNode);
            this.projectableNodes = projectableNodes;
            return this.createInternal(rootSelectorOrNode);
        };
        /**
         * Overwritten by implementations.
         * Returns the AppElement for the host element for ViewType.HOST.
         */
        AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };
        AppView.prototype.init = function (rootNodesOrAppElements, allNodes, disposables, subscriptions) {
            this.rootNodesOrAppElements = rootNodesOrAppElements;
            this.allNodes = allNodes;
            this.disposables = disposables;
            this.subscriptions = subscriptions;
            if (this.type === ViewType.COMPONENT) {
                // Note: the render nodes have been attached to their host element
                // in the ViewFactory already.
                this.declarationAppElement.parentView.viewChildren.push(this);
                this.dirtyParentQueriesInternal();
            }
        };
        AppView.prototype.selectOrCreateHostElement = function (elementName, rootSelectorOrNode, debugInfo) {
            var hostElement;
            if (isPresent(rootSelectorOrNode)) {
                hostElement = this.renderer.selectRootElement(rootSelectorOrNode, debugInfo);
            }
            else {
                hostElement = this.renderer.createElement(null, elementName, debugInfo);
            }
            return hostElement;
        };
        AppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
            return this.injectorGetInternal(token, nodeIndex, notFoundResult);
        };
        /**
         * Overwritten by implementations
         */
        AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
            return notFoundResult;
        };
        AppView.prototype.injector = function (nodeIndex) {
            if (isPresent(nodeIndex)) {
                return new ElementInjector(this, nodeIndex);
            }
            else {
                return this.parentInjector;
            }
        };
        AppView.prototype.destroy = function () {
            if (this._hasExternalHostElement) {
                this.renderer.detachView(this.flatRootNodes);
            }
            else if (isPresent(this.viewContainerElement)) {
                this.viewContainerElement.detachView(this.viewContainerElement.nestedViews.indexOf(this));
            }
            this._destroyRecurse();
        };
        AppView.prototype._destroyRecurse = function () {
            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
                return;
            }
            var children = this.contentChildren;
            for (var i = 0; i < children.length; i++) {
                children[i]._destroyRecurse();
            }
            children = this.viewChildren;
            for (var i = 0; i < children.length; i++) {
                children[i]._destroyRecurse();
            }
            this.destroyLocal();
            this.cdMode = ChangeDetectorStatus.Destroyed;
        };
        AppView.prototype.destroyLocal = function () {
            var _this = this;
            var hostElement = this.type === ViewType.COMPONENT ? this.declarationAppElement.nativeElement : null;
            for (var i = 0; i < this.disposables.length; i++) {
                this.disposables[i]();
            }
            for (var i = 0; i < this.subscriptions.length; i++) {
                this.subscriptions[i].unsubscribe();
            }
            this.destroyInternal();
            this.dirtyParentQueriesInternal();
            if (this.animationPlayers.length == 0) {
                this.renderer.destroyView(hostElement, this.allNodes);
            }
            else {
                var player = new AnimationGroupPlayer(this.animationPlayers.getAllPlayers());
                player.onDone(function () { _this.renderer.destroyView(hostElement, _this.allNodes); });
            }
        };
        /**
         * Overwritten by implementations
         */
        AppView.prototype.destroyInternal = function () { };
        /**
         * Overwritten by implementations
         */
        AppView.prototype.detachInternal = function () { };
        AppView.prototype.detach = function () {
            var _this = this;
            this.detachInternal();
            if (this.animationPlayers.length == 0) {
                this.renderer.detachView(this.flatRootNodes);
            }
            else {
                var player = new AnimationGroupPlayer(this.animationPlayers.getAllPlayers());
                player.onDone(function () { _this.renderer.detachView(_this.flatRootNodes); });
            }
        };
        Object.defineProperty(AppView.prototype, "changeDetectorRef", {
            get: function () { return this.ref; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppView.prototype, "parent", {
            get: function () {
                return isPresent(this.declarationAppElement) ? this.declarationAppElement.parentView : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppView.prototype, "flatRootNodes", {
            get: function () { return flattenNestedViewRenderNodes(this.rootNodesOrAppElements); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AppView.prototype, "lastRootNode", {
            get: function () {
                var lastNode = this.rootNodesOrAppElements.length > 0 ?
                    this.rootNodesOrAppElements[this.rootNodesOrAppElements.length - 1] :
                    null;
                return _findLastRenderNode(lastNode);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Overwritten by implementations
         */
        AppView.prototype.dirtyParentQueriesInternal = function () { };
        AppView.prototype.detectChanges = function (throwOnChange) {
            var s = _scope_check(this.clazz);
            if (this.cdMode === ChangeDetectorStatus.Checked ||
                this.cdMode === ChangeDetectorStatus.Errored)
                return;
            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
                this.throwDestroyedError('detectChanges');
            }
            this.detectChangesInternal(throwOnChange);
            if (this.cdMode === ChangeDetectorStatus.CheckOnce)
                this.cdMode = ChangeDetectorStatus.Checked;
            this.numberOfChecks++;
            wtfLeave(s);
        };
        /**
         * Overwritten by implementations
         */
        AppView.prototype.detectChangesInternal = function (throwOnChange) {
            this.detectContentChildrenChanges(throwOnChange);
            this.detectViewChildrenChanges(throwOnChange);
        };
        AppView.prototype.detectContentChildrenChanges = function (throwOnChange) {
            for (var i = 0; i < this.contentChildren.length; ++i) {
                var child = this.contentChildren[i];
                if (child.cdMode === ChangeDetectorStatus.Detached)
                    continue;
                child.detectChanges(throwOnChange);
            }
        };
        AppView.prototype.detectViewChildrenChanges = function (throwOnChange) {
            for (var i = 0; i < this.viewChildren.length; ++i) {
                var child = this.viewChildren[i];
                if (child.cdMode === ChangeDetectorStatus.Detached)
                    continue;
                child.detectChanges(throwOnChange);
            }
        };
        AppView.prototype.markContentChildAsMoved = function (renderAppElement) { this.dirtyParentQueriesInternal(); };
        AppView.prototype.addToContentChildren = function (renderAppElement) {
            renderAppElement.parentView.contentChildren.push(this);
            this.viewContainerElement = renderAppElement;
            this.dirtyParentQueriesInternal();
        };
        AppView.prototype.removeFromContentChildren = function (renderAppElement) {
            ListWrapper.remove(renderAppElement.parentView.contentChildren, this);
            this.dirtyParentQueriesInternal();
            this.viewContainerElement = null;
        };
        AppView.prototype.markAsCheckOnce = function () { this.cdMode = ChangeDetectorStatus.CheckOnce; };
        AppView.prototype.markPathToRootAsCheckOnce = function () {
            var c = this;
            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {
                if (c.cdMode === ChangeDetectorStatus.Checked) {
                    c.cdMode = ChangeDetectorStatus.CheckOnce;
                }
                var parentEl = c.type === ViewType.COMPONENT ? c.declarationAppElement : c.viewContainerElement;
                c = isPresent(parentEl) ? parentEl.parentView : null;
            }
        };
        AppView.prototype.eventHandler = function (cb) { return cb; };
        AppView.prototype.throwDestroyedError = function (details) { throw new ViewDestroyedError(details); };
        return AppView;
    }());
    var DebugAppView = (function (_super) {
        __extends$14(DebugAppView, _super);
        function DebugAppView(clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode, staticNodeDebugInfos) {
            _super.call(this, clazz, componentType, type, viewUtils, parentInjector, declarationAppElement, cdMode);
            this.staticNodeDebugInfos = staticNodeDebugInfos;
            this._currentDebugContext = null;
        }
        DebugAppView.prototype.create = function (context, givenProjectableNodes, rootSelectorOrNode) {
            this._resetDebug();
            try {
                return _super.prototype.create.call(this, context, givenProjectableNodes, rootSelectorOrNode);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
            this._resetDebug();
            try {
                return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype.detach = function () {
            this._resetDebug();
            try {
                _super.prototype.detach.call(this);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype.destroyLocal = function () {
            this._resetDebug();
            try {
                _super.prototype.destroyLocal.call(this);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype.detectChanges = function (throwOnChange) {
            this._resetDebug();
            try {
                _super.prototype.detectChanges.call(this, throwOnChange);
            }
            catch (e) {
                this._rethrowWithContext(e);
                throw e;
            }
        };
        DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };
        DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {
            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);
        };
        DebugAppView.prototype._rethrowWithContext = function (e) {
            if (!(e instanceof ViewWrappedError)) {
                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedError)) {
                    this.cdMode = ChangeDetectorStatus.Errored;
                }
                if (isPresent(this._currentDebugContext)) {
                    throw new ViewWrappedError(e, this._currentDebugContext);
                }
            }
        };
        DebugAppView.prototype.eventHandler = function (cb) {
            var _this = this;
            var superHandler = _super.prototype.eventHandler.call(this, cb);
            return function (event) {
                _this._resetDebug();
                try {
                    return superHandler(event);
                }
                catch (e) {
                    _this._rethrowWithContext(e);
                    throw e;
                }
            };
        };
        return DebugAppView;
    }(AppView));
    function _findLastRenderNode(node) {
        var lastNode;
        if (node instanceof AppElement) {
            var appEl = node;
            lastNode = appEl.nativeElement;
            if (isPresent(appEl.nestedViews)) {
                // Note: Views might have no root nodes at all!
                for (var i = appEl.nestedViews.length - 1; i >= 0; i--) {
                    var nestedView = appEl.nestedViews[i];
                    if (nestedView.rootNodesOrAppElements.length > 0) {
                        lastNode = _findLastRenderNode(nestedView.rootNodesOrAppElements[nestedView.rootNodesOrAppElements.length - 1]);
                    }
                }
            }
        }
        else {
            lastNode = node;
        }
        return lastNode;
    }
    var _AnimationOutputHandler = (function () {
        function _AnimationOutputHandler(eventName, eventPhase, handler) {
            this.eventName = eventName;
            this.eventPhase = eventPhase;
            this.handler = handler;
        }
        return _AnimationOutputHandler;
    }());

    var __core_private__ = {
        isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,
        ChangeDetectorStatus: ChangeDetectorStatus,
        constructDependencies: constructDependencies,
        LifecycleHooks: LifecycleHooks,
        LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,
        ReflectorReader: ReflectorReader,
        CodegenComponentFactoryResolver: CodegenComponentFactoryResolver,
        AppElement: AppElement,
        AppView: AppView,
        DebugAppView: DebugAppView,
        NgModuleInjector: NgModuleInjector,
        registerModuleFactory: registerModuleFactory,
        ViewType: ViewType,
        MAX_INTERPOLATION_VALUES: MAX_INTERPOLATION_VALUES,
        checkBinding: checkBinding,
        flattenNestedViewRenderNodes: flattenNestedViewRenderNodes,
        interpolate: interpolate,
        ViewUtils: ViewUtils,
        ViewMetadata: ViewMetadata,
        DebugContext: DebugContext,
        StaticNodeDebugInfo: StaticNodeDebugInfo,
        devModeEqual: devModeEqual,
        UNINITIALIZED: UNINITIALIZED,
        ValueUnwrapper: ValueUnwrapper,
        RenderDebugInfo: RenderDebugInfo,
        TemplateRef_: TemplateRef_,
        ReflectionCapabilities: ReflectionCapabilities,
        makeDecorator: makeDecorator,
        DebugDomRootRenderer: DebugDomRootRenderer,
        EMPTY_ARRAY: EMPTY_ARRAY,
        EMPTY_MAP: EMPTY_MAP,
        pureProxy1: pureProxy1,
        pureProxy2: pureProxy2,
        pureProxy3: pureProxy3,
        pureProxy4: pureProxy4,
        pureProxy5: pureProxy5,
        pureProxy6: pureProxy6,
        pureProxy7: pureProxy7,
        pureProxy8: pureProxy8,
        pureProxy9: pureProxy9,
        pureProxy10: pureProxy10,
        castByValue: castByValue,
        Console: Console,
        reflector: reflector,
        Reflector: Reflector,
        NoOpAnimationPlayer: NoOpAnimationPlayer,
        AnimationPlayer: AnimationPlayer,
        AnimationSequencePlayer: AnimationSequencePlayer,
        AnimationGroupPlayer: AnimationGroupPlayer,
        AnimationKeyframe: AnimationKeyframe,
        prepareFinalAnimationStyles: prepareFinalAnimationStyles,
        balanceAnimationKeyframes: balanceAnimationKeyframes,
        flattenStyles: flattenStyles,
        clearStyles: clearStyles,
        renderStyles: renderStyles,
        collectAndResolveStyles: collectAndResolveStyles,
        AnimationStyles: AnimationStyles,
        ANY_STATE: ANY_STATE,
        DEFAULT_STATE: DEFAULT_STATE,
        EMPTY_STATE: EMPTY_STATE,
        FILL_STYLE_FLAG: FILL_STYLE_FLAG,
        ComponentStillLoadingError: ComponentStillLoadingError,
        isPromise: isPromise
    };

    exports.createPlatform = createPlatform;
    exports.assertPlatform = assertPlatform;
    exports.destroyPlatform = destroyPlatform;
    exports.getPlatform = getPlatform;
    exports.PlatformRef = PlatformRef;
    exports.ApplicationRef = ApplicationRef;
    exports.enableProdMode = enableProdMode;
    exports.isDevMode = isDevMode;
    exports.createPlatformFactory = createPlatformFactory;
    exports.APP_ID = APP_ID;
    exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
    exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
    exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;
    exports.APP_INITIALIZER = APP_INITIALIZER;
    exports.ApplicationInitStatus = ApplicationInitStatus;
    exports.DebugElement = DebugElement;
    exports.DebugNode = DebugNode;
    exports.asNativeElements = asNativeElements;
    exports.getDebugNode = getDebugNode;
    exports.Testability = Testability;
    exports.TestabilityRegistry = TestabilityRegistry;
    exports.setTestabilityGetter = setTestabilityGetter;
    exports.TRANSLATIONS = TRANSLATIONS;
    exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;
    exports.LOCALE_ID = LOCALE_ID;
    exports.ApplicationModule = ApplicationModule;
    exports.wtfCreateScope = wtfCreateScope;
    exports.wtfLeave = wtfLeave;
    exports.wtfStartTimeRange = wtfStartTimeRange;
    exports.wtfEndTimeRange = wtfEndTimeRange;
    exports.Type = Type;
    exports.EventEmitter = EventEmitter;
    exports.ErrorHandler = ErrorHandler;
    exports.AnimationTransitionEvent = AnimationTransitionEvent;
    exports.AnimationPlayer = AnimationPlayer;
    exports.Sanitizer = Sanitizer;
    exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;
    exports.Attribute = Attribute;
    exports.ContentChild = ContentChild;
    exports.ContentChildren = ContentChildren;
    exports.Query = Query;
    exports.ViewChild = ViewChild;
    exports.ViewChildren = ViewChildren;
    exports.Component = Component;
    exports.Directive = Directive;
    exports.HostBinding = HostBinding;
    exports.HostListener = HostListener;
    exports.Input = Input;
    exports.Output = Output;
    exports.Pipe = Pipe;
    exports.AfterContentChecked = AfterContentChecked;
    exports.AfterContentInit = AfterContentInit;
    exports.AfterViewChecked = AfterViewChecked;
    exports.AfterViewInit = AfterViewInit;
    exports.DoCheck = DoCheck;
    exports.OnChanges = OnChanges;
    exports.OnDestroy = OnDestroy;
    exports.OnInit = OnInit;
    exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;
    exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;
    exports.NgModule = NgModule;
    exports.Class = Class;
    exports.forwardRef = forwardRef;
    exports.resolveForwardRef = resolveForwardRef;
    exports.Injector = Injector;
    exports.ReflectiveInjector = ReflectiveInjector;
    exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
    exports.ReflectiveKey = ReflectiveKey;
    exports.OpaqueToken = OpaqueToken;
    exports.Inject = Inject;
    exports.Optional = Optional;
    exports.Injectable = Injectable;
    exports.Self = Self;
    exports.SkipSelf = SkipSelf;
    exports.Host = Host;
    exports.NgZone = NgZone;
    exports.RenderComponentType = RenderComponentType;
    exports.Renderer = Renderer;
    exports.RootRenderer = RootRenderer;
    exports.COMPILER_OPTIONS = COMPILER_OPTIONS;
    exports.Compiler = Compiler;
    exports.CompilerFactory = CompilerFactory;
    exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
    exports.ComponentFactory = ComponentFactory;
    exports.ComponentRef = ComponentRef;
    exports.ComponentFactoryResolver = ComponentFactoryResolver;
    exports.ElementRef = ElementRef;
    exports.NgModuleFactory = NgModuleFactory;
    exports.NgModuleRef = NgModuleRef;
    exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
    exports.getModuleFactory = getModuleFactory;
    exports.QueryList = QueryList;
    exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
    exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;
    exports.TemplateRef = TemplateRef;
    exports.ViewContainerRef = ViewContainerRef;
    exports.EmbeddedViewRef = EmbeddedViewRef;
    exports.ViewRef = ViewRef;
    exports.ChangeDetectorRef = ChangeDetectorRef;
    exports.CollectionChangeRecord = CollectionChangeRecord;
    exports.DefaultIterableDiffer = DefaultIterableDiffer;
    exports.IterableDiffers = IterableDiffers;
    exports.KeyValueChangeRecord = KeyValueChangeRecord;
    exports.KeyValueDiffers = KeyValueDiffers;
    exports.SimpleChange = SimpleChange;
    exports.WrappedValue = WrappedValue;
    exports.platformCore = platformCore;
    exports.__core_private__ = __core_private__;
    exports.AUTO_STYLE = AUTO_STYLE;
    exports.AnimationEntryMetadata = AnimationEntryMetadata;
    exports.AnimationStateMetadata = AnimationStateMetadata;
    exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;
    exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;
    exports.AnimationMetadata = AnimationMetadata;
    exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;
    exports.AnimationStyleMetadata = AnimationStyleMetadata;
    exports.AnimationAnimateMetadata = AnimationAnimateMetadata;
    exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;
    exports.AnimationSequenceMetadata = AnimationSequenceMetadata;
    exports.AnimationGroupMetadata = AnimationGroupMetadata;
    exports.animate = animate;
    exports.group = group;
    exports.sequence = sequence;
    exports.style = style;
    exports.state = state;
    exports.keyframes = keyframes;
    exports.transition = transition;
    exports.trigger = trigger;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"rxjs/Observable":6,"rxjs/Subject":8}],4:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.0.2
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/compiler'), require('@angular/core'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/compiler', '@angular/core', '@angular/platform-browser'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.platformBrowserDynamic = global.ng.platformBrowserDynamic || {}),global.ng.compiler,global.ng.core,global.ng.platformBrowser));
}(this, function (exports,_angular_compiler,_angular_core,_angular_platformBrowser) { 'use strict';

    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = _angular_platformBrowser.__platform_browser_private__.INTERNAL_BROWSER_PLATFORM_PROVIDERS;

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = self;
        }
        else {
            globalScope = global;
        }
    }
    else {
        globalScope = window;
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var global$1 = globalScope;
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    global$1.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    var NumberWrapper = (function () {
        function NumberWrapper() {
        }
        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
        NumberWrapper.equal = function (a, b) { return a === b; };
        NumberWrapper.parseIntAutoRadix = function (text) {
            var result = parseInt(text);
            if (isNaN(result)) {
                throw new Error('Invalid integer literal when parsing ' + text);
            }
            return result;
        };
        NumberWrapper.parseInt = function (text, radix) {
            if (radix == 10) {
                if (/^(\-|\+)?[0-9]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else if (radix == 16) {
                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else {
                var result = parseInt(text, radix);
                if (!isNaN(result)) {
                    return result;
                }
            }
            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
        };
        Object.defineProperty(NumberWrapper, "NaN", {
            get: function () { return NaN; },
            enumerable: true,
            configurable: true
        });
        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
        NumberWrapper.isNaN = function (value) { return isNaN(value); };
        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
        return NumberWrapper;
    }());

    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var ResourceLoaderImpl = (function (_super) {
        __extends(ResourceLoaderImpl, _super);
        function ResourceLoaderImpl() {
            _super.apply(this, arguments);
        }
        ResourceLoaderImpl.prototype.get = function (url) {
            var resolve;
            var reject;
            var promise = new Promise(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.responseType = 'text';
            xhr.onload = function () {
                // responseText is the old-school way of retrieving response (supported by IE8 & 9)
                // response/responseType properties were introduced in ResourceLoader Level2 spec (supported
                // by IE10)
                var response = isPresent(xhr.response) ? xhr.response : xhr.responseText;
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status = xhr.status === 1223 ? 204 : xhr.status;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status === 0) {
                    status = response ? 200 : 0;
                }
                if (200 <= status && status <= 300) {
                    resolve(response);
                }
                else {
                    reject("Failed to load " + url);
                }
            };
            xhr.onerror = function () { reject("Failed to load " + url); };
            xhr.send();
            return promise;
        };
        ResourceLoaderImpl.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        ResourceLoaderImpl.ctorParameters = [];
        return ResourceLoaderImpl;
    }(_angular_compiler.ResourceLoader));

    var INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [
        INTERNAL_BROWSER_PLATFORM_PROVIDERS,
        {
            provide: _angular_core.COMPILER_OPTIONS,
            useValue: { providers: [{ provide: _angular_compiler.ResourceLoader, useClass: ResourceLoaderImpl }] },
            multi: true
        },
    ];

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * An implementation of ResourceLoader that uses a template cache to avoid doing an actual
     * ResourceLoader.
     *
     * The template cache needs to be built and loaded into window.$templateCache
     * via a separate mechanism.
     */
    var CachedResourceLoader = (function (_super) {
        __extends$1(CachedResourceLoader, _super);
        function CachedResourceLoader() {
            _super.call(this);
            this._cache = global$1.$templateCache;
            if (this._cache == null) {
                throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');
            }
        }
        CachedResourceLoader.prototype.get = function (url) {
            if (this._cache.hasOwnProperty(url)) {
                return Promise.resolve(this._cache[url]);
            }
            else {
                return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);
            }
        };
        return CachedResourceLoader;
    }(_angular_compiler.ResourceLoader));

    var __platform_browser_dynamic_private__ = {
        INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS: INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS,
        ResourceLoaderImpl: ResourceLoaderImpl
    };

    /**
     * @experimental
     */
    var RESOURCE_CACHE_PROVIDER = [{ provide: _angular_compiler.ResourceLoader, useClass: CachedResourceLoader }];
    /**
     * @experimental API related to bootstrapping are still under review.
     */
    var platformBrowserDynamic = _angular_core.createPlatformFactory(_angular_compiler.platformCoreDynamic, 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);

    exports.RESOURCE_CACHE_PROVIDER = RESOURCE_CACHE_PROVIDER;
    exports.platformBrowserDynamic = platformBrowserDynamic;
    exports.__platform_browser_dynamic_private__ = __platform_browser_dynamic_private__;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@angular/compiler":2,"@angular/core":3,"@angular/platform-browser":5}],5:[function(require,module,exports){
(function (global){
/**
 * @license Angular v2.0.2
 * (c) 2010-2016 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}),global.ng.common,global.ng.core));
}(this, function (exports,_angular_common,_angular_core) { 'use strict';

    var DebugDomRootRenderer = _angular_core.__core_private__.DebugDomRootRenderer;
    var NoOpAnimationPlayer = _angular_core.__core_private__.NoOpAnimationPlayer;

    var _NoOpAnimationDriver = (function () {
        function _NoOpAnimationDriver() {
        }
        _NoOpAnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
            return new NoOpAnimationPlayer();
        };
        return _NoOpAnimationDriver;
    }());
    /**
     * @experimental
     */
    var AnimationDriver = (function () {
        function AnimationDriver() {
        }
        AnimationDriver.NOOP = new _NoOpAnimationDriver();
        return AnimationDriver;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = self;
        }
        else {
            globalScope = global;
        }
    }
    else {
        globalScope = window;
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var global$1 = globalScope;
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    global$1.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }
    function isNumber(obj) {
        return typeof obj === 'number';
    }
    function isString(obj) {
        return typeof obj === 'string';
    }
    function isArray(obj) {
        return Array.isArray(obj);
    }
    function stringify(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return token.overriddenName;
        }
        if (token.name) {
            return token.name;
        }
        var res = token.toString();
        var newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    var StringWrapper = (function () {
        function StringWrapper() {
        }
        StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
        StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
        StringWrapper.split = function (s, regExp) { return s.split(regExp); };
        StringWrapper.equals = function (s, s2) { return s === s2; };
        StringWrapper.stripLeft = function (s, charVal) {
            if (s && s.length) {
                var pos = 0;
                for (var i = 0; i < s.length; i++) {
                    if (s[i] != charVal)
                        break;
                    pos++;
                }
                s = s.substring(pos);
            }
            return s;
        };
        StringWrapper.stripRight = function (s, charVal) {
            if (s && s.length) {
                var pos = s.length;
                for (var i = s.length - 1; i >= 0; i--) {
                    if (s[i] != charVal)
                        break;
                    pos--;
                }
                s = s.substring(0, pos);
            }
            return s;
        };
        StringWrapper.replace = function (s, from, replace) {
            return s.replace(from, replace);
        };
        StringWrapper.replaceAll = function (s, from, replace) {
            return s.replace(from, replace);
        };
        StringWrapper.slice = function (s, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return s.slice(from, to === null ? undefined : to);
        };
        StringWrapper.replaceAllMapped = function (s, from, cb) {
            return s.replace(from, function () {
                var matches = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    matches[_i - 0] = arguments[_i];
                }
                // Remove offset & string from the result array
                matches.splice(-2, 2);
                // The callback receives match, p1, ..., pn
                return cb(matches);
            });
        };
        StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
        StringWrapper.compare = function (a, b) {
            if (a < b) {
                return -1;
            }
            else if (a > b) {
                return 1;
            }
            else {
                return 0;
            }
        };
        return StringWrapper;
    }());
    var NumberWrapper = (function () {
        function NumberWrapper() {
        }
        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
        NumberWrapper.equal = function (a, b) { return a === b; };
        NumberWrapper.parseIntAutoRadix = function (text) {
            var result = parseInt(text);
            if (isNaN(result)) {
                throw new Error('Invalid integer literal when parsing ' + text);
            }
            return result;
        };
        NumberWrapper.parseInt = function (text, radix) {
            if (radix == 10) {
                if (/^(\-|\+)?[0-9]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else if (radix == 16) {
                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else {
                var result = parseInt(text, radix);
                if (!isNaN(result)) {
                    return result;
                }
            }
            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
        };
        Object.defineProperty(NumberWrapper, "NaN", {
            get: function () { return NaN; },
            enumerable: true,
            configurable: true
        });
        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
        NumberWrapper.isNaN = function (value) { return isNaN(value); };
        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
        return NumberWrapper;
    }());
    // Can't be all uppercase as our transpiler would think it is a special directive...
    var Json = (function () {
        function Json() {
        }
        Json.parse = function (s) { return global$1.JSON.parse(s); };
        Json.stringify = function (data) {
            // Dart doesn't take 3 arguments
            return global$1.JSON.stringify(data, null, 2);
        };
        return Json;
    }());
    function setValueOnPath(global, path, value) {
        var parts = path.split('.');
        var obj = global;
        while (parts.length > 1) {
            var name = parts.shift();
            if (obj.hasOwnProperty(name) && isPresent(obj[name])) {
                obj = obj[name];
            }
            else {
                obj = obj[name] = {};
            }
        }
        if (obj === undefined || obj === null) {
            obj = {};
        }
        obj[parts.shift()] = value;
    }

    var CAMEL_CASE_REGEXP = /([A-Z])/g;
    var DASH_CASE_REGEXP = /-([a-z])/g;
    function camelCaseToDashCase(input) {
        return StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });
    }
    function dashCaseToCamelCase(input) {
        return StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var _DOM = null;
    function getDOM() {
        return _DOM;
    }
    function setRootDomAdapter(adapter) {
        if (!_DOM) {
            _DOM = adapter;
        }
    }
    /* tslint:disable:requireParameterType */
    /**
     * Provides DOM operations in an environment-agnostic way.
     *
     * @security Tread carefully! Interacting with the DOM directly is dangerous and
     * can introduce XSS risks.
     */
    var DomAdapter = (function () {
        function DomAdapter() {
            this.resourceLoaderType = null;
        }
        Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
            /**
             * Maps attribute names to their corresponding property names for cases
             * where attribute name doesn't match property name.
             */
            get: function () { return this._attrToPropMap; },
            set: function (value) { this._attrToPropMap = value; },
            enumerable: true,
            configurable: true
        });
        ;
        ;
        return DomAdapter;
    }());

    var WebAnimationsPlayer = (function () {
        function WebAnimationsPlayer(element, keyframes, options) {
            this.element = element;
            this.keyframes = keyframes;
            this.options = options;
            this._onDoneFns = [];
            this._onStartFns = [];
            this._finished = false;
            this._initialized = false;
            this._started = false;
            this.parentPlayer = null;
            this._duration = options['duration'];
        }
        WebAnimationsPlayer.prototype._onFinish = function () {
            if (!this._finished) {
                this._finished = true;
                if (!isPresent(this.parentPlayer)) {
                    this.destroy();
                }
                this._onDoneFns.forEach(function (fn) { return fn(); });
                this._onDoneFns = [];
            }
        };
        WebAnimationsPlayer.prototype.init = function () {
            var _this = this;
            if (this._initialized)
                return;
            this._initialized = true;
            var keyframes = this.keyframes.map(function (styles) {
                var formattedKeyframe = {};
                Object.keys(styles).forEach(function (prop) {
                    var value = styles[prop];
                    formattedKeyframe[prop] = value == _angular_core.AUTO_STYLE ? _computeStyle(_this.element, prop) : value;
                });
                return formattedKeyframe;
            });
            this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
            // this is required so that the player doesn't start to animate right away
            this.reset();
            this._player.onfinish = function () { return _this._onFinish(); };
        };
        /** @internal */
        WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {
            return element.animate(keyframes, options);
        };
        WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
        WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
        WebAnimationsPlayer.prototype.play = function () {
            this.init();
            if (!this.hasStarted()) {
                this._onStartFns.forEach(function (fn) { return fn(); });
                this._onStartFns = [];
                this._started = true;
            }
            this._player.play();
        };
        WebAnimationsPlayer.prototype.pause = function () {
            this.init();
            this._player.pause();
        };
        WebAnimationsPlayer.prototype.finish = function () {
            this.init();
            this._onFinish();
            this._player.finish();
        };
        WebAnimationsPlayer.prototype.reset = function () { this._player.cancel(); };
        WebAnimationsPlayer.prototype.restart = function () {
            this.reset();
            this.play();
        };
        WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };
        WebAnimationsPlayer.prototype.destroy = function () {
            this.reset();
            this._onFinish();
        };
        Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
            get: function () { return this._duration; },
            enumerable: true,
            configurable: true
        });
        WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.totalTime; };
        WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.totalTime; };
        return WebAnimationsPlayer;
    }());
    function _computeStyle(element, prop) {
        return getDOM().getComputedStyle(element)[prop];
    }

    var WebAnimationsDriver = (function () {
        function WebAnimationsDriver() {
        }
        WebAnimationsDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
            var formattedSteps = [];
            var startingStyleLookup = {};
            if (isPresent(startingStyles) && startingStyles.styles.length > 0) {
                startingStyleLookup = _populateStyles(element, startingStyles, {});
                startingStyleLookup['offset'] = 0;
                formattedSteps.push(startingStyleLookup);
            }
            keyframes.forEach(function (keyframe) {
                var data = _populateStyles(element, keyframe.styles, startingStyleLookup);
                data['offset'] = keyframe.offset;
                formattedSteps.push(data);
            });
            // this is a special case when only styles are applied as an
            // animation. When this occurs we want to animate from start to
            // end with the same values. Removing the offset and having only
            // start/end values is suitable enough for the web-animations API
            if (formattedSteps.length == 1) {
                var start = formattedSteps[0];
                start['offset'] = null;
                formattedSteps = [start, start];
            }
            var playerOptions = {
                'duration': duration,
                'delay': delay,
                'fill': 'both' // we use `both` because it allows for styling at 0% to work with `delay`
            };
            // we check for this to avoid having a null|undefined value be present
            // for the easing (which results in an error for certain browsers #9752)
            if (easing) {
                playerOptions['easing'] = easing;
            }
            return new WebAnimationsPlayer(element, formattedSteps, playerOptions);
        };
        return WebAnimationsDriver;
    }());
    function _populateStyles(element, styles, defaultStyles) {
        var data = {};
        styles.styles.forEach(function (entry) {
            Object.keys(entry).forEach(function (prop) {
                var val = entry[prop];
                var formattedProp = dashCaseToCamelCase(prop);
                data[formattedProp] =
                    val == _angular_core.AUTO_STYLE ? val : val.toString() + _resolveStyleUnit(val, prop, formattedProp);
            });
        });
        Object.keys(defaultStyles).forEach(function (prop) {
            if (!isPresent(data[prop])) {
                data[prop] = defaultStyles[prop];
            }
        });
        return data;
    }
    function _resolveStyleUnit(val, userProvidedProp, formattedProp) {
        var unit = '';
        if (_isPixelDimensionStyle(formattedProp) && val != 0 && val != '0') {
            if (isNumber(val)) {
                unit = 'px';
            }
            else if (_findDimensionalSuffix(val.toString()).length == 0) {
                throw new Error('Please provide a CSS unit value for ' + userProvidedProp + ':' + val);
            }
        }
        return unit;
    }
    var _$0 = 48;
    var _$9 = 57;
    var _$PERIOD = 46;
    function _findDimensionalSuffix(value) {
        for (var i = 0; i < value.length; i++) {
            var c = StringWrapper.charCodeAt(value, i);
            if ((c >= _$0 && c <= _$9) || c == _$PERIOD)
                continue;
            return value.substring(i, value.length);
        }
        return '';
    }
    function _isPixelDimensionStyle(prop) {
        switch (prop) {
            case 'width':
            case 'height':
            case 'minWidth':
            case 'minHeight':
            case 'maxWidth':
            case 'maxHeight':
            case 'left':
            case 'top':
            case 'bottom':
            case 'right':
            case 'fontSize':
            case 'outlineWidth':
            case 'outlineOffset':
            case 'paddingTop':
            case 'paddingLeft':
            case 'paddingBottom':
            case 'paddingRight':
            case 'marginTop':
            case 'marginLeft':
            case 'marginBottom':
            case 'marginRight':
            case 'borderRadius':
            case 'borderWidth':
            case 'borderTopWidth':
            case 'borderLeftWidth':
            case 'borderRightWidth':
            case 'borderBottomWidth':
            case 'textIndent':
                return true;
            default:
                return false;
        }
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Provides DOM operations in any browser environment.
     *
     * @security Tread carefully! Interacting with the DOM directly is dangerous and
     * can introduce XSS risks.
     */
    var GenericBrowserDomAdapter = (function (_super) {
        __extends$1(GenericBrowserDomAdapter, _super);
        function GenericBrowserDomAdapter() {
            var _this = this;
            _super.call(this);
            this._animationPrefix = null;
            this._transitionEnd = null;
            try {
                var element_1 = this.createElement('div', this.defaultDoc());
                if (isPresent(this.getStyle(element_1, 'animationName'))) {
                    this._animationPrefix = '';
                }
                else {
                    var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
                    for (var i = 0; i < domPrefixes.length; i++) {
                        if (isPresent(this.getStyle(element_1, domPrefixes[i] + 'AnimationName'))) {
                            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
                            break;
                        }
                    }
                }
                var transEndEventNames_1 = {
                    WebkitTransition: 'webkitTransitionEnd',
                    MozTransition: 'transitionend',
                    OTransition: 'oTransitionEnd otransitionend',
                    transition: 'transitionend'
                };
                Object.keys(transEndEventNames_1).forEach(function (key) {
                    if (isPresent(_this.getStyle(element_1, key))) {
                        _this._transitionEnd = transEndEventNames_1[key];
                    }
                });
            }
            catch (e) {
                this._animationPrefix = null;
                this._transitionEnd = null;
            }
        }
        GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };
        GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
            el.href = href == null ? baseUrl : baseUrl + '/../' + href;
        };
        GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
        GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
            return typeof this.defaultDoc().body.createShadowRoot === 'function';
        };
        GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () { return this._animationPrefix ? this._animationPrefix : ''; };
        GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return this._transitionEnd ? this._transitionEnd : ''; };
        GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
            return isPresent(this._animationPrefix) && isPresent(this._transitionEnd);
        };
        return GenericBrowserDomAdapter;
    }(DomAdapter));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _attrToPropMap = {
        'class': 'className',
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex',
    };
    var DOM_KEY_LOCATION_NUMPAD = 3;
    // Map to convert some key or keyIdentifier values to what will be returned by getEventKey
    var _keyMap = {
        // The following values are here for cross-browser compatibility and to match the W3C standard
        // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
        '\b': 'Backspace',
        '\t': 'Tab',
        '\x7F': 'Delete',
        '\x1B': 'Escape',
        'Del': 'Delete',
        'Esc': 'Escape',
        'Left': 'ArrowLeft',
        'Right': 'ArrowRight',
        'Up': 'ArrowUp',
        'Down': 'ArrowDown',
        'Menu': 'ContextMenu',
        'Scroll': 'ScrollLock',
        'Win': 'OS'
    };
    // There is a bug in Chrome for numeric keypad keys:
    // https://code.google.com/p/chromium/issues/detail?id=155654
    // 1, 2, 3 ... are reported as A, B, C ...
    var _chromeNumKeyPadMap = {
        'A': '1',
        'B': '2',
        'C': '3',
        'D': '4',
        'E': '5',
        'F': '6',
        'G': '7',
        'H': '8',
        'I': '9',
        'J': '*',
        'K': '+',
        'M': '-',
        'N': '.',
        'O': '/',
        '\x60': '0',
        '\x90': 'NumLock'
    };
    /**
     * A `DomAdapter` powered by full browser DOM APIs.
     *
     * @security Tread carefully! Interacting with the DOM directly is dangerous and
     * can introduce XSS risks.
     */
    /* tslint:disable:requireParameterType */
    var BrowserDomAdapter = (function (_super) {
        __extends(BrowserDomAdapter, _super);
        function BrowserDomAdapter() {
            _super.apply(this, arguments);
        }
        BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };
        BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };
        BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
        BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };
        BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };
        BrowserDomAdapter.prototype.invoke = function (el, methodName, args) { (_a = el)[methodName].apply(_a, args); var _a; };
        // TODO(tbosch): move this into a separate environment class once we have it
        BrowserDomAdapter.prototype.logError = function (error) { (window.console.error || window.console.log)(error); };
        BrowserDomAdapter.prototype.log = function (error) { window.console.log(error); };
        BrowserDomAdapter.prototype.logGroup = function (error) {
            window.console.group && window.console.group(error);
            this.logError(error);
        };
        BrowserDomAdapter.prototype.logGroupEnd = function () { window.console.groupEnd && window.console.groupEnd(); };
        Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
            get: function () { return _attrToPropMap; },
            enumerable: true,
            configurable: true
        });
        BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
        BrowserDomAdapter.prototype.querySelector = function (el, selector) {
            return el.querySelector(selector);
        };
        BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
        BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
        BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
            el.addEventListener(evt, listener, false);
            // Needed to follow Dart's subscription semantic, until fix of
            // https://code.google.com/p/dart/issues/detail?id=17406
            return function () { el.removeEventListener(evt, listener, false); };
        };
        BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
        BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
            var evt = document.createEvent('MouseEvent');
            evt.initEvent(eventType, true, true);
            return evt;
        };
        BrowserDomAdapter.prototype.createEvent = function (eventType) {
            var evt = document.createEvent('Event');
            evt.initEvent(eventType, true, true);
            return evt;
        };
        BrowserDomAdapter.prototype.preventDefault = function (evt) {
            evt.preventDefault();
            evt.returnValue = false;
        };
        BrowserDomAdapter.prototype.isPrevented = function (evt) {
            return evt.defaultPrevented || isPresent(evt.returnValue) && !evt.returnValue;
        };
        BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
        BrowserDomAdapter.prototype.getTemplateContent = function (el) {
            return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
        };
        BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
        BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
        BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
        BrowserDomAdapter.prototype.type = function (node) { return node.type; };
        BrowserDomAdapter.prototype.content = function (node) {
            if (this.hasProperty(node, 'content')) {
                return node.content;
            }
            else {
                return node;
            }
        };
        BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
        BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
        BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
        BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
        BrowserDomAdapter.prototype.childNodesAsList = function (el) {
            var childNodes = el.childNodes;
            var res = new Array(childNodes.length);
            for (var i = 0; i < childNodes.length; i++) {
                res[i] = childNodes[i];
            }
            return res;
        };
        BrowserDomAdapter.prototype.clearNodes = function (el) {
            while (el.firstChild) {
                el.removeChild(el.firstChild);
            }
        };
        BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
        BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
        BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
        BrowserDomAdapter.prototype.remove = function (node) {
            if (node.parentNode) {
                node.parentNode.removeChild(node);
            }
            return node;
        };
        BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };
        BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) {
            nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); });
        };
        BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };
        BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
        BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
        BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
        BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
        BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
        BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
        BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
        BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
        BrowserDomAdapter.prototype.createTemplate = function (html) {
            var t = document.createElement('template');
            t.innerHTML = html;
            return t;
        };
        BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
            if (doc === void 0) { doc = document; }
            return doc.createElement(tagName);
        };
        BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {
            if (doc === void 0) { doc = document; }
            return doc.createElementNS(ns, tagName);
        };
        BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
            if (doc === void 0) { doc = document; }
            return doc.createTextNode(text);
        };
        BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
            if (doc === void 0) { doc = document; }
            var el = doc.createElement('SCRIPT');
            el.setAttribute(attrName, attrValue);
            return el;
        };
        BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
            if (doc === void 0) { doc = document; }
            var style = doc.createElement('style');
            this.appendChild(style, this.createTextNode(css));
            return style;
        };
        BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };
        BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };
        BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };
        BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
        BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
            return element.getElementsByClassName(name);
        };
        BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
            return element.getElementsByTagName(name);
        };
        BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
        BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };
        BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };
        BrowserDomAdapter.prototype.hasClass = function (element, className) {
            return element.classList.contains(className);
        };
        BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {
            element.style[styleName] = styleValue;
        };
        BrowserDomAdapter.prototype.removeStyle = function (element, stylename) {
            // IE requires '' instead of null
            // see https://github.com/angular/angular/issues/7916
            element.style[stylename] = '';
        };
        BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
        BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {
            if (styleValue === void 0) { styleValue = null; }
            var value = this.getStyle(element, styleName) || '';
            return styleValue ? value == styleValue : value.length > 0;
        };
        BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
        BrowserDomAdapter.prototype.attributeMap = function (element) {
            var res = new Map();
            var elAttrs = element.attributes;
            for (var i = 0; i < elAttrs.length; i++) {
                var attrib = elAttrs[i];
                res.set(attrib.name, attrib.value);
            }
            return res;
        };
        BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) {
            return element.hasAttribute(attribute);
        };
        BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {
            return element.hasAttributeNS(ns, attribute);
        };
        BrowserDomAdapter.prototype.getAttribute = function (element, attribute) {
            return element.getAttribute(attribute);
        };
        BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {
            return element.getAttributeNS(ns, name);
        };
        BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
        BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {
            element.setAttributeNS(ns, name, value);
        };
        BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
        BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) {
            element.removeAttributeNS(ns, name);
        };
        BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
        BrowserDomAdapter.prototype.createHtmlDocument = function () {
            return document.implementation.createHTMLDocument('fakeTitle');
        };
        BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
        BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
            try {
                return el.getBoundingClientRect();
            }
            catch (e) {
                return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
            }
        };
        BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
        BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
        BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
            if (n instanceof HTMLElement) {
                return n.matches && n.matches(selector) ||
                    n.msMatchesSelector && n.msMatchesSelector(selector) ||
                    n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
            }
            return false;
        };
        BrowserDomAdapter.prototype.isTemplateElement = function (el) {
            return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
        };
        BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
        BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
        BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
        BrowserDomAdapter.prototype.hasShadowRoot = function (node) {
            return isPresent(node.shadowRoot) && node instanceof HTMLElement;
        };
        BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
        BrowserDomAdapter.prototype.importIntoDoc = function (node) { return document.importNode(this.templateAwareRoot(node), true); };
        BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
        BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };
        BrowserDomAdapter.prototype.getEventKey = function (event) {
            var key = event.key;
            if (isBlank(key)) {
                key = event.keyIdentifier;
                // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
                // Safari cf
                // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
                if (isBlank(key)) {
                    return 'Unidentified';
                }
                if (key.startsWith('U+')) {
                    key = String.fromCharCode(parseInt(key.substring(2), 16));
                    if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                        // There is a bug in Chrome for numeric keypad keys:
                        // https://code.google.com/p/chromium/issues/detail?id=155654
                        // 1, 2, 3 ... are reported as A, B, C ...
                        key = _chromeNumKeyPadMap[key];
                    }
                }
            }
            return _keyMap[key] || key;
        };
        BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
            if (target === 'window') {
                return window;
            }
            if (target === 'document') {
                return document;
            }
            if (target === 'body') {
                return document.body;
            }
        };
        BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
        BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
        BrowserDomAdapter.prototype.getBaseHref = function () {
            var href = getBaseElementHref();
            return isBlank(href) ? null : relativePath(href);
        };
        BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
        BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
        BrowserDomAdapter.prototype.setData = function (element, name, value) {
            this.setAttribute(element, 'data-' + name, value);
        };
        BrowserDomAdapter.prototype.getData = function (element, name) {
            return this.getAttribute(element, 'data-' + name);
        };
        BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
        // TODO(tbosch): move this into a separate environment class once we have it
        BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { setValueOnPath(global$1, path, value); };
        BrowserDomAdapter.prototype.supportsWebAnimation = function () {
            return typeof Element.prototype['animate'] === 'function';
        };
        BrowserDomAdapter.prototype.performanceNow = function () {
            // performance.now() is not available in all browsers, see
            // http://caniuse.com/#search=performance.now
            return window.performance && window.performance.now ? window.performance.now() :
                new Date().getTime();
        };
        BrowserDomAdapter.prototype.supportsCookies = function () { return true; };
        BrowserDomAdapter.prototype.getCookie = function (name) { return parseCookieValue(document.cookie, name); };
        BrowserDomAdapter.prototype.setCookie = function (name, value) {
            // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
            // not clear other cookies.
            document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
        };
        return BrowserDomAdapter;
    }(GenericBrowserDomAdapter));
    var baseElement = null;
    function getBaseElementHref() {
        if (!baseElement) {
            baseElement = document.querySelector('base');
            if (!baseElement) {
                return null;
            }
        }
        return baseElement.getAttribute('href');
    }
    // based on urlUtils.js in AngularJS 1
    var urlParsingNode;
    function relativePath(url) {
        if (!urlParsingNode) {
            urlParsingNode = document.createElement('a');
        }
        urlParsingNode.setAttribute('href', url);
        return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
            '/' + urlParsingNode.pathname;
    }
    function parseCookieValue(cookieStr, name) {
        name = encodeURIComponent(name);
        for (var _i = 0, _a = cookieStr.split(';'); _i < _a.length; _i++) {
            var cookie = _a[_i];
            var eqIndex = cookie.indexOf('=');
            var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)], cookieName = _b[0], cookieValue = _b[1];
            if (cookieName.trim() === name) {
                return decodeURIComponent(cookieValue);
            }
        }
        return null;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function supportsState() {
        return !!window.history.pushState;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$2 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
     * This class should not be used directly by an application developer. Instead, use
     * {@link Location}.
     */
    var BrowserPlatformLocation = (function (_super) {
        __extends$2(BrowserPlatformLocation, _super);
        function BrowserPlatformLocation() {
            _super.call(this);
            this._init();
        }
        // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it
        /** @internal */
        BrowserPlatformLocation.prototype._init = function () {
            this._location = getDOM().getLocation();
            this._history = getDOM().getHistory();
        };
        Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
            get: function () { return this._location; },
            enumerable: true,
            configurable: true
        });
        BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return getDOM().getBaseHref(); };
        BrowserPlatformLocation.prototype.onPopState = function (fn) {
            getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
        };
        BrowserPlatformLocation.prototype.onHashChange = function (fn) {
            getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
        };
        Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
            get: function () { return this._location.pathname; },
            set: function (newPath) { this._location.pathname = newPath; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
            get: function () { return this._location.search; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
            get: function () { return this._location.hash; },
            enumerable: true,
            configurable: true
        });
        BrowserPlatformLocation.prototype.pushState = function (state, title, url) {
            if (supportsState()) {
                this._history.pushState(state, title, url);
            }
            else {
                this._location.hash = url;
            }
        };
        BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {
            if (supportsState()) {
                this._history.replaceState(state, title, url);
            }
            else {
                this._location.hash = url;
            }
        };
        BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };
        BrowserPlatformLocation.prototype.back = function () { this._history.back(); };
        BrowserPlatformLocation.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        BrowserPlatformLocation.ctorParameters = [];
        return BrowserPlatformLocation;
    }(_angular_common.PlatformLocation));

    var _clearValues = (function () {
        if ((new Map()).keys().next) {
            return function _clearValues(m) {
                var keyIterator = m.keys();
                var k;
                while (!((k = keyIterator.next()).done)) {
                    m.set(k.value, null);
                }
            };
        }
        else {
            return function _clearValuesWithForeEach(m) {
                m.forEach(function (v, k) { m.set(k, null); });
            };
        }
    })();
    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
    var _arrayFromMap = (function () {
        try {
            if ((new Map()).values().next) {
                return function createArrayFromMap(m, getValues) {
                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
                };
            }
        }
        catch (e) {
        }
        return function createArrayFromMapWithForeach(m, getValues) {
            var res = new Array(m.size), i = 0;
            m.forEach(function (v, k) {
                res[i] = getValues ? v : k;
                i++;
            });
            return res;
        };
    })();
    /**
     * Wraps Javascript Objects
     */
    var StringMapWrapper = (function () {
        function StringMapWrapper() {
        }
        StringMapWrapper.merge = function (m1, m2) {
            var m = {};
            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
                var k = _a[_i];
                m[k] = m1[k];
            }
            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
                var k = _c[_b];
                m[k] = m2[k];
            }
            return m;
        };
        StringMapWrapper.equals = function (m1, m2) {
            var k1 = Object.keys(m1);
            var k2 = Object.keys(m2);
            if (k1.length != k2.length) {
                return false;
            }
            for (var i = 0; i < k1.length; i++) {
                var key = k1[i];
                if (m1[key] !== m2[key]) {
                    return false;
                }
            }
            return true;
        };
        return StringMapWrapper;
    }());
    var ListWrapper = (function () {
        function ListWrapper() {
        }
        // JS has no way to express a statically fixed size list, but dart does so we
        // keep both methods.
        ListWrapper.createFixedSize = function (size) { return new Array(size); };
        ListWrapper.createGrowableSize = function (size) { return new Array(size); };
        ListWrapper.clone = function (array) { return array.slice(0); };
        ListWrapper.forEachWithIndex = function (array, fn) {
            for (var i = 0; i < array.length; i++) {
                fn(array[i], i);
            }
        };
        ListWrapper.first = function (array) {
            if (!array)
                return null;
            return array[0];
        };
        ListWrapper.last = function (array) {
            if (!array || array.length == 0)
                return null;
            return array[array.length - 1];
        };
        ListWrapper.indexOf = function (array, value, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            return array.indexOf(value, startIndex);
        };
        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
        ListWrapper.reversed = function (array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
        };
        ListWrapper.concat = function (a, b) { return a.concat(b); };
        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
        ListWrapper.removeAt = function (list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
        };
        ListWrapper.removeAll = function (list, items) {
            for (var i = 0; i < items.length; ++i) {
                var index = list.indexOf(items[i]);
                list.splice(index, 1);
            }
        };
        ListWrapper.remove = function (list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
                return true;
            }
            return false;
        };
        ListWrapper.clear = function (list) { list.length = 0; };
        ListWrapper.isEmpty = function (list) { return list.length == 0; };
        ListWrapper.fill = function (list, value, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = null; }
            list.fill(value, start, end === null ? list.length : end);
        };
        ListWrapper.equals = function (a, b) {
            if (a.length != b.length)
                return false;
            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        };
        ListWrapper.slice = function (l, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return l.slice(from, to === null ? undefined : to);
        };
        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
        ListWrapper.sort = function (l, compareFn) {
            if (isPresent(compareFn)) {
                l.sort(compareFn);
            }
            else {
                l.sort();
            }
        };
        ListWrapper.toString = function (l) { return l.toString(); };
        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
        ListWrapper.maximum = function (list, predicate) {
            if (list.length == 0) {
                return null;
            }
            var solution = null;
            var maxValue = -Infinity;
            for (var index = 0; index < list.length; index++) {
                var candidate = list[index];
                if (isBlank(candidate)) {
                    continue;
                }
                var candidateValue = predicate(candidate);
                if (candidateValue > maxValue) {
                    solution = candidate;
                    maxValue = candidateValue;
                }
            }
            return solution;
        };
        ListWrapper.flatten = function (list) {
            var target = [];
            _flattenArray(list, target);
            return target;
        };
        ListWrapper.addAll = function (list, source) {
            for (var i = 0; i < source.length; i++) {
                list.push(source[i]);
            }
        };
        return ListWrapper;
    }());
    function _flattenArray(source, target) {
        if (isPresent(source)) {
            for (var i = 0; i < source.length; i++) {
                var item = source[i];
                if (isArray(item)) {
                    _flattenArray(item, target);
                }
                else {
                    target.push(item);
                }
            }
        }
        return target;
    }

    var BrowserGetTestability = (function () {
        function BrowserGetTestability() {
        }
        BrowserGetTestability.init = function () { _angular_core.setTestabilityGetter(new BrowserGetTestability()); };
        BrowserGetTestability.prototype.addToWindow = function (registry) {
            global$1.getAngularTestability = function (elem, findInAncestors) {
                if (findInAncestors === void 0) { findInAncestors = true; }
                var testability = registry.findTestabilityInTree(elem, findInAncestors);
                if (testability == null) {
                    throw new Error('Could not find testability for element.');
                }
                return testability;
            };
            global$1.getAllAngularTestabilities = function () { return registry.getAllTestabilities(); };
            global$1.getAllAngularRootElements = function () { return registry.getAllRootElements(); };
            var whenAllStable = function (callback /** TODO #9100 */) {
                var testabilities = global$1.getAllAngularTestabilities();
                var count = testabilities.length;
                var didWork = false;
                var decrement = function (didWork_ /** TODO #9100 */) {
                    didWork = didWork || didWork_;
                    count--;
                    if (count == 0) {
                        callback(didWork);
                    }
                };
                testabilities.forEach(function (testability /** TODO #9100 */) {
                    testability.whenStable(decrement);
                });
            };
            if (!global$1['frameworkStabilizers']) {
                global$1['frameworkStabilizers'] = ListWrapper.createGrowableSize(0);
            }
            global$1['frameworkStabilizers'].push(whenAllStable);
        };
        BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
            if (elem == null) {
                return null;
            }
            var t = registry.getTestability(elem);
            if (isPresent(t)) {
                return t;
            }
            else if (!findInAncestors) {
                return null;
            }
            if (getDOM().isShadowRoot(elem)) {
                return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
            }
            return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
        };
        return BrowserGetTestability;
    }());

    /**
     * A service that can be used to get and set the title of a current HTML document.
     *
     * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
     * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
     * (representing the `<title>` tag). Instead, this service can be used to set and get the current
     * title value.
     *
     * @experimental
     */
    var Title = (function () {
        function Title() {
        }
        /**
         * Get the title of the current HTML document.
         * @returns {string}
         */
        Title.prototype.getTitle = function () { return getDOM().getTitle(); };
        /**
         * Set the title of the current HTML document.
         * @param newTitle
         */
        Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(newTitle); };
        return Title;
    }());

    /**
     * A DI Token representing the main rendering context. In a browser this is the DOM Document.
     *
     * Note: Document might not be available in the Application Context when Application and Rendering
     * Contexts are not the same (e.g. when running the application into a Web Worker).
     *
     * @stable
     */
    var DOCUMENT = new _angular_core.OpaqueToken('DocumentToken');

    /**
     * @stable
     */
    var EVENT_MANAGER_PLUGINS = new _angular_core.OpaqueToken('EventManagerPlugins');
    /**
     * @stable
     */
    var EventManager = (function () {
        function EventManager(plugins, _zone) {
            var _this = this;
            this._zone = _zone;
            plugins.forEach(function (p) { return p.manager = _this; });
            this._plugins = plugins.slice().reverse();
        }
        EventManager.prototype.addEventListener = function (element, eventName, handler) {
            var plugin = this._findPluginFor(eventName);
            return plugin.addEventListener(element, eventName, handler);
        };
        EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
            var plugin = this._findPluginFor(eventName);
            return plugin.addGlobalEventListener(target, eventName, handler);
        };
        EventManager.prototype.getZone = function () { return this._zone; };
        /** @internal */
        EventManager.prototype._findPluginFor = function (eventName) {
            var plugins = this._plugins;
            for (var i = 0; i < plugins.length; i++) {
                var plugin = plugins[i];
                if (plugin.supports(eventName)) {
                    return plugin;
                }
            }
            throw new Error("No event manager plugin found for event " + eventName);
        };
        EventManager.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        EventManager.ctorParameters = [
            { type: Array, decorators: [{ type: _angular_core.Inject, args: [EVENT_MANAGER_PLUGINS,] },] },
            { type: _angular_core.NgZone, },
        ];
        return EventManager;
    }());
    var EventManagerPlugin = (function () {
        function EventManagerPlugin() {
        }
        // That is equivalent to having supporting $event.target
        EventManagerPlugin.prototype.supports = function (eventName) { return false; };
        EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {
            throw 'not implemented';
        };
        EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
            throw 'not implemented';
        };
        return EventManagerPlugin;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$4 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var SharedStylesHost = (function () {
        function SharedStylesHost() {
            /** @internal */
            this._styles = [];
            /** @internal */
            this._stylesSet = new Set();
        }
        SharedStylesHost.prototype.addStyles = function (styles) {
            var _this = this;
            var additions = [];
            styles.forEach(function (style) {
                if (!_this._stylesSet.has(style)) {
                    _this._stylesSet.add(style);
                    _this._styles.push(style);
                    additions.push(style);
                }
            });
            this.onStylesAdded(additions);
        };
        SharedStylesHost.prototype.onStylesAdded = function (additions) { };
        SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };
        SharedStylesHost.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        SharedStylesHost.ctorParameters = [];
        return SharedStylesHost;
    }());
    var DomSharedStylesHost = (function (_super) {
        __extends$4(DomSharedStylesHost, _super);
        function DomSharedStylesHost(doc) {
            _super.call(this);
            this._hostNodes = new Set();
            this._hostNodes.add(doc.head);
        }
        /** @internal */
        DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
            for (var i = 0; i < styles.length; i++) {
                var style = styles[i];
                getDOM().appendChild(host, getDOM().createStyleElement(style));
            }
        };
        DomSharedStylesHost.prototype.addHost = function (hostNode) {
            this._addStylesToHost(this._styles, hostNode);
            this._hostNodes.add(hostNode);
        };
        DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };
        DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
            var _this = this;
            this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });
        };
        DomSharedStylesHost.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        DomSharedStylesHost.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },
        ];
        return DomSharedStylesHost;
    }(SharedStylesHost));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$3 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var NAMESPACE_URIS = {
        'xlink': 'http://www.w3.org/1999/xlink',
        'svg': 'http://www.w3.org/2000/svg',
        'xhtml': 'http://www.w3.org/1999/xhtml'
    };
    var TEMPLATE_COMMENT_TEXT = 'template bindings={}';
    var TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/;
    var DomRootRenderer = (function () {
        function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver) {
            this.document = document;
            this.eventManager = eventManager;
            this.sharedStylesHost = sharedStylesHost;
            this.animationDriver = animationDriver;
            this.registeredComponents = new Map();
        }
        DomRootRenderer.prototype.renderComponent = function (componentProto) {
            var renderer = this.registeredComponents.get(componentProto.id);
            if (!renderer) {
                renderer = new DomRenderer(this, componentProto, this.animationDriver);
                this.registeredComponents.set(componentProto.id, renderer);
            }
            return renderer;
        };
        return DomRootRenderer;
    }());
    var DomRootRenderer_ = (function (_super) {
        __extends$3(DomRootRenderer_, _super);
        function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver) {
            _super.call(this, _document, _eventManager, sharedStylesHost, animationDriver);
        }
        DomRootRenderer_.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        DomRootRenderer_.ctorParameters = [
            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [DOCUMENT,] },] },
            { type: EventManager, },
            { type: DomSharedStylesHost, },
            { type: AnimationDriver, },
        ];
        return DomRootRenderer_;
    }(DomRootRenderer));
    var DomRenderer = (function () {
        function DomRenderer(_rootRenderer, componentProto, _animationDriver) {
            this._rootRenderer = _rootRenderer;
            this.componentProto = componentProto;
            this._animationDriver = _animationDriver;
            this._styles = _flattenStyles(componentProto.id, componentProto.styles, []);
            if (componentProto.encapsulation !== _angular_core.ViewEncapsulation.Native) {
                this._rootRenderer.sharedStylesHost.addStyles(this._styles);
            }
            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Emulated) {
                this._contentAttr = _shimContentAttribute(componentProto.id);
                this._hostAttr = _shimHostAttribute(componentProto.id);
            }
            else {
                this._contentAttr = null;
                this._hostAttr = null;
            }
        }
        DomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
            var el;
            if (isString(selectorOrNode)) {
                el = getDOM().querySelector(this._rootRenderer.document, selectorOrNode);
                if (isBlank(el)) {
                    throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
                }
            }
            else {
                el = selectorOrNode;
            }
            getDOM().clearNodes(el);
            return el;
        };
        DomRenderer.prototype.createElement = function (parent, name, debugInfo) {
            var nsAndName = splitNamespace(name);
            var el = isPresent(nsAndName[0]) ?
                getDOM().createElementNS(NAMESPACE_URIS[nsAndName[0]], nsAndName[1]) :
                getDOM().createElement(nsAndName[1]);
            if (isPresent(this._contentAttr)) {
                getDOM().setAttribute(el, this._contentAttr, '');
            }
            if (isPresent(parent)) {
                getDOM().appendChild(parent, el);
            }
            return el;
        };
        DomRenderer.prototype.createViewRoot = function (hostElement) {
            var nodesParent;
            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native) {
                nodesParent = getDOM().createShadowRoot(hostElement);
                this._rootRenderer.sharedStylesHost.addHost(nodesParent);
                for (var i = 0; i < this._styles.length; i++) {
                    getDOM().appendChild(nodesParent, getDOM().createStyleElement(this._styles[i]));
                }
            }
            else {
                if (isPresent(this._hostAttr)) {
                    getDOM().setAttribute(hostElement, this._hostAttr, '');
                }
                nodesParent = hostElement;
            }
            return nodesParent;
        };
        DomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
            var comment = getDOM().createComment(TEMPLATE_COMMENT_TEXT);
            if (isPresent(parentElement)) {
                getDOM().appendChild(parentElement, comment);
            }
            return comment;
        };
        DomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
            var node = getDOM().createTextNode(value);
            if (isPresent(parentElement)) {
                getDOM().appendChild(parentElement, node);
            }
            return node;
        };
        DomRenderer.prototype.projectNodes = function (parentElement, nodes) {
            if (isBlank(parentElement))
                return;
            appendNodes(parentElement, nodes);
        };
        DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) { moveNodesAfterSibling(node, viewRootNodes); };
        DomRenderer.prototype.detachView = function (viewRootNodes) {
            for (var i = 0; i < viewRootNodes.length; i++) {
                getDOM().remove(viewRootNodes[i]);
            }
        };
        DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
            if (this.componentProto.encapsulation === _angular_core.ViewEncapsulation.Native && isPresent(hostElement)) {
                this._rootRenderer.sharedStylesHost.removeHost(getDOM().getShadowRoot(hostElement));
            }
        };
        DomRenderer.prototype.listen = function (renderElement, name, callback) {
            return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
        };
        DomRenderer.prototype.listenGlobal = function (target, name, callback) {
            return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
        };
        DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
            getDOM().setProperty(renderElement, propertyName, propertyValue);
        };
        DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
            var attrNs;
            var nsAndName = splitNamespace(attributeName);
            if (isPresent(nsAndName[0])) {
                attributeName = nsAndName[0] + ':' + nsAndName[1];
                attrNs = NAMESPACE_URIS[nsAndName[0]];
            }
            if (isPresent(attributeValue)) {
                if (isPresent(attrNs)) {
                    getDOM().setAttributeNS(renderElement, attrNs, attributeName, attributeValue);
                }
                else {
                    getDOM().setAttribute(renderElement, attributeName, attributeValue);
                }
            }
            else {
                if (isPresent(attrNs)) {
                    getDOM().removeAttributeNS(renderElement, attrNs, nsAndName[1]);
                }
                else {
                    getDOM().removeAttribute(renderElement, attributeName);
                }
            }
        };
        DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
            var dashCasedPropertyName = camelCaseToDashCase(propertyName);
            if (getDOM().isCommentNode(renderElement)) {
                var existingBindings = StringWrapper.replaceAll(getDOM().getText(renderElement), /\n/g, '')
                    .match(TEMPLATE_BINDINGS_EXP);
                var parsedBindings = Json.parse(existingBindings[1]);
                parsedBindings[dashCasedPropertyName] = propertyValue;
                getDOM().setText(renderElement, StringWrapper.replace(TEMPLATE_COMMENT_TEXT, '{}', Json.stringify(parsedBindings)));
            }
            else {
                this.setElementAttribute(renderElement, propertyName, propertyValue);
            }
        };
        DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
            if (isAdd) {
                getDOM().addClass(renderElement, className);
            }
            else {
                getDOM().removeClass(renderElement, className);
            }
        };
        DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
            if (isPresent(styleValue)) {
                getDOM().setStyle(renderElement, styleName, stringify(styleValue));
            }
            else {
                getDOM().removeStyle(renderElement, styleName);
            }
        };
        DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
            getDOM().invoke(renderElement, methodName, args);
        };
        DomRenderer.prototype.setText = function (renderNode, text) { getDOM().setText(renderNode, text); };
        DomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing) {
            return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing);
        };
        return DomRenderer;
    }());
    function moveNodesAfterSibling(sibling /** TODO #9100 */, nodes /** TODO #9100 */) {
        var parent = getDOM().parentElement(sibling);
        if (nodes.length > 0 && isPresent(parent)) {
            var nextSibling = getDOM().nextSibling(sibling);
            if (isPresent(nextSibling)) {
                for (var i = 0; i < nodes.length; i++) {
                    getDOM().insertBefore(nextSibling, nodes[i]);
                }
            }
            else {
                for (var i = 0; i < nodes.length; i++) {
                    getDOM().appendChild(parent, nodes[i]);
                }
            }
        }
    }
    function appendNodes(parent /** TODO #9100 */, nodes /** TODO #9100 */) {
        for (var i = 0; i < nodes.length; i++) {
            getDOM().appendChild(parent, nodes[i]);
        }
    }
    function decoratePreventDefault(eventHandler) {
        return function (event /** TODO #9100 */) {
            var allowDefaultBehavior = eventHandler(event);
            if (allowDefaultBehavior === false) {
                // TODO(tbosch): move preventDefault into event plugins...
                getDOM().preventDefault(event);
            }
        };
    }
    var COMPONENT_REGEX = /%COMP%/g;
    var COMPONENT_VARIABLE = '%COMP%';
    var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
    var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
    function _shimContentAttribute(componentShortId) {
        return StringWrapper.replaceAll(CONTENT_ATTR, COMPONENT_REGEX, componentShortId);
    }
    function _shimHostAttribute(componentShortId) {
        return StringWrapper.replaceAll(HOST_ATTR, COMPONENT_REGEX, componentShortId);
    }
    function _flattenStyles(compId, styles, target) {
        for (var i = 0; i < styles.length; i++) {
            var style = styles[i];
            if (isArray(style)) {
                _flattenStyles(compId, style, target);
            }
            else {
                style = StringWrapper.replaceAll(style, COMPONENT_REGEX, compId);
                target.push(style);
            }
        }
        return target;
    }
    var NS_PREFIX_RE = /^:([^:]+):(.+)$/;
    function splitNamespace(name) {
        if (name[0] != ':') {
            return [null, name];
        }
        var match = name.match(NS_PREFIX_RE);
        return [match[1], match[2]];
    }

    var CORE_TOKENS = {
        'ApplicationRef': _angular_core.ApplicationRef,
        'NgZone': _angular_core.NgZone
    };
    var INSPECT_GLOBAL_NAME = 'ng.probe';
    var CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
    /**
     * Returns a {@link DebugElement} for the given native DOM element, or
     * null if the given native element does not have an Angular view associated
     * with it.
     */
    function inspectNativeElement(element /** TODO #9100 */) {
        return _angular_core.getDebugNode(element);
    }
    /**
     * @experimental
     */
    var NgProbeToken = (function () {
        function NgProbeToken(name, token) {
            this.name = name;
            this.token = token;
        }
        return NgProbeToken;
    }());
    function _createConditionalRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {
        if (_angular_core.isDevMode()) {
            return _createRootRenderer(rootRenderer, extraTokens);
        }
        return rootRenderer;
    }
    function _createRootRenderer(rootRenderer /** TODO #9100 */, extraTokens) {
        getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
        getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, StringMapWrapper.merge(CORE_TOKENS, _ngProbeTokensToMap(extraTokens || [])));
        return new DebugDomRootRenderer(rootRenderer);
    }
    function _ngProbeTokensToMap(tokens) {
        return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});
    }
    /**
     * Providers which support debugging Angular applications (e.g. via `ng.probe`).
     */
    var ELEMENT_PROBE_PROVIDERS = [{
            provide: _angular_core.RootRenderer,
            useFactory: _createConditionalRootRenderer,
            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]
        }];
    var ELEMENT_PROBE_PROVIDERS_PROD_MODE = [{
            provide: _angular_core.RootRenderer,
            useFactory: _createRootRenderer,
            deps: [DomRootRenderer, [NgProbeToken, new _angular_core.Optional()]]
        }];

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$5 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var DomEventsPlugin = (function (_super) {
        __extends$5(DomEventsPlugin, _super);
        function DomEventsPlugin() {
            _super.apply(this, arguments);
        }
        // This plugin should come last in the list of plugins, because it accepts all
        // events.
        DomEventsPlugin.prototype.supports = function (eventName) { return true; };
        DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
            var zone = this.manager.getZone();
            var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };
            return this.manager.getZone().runOutsideAngular(function () { return getDOM().onAndCancel(element, eventName, outsideHandler); });
        };
        DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {
            var element = getDOM().getGlobalEventTarget(target);
            var zone = this.manager.getZone();
            var outsideHandler = function (event /** TODO #9100 */) { return zone.runGuarded(function () { return handler(event); }); };
            return this.manager.getZone().runOutsideAngular(function () { return getDOM().onAndCancel(element, eventName, outsideHandler); });
        };
        DomEventsPlugin.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        DomEventsPlugin.ctorParameters = [];
        return DomEventsPlugin;
    }(EventManagerPlugin));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$7 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var _eventNames = {
        // pan
        'pan': true,
        'panstart': true,
        'panmove': true,
        'panend': true,
        'pancancel': true,
        'panleft': true,
        'panright': true,
        'panup': true,
        'pandown': true,
        // pinch
        'pinch': true,
        'pinchstart': true,
        'pinchmove': true,
        'pinchend': true,
        'pinchcancel': true,
        'pinchin': true,
        'pinchout': true,
        // press
        'press': true,
        'pressup': true,
        // rotate
        'rotate': true,
        'rotatestart': true,
        'rotatemove': true,
        'rotateend': true,
        'rotatecancel': true,
        // swipe
        'swipe': true,
        'swipeleft': true,
        'swiperight': true,
        'swipeup': true,
        'swipedown': true,
        // tap
        'tap': true,
    };
    var HammerGesturesPluginCommon = (function (_super) {
        __extends$7(HammerGesturesPluginCommon, _super);
        function HammerGesturesPluginCommon() {
            _super.call(this);
        }
        HammerGesturesPluginCommon.prototype.supports = function (eventName) {
            return _eventNames.hasOwnProperty(eventName.toLowerCase());
        };
        return HammerGesturesPluginCommon;
    }(EventManagerPlugin));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$6 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure
     * Hammer gestures.
     *
     * @experimental
     */
    var HAMMER_GESTURE_CONFIG = new _angular_core.OpaqueToken('HammerGestureConfig');
    /**
     * @experimental
     */
    var HammerGestureConfig = (function () {
        function HammerGestureConfig() {
            this.events = [];
            this.overrides = {};
        }
        HammerGestureConfig.prototype.buildHammer = function (element) {
            var mc = new Hammer(element);
            mc.get('pinch').set({ enable: true });
            mc.get('rotate').set({ enable: true });
            for (var eventName in this.overrides) {
                mc.get(eventName).set(this.overrides[eventName]);
            }
            return mc;
        };
        HammerGestureConfig.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        HammerGestureConfig.ctorParameters = [];
        return HammerGestureConfig;
    }());
    var HammerGesturesPlugin = (function (_super) {
        __extends$6(HammerGesturesPlugin, _super);
        function HammerGesturesPlugin(_config) {
            _super.call(this);
            this._config = _config;
        }
        HammerGesturesPlugin.prototype.supports = function (eventName) {
            if (!_super.prototype.supports.call(this, eventName) && !this.isCustomEvent(eventName))
                return false;
            if (!isPresent(window['Hammer'])) {
                throw new Error("Hammer.js is not loaded, can not bind " + eventName + " event");
            }
            return true;
        };
        HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
            var _this = this;
            var zone = this.manager.getZone();
            eventName = eventName.toLowerCase();
            return zone.runOutsideAngular(function () {
                // Creating the manager bind events, must be done outside of angular
                var mc = _this._config.buildHammer(element);
                var callback = function (eventObj /** TODO #???? */) {
                    zone.runGuarded(function () { handler(eventObj); });
                };
                mc.on(eventName, callback);
                return function () { mc.off(eventName, callback); };
            });
        };
        HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };
        HammerGesturesPlugin.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        HammerGesturesPlugin.ctorParameters = [
            { type: HammerGestureConfig, decorators: [{ type: _angular_core.Inject, args: [HAMMER_GESTURE_CONFIG,] },] },
        ];
        return HammerGesturesPlugin;
    }(HammerGesturesPluginCommon));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$8 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var modifierKeys = ['alt', 'control', 'meta', 'shift'];
    var modifierKeyGetters = {
        'alt': function (event) { return event.altKey; },
        'control': function (event) { return event.ctrlKey; },
        'meta': function (event) { return event.metaKey; },
        'shift': function (event) { return event.shiftKey; }
    };
    /**
     * @experimental
     */
    var KeyEventsPlugin = (function (_super) {
        __extends$8(KeyEventsPlugin, _super);
        function KeyEventsPlugin() {
            _super.call(this);
        }
        KeyEventsPlugin.prototype.supports = function (eventName) {
            return isPresent(KeyEventsPlugin.parseEventName(eventName));
        };
        KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
            var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
            var outsideHandler = KeyEventsPlugin.eventCallback(element, parsedEvent['fullKey'], handler, this.manager.getZone());
            return this.manager.getZone().runOutsideAngular(function () {
                return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
            });
        };
        KeyEventsPlugin.parseEventName = function (eventName) {
            var parts = eventName.toLowerCase().split('.');
            var domEventName = parts.shift();
            if ((parts.length === 0) ||
                !(StringWrapper.equals(domEventName, 'keydown') ||
                    StringWrapper.equals(domEventName, 'keyup'))) {
                return null;
            }
            var key = KeyEventsPlugin._normalizeKey(parts.pop());
            var fullKey = '';
            modifierKeys.forEach(function (modifierName) {
                if (ListWrapper.contains(parts, modifierName)) {
                    ListWrapper.remove(parts, modifierName);
                    fullKey += modifierName + '.';
                }
            });
            fullKey += key;
            if (parts.length != 0 || key.length === 0) {
                // returning null instead of throwing to let another plugin process the event
                return null;
            }
            var result = {};
            result['domEventName'] = domEventName;
            result['fullKey'] = fullKey;
            return result;
        };
        KeyEventsPlugin.getEventFullKey = function (event) {
            var fullKey = '';
            var key = getDOM().getEventKey(event);
            key = key.toLowerCase();
            if (StringWrapper.equals(key, ' ')) {
                key = 'space'; // for readability
            }
            else if (StringWrapper.equals(key, '.')) {
                key = 'dot'; // because '.' is used as a separator in event names
            }
            modifierKeys.forEach(function (modifierName) {
                if (modifierName != key) {
                    var modifierGetter = modifierKeyGetters[modifierName];
                    if (modifierGetter(event)) {
                        fullKey += modifierName + '.';
                    }
                }
            });
            fullKey += key;
            return fullKey;
        };
        KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {
            return function (event /** TODO #9100 */) {
                if (StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
                    zone.runGuarded(function () { return handler(event); });
                }
            };
        };
        /** @internal */
        KeyEventsPlugin._normalizeKey = function (keyName) {
            // TODO: switch to a StringMap if the mapping grows too much
            switch (keyName) {
                case 'esc':
                    return 'escape';
                default:
                    return keyName;
            }
        };
        KeyEventsPlugin.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        KeyEventsPlugin.ctorParameters = [];
        return KeyEventsPlugin;
    }(EventManagerPlugin));

    /**
     * A pattern that recognizes a commonly useful subset of URLs that are safe.
     *
     * This regular expression matches a subset of URLs that will not cause script
     * execution if used in URL context within a HTML document. Specifically, this
     * regular expression matches if (comment from here on and regex copied from
     * Soy's EscapingConventions):
     * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
     * (2) or no protocol.  A protocol must be followed by a colon. The below
     *     allows that by allowing colons only after one of the characters [/?#].
     *     A colon after a hash (#) must be in the fragment.
     *     Otherwise, a colon after a (?) must be in a query.
     *     Otherwise, a colon after a single solidus (/) must be in a path.
     *     Otherwise, a colon after a double solidus (//) must be in the authority
     *     (before port).
     *
     * The pattern disallows &, used in HTML entity declarations before
     * one of the characters in [/?#]. This disallows HTML entities used in the
     * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
     * It also disallows HTML entities in the first path part of a relative path,
     * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
     * that. More importantly, it disallows masking of a colon,
     * e.g. "javascript&#58;...".
     *
     * This regular expression was taken from the Closure sanitization library.
     */
    var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
    /** A pattern that matches safe data URLs. Only matches image, video and audio types. */
    var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
    function sanitizeUrl(url) {
        url = String(url);
        if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
            return url;
        if (_angular_core.isDevMode()) {
            getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
        }
        return 'unsafe:' + url;
    }
    function sanitizeSrcset(srcset) {
        srcset = String(srcset);
        return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');
    }

    /** A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below. */
    var inertElement = null;
    /** Lazily initialized to make sure the DOM adapter gets set before use. */
    var DOM = null;
    /** Returns an HTML element that is guaranteed to not execute code when creating elements in it. */
    function getInertElement() {
        if (inertElement)
            return inertElement;
        DOM = getDOM();
        // Prefer using <template> element if supported.
        var templateEl = DOM.createElement('template');
        if ('content' in templateEl)
            return templateEl;
        var doc = DOM.createHtmlDocument();
        inertElement = DOM.querySelector(doc, 'body');
        if (inertElement == null) {
            // usually there should be only one body element in the document, but IE doesn't have any, so we
            // need to create one.
            var html = DOM.createElement('html', doc);
            inertElement = DOM.createElement('body', doc);
            DOM.appendChild(html, inertElement);
            DOM.appendChild(doc, html);
        }
        return inertElement;
    }
    function tagSet(tags) {
        var res = {};
        for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {
            var t = _a[_i];
            res[t] = true;
        }
        return res;
    }
    function merge() {
        var sets = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            sets[_i - 0] = arguments[_i];
        }
        var res = {};
        for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {
            var s = sets_1[_a];
            for (var v in s) {
                if (s.hasOwnProperty(v))
                    res[v] = true;
            }
        }
        return res;
    }
    // Good source of info about elements and attributes
    // http://dev.w3.org/html5/spec/Overview.html#semantics
    // http://simon.html5.org/html-elements
    // Safe Void Elements - HTML5
    // http://dev.w3.org/html5/spec/Overview.html#void-elements
    var VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
    // Elements that you can, intentionally, leave open (and which close themselves)
    // http://dev.w3.org/html5/spec/Overview.html#optional-tags
    var OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
    var OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
    var OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
    // Safe Block Elements - HTML5
    var BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
    // Inline Elements - HTML5
    var INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
    var VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
    // Attributes that have href and hence need to be sanitized
    var URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
    // Attributes that have special href set hence need to be sanitized
    var SRCSET_ATTRS = tagSet('srcset');
    var HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
        'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
        'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
        'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
        'valign,value,vspace,width');
    // NB: This currently conciously doesn't support SVG. SVG sanitization has had several security
    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
    // innerHTML is required, SVG attributes should be added here.
    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
    // can be sanitized, but they increase security surface area without a legitimate use case, so they
    // are left out here.
    var VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
    /**
     * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
     * attributes.
     */
    var SanitizingHtmlSerializer = (function () {
        function SanitizingHtmlSerializer() {
            // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
            // because characters were re-encoded.
            this.sanitizedSomething = false;
            this.buf = [];
        }
        SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {
            // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
            // However this code never accesses properties off of `document` before deleting its contents
            // again, so it shouldn't be vulnerable to DOM clobbering.
            var current = el.firstChild;
            while (current) {
                if (DOM.isElementNode(current)) {
                    this.startElement(current);
                }
                else if (DOM.isTextNode(current)) {
                    this.chars(DOM.nodeValue(current));
                }
                else {
                    // Strip non-element, non-text nodes.
                    this.sanitizedSomething = true;
                }
                if (DOM.firstChild(current)) {
                    current = DOM.firstChild(current);
                    continue;
                }
                while (current) {
                    // Leaving the element. Walk up and to the right, closing tags as we go.
                    if (DOM.isElementNode(current)) {
                        this.endElement(current);
                    }
                    if (DOM.nextSibling(current)) {
                        current = DOM.nextSibling(current);
                        break;
                    }
                    current = DOM.parentElement(current);
                }
            }
            return this.buf.join('');
        };
        SanitizingHtmlSerializer.prototype.startElement = function (element) {
            var _this = this;
            var tagName = DOM.nodeName(element).toLowerCase();
            if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
                this.sanitizedSomething = true;
                return;
            }
            this.buf.push('<');
            this.buf.push(tagName);
            DOM.attributeMap(element).forEach(function (value, attrName) {
                var lower = attrName.toLowerCase();
                if (!VALID_ATTRS.hasOwnProperty(lower)) {
                    _this.sanitizedSomething = true;
                    return;
                }
                // TODO(martinprobst): Special case image URIs for data:image/...
                if (URI_ATTRS[lower])
                    value = sanitizeUrl(value);
                if (SRCSET_ATTRS[lower])
                    value = sanitizeSrcset(value);
                _this.buf.push(' ');
                _this.buf.push(attrName);
                _this.buf.push('="');
                _this.buf.push(encodeEntities(value));
                _this.buf.push('"');
            });
            this.buf.push('>');
        };
        SanitizingHtmlSerializer.prototype.endElement = function (current) {
            var tagName = DOM.nodeName(current).toLowerCase();
            if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
                this.buf.push('</');
                this.buf.push(tagName);
                this.buf.push('>');
            }
        };
        SanitizingHtmlSerializer.prototype.chars = function (chars /** TODO #9100 */) { this.buf.push(encodeEntities(chars)); };
        return SanitizingHtmlSerializer;
    }());
    // Regular Expressions for parsing tags and attributes
    var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    // ! to ~ is the ASCII range.
    var NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
    /**
     * Escapes all potentially dangerous characters, so that the
     * resulting string can be safely inserted into attribute or
     * element text.
     * @param value
     * @returns {string} escaped text
     */
    function encodeEntities(value) {
        return value.replace(/&/g, '&amp;')
            .replace(SURROGATE_PAIR_REGEXP, function (match) {
            var hi = match.charCodeAt(0);
            var low = match.charCodeAt(1);
            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        })
            .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    }
    /**
     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').
     *
     * This is undesirable since we don't want to allow any of these custom attributes. This method
     * strips them all.
     */
    function stripCustomNsAttrs(el) {
        DOM.attributeMap(el).forEach(function (_, attrName) {
            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
                DOM.removeAttribute(el, attrName);
            }
        });
        for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
            var n = _a[_i];
            if (DOM.isElementNode(n))
                stripCustomNsAttrs(n);
        }
    }
    /**
     * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
     * the DOM in a browser environment.
     */
    function sanitizeHtml(unsafeHtmlInput) {
        try {
            var containerEl = getInertElement();
            // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
            var unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
            // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
            // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
            var mXSSAttempts = 5;
            var parsedHtml = unsafeHtml;
            do {
                if (mXSSAttempts === 0) {
                    throw new Error('Failed to sanitize html because the input is unstable');
                }
                mXSSAttempts--;
                unsafeHtml = parsedHtml;
                DOM.setInnerHTML(containerEl, unsafeHtml);
                if (DOM.defaultDoc().documentMode) {
                    // strip custom-namespaced attributes on IE<=11
                    stripCustomNsAttrs(containerEl);
                }
                parsedHtml = DOM.getInnerHTML(containerEl);
            } while (unsafeHtml !== parsedHtml);
            var sanitizer = new SanitizingHtmlSerializer();
            var safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
            // Clear out the body element.
            var parent_1 = DOM.getTemplateContent(containerEl) || containerEl;
            for (var _i = 0, _a = DOM.childNodesAsList(parent_1); _i < _a.length; _i++) {
                var child = _a[_i];
                DOM.removeChild(parent_1, child);
            }
            if (_angular_core.isDevMode() && sanitizer.sanitizedSomething) {
                DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
            }
            return safeHtml;
        }
        catch (e) {
            // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
            inertElement = null;
            throw e;
        }
    }

    /**
     * Regular expression for safe style values.
     *
     * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
     *
     * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
     * font-family) and hence could allow multiple values to get injected, but that should pose no risk
     * of XSS.
     *
     * The function expression checks only for XSS safety, not for CSS validity.
     *
     * This regular expression was taken from the Closure sanitization library, and augmented for
     * transformation values.
     */
    var VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
    var TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
    var COLOR_FNS = '(?:rgb|hsl)a?';
    var FN_ARGS = '\\([-0-9.%, a-zA-Z]+\\)';
    var SAFE_STYLE_VALUE = new RegExp("^(" + VALUES + "|(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + ")" + FN_ARGS + ")$", 'g');
    /**
     * Matches a `url(...)` value with an arbitrary argument as long as it does
     * not contain parentheses.
     *
     * The URL value still needs to be sanitized separately.
     *
     * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
     * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
     * by observing whether scroll bars are displayed, or character ranges used by a font face
     * definition.
     *
     * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
     * binding a URL value without further cooperation from the page will cause an information leak, and
     * if so, it is just a leak, not a full blown XSS vulnerability.
     *
     * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
     * code is permissive and allows URLs that sanitize otherwise.
     */
    var URL_RE = /^url\(([^)]+)\)$/;
    /**
     * Checks that quotes (" and ') are properly balanced inside a string. Assumes
     * that neither escape (\) nor any other character that could result in
     * breaking out of a string parsing context are allowed;
     * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
     *
     * This code was taken from the Closure sanitization library.
     */
    function hasBalancedQuotes(value) {
        var outsideSingle = true;
        var outsideDouble = true;
        for (var i = 0; i < value.length; i++) {
            var c = value.charAt(i);
            if (c === '\'' && outsideDouble) {
                outsideSingle = !outsideSingle;
            }
            else if (c === '"' && outsideSingle) {
                outsideDouble = !outsideDouble;
            }
        }
        return outsideSingle && outsideDouble;
    }
    /**
     * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
     * value) and returns a value that is safe to use in a browser environment.
     */
    function sanitizeStyle(value) {
        value = String(value).trim(); // Make sure it's actually a string.
        if (!value)
            return '';
        // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
        // reasoning behind this.
        var urlMatch = value.match(URL_RE);
        if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||
            value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
            return value; // Safe style values.
        }
        if (_angular_core.isDevMode()) {
            getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
        }
        return 'unsafe';
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$9 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
     * values to be safe to use in the different DOM contexts.
     *
     * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
     * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
     * the website.
     *
     * In specific situations, it might be necessary to disable sanitization, for example if the
     * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
     * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
     * methods, and then binding to that value from the template.
     *
     * These situations should be very rare, and extraordinary care must be taken to avoid creating a
     * Cross Site Scripting (XSS) security bug!
     *
     * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
     * close as possible to the source of the value, to make it easy to verify no security bug is
     * created by its use.
     *
     * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
     * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
     * code. The sanitizer leaves safe values intact.
     *
     * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
     * sanitization for the value passed in. Carefully check and audit all values and code paths going
     * into this call. Make sure any user data is appropriately escaped for this security context.
     * For more detail, see the [Security Guide](http://g.co/ng/security).
     *
     * @stable
     */
    var DomSanitizer = (function () {
        function DomSanitizer() {
        }
        return DomSanitizer;
    }());
    var DomSanitizerImpl = (function (_super) {
        __extends$9(DomSanitizerImpl, _super);
        function DomSanitizerImpl() {
            _super.apply(this, arguments);
        }
        DomSanitizerImpl.prototype.sanitize = function (ctx, value) {
            if (value == null)
                return null;
            switch (ctx) {
                case _angular_core.SecurityContext.NONE:
                    return value;
                case _angular_core.SecurityContext.HTML:
                    if (value instanceof SafeHtmlImpl)
                        return value.changingThisBreaksApplicationSecurity;
                    this.checkNotSafeValue(value, 'HTML');
                    return sanitizeHtml(String(value));
                case _angular_core.SecurityContext.STYLE:
                    if (value instanceof SafeStyleImpl)
                        return value.changingThisBreaksApplicationSecurity;
                    this.checkNotSafeValue(value, 'Style');
                    return sanitizeStyle(value);
                case _angular_core.SecurityContext.SCRIPT:
                    if (value instanceof SafeScriptImpl)
                        return value.changingThisBreaksApplicationSecurity;
                    this.checkNotSafeValue(value, 'Script');
                    throw new Error('unsafe value used in a script context');
                case _angular_core.SecurityContext.URL:
                    if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
                        // Allow resource URLs in URL contexts, they are strictly more trusted.
                        return value.changingThisBreaksApplicationSecurity;
                    }
                    this.checkNotSafeValue(value, 'URL');
                    return sanitizeUrl(String(value));
                case _angular_core.SecurityContext.RESOURCE_URL:
                    if (value instanceof SafeResourceUrlImpl) {
                        return value.changingThisBreaksApplicationSecurity;
                    }
                    this.checkNotSafeValue(value, 'ResourceURL');
                    throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
                default:
                    throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
            }
        };
        DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {
            if (value instanceof SafeValueImpl) {
                throw new Error(("Required a safe " + expectedType + ", got a " + value.getTypeName() + " ") +
                    "(see http://g.co/ng/security#xss)");
            }
        };
        DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };
        DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };
        DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };
        DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };
        DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {
            return new SafeResourceUrlImpl(value);
        };
        DomSanitizerImpl.decorators = [
            { type: _angular_core.Injectable },
        ];
        /** @nocollapse */
        DomSanitizerImpl.ctorParameters = [];
        return DomSanitizerImpl;
    }(DomSanitizer));
    var SafeValueImpl = (function () {
        function SafeValueImpl(changingThisBreaksApplicationSecurity) {
            this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
            // empty
        }
        SafeValueImpl.prototype.toString = function () {
            return ("SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity) +
                " (see http://g.co/ng/security#xss)";
        };
        return SafeValueImpl;
    }());
    var SafeHtmlImpl = (function (_super) {
        __extends$9(SafeHtmlImpl, _super);
        function SafeHtmlImpl() {
            _super.apply(this, arguments);
        }
        SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };
        return SafeHtmlImpl;
    }(SafeValueImpl));
    var SafeStyleImpl = (function (_super) {
        __extends$9(SafeStyleImpl, _super);
        function SafeStyleImpl() {
            _super.apply(this, arguments);
        }
        SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };
        return SafeStyleImpl;
    }(SafeValueImpl));
    var SafeScriptImpl = (function (_super) {
        __extends$9(SafeScriptImpl, _super);
        function SafeScriptImpl() {
            _super.apply(this, arguments);
        }
        SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };
        return SafeScriptImpl;
    }(SafeValueImpl));
    var SafeUrlImpl = (function (_super) {
        __extends$9(SafeUrlImpl, _super);
        function SafeUrlImpl() {
            _super.apply(this, arguments);
        }
        SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };
        return SafeUrlImpl;
    }(SafeValueImpl));
    var SafeResourceUrlImpl = (function (_super) {
        __extends$9(SafeResourceUrlImpl, _super);
        function SafeResourceUrlImpl() {
            _super.apply(this, arguments);
        }
        SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };
        return SafeResourceUrlImpl;
    }(SafeValueImpl));

    var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
        { provide: _angular_core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
        { provide: _angular_common.PlatformLocation, useClass: BrowserPlatformLocation }
    ];
    /**
     * @security Replacing built-in sanitization providers exposes the application to XSS risks.
     * Attacker-controlled data introduced by an unsanitized provider could expose your
     * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
     * @experimental
     */
    var BROWSER_SANITIZATION_PROVIDERS = [
        { provide: _angular_core.Sanitizer, useExisting: DomSanitizer },
        { provide: DomSanitizer, useClass: DomSanitizerImpl },
    ];
    /**
     * @stable
     */
    var platformBrowser = _angular_core.createPlatformFactory(_angular_core.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
    function initDomAdapter() {
        BrowserDomAdapter.makeCurrent();
        BrowserGetTestability.init();
    }
    function errorHandler() {
        return new _angular_core.ErrorHandler();
    }
    function _document() {
        return getDOM().defaultDoc();
    }
    function _resolveDefaultAnimationDriver() {
        if (getDOM().supportsWebAnimation()) {
            return new WebAnimationsDriver();
        }
        return AnimationDriver.NOOP;
    }
    /**
     * The ng module for the browser.
     *
     * @stable
     */
    var BrowserModule = (function () {
        function BrowserModule(parentModule) {
            if (parentModule) {
                throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
            }
        }
        BrowserModule.decorators = [
            { type: _angular_core.NgModule, args: [{
                        providers: [
                            BROWSER_SANITIZATION_PROVIDERS, { provide: _angular_core.ErrorHandler, useFactory: errorHandler, deps: [] },
                            { provide: DOCUMENT, useFactory: _document, deps: [] },
                            { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },
                            { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },
                            { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },
                            { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },
                            { provide: DomRootRenderer, useClass: DomRootRenderer_ },
                            { provide: _angular_core.RootRenderer, useExisting: DomRootRenderer },
                            { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
                            { provide: AnimationDriver, useFactory: _resolveDefaultAnimationDriver }, DomSharedStylesHost,
                            _angular_core.Testability, EventManager, ELEMENT_PROBE_PROVIDERS, Title
                        ],
                        exports: [_angular_common.CommonModule, _angular_core.ApplicationModule]
                    },] },
        ];
        /** @nocollapse */
        BrowserModule.ctorParameters = [
            { type: BrowserModule, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.SkipSelf },] },
        ];
        return BrowserModule;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * JS version of browser APIs. This library can only run in the browser.
     */
    var win = typeof window !== 'undefined' && window || {};

    var ChangeDetectionPerfRecord = (function () {
        function ChangeDetectionPerfRecord(msPerTick, numTicks) {
            this.msPerTick = msPerTick;
            this.numTicks = numTicks;
        }
        return ChangeDetectionPerfRecord;
    }());
    /**
     * Entry point for all Angular debug tools. This object corresponds to the `ng`
     * global variable accessible in the dev console.
     */
    var AngularTools = (function () {
        function AngularTools(ref) {
            this.profiler = new AngularProfiler(ref);
        }
        return AngularTools;
    }());
    /**
     * Entry point for all Angular profiling-related debug tools. This object
     * corresponds to the `ng.profiler` in the dev console.
     */
    var AngularProfiler = (function () {
        function AngularProfiler(ref) {
            this.appRef = ref.injector.get(_angular_core.ApplicationRef);
        }
        /**
         * Exercises change detection in a loop and then prints the average amount of
         * time in milliseconds how long a single round of change detection takes for
         * the current state of the UI. It runs a minimum of 5 rounds for a minimum
         * of 500 milliseconds.
         *
         * Optionally, a user may pass a `config` parameter containing a map of
         * options. Supported options are:
         *
         * `record` (boolean) - causes the profiler to record a CPU profile while
         * it exercises the change detector. Example:
         *
         * ```
         * ng.profiler.timeChangeDetection({record: true})
         * ```
         */
        AngularProfiler.prototype.timeChangeDetection = function (config) {
            var record = isPresent(config) && config['record'];
            var profileName = 'Change Detection';
            // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
            var isProfilerAvailable = isPresent(win.console.profile);
            if (record && isProfilerAvailable) {
                win.console.profile(profileName);
            }
            var start = getDOM().performanceNow();
            var numTicks = 0;
            while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {
                this.appRef.tick();
                numTicks++;
            }
            var end = getDOM().performanceNow();
            if (record && isProfilerAvailable) {
                // need to cast to <any> because type checker thinks there's no argument
                // while in fact there is:
                //
                // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
                win.console.profileEnd(profileName);
            }
            var msPerTick = (end - start) / numTicks;
            win.console.log("ran " + numTicks + " change detection cycles");
            win.console.log(NumberWrapper.toFixed(msPerTick, 2) + " ms per check");
            return new ChangeDetectionPerfRecord(msPerTick, numTicks);
        };
        return AngularProfiler;
    }());

    var context = global$1;
    /**
     * Enabled Angular 2 debug tools that are accessible via your browser's
     * developer console.
     *
     * Usage:
     *
     * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
     * 1. Type `ng.` (usually the console will show auto-complete suggestion)
     * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
     *    then hit Enter.
     *
     * @experimental All debugging apis are currently experimental.
     */
    function enableDebugTools(ref) {
        context.ng = new AngularTools(ref);
        return ref;
    }
    /**
     * Disables Angular 2 tools.
     *
     * @experimental All debugging apis are currently experimental.
     */
    function disableDebugTools() {
        delete context.ng;
    }

    /**
     * Predicates for use with {@link DebugElement}'s query functions.
     *
     * @experimental All debugging apis are currently experimental.
     */
    var By = (function () {
        function By() {
        }
        /**
         * Match all elements.
         *
         * ## Example
         *
         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
         */
        By.all = function () { return function (debugElement) { return true; }; };
        /**
         * Match elements by the given CSS selector.
         *
         * ## Example
         *
         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
         */
        By.css = function (selector) {
            return function (debugElement) {
                return isPresent(debugElement.nativeElement) ?
                    getDOM().elementMatches(debugElement.nativeElement, selector) :
                    false;
            };
        };
        /**
         * Match elements that have the given directive present.
         *
         * ## Example
         *
         * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
         */
        By.directive = function (type) {
            return function (debugElement) { return debugElement.providerTokens.indexOf(type) !== -1; };
        };
        return By;
    }());

    var __platform_browser_private__ = {
        BrowserPlatformLocation: BrowserPlatformLocation,
        DomAdapter: DomAdapter,
        BrowserDomAdapter: BrowserDomAdapter,
        BrowserGetTestability: BrowserGetTestability,
        getDOM: getDOM,
        setRootDomAdapter: setRootDomAdapter,
        DomRootRenderer_: DomRootRenderer_,
        DomRootRenderer: DomRootRenderer,
        DomSharedStylesHost: DomSharedStylesHost,
        SharedStylesHost: SharedStylesHost,
        ELEMENT_PROBE_PROVIDERS: ELEMENT_PROBE_PROVIDERS,
        DomEventsPlugin: DomEventsPlugin,
        KeyEventsPlugin: KeyEventsPlugin,
        HammerGesturesPlugin: HammerGesturesPlugin,
        initDomAdapter: initDomAdapter,
        INTERNAL_BROWSER_PLATFORM_PROVIDERS: INTERNAL_BROWSER_PLATFORM_PROVIDERS,
        BROWSER_SANITIZATION_PROVIDERS: BROWSER_SANITIZATION_PROVIDERS
    };

    exports.BrowserModule = BrowserModule;
    exports.platformBrowser = platformBrowser;
    exports.Title = Title;
    exports.disableDebugTools = disableDebugTools;
    exports.enableDebugTools = enableDebugTools;
    exports.AnimationDriver = AnimationDriver;
    exports.By = By;
    exports.NgProbeToken = NgProbeToken;
    exports.DOCUMENT = DOCUMENT;
    exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;
    exports.EventManager = EventManager;
    exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;
    exports.HammerGestureConfig = HammerGestureConfig;
    exports.DomSanitizer = DomSanitizer;
    exports.__platform_browser_private__ = __platform_browser_private__;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"@angular/common":1,"@angular/core":3}],6:[function(require,module,exports){
"use strict";
var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Registers handlers for handling emitted values, error and completions from the observable, and
     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
     * @method subscribe
     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled
     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this);
        }
        else {
            sink.add(this._subscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            }
            else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                }
                else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;

},{"./symbol/observable":12,"./util/root":20,"./util/toSubscriber":21}],7:[function(require,module,exports){
"use strict";
exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) { throw err; },
    complete: function () { }
};

},{}],8:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

},{"./Observable":6,"./SubjectSubscription":9,"./Subscriber":10,"./Subscription":11,"./symbol/rxSubscriber":13,"./util/ObjectUnsubscribedError":14}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

},{"./Subscription":11}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    }
                    else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parent, observerOrNext, error, complete) {
        _super.call(this);
        this._parent = _parent;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parent = this._parent;
            if (!_parent.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parent, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._error) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parent.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            }
            else {
                _parent.syncErrorValue = err;
                _parent.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parent = this._parent;
            if (this._complete) {
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parent, this._complete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parent = this._parent;
        this._context = null;
        this._parent = null;
        _parent.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

},{"./Observer":7,"./Subscription":11,"./symbol/rxSubscriber":13,"./util/isFunction":18}],11:[function(require,module,exports){
"use strict";
var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        this.closed = true;
        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this._subscriptions = null;
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                (errors = errors || []).push(errorObject_1.errorObject.e);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(err.errors);
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var sub = teardown;
        switch (typeof teardown) {
            case 'function':
                sub = new Subscription(teardown);
            case 'object':
                if (sub.closed || typeof sub.unsubscribe !== 'function') {
                    break;
                }
                else if (this.closed) {
                    sub.unsubscribe();
                }
                else {
                    (this._subscriptions || (this._subscriptions = [])).push(sub);
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        return sub;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        // HACK: This might be redundant because of the logic in `add()`
        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
            return;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;

},{"./util/UnsubscriptionError":15,"./util/errorObject":16,"./util/isArray":17,"./util/isFunction":18,"./util/isObject":19,"./util/tryCatch":22}],12:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        }
        else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.$$observable = getSymbolObservable(root_1.root);

},{"../util/root":20}],13:[function(require,module,exports){
"use strict";
var root_1 = require('../util/root');
var Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
    Symbol.for('rxSubscriber') : '@@rxSubscriber';

},{"../util/root":20}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;

},{}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;

},{}],16:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };

},{}],17:[function(require,module,exports){
"use strict";
exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

},{}],18:[function(require,module,exports){
"use strict";
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

},{}],19:[function(require,module,exports){
"use strict";
function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;

},{}],20:[function(require,module,exports){
(function (global){
"use strict";
var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
};
exports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
var freeGlobal = objectTypes[typeof global] && global;
if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    exports.root = freeGlobal;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],21:[function(require,module,exports){
"use strict";
var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber();
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

},{"../Subscriber":10,"../symbol/rxSubscriber":13}],22:[function(require,module,exports){
"use strict";
var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;

},{"./errorObject":16}],23:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require('@angular/core');
var AppComponent = (function () {
    function AppComponent() {
        this.title = 'ClearWater Reloaded!!';
    }
    AppComponent = __decorate([
        core_1.Component({
            selector: 'my-app',
            template: '<h1>{{title}}</h1>',
        })
    ], AppComponent);
    return AppComponent;
}());
exports.AppComponent = AppComponent;

},{"@angular/core":3}],24:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var core_1 = require('@angular/core');
var platform_browser_1 = require('@angular/platform-browser');
var app_component_1 = require('./app.component');
var AppModule = (function () {
    function AppModule() {
    }
    AppModule = __decorate([
        core_1.NgModule({
            imports: [platform_browser_1.BrowserModule],
            declarations: [app_component_1.AppComponent],
            bootstrap: [app_component_1.AppComponent]
        })
    ], AppModule);
    return AppModule;
}());
exports.AppModule = AppModule;

},{"./app.component":23,"@angular/core":3,"@angular/platform-browser":5}],25:[function(require,module,exports){
var main_1 = require('./main');
var CWv2;
(function (CWv2) {
    "use strict";
    var Application;
    (function (Application) {
        function initialize() {
            document.addEventListener('deviceready', onDeviceReady, false);
        }
        Application.initialize = initialize;
        function onDeviceReady() {
            document.addEventListener('pause', onPause, false);
            document.addEventListener('resume', onResume, false);
            var parentElement = document.getElementById('deviceready');
            var listeningElement = parentElement.querySelector('.listening');
            var receivedElement = parentElement.querySelector('.received');
            listeningElement.setAttribute('style', 'display:none;');
            receivedElement.setAttribute('style', 'display:block;');
            main_1.callWhenReady();
        }
        function onPause() {
        }
        function onResume() {
        }
    })(Application = CWv2.Application || (CWv2.Application = {}));
    window.onload = function () {
        Application.initialize();
    };
})(CWv2 || (CWv2 = {}));
},{"./main":26}],26:[function(require,module,exports){
//dynamic bootstrapping
"use strict";
// The browser platform with a compiler
var platform_browser_dynamic_1 = require('@angular/platform-browser-dynamic');
// The app module
var app_module_1 = require('./app.module');
function callWhenReady() {
    // Compile and launch the module
    platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);
}
exports.callWhenReady = callWhenReady;
//static bootstrapping
//// The browser platform without a compiler
//import { platformBrowser } from '@angular/platform-browser';
//// The app module factory produced by the static offline compiler
//import { AppModuleNgFactory } from './app.module.ngfactory';
//// Launch with the app module factory.
//platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);

},{"./app.module":24,"@angular/platform-browser-dynamic":4}]},{},[25])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tbW9uL2J1bmRsZXMvY29tbW9uLnVtZC5qcyIsIm5vZGVfbW9kdWxlcy9AYW5ndWxhci9jb21waWxlci9idW5kbGVzL2NvbXBpbGVyLnVtZC5qcyIsIm5vZGVfbW9kdWxlcy9AYW5ndWxhci9jb3JlL2J1bmRsZXMvY29yZS51bWQuanMiLCJub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljLnVtZC5qcyIsIm5vZGVfbW9kdWxlcy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyL2J1bmRsZXMvcGxhdGZvcm0tYnJvd3Nlci51bWQuanMiLCJub2RlX21vZHVsZXMvcnhqcy9PYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2ZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9TdWJqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdFN1YnNjcmlwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL1N1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpcHRpb24uanMiLCJub2RlX21vZHVsZXMvcnhqcy9zeW1ib2wvb2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9yeFN1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9lcnJvck9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL3Jvb3QuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL3RvU3Vic2NyaWJlci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvdHJ5Q2F0Y2guanMiLCJzY3JpcHRzL2FwcC5jb21wb25lbnQuanMiLCJzY3JpcHRzL2FwcC5tb2R1bGUuanMiLCJzY3JpcHRzL2luZGV4LnRzIiwic2NyaXB0cy9tYWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25qR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdyaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1bVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQSxxQkFBNEIsUUFBUSxDQUFDLENBQUE7QUFNckMsSUFBTyxJQUFJLENBbUNWO0FBbkNELFdBQU8sSUFBSSxFQUFDLENBQUM7SUFDVCxZQUFZLENBQUM7SUFFYixJQUFjLFdBQVcsQ0EyQnhCO0lBM0JELFdBQWMsV0FBVyxFQUFDLENBQUM7UUFDdkI7WUFDSSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLGFBQWEsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNuRSxDQUFDO1FBRmUsc0JBQVUsYUFFekIsQ0FBQTtRQUVEO1lBRUksUUFBUSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDbkQsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFHckQsSUFBSSxhQUFhLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUMzRCxJQUFJLGdCQUFnQixHQUFHLGFBQWEsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDakUsSUFBSSxlQUFlLEdBQUcsYUFBYSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUMvRCxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1lBQ3hELGVBQWUsQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLGdCQUFnQixDQUFDLENBQUM7WUFDeEQsb0JBQWEsRUFBRSxDQUFDO1FBQ3BCLENBQUM7UUFFRDtRQUVBLENBQUM7UUFFRDtRQUVBLENBQUM7SUFFTCxDQUFDLEVBM0JhLFdBQVcsR0FBWCxnQkFBVyxLQUFYLGdCQUFXLFFBMkJ4QjtJQUVELE1BQU0sQ0FBQyxNQUFNLEdBQUc7UUFDWixXQUFXLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDN0IsQ0FBQyxDQUFBO0FBQ0wsQ0FBQyxFQW5DTSxJQUFJLEtBQUosSUFBSSxRQW1DVjs7QUMzQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYyLjAuMlxuICogKGMpIDIwMTAtMjAxNiBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5jb21tb24gPSBnbG9iYWwubmcuY29tbW9uIHx8IHt9KSxnbG9iYWwubmcuY29yZSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSBieSBhbiBhcHBsaWNhdGlvbiBkZXZlbG9wZXIuIEluc3RlYWQsIHVzZVxuICAgICAqIHtAbGluayBMb2NhdGlvbn0uXG4gICAgICpcbiAgICAgKiBgUGxhdGZvcm1Mb2NhdGlvbmAgZW5jYXBzdWxhdGVzIGFsbCBjYWxscyB0byBET00gYXBpcywgd2hpY2ggYWxsb3dzIHRoZSBSb3V0ZXIgdG8gYmUgcGxhdGZvcm1cbiAgICAgKiBhZ25vc3RpYy5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgd2UgY2FuIGhhdmUgZGlmZmVyZW50IGltcGxlbWVudGF0aW9uIG9mIGBQbGF0Zm9ybUxvY2F0aW9uYCBmb3IgdGhlIGRpZmZlcmVudFxuICAgICAqIHBsYXRmb3Jtc1xuICAgICAqIHRoYXQgYW5ndWxhciBzdXBwb3J0cy4gRm9yIGV4YW1wbGUsIHRoZSBkZWZhdWx0IGBQbGF0Zm9ybUxvY2F0aW9uYCBpcyB7QGxpbmtcbiAgICAgKiBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbn0sXG4gICAgICogaG93ZXZlciB3aGVuIHlvdSBydW4geW91ciBhcHAgaW4gYSBXZWJXb3JrZXIgeW91IHVzZSB7QGxpbmsgV2ViV29ya2VyUGxhdGZvcm1Mb2NhdGlvbn0uXG4gICAgICpcbiAgICAgKiBUaGUgYFBsYXRmb3JtTG9jYXRpb25gIGNsYXNzIGlzIHVzZWQgZGlyZWN0bHkgYnkgYWxsIGltcGxlbWVudGF0aW9ucyBvZiB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX1cbiAgICAgKiB3aGVuXG4gICAgICogdGhleSBuZWVkIHRvIGludGVyYWN0IHdpdGggdGhlIERPTSBhcGlzIGxpa2UgcHVzaFN0YXRlLCBwb3BTdGF0ZSwgZXRjLi4uXG4gICAgICpcbiAgICAgKiB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX0gaW4gdHVybiBpcyB1c2VkIGJ5IHRoZSB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2Ugd2hpY2ggaXMgdXNlZCBkaXJlY3RseVxuICAgICAqIGJ5XG4gICAgICogdGhlIHtAbGluayBSb3V0ZXJ9IGluIG9yZGVyIHRvIG5hdmlnYXRlIGJldHdlZW4gcm91dGVzLiBTaW5jZSBhbGwgaW50ZXJhY3Rpb25zIGJldHdlZW4ge0BsaW5rXG4gICAgICogUm91dGVyfSAvXG4gICAgICoge0BsaW5rIExvY2F0aW9ufSAvIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSBhbmQgRE9NIGFwaXMgZmxvdyB0aHJvdWdoIHRoZSBgUGxhdGZvcm1Mb2NhdGlvbmBcbiAgICAgKiBjbGFzc1xuICAgICAqIHRoZXkgYXJlIGFsbCBwbGF0Zm9ybSBpbmRlcGVuZGVudC5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUGxhdGZvcm1Mb2NhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBsYXRmb3JtTG9jYXRpb24oKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInBhdGhuYW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJzZWFyY2hcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImhhc2hcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBsYXRmb3JtTG9jYXRpb247XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIGBMb2NhdGlvblN0cmF0ZWd5YCBpcyByZXNwb25zaWJsZSBmb3IgcmVwcmVzZW50aW5nIGFuZCByZWFkaW5nIHJvdXRlIHN0YXRlXG4gICAgICogZnJvbSB0aGUgYnJvd3NlcidzIFVSTC4gQW5ndWxhciBwcm92aWRlcyB0d28gc3RyYXRlZ2llczpcbiAgICAgKiB7QGxpbmsgSGFzaExvY2F0aW9uU3RyYXRlZ3l9IGFuZCB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9IChkZWZhdWx0KS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZCB1bmRlciB0aGUgaG9vZCBvZiB0aGUge0BsaW5rIExvY2F0aW9ufSBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQXBwbGljYXRpb25zIHNob3VsZCB1c2UgdGhlIHtAbGluayBSb3V0ZXJ9IG9yIHtAbGluayBMb2NhdGlvbn0gc2VydmljZXMgdG9cbiAgICAgKiBpbnRlcmFjdCB3aXRoIGFwcGxpY2F0aW9uIHJvdXRlIHN0YXRlLlxuICAgICAqXG4gICAgICogRm9yIGluc3RhbmNlLCB7QGxpbmsgSGFzaExvY2F0aW9uU3RyYXRlZ3l9IHByb2R1Y2VzIFVSTHMgbGlrZVxuICAgICAqIGBodHRwOi8vZXhhbXBsZS5jb20jL2Zvb2AsIGFuZCB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9IHByb2R1Y2VzXG4gICAgICogYGh0dHA6Ly9leGFtcGxlLmNvbS9mb29gIGFzIGFuIGVxdWl2YWxlbnQgVVJMLlxuICAgICAqXG4gICAgICogU2VlIHRoZXNlIHR3byBjbGFzc2VzIGZvciBtb3JlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBMb2NhdGlvblN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTG9jYXRpb25TdHJhdGVneSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTG9jYXRpb25TdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBgQVBQX0JBU0VfSFJFRmAgdG9rZW4gcmVwcmVzZW50cyB0aGUgYmFzZSBocmVmIHRvIGJlIHVzZWQgd2l0aCB0aGVcbiAgICAgKiB7QGxpbmsgUGF0aExvY2F0aW9uU3RyYXRlZ3l9LlxuICAgICAqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIHtAbGluayBQYXRoTG9jYXRpb25TdHJhdGVneX0sIHlvdSBtdXN0IHByb3ZpZGUgYSBwcm92aWRlciB0byBhIHN0cmluZ1xuICAgICAqIHJlcHJlc2VudGluZyB0aGUgVVJMIHByZWZpeCB0aGF0IHNob3VsZCBiZSBwcmVzZXJ2ZWQgd2hlbiBnZW5lcmF0aW5nIGFuZCByZWNvZ25pemluZ1xuICAgICAqIFVSTHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7Q29tcG9uZW50LCBOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHtBUFBfQkFTRV9IUkVGfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuICAgICAqXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBBUFBfQkFTRV9IUkVGLCB1c2VWYWx1ZTogJy9teS9hcHAnfV1cbiAgICAgKiB9KVxuICAgICAqIGNsYXNzIEFwcE1vZHVsZSB7fVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBUFBfQkFTRV9IUkVGID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ2FwcEJhc2VIcmVmJyk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIGdsb2JhbFNjb3BlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gZ2xvYmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbiAgICB9XG4gICAgLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4gICAgLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbiAgICB2YXIgX2dsb2JhbCA9IGdsb2JhbFNjb3BlO1xuICAgIGZ1bmN0aW9uIGdldFR5cGVOYW1lRm9yRGVidWdnaW5nKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVbJ25hbWUnXSB8fCB0eXBlb2YgdHlwZTtcbiAgICB9XG4gICAgLy8gVE9ETzogcmVtb3ZlIGNhbGxzIHRvIGFzc2VydCBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50XG4gICAgLy8gTm90ZTogQ2FuJ3QganVzdCBleHBvcnQgdGhpcyBhbmQgaW1wb3J0IGluIGluIG90aGVyIGZpbGVzXG4gICAgLy8gYXMgYGFzc2VydGAgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGluIERhcnRcbiAgICBfZ2xvYmFsLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogdG8gYmUgZml4ZWQgcHJvcGVybHkgdmlhICMyODMwLCBub29wIGZvciBub3dcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCbGFuayhvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTdHJpbmdNYXAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKG9iai52YWx1ZU9mKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gPT09IHVuZGVmaW5lZCB8fCB0b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ub3ZlcnJpZGRlbk5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSB0b2tlbi50b1N0cmluZygpO1xuICAgICAgICB2YXIgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICByZXR1cm4gbmV3TGluZUluZGV4ID09PSAtMSA/IHJlcyA6IHJlcy5zdWJzdHJpbmcoMCwgbmV3TGluZUluZGV4KTtcbiAgICB9XG4gICAgdmFyIE51bWJlcldyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOdW1iZXJXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE51bWJlcldyYXBwZXIudG9GaXhlZCA9IGZ1bmN0aW9uIChuLCBmcmFjdGlvbkRpZ2l0cykgeyByZXR1cm4gbi50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKTsgfTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5lcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhID09PSBiOyB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgJyArIHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5wYXJzZUludCA9IGZ1bmN0aW9uICh0ZXh0LCByYWRpeCkge1xuICAgICAgICAgICAgaWYgKHJhZGl4ID09IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTldKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyYWRpeCA9PSAxNikge1xuICAgICAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT9bMC05QUJDREVGYWJjZGVmXSskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCArICcgaW4gYmFzZSAnICsgcmFkaXgpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTnVtYmVyV3JhcHBlciwgXCJOYU5cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOYU47IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOdW1iZXJXcmFwcGVyLmlzTnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gIWlzTmFOKHZhbHVlIC0gcGFyc2VGbG9hdCh2YWx1ZSkpOyB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLmlzTmFOID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpc05hTih2YWx1ZSk7IH07XG4gICAgICAgIE51bWJlcldyYXBwZXIuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTsgfTtcbiAgICAgICAgcmV0dXJuIE51bWJlcldyYXBwZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBpc0pzT2JqZWN0KG8pIHtcbiAgICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvID09PSAnb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8vIENhbid0IGJlIGFsbCB1cHBlcmNhc2UgYXMgb3VyIHRyYW5zcGlsZXIgd291bGQgdGhpbmsgaXQgaXMgYSBzcGVjaWFsIGRpcmVjdGl2ZS4uLlxuICAgIHZhciBKc29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSnNvbigpIHtcbiAgICAgICAgfVxuICAgICAgICBKc29uLnBhcnNlID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIF9nbG9iYWwuSlNPTi5wYXJzZShzKTsgfTtcbiAgICAgICAgSnNvbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gRGFydCBkb2Vzbid0IHRha2UgMyBhcmd1bWVudHNcbiAgICAgICAgICAgIHJldHVybiBfZ2xvYmFsLkpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSnNvbjtcbiAgICB9KCkpO1xuICAgIHZhciBfc3ltYm9sSXRlcmF0b3IgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICAgICAgICBpZiAoaXNCbGFuayhfc3ltYm9sSXRlcmF0b3IpKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGdsb2JhbFNjb3BlLlN5bWJvbCkgJiYgaXNQcmVzZW50KFN5bWJvbC5pdGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlczYtc2hpbSBzcGVjaWZpYyBsb2dpY1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWFwLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVba2V5XSA9PT0gTWFwLnByb3RvdHlwZVsnZW50cmllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3ltYm9sSXRlcmF0b3IgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zeW1ib2xJdGVyYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBgTG9jYXRpb25gIGlzIGEgc2VydmljZSB0aGF0IGFwcGxpY2F0aW9ucyBjYW4gdXNlIHRvIGludGVyYWN0IHdpdGggYSBicm93c2VyJ3MgVVJMLlxuICAgICAqIERlcGVuZGluZyBvbiB3aGljaCB7QGxpbmsgTG9jYXRpb25TdHJhdGVneX0gaXMgdXNlZCwgYExvY2F0aW9uYCB3aWxsIGVpdGhlciBwZXJzaXN0XG4gICAgICogdG8gdGhlIFVSTCdzIHBhdGggb3IgdGhlIFVSTCdzIGhhc2ggc2VnbWVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGl0J3MgYmV0dGVyIHRvIHVzZSB7QGxpbmsgUm91dGVyI25hdmlnYXRlfSBzZXJ2aWNlIHRvIHRyaWdnZXIgcm91dGUgY2hhbmdlcy4gVXNlXG4gICAgICogYExvY2F0aW9uYCBvbmx5IGlmIHlvdSBuZWVkIHRvIGludGVyYWN0IHdpdGggb3IgY3JlYXRlIG5vcm1hbGl6ZWQgVVJMcyBvdXRzaWRlIG9mXG4gICAgICogcm91dGluZy5cbiAgICAgKlxuICAgICAqIGBMb2NhdGlvbmAgaXMgcmVzcG9uc2libGUgZm9yIG5vcm1hbGl6aW5nIHRoZSBVUkwgYWdhaW5zdCB0aGUgYXBwbGljYXRpb24ncyBiYXNlIGhyZWYuXG4gICAgICogQSBub3JtYWxpemVkIFVSTCBpcyBhYnNvbHV0ZSBmcm9tIHRoZSBVUkwgaG9zdCwgaW5jbHVkZXMgdGhlIGFwcGxpY2F0aW9uJ3MgYmFzZSBocmVmLCBhbmQgaGFzIG5vXG4gICAgICogdHJhaWxpbmcgc2xhc2g6XG4gICAgICogLSBgL215L2FwcC91c2VyLzEyM2AgaXMgbm9ybWFsaXplZFxuICAgICAqIC0gYG15L2FwcC91c2VyLzEyM2AgKippcyBub3QqKiBub3JtYWxpemVkXG4gICAgICogLSBgL215L2FwcC91c2VyLzEyMy9gICoqaXMgbm90Kiogbm9ybWFsaXplZFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAgICAgKiBpbXBvcnQge0xvY2F0aW9ufSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuICAgICAqXG4gICAgICogQENvbXBvbmVudCh7c2VsZWN0b3I6ICdhcHAtY29tcG9uZW50J30pXG4gICAgICogY2xhc3MgQXBwQ21wIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGxvY2F0aW9uOiBMb2NhdGlvbikge1xuICAgICAqICAgICBsb2NhdGlvbi5nbygnL2ZvbycpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMb2NhdGlvbihwbGF0Zm9ybVN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fc3ViamVjdCA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneSA9IHBsYXRmb3JtU3RyYXRlZ3k7XG4gICAgICAgICAgICB2YXIgYnJvd3NlckJhc2VIcmVmID0gdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5nZXRCYXNlSHJlZigpO1xuICAgICAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSBMb2NhdGlvbi5zdHJpcFRyYWlsaW5nU2xhc2goX3N0cmlwSW5kZXhIdG1sKGJyb3dzZXJCYXNlSHJlZikpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5vblBvcFN0YXRlKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdWJqZWN0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAndXJsJzogX3RoaXMucGF0aCh0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgJ3BvcCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogZXYudHlwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIFVSTCBwYXRoLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETzogdnNhdmtpbi4gUmVtb3ZlIHRoZSBib29sZWFuIGZsYWcgYW5kIGFsd2F5cyBpbmNsdWRlIGhhc2ggb25jZSB0aGUgZGVwcmVjYXRlZCByb3V0ZXIgaXNcbiAgICAgICAgLy8gcmVtb3ZlZC5cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoaW5jbHVkZUhhc2gpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlSGFzaCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVIYXNoID0gZmFsc2U7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSh0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnBhdGgoaW5jbHVkZUhhc2gpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIHBhdGggYW5kIGNvbXBhcmVzIHRvIHRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcGF0aC5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnByb3RvdHlwZS5pc0N1cnJlbnRQYXRoRXF1YWxUbyA9IGZ1bmN0aW9uIChwYXRoLCBxdWVyeSkge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDApIHsgcXVlcnkgPSAnJzsgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aCgpID09IHRoaXMubm9ybWFsaXplKHBhdGggKyBMb2NhdGlvbi5ub3JtYWxpemVRdWVyeVBhcmFtcyhxdWVyeSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgVVJMLCByZXR1cm5zIHRoZSBub3JtYWxpemVkIFVSTCBwYXRoIHdpdGhvdXQgbGVhZGluZyBvclxuICAgICAgICAgKiB0cmFpbGluZyBzbGFzaGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2NhdGlvbi5zdHJpcFRyYWlsaW5nU2xhc2goX3N0cmlwQmFzZUhyZWYodGhpcy5fYmFzZUhyZWYsIF9zdHJpcEluZGV4SHRtbCh1cmwpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBVUkwsIHJldHVybnMgdGhlIHBsYXRmb3JtLXNwZWNpZmljIGV4dGVybmFsIFVSTCBwYXRoLlxuICAgICAgICAgKiBJZiB0aGUgZ2l2ZW4gVVJMIGRvZXNuJ3QgYmVnaW4gd2l0aCBhIGxlYWRpbmcgc2xhc2ggKGAnLydgKSwgdGhpcyBtZXRob2QgYWRkcyBvbmVcbiAgICAgICAgICogYmVmb3JlIG5vcm1hbGl6aW5nLiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gYWRkIGEgaGFzaCBpZiBgSGFzaExvY2F0aW9uU3RyYXRlZ3lgIGlzXG4gICAgICAgICAqIHVzZWQsIG9yIHRoZSBgQVBQX0JBU0VfSFJFRmAgaWYgdGhlIGBQYXRoTG9jYXRpb25TdHJhdGVneWAgaXMgaW4gdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLnByZXBhcmVFeHRlcm5hbFVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIGlmICh1cmwubGVuZ3RoID4gMCAmJiAhdXJsLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHVybCA9ICcvJyArIHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnByZXBhcmVFeHRlcm5hbFVybCh1cmwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiByZW5hbWUgdGhpcyBtZXRob2QgdG8gcHVzaFN0YXRlXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBicm93c2VycyBVUkwgdG8gdGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gVVJMLCBhbmQgcHVzaGVzIGFcbiAgICAgICAgICogbmV3IGl0ZW0gb250byB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5LlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gKHBhdGgsIHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAocXVlcnkgPT09IHZvaWQgMCkgeyBxdWVyeSA9ICcnOyB9XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybVN0cmF0ZWd5LnB1c2hTdGF0ZShudWxsLCAnJywgcGF0aCwgcXVlcnkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgYnJvd3NlcnMgVVJMIHRvIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIFVSTCwgYW5kIHJlcGxhY2VzXG4gICAgICAgICAqIHRoZSB0b3AgaXRlbSBvbiB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5IHN0YWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChwYXRoLCBxdWVyeSkge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5ID09PSB2b2lkIDApIHsgcXVlcnkgPSAnJzsgfVxuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5yZXBsYWNlU3RhdGUobnVsbCwgJycsIHBhdGgsIHF1ZXJ5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hdmlnYXRlcyBmb3J3YXJkIGluIHRoZSBwbGF0Zm9ybSdzIGhpc3RvcnkuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1TdHJhdGVneS5mb3J3YXJkKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYXZpZ2F0ZXMgYmFjayBpbiB0aGUgcGxhdGZvcm0ncyBoaXN0b3J5LlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtU3RyYXRlZ3kuYmFjaygpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Vic2NyaWJlIHRvIHRoZSBwbGF0Zm9ybSdzIGBwb3BTdGF0ZWAgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvbk5leHQsIG9uVGhyb3csIG9uUmV0dXJuKSB7XG4gICAgICAgICAgICBpZiAob25UaHJvdyA9PT0gdm9pZCAwKSB7IG9uVGhyb3cgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAob25SZXR1cm4gPT09IHZvaWQgMCkgeyBvblJldHVybiA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0LnN1YnNjcmliZSh7IG5leHQ6IG9uTmV4dCwgZXJyb3I6IG9uVGhyb3csIGNvbXBsZXRlOiBvblJldHVybiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgc3RyaW5nIG9mIHVybCBwYXJhbWV0ZXJzLCBwcmVwZW5kIHdpdGggJz8nIGlmIG5lZWRlZCwgb3RoZXJ3aXNlIHJldHVybiBwYXJhbWV0ZXJzIGFzXG4gICAgICAgICAqIGlzLlxuICAgICAgICAgKi9cbiAgICAgICAgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gKHBhcmFtcy5sZW5ndGggPiAwICYmIHBhcmFtcy5zdWJzdHJpbmcoMCwgMSkgIT0gJz8nKSA/ICgnPycgKyBwYXJhbXMpIDogcGFyYW1zO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gMiBwYXJ0cyBvZiBhIHVybCwgam9pbiB0aGVtIHdpdGggYSBzbGFzaCBpZiBuZWVkZWQuXG4gICAgICAgICAqL1xuICAgICAgICBMb2NhdGlvbi5qb2luV2l0aFNsYXNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChzdGFydC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNsYXNoZXMgPSAwO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBzbGFzaGVzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHNsYXNoZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzbGFzaGVzID09IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnQgKyBlbmQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNsYXNoZXMgPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydCArIGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFydCArICcvJyArIGVuZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHVybCBoYXMgYSB0cmFpbGluZyBzbGFzaCwgcmVtb3ZlIGl0LCBvdGhlcndpc2UgcmV0dXJuIHVybCBhcyBpcy5cbiAgICAgICAgICovXG4gICAgICAgIExvY2F0aW9uLnN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIGlmICgvXFwvJC9nLnRlc3QodXJsKSkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfTtcbiAgICAgICAgTG9jYXRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBMb2NhdGlvbi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTG9jYXRpb25TdHJhdGVneSwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX3N0cmlwQmFzZUhyZWYoYmFzZUhyZWYsIHVybCkge1xuICAgICAgICBpZiAoYmFzZUhyZWYubGVuZ3RoID4gMCAmJiB1cmwuc3RhcnRzV2l0aChiYXNlSHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKGJhc2VIcmVmLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3N0cmlwSW5kZXhIdG1sKHVybCkge1xuICAgICAgICBpZiAoL1xcL2luZGV4Lmh0bWwkL2cudGVzdCh1cmwpKSB7XG4gICAgICAgICAgICAvLyAnL2luZGV4Lmh0bWwnLmxlbmd0aCA9PSAxMVxuICAgICAgICAgICAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDExKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYEhhc2hMb2NhdGlvblN0cmF0ZWd5YCBpcyBhIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGVcbiAgICAgKiB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2UgdG8gcmVwcmVzZW50IGl0cyBzdGF0ZSBpbiB0aGVcbiAgICAgKiBbaGFzaCBmcmFnbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pZm9ybV9SZXNvdXJjZV9Mb2NhdG9yI1N5bnRheClcbiAgICAgKiBvZiB0aGUgYnJvd3NlcidzIFVSTC5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSwgaWYgeW91IGNhbGwgYGxvY2F0aW9uLmdvKCcvZm9vJylgLCB0aGUgYnJvd3NlcidzIFVSTCB3aWxsIGJlY29tZVxuICAgICAqIGBleGFtcGxlLmNvbSMvZm9vYC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQge0NvbXBvbmVudCwgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqIGltcG9ydCB7XG4gICAgICogICBMb2NhdGlvblN0cmF0ZWd5LFxuICAgICAqICAgSGFzaExvY2F0aW9uU3RyYXRlZ3lcbiAgICAgKiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG4gICAgICpcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IExvY2F0aW9uU3RyYXRlZ3ksIHVzZUNsYXNzOiBIYXNoTG9jYXRpb25TdHJhdGVneX1dXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBBcHBNb2R1bGUge31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSGFzaExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoSGFzaExvY2F0aW9uU3RyYXRlZ3ksIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEhhc2hMb2NhdGlvblN0cmF0ZWd5KF9wbGF0Zm9ybUxvY2F0aW9uLCBfYmFzZUhyZWYpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbiA9IF9wbGF0Zm9ybUxvY2F0aW9uO1xuICAgICAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSAnJztcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoX2Jhc2VIcmVmKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jhc2VIcmVmID0gX2Jhc2VIcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5vblBvcFN0YXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uUG9wU3RhdGUoZm4pO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5vbkhhc2hDaGFuZ2UoZm4pO1xuICAgICAgICB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9iYXNlSHJlZjsgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiAoaW5jbHVkZUhhc2gpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlSGFzaCA9PT0gdm9pZCAwKSB7IGluY2x1ZGVIYXNoID0gZmFsc2U7IH1cbiAgICAgICAgICAgIC8vIHRoZSBoYXNoIHZhbHVlIGlzIGFsd2F5cyBwcmVmaXhlZCB3aXRoIGEgYCNgXG4gICAgICAgICAgICAvLyBhbmQgaWYgaXQgaXMgZW1wdHkgdGhlbiBpdCB3aWxsIHN0YXkgZW1wdHlcbiAgICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5oYXNoO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQocGF0aCkpXG4gICAgICAgICAgICAgICAgcGF0aCA9ICcjJztcbiAgICAgICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgPyBwYXRoLnN1YnN0cmluZygxKSA6IHBhdGg7XG4gICAgICAgIH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5wcmVwYXJlRXh0ZXJuYWxVcmwgPSBmdW5jdGlvbiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBMb2NhdGlvbi5qb2luV2l0aFNsYXNoKHRoaXMuX2Jhc2VIcmVmLCBpbnRlcm5hbCk7XG4gICAgICAgICAgICByZXR1cm4gdXJsLmxlbmd0aCA+IDAgPyAoJyMnICsgdXJsKSA6IHVybDtcbiAgICAgICAgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5wcmVwYXJlRXh0ZXJuYWxVcmwocGF0aCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgICAgICAgICBpZiAodXJsLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgdXJsID0gdGhpcy5wcmVwYXJlRXh0ZXJuYWxVcmwocGF0aCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgICAgICAgICBpZiAodXJsLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uZm9yd2FyZCgpOyB9O1xuICAgICAgICBIYXNoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5iYWNrKCk7IH07XG4gICAgICAgIEhhc2hMb2NhdGlvblN0cmF0ZWd5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSGFzaExvY2F0aW9uU3RyYXRlZ3kuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IFBsYXRmb3JtTG9jYXRpb24sIH0sXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbQVBQX0JBU0VfSFJFRixdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gSGFzaExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgfShMb2NhdGlvblN0cmF0ZWd5KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYFBhdGhMb2NhdGlvblN0cmF0ZWd5YCBpcyBhIHtAbGluayBMb2NhdGlvblN0cmF0ZWd5fSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGVcbiAgICAgKiB7QGxpbmsgTG9jYXRpb259IHNlcnZpY2UgdG8gcmVwcmVzZW50IGl0cyBzdGF0ZSBpbiB0aGVcbiAgICAgKiBbcGF0aF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pZm9ybV9SZXNvdXJjZV9Mb2NhdG9yI1N5bnRheCkgb2YgdGhlXG4gICAgICogYnJvd3NlcidzIFVSTC5cbiAgICAgKlxuICAgICAqIGBQYXRoTG9jYXRpb25TdHJhdGVneWAgaXMgdGhlIGRlZmF1bHQgYmluZGluZyBmb3Ige0BsaW5rIExvY2F0aW9uU3RyYXRlZ3l9XG4gICAgICogcHJvdmlkZWQgaW4ge0BsaW5rIFJPVVRFUl9QUk9WSURFUlN9LlxuICAgICAqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIGBQYXRoTG9jYXRpb25TdHJhdGVneWAsIHlvdSBtdXN0IHByb3ZpZGUgYSB7QGxpbmsgQVBQX0JBU0VfSFJFRn1cbiAgICAgKiBvciBhZGQgYSBiYXNlIGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50LiBUaGlzIFVSTCBwcmVmaXggdGhhdCB3aWxsIGJlIHByZXNlcnZlZFxuICAgICAqIHdoZW4gZ2VuZXJhdGluZyBhbmQgcmVjb2duaXppbmcgVVJMcy5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSwgaWYgeW91IHByb3ZpZGUgYW4gYEFQUF9CQVNFX0hSRUZgIG9mIGAnL215L2FwcCdgIGFuZCBjYWxsXG4gICAgICogYGxvY2F0aW9uLmdvKCcvZm9vJylgLCB0aGUgYnJvd3NlcidzIFVSTCB3aWxsIGJlY29tZVxuICAgICAqIGBleGFtcGxlLmNvbS9teS9hcHAvZm9vYC5cbiAgICAgKlxuICAgICAqIFNpbWlsYXJseSwgaWYgeW91IGFkZCBgPGJhc2UgaHJlZj0nL215L2FwcCcvPmAgdG8gdGhlIGRvY3VtZW50IGFuZCBjYWxsXG4gICAgICogYGxvY2F0aW9uLmdvKCcvZm9vJylgLCB0aGUgYnJvd3NlcidzIFVSTCB3aWxsIGJlY29tZVxuICAgICAqIGBleGFtcGxlLmNvbS9teS9hcHAvZm9vYC5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUGF0aExvY2F0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShQYXRoTG9jYXRpb25TdHJhdGVneSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUGF0aExvY2F0aW9uU3RyYXRlZ3koX3BsYXRmb3JtTG9jYXRpb24sIGhyZWYpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbiA9IF9wbGF0Zm9ybUxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBocmVmID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5nZXRCYXNlSHJlZkZyb21ET00oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0JsYW5rKGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFzZSBocmVmIHNldC4gUGxlYXNlIHByb3ZpZGUgYSB2YWx1ZSBmb3IgdGhlIEFQUF9CQVNFX0hSRUYgdG9rZW4gb3IgYWRkIGEgYmFzZSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iYXNlSHJlZiA9IGhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLm9uUG9wU3RhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtTG9jYXRpb24ub25Qb3BTdGF0ZShmbik7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLm9uSGFzaENoYW5nZShmbik7XG4gICAgICAgIH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5nZXRCYXNlSHJlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Jhc2VIcmVmOyB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucHJlcGFyZUV4dGVybmFsVXJsID0gZnVuY3Rpb24gKGludGVybmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9jYXRpb24uam9pbldpdGhTbGFzaCh0aGlzLl9iYXNlSHJlZiwgaW50ZXJuYWwpO1xuICAgICAgICB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uIChpbmNsdWRlSGFzaCkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVIYXNoID09PSB2b2lkIDApIHsgaW5jbHVkZUhhc2ggPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHBhdGhuYW1lID0gdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5wYXRobmFtZSArXG4gICAgICAgICAgICAgICAgTG9jYXRpb24ubm9ybWFsaXplUXVlcnlQYXJhbXModGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5zZWFyY2gpO1xuICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLmhhc2g7XG4gICAgICAgICAgICByZXR1cm4gaGFzaCAmJiBpbmNsdWRlSGFzaCA/IFwiXCIgKyBwYXRobmFtZSArIGhhc2ggOiBwYXRobmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBleHRlcm5hbFVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHVybCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnB1c2hTdGF0ZShzdGF0ZSwgdGl0bGUsIGV4dGVybmFsVXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBleHRlcm5hbFVybCA9IHRoaXMucHJlcGFyZUV4dGVybmFsVXJsKHVybCArIExvY2F0aW9uLm5vcm1hbGl6ZVF1ZXJ5UGFyYW1zKHF1ZXJ5UGFyYW1zKSk7XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybUxvY2F0aW9uLnJlcGxhY2VTdGF0ZShzdGF0ZSwgdGl0bGUsIGV4dGVybmFsVXJsKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXRmb3JtTG9jYXRpb24uZm9yd2FyZCgpOyB9O1xuICAgICAgICBQYXRoTG9jYXRpb25TdHJhdGVneS5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxhdGZvcm1Mb2NhdGlvbi5iYWNrKCk7IH07XG4gICAgICAgIFBhdGhMb2NhdGlvblN0cmF0ZWd5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGF0aExvY2F0aW9uU3RyYXRlZ3kuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IFBsYXRmb3JtTG9jYXRpb24sIH0sXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbQVBQX0JBU0VfSFJFRixdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gUGF0aExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgfShMb2NhdGlvblN0cmF0ZWd5KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ0xvY2FsaXphdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nTG9jYWxpemF0aW9uKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOZ0xvY2FsaXphdGlvbjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBsdXJhbCBjYXRlZ29yeSBmb3IgYSBnaXZlbiB2YWx1ZS5cbiAgICAgKiAtIFwiPXZhbHVlXCIgd2hlbiB0aGUgY2FzZSBleGlzdHMsXG4gICAgICogLSB0aGUgcGx1cmFsIGNhdGVnb3J5IG90aGVyd2lzZVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UGx1cmFsQ2F0ZWdvcnkodmFsdWUsIGNhc2VzLCBuZ0xvY2FsaXphdGlvbikge1xuICAgICAgICB2YXIgbmJDYXNlID0gXCI9XCIgKyB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhc2VzLmluZGV4T2YobmJDYXNlKSA+IC0xID8gbmJDYXNlIDogbmdMb2NhbGl6YXRpb24uZ2V0UGx1cmFsQ2F0ZWdvcnkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwbHVyYWwgY2FzZSBiYXNlZCBvbiB0aGUgbG9jYWxlXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5nTG9jYWxlTG9jYWxpemF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDIoTmdMb2NhbGVMb2NhbGl6YXRpb24sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nTG9jYWxlTG9jYWxpemF0aW9uKF9sb2NhbGUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gX2xvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBOZ0xvY2FsZUxvY2FsaXphdGlvbi5wcm90b3R5cGUuZ2V0UGx1cmFsQ2F0ZWdvcnkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBwbHVyYWwgPSBnZXRQbHVyYWxDYXNlKHRoaXMuX2xvY2FsZSwgdmFsdWUpO1xuICAgICAgICAgICAgc3dpdGNoIChwbHVyYWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFBsdXJhbC5aZXJvOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3plcm8nO1xuICAgICAgICAgICAgICAgIGNhc2UgUGx1cmFsLk9uZTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdvbmUnO1xuICAgICAgICAgICAgICAgIGNhc2UgUGx1cmFsLlR3bzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0d28nO1xuICAgICAgICAgICAgICAgIGNhc2UgUGx1cmFsLkZldzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdmZXcnO1xuICAgICAgICAgICAgICAgIGNhc2UgUGx1cmFsLk1hbnk6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbWFueSc7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nTG9jYWxlTG9jYWxpemF0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdMb2NhbGVMb2NhbGl6YXRpb24uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTmdMb2NhbGVMb2NhbGl6YXRpb247XG4gICAgfShOZ0xvY2FsaXphdGlvbikpO1xuICAgIC8vIFRoaXMgaXMgZ2VuZXJhdGVkIGNvZGUgRE8gTk9UIE1PRElGWVxuICAgIC8vIHNlZSBhbmd1bGFyMi9zY3JpcHQvY2xkci9nZW5fcGx1cmFsX3J1bGVzLmpzXG4gICAgLyoqIEBleHBlcmltZW50YWwgKi9cbiAgICB2YXIgUGx1cmFsO1xuICAgIChmdW5jdGlvbiAoUGx1cmFsKSB7XG4gICAgICAgIFBsdXJhbFtQbHVyYWxbXCJaZXJvXCJdID0gMF0gPSBcIlplcm9cIjtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIk9uZVwiXSA9IDFdID0gXCJPbmVcIjtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIlR3b1wiXSA9IDJdID0gXCJUd29cIjtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIkZld1wiXSA9IDNdID0gXCJGZXdcIjtcbiAgICAgICAgUGx1cmFsW1BsdXJhbFtcIk1hbnlcIl0gPSA0XSA9IFwiTWFueVwiO1xuICAgICAgICBQbHVyYWxbUGx1cmFsW1wiT3RoZXJcIl0gPSA1XSA9IFwiT3RoZXJcIjtcbiAgICB9KShQbHVyYWwgfHwgKFBsdXJhbCA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGx1cmFsIGNhc2UgYmFzZWQgb24gdGhlIGxvY2FsZVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBsdXJhbENhc2UobG9jYWxlLCBuTGlrZSkge1xuICAgICAgICAvLyBUT0RPKHZpY2IpOiBsYXp5IGNvbXB1dGVcbiAgICAgICAgaWYgKHR5cGVvZiBuTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5MaWtlID0gcGFyc2VJbnQobkxpa2UsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IG5MaWtlO1xuICAgICAgICB2YXIgbkRlY2ltYWwgPSBuLnRvU3RyaW5nKCkucmVwbGFjZSgvXlteLl0qXFwuPy8sICcnKTtcbiAgICAgICAgdmFyIGkgPSBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICAgICAgdmFyIHYgPSBuRGVjaW1hbC5sZW5ndGg7XG4gICAgICAgIHZhciBmID0gcGFyc2VJbnQobkRlY2ltYWwsIDEwKTtcbiAgICAgICAgdmFyIHQgPSBwYXJzZUludChuLnRvU3RyaW5nKCkucmVwbGFjZSgvXlteLl0qXFwuP3wwKyQvZywgJycpLCAxMCkgfHwgMDtcbiAgICAgICAgdmFyIGxhbmcgPSBsb2NhbGUuc3BsaXQoJy0nKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKGxhbmcpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FmJzpcbiAgICAgICAgICAgIGNhc2UgJ2FzYSc6XG4gICAgICAgICAgICBjYXNlICdheic6XG4gICAgICAgICAgICBjYXNlICdiZW0nOlxuICAgICAgICAgICAgY2FzZSAnYmV6JzpcbiAgICAgICAgICAgIGNhc2UgJ2JnJzpcbiAgICAgICAgICAgIGNhc2UgJ2JyeCc6XG4gICAgICAgICAgICBjYXNlICdjZSc6XG4gICAgICAgICAgICBjYXNlICdjZ2cnOlxuICAgICAgICAgICAgY2FzZSAnY2hyJzpcbiAgICAgICAgICAgIGNhc2UgJ2NrYic6XG4gICAgICAgICAgICBjYXNlICdlZSc6XG4gICAgICAgICAgICBjYXNlICdlbCc6XG4gICAgICAgICAgICBjYXNlICdlbyc6XG4gICAgICAgICAgICBjYXNlICdlcyc6XG4gICAgICAgICAgICBjYXNlICdldSc6XG4gICAgICAgICAgICBjYXNlICdmbyc6XG4gICAgICAgICAgICBjYXNlICdmdXInOlxuICAgICAgICAgICAgY2FzZSAnZ3N3JzpcbiAgICAgICAgICAgIGNhc2UgJ2hhJzpcbiAgICAgICAgICAgIGNhc2UgJ2hhdyc6XG4gICAgICAgICAgICBjYXNlICdodSc6XG4gICAgICAgICAgICBjYXNlICdqZ28nOlxuICAgICAgICAgICAgY2FzZSAnam1jJzpcbiAgICAgICAgICAgIGNhc2UgJ2thJzpcbiAgICAgICAgICAgIGNhc2UgJ2trJzpcbiAgICAgICAgICAgIGNhc2UgJ2traic6XG4gICAgICAgICAgICBjYXNlICdrbCc6XG4gICAgICAgICAgICBjYXNlICdrcyc6XG4gICAgICAgICAgICBjYXNlICdrc2InOlxuICAgICAgICAgICAgY2FzZSAna3knOlxuICAgICAgICAgICAgY2FzZSAnbGInOlxuICAgICAgICAgICAgY2FzZSAnbGcnOlxuICAgICAgICAgICAgY2FzZSAnbWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ21nbyc6XG4gICAgICAgICAgICBjYXNlICdtbCc6XG4gICAgICAgICAgICBjYXNlICdtbic6XG4gICAgICAgICAgICBjYXNlICduYic6XG4gICAgICAgICAgICBjYXNlICduZCc6XG4gICAgICAgICAgICBjYXNlICduZSc6XG4gICAgICAgICAgICBjYXNlICdubic6XG4gICAgICAgICAgICBjYXNlICdubmgnOlxuICAgICAgICAgICAgY2FzZSAnbnluJzpcbiAgICAgICAgICAgIGNhc2UgJ29tJzpcbiAgICAgICAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgICAgIGNhc2UgJ29zJzpcbiAgICAgICAgICAgIGNhc2UgJ3BzJzpcbiAgICAgICAgICAgIGNhc2UgJ3JtJzpcbiAgICAgICAgICAgIGNhc2UgJ3JvZic6XG4gICAgICAgICAgICBjYXNlICdyd2snOlxuICAgICAgICAgICAgY2FzZSAnc2FxJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlaCc6XG4gICAgICAgICAgICBjYXNlICdzbic6XG4gICAgICAgICAgICBjYXNlICdzbyc6XG4gICAgICAgICAgICBjYXNlICdzcSc6XG4gICAgICAgICAgICBjYXNlICd0YSc6XG4gICAgICAgICAgICBjYXNlICd0ZSc6XG4gICAgICAgICAgICBjYXNlICd0ZW8nOlxuICAgICAgICAgICAgY2FzZSAndGsnOlxuICAgICAgICAgICAgY2FzZSAndHInOlxuICAgICAgICAgICAgY2FzZSAndWcnOlxuICAgICAgICAgICAgY2FzZSAndXonOlxuICAgICAgICAgICAgY2FzZSAndm8nOlxuICAgICAgICAgICAgY2FzZSAndnVuJzpcbiAgICAgICAgICAgIGNhc2UgJ3dhZSc6XG4gICAgICAgICAgICBjYXNlICd4b2cnOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnYWdxJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jhcyc6XG4gICAgICAgICAgICBjYXNlICdjdSc6XG4gICAgICAgICAgICBjYXNlICdkYXYnOlxuICAgICAgICAgICAgY2FzZSAnZGplJzpcbiAgICAgICAgICAgIGNhc2UgJ2R1YSc6XG4gICAgICAgICAgICBjYXNlICdkeW8nOlxuICAgICAgICAgICAgY2FzZSAnZWJ1JzpcbiAgICAgICAgICAgIGNhc2UgJ2V3byc6XG4gICAgICAgICAgICBjYXNlICdndXonOlxuICAgICAgICAgICAgY2FzZSAna2FtJzpcbiAgICAgICAgICAgIGNhc2UgJ2tocSc6XG4gICAgICAgICAgICBjYXNlICdraSc6XG4gICAgICAgICAgICBjYXNlICdrbG4nOlxuICAgICAgICAgICAgY2FzZSAna29rJzpcbiAgICAgICAgICAgIGNhc2UgJ2tzZic6XG4gICAgICAgICAgICBjYXNlICdscmMnOlxuICAgICAgICAgICAgY2FzZSAnbHUnOlxuICAgICAgICAgICAgY2FzZSAnbHVvJzpcbiAgICAgICAgICAgIGNhc2UgJ2x1eSc6XG4gICAgICAgICAgICBjYXNlICdtZXInOlxuICAgICAgICAgICAgY2FzZSAnbWZlJzpcbiAgICAgICAgICAgIGNhc2UgJ21naCc6XG4gICAgICAgICAgICBjYXNlICdtdWEnOlxuICAgICAgICAgICAgY2FzZSAnbXpuJzpcbiAgICAgICAgICAgIGNhc2UgJ25tZyc6XG4gICAgICAgICAgICBjYXNlICdudXMnOlxuICAgICAgICAgICAgY2FzZSAncXUnOlxuICAgICAgICAgICAgY2FzZSAncm4nOlxuICAgICAgICAgICAgY2FzZSAncncnOlxuICAgICAgICAgICAgY2FzZSAnc2JwJzpcbiAgICAgICAgICAgIGNhc2UgJ3R3cSc6XG4gICAgICAgICAgICBjYXNlICd2YWknOlxuICAgICAgICAgICAgY2FzZSAneWF2JzpcbiAgICAgICAgICAgIGNhc2UgJ3l1ZSc6XG4gICAgICAgICAgICBjYXNlICd6Z2gnOlxuICAgICAgICAgICAgY2FzZSAnYWsnOlxuICAgICAgICAgICAgY2FzZSAnbG4nOlxuICAgICAgICAgICAgY2FzZSAnbWcnOlxuICAgICAgICAgICAgY2FzZSAncGEnOlxuICAgICAgICAgICAgY2FzZSAndGknOlxuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMCAmJiBuIDw9IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdhbSc6XG4gICAgICAgICAgICBjYXNlICdhcyc6XG4gICAgICAgICAgICBjYXNlICdibic6XG4gICAgICAgICAgICBjYXNlICdmYSc6XG4gICAgICAgICAgICBjYXNlICdndSc6XG4gICAgICAgICAgICBjYXNlICdoaSc6XG4gICAgICAgICAgICBjYXNlICdrbic6XG4gICAgICAgICAgICBjYXNlICdtcic6XG4gICAgICAgICAgICBjYXNlICd6dSc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgbiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2FyJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5aZXJvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMTEgJiYgbiAlIDEwMCA8PSA5OSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdhc3QnOlxuICAgICAgICAgICAgY2FzZSAnY2EnOlxuICAgICAgICAgICAgY2FzZSAnZGUnOlxuICAgICAgICAgICAgY2FzZSAnZW4nOlxuICAgICAgICAgICAgY2FzZSAnZXQnOlxuICAgICAgICAgICAgY2FzZSAnZmknOlxuICAgICAgICAgICAgY2FzZSAnZnknOlxuICAgICAgICAgICAgY2FzZSAnZ2wnOlxuICAgICAgICAgICAgY2FzZSAnaXQnOlxuICAgICAgICAgICAgY2FzZSAnbmwnOlxuICAgICAgICAgICAgY2FzZSAnc3YnOlxuICAgICAgICAgICAgY2FzZSAnc3cnOlxuICAgICAgICAgICAgY2FzZSAndXInOlxuICAgICAgICAgICAgY2FzZSAneWknOlxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHYgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdiZSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiAhKG4gJSAxMDAgPT09IDExKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gTWF0aC5mbG9vcihuICUgMTApICYmIG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgICEobiAlIDEwMCA+PSAxMiAmJiBuICUgMTAwIDw9IDE0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMCB8fCBuICUgMTAgPT09IE1hdGguZmxvb3IobiAlIDEwKSAmJiBuICUgMTAgPj0gNSAmJiBuICUgMTAgPD0gOSB8fFxuICAgICAgICAgICAgICAgICAgICBuICUgMTAwID09PSBNYXRoLmZsb29yKG4gJSAxMDApICYmIG4gJSAxMDAgPj0gMTEgJiYgbiAlIDEwMCA8PSAxNClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMSAmJiAhKG4gJSAxMDAgPT09IDExIHx8IG4gJSAxMDAgPT09IDcxIHx8IG4gJSAxMDAgPT09IDkxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gMiAmJiAhKG4gJSAxMDAgPT09IDEyIHx8IG4gJSAxMDAgPT09IDcyIHx8IG4gJSAxMDAgPT09IDkyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5Ud287XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMCA9PT0gTWF0aC5mbG9vcihuICUgMTApICYmIChuICUgMTAgPj0gMyAmJiBuICUgMTAgPD0gNCB8fCBuICUgMTAgPT09IDkpICYmXG4gICAgICAgICAgICAgICAgICAgICEobiAlIDEwMCA+PSAxMCAmJiBuICUgMTAwIDw9IDE5IHx8IG4gJSAxMDAgPj0gNzAgJiYgbiAlIDEwMCA8PSA3OSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbiAlIDEwMCA+PSA5MCAmJiBuICUgMTAwIDw9IDk5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKCEobiA9PT0gMCkgJiYgbiAlIDFlNiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdicyc6XG4gICAgICAgICAgICBjYXNlICdocic6XG4gICAgICAgICAgICBjYXNlICdzcic6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAxICYmICEoaSAlIDEwMCA9PT0gMTEpIHx8IGYgJSAxMCA9PT0gMSAmJiAhKGYgJSAxMDAgPT09IDExKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDIgJiYgaSAlIDEwIDw9IDQgJiZcbiAgICAgICAgICAgICAgICAgICAgIShpICUgMTAwID49IDEyICYmIGkgJSAxMDAgPD0gMTQpIHx8XG4gICAgICAgICAgICAgICAgICAgIGYgJSAxMCA9PT0gTWF0aC5mbG9vcihmICUgMTApICYmIGYgJSAxMCA+PSAyICYmIGYgJSAxMCA8PSA0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGYgJSAxMDAgPj0gMTIgJiYgZiAlIDEwMCA8PSAxNCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdjcyc6XG4gICAgICAgICAgICBjYXNlICdzayc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IE1hdGguZmxvb3IoaSkgJiYgaSA+PSAyICYmIGkgPD0gNCAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAoISh2ID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdjeSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuWmVybztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gNilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdkYSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEgfHwgISh0ID09PSAwKSAmJiAoaSA9PT0gMCB8fCBpID09PSAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2RzYic6XG4gICAgICAgICAgICBjYXNlICdoc2InOlxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMDAgPT09IDEgfHwgZiAlIDEwMCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gMiB8fCBmICUgMTAwID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSBNYXRoLmZsb29yKGkgJSAxMDApICYmIGkgJSAxMDAgPj0gMyAmJiBpICUgMTAwIDw9IDQgfHxcbiAgICAgICAgICAgICAgICAgICAgZiAlIDEwMCA9PT0gTWF0aC5mbG9vcihmICUgMTAwKSAmJiBmICUgMTAwID49IDMgJiYgZiAlIDEwMCA8PSA0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZmYnOlxuICAgICAgICAgICAgY2FzZSAnZnInOlxuICAgICAgICAgICAgY2FzZSAnaHknOlxuICAgICAgICAgICAgY2FzZSAna2FiJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZmlsJzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiAoaSA9PT0gMSB8fCBpID09PSAyIHx8IGkgPT09IDMpIHx8XG4gICAgICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgIShpICUgMTAgPT09IDQgfHwgaSAlIDEwID09PSA2IHx8IGkgJSAxMCA9PT0gOSkgfHxcbiAgICAgICAgICAgICAgICAgICAgISh2ID09PSAwKSAmJiAhKGYgJSAxMCA9PT0gNCB8fCBmICUgMTAgPT09IDYgfHwgZiAlIDEwID09PSA5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2dhJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMyAmJiBuIDw9IDYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gNyAmJiBuIDw9IDEwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2dkJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSB8fCBuID09PSAxMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDIgfHwgbiA9PT0gMTIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuVHdvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBNYXRoLmZsb29yKG4pICYmIChuID49IDMgJiYgbiA8PSAxMCB8fCBuID49IDEzICYmIG4gPD0gMTkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnZ3YnOlxuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAoaSAlIDEwMCA9PT0gMCB8fCBpICUgMTAwID09PSAyMCB8fCBpICUgMTAwID09PSA0MCB8fCBpICUgMTAwID09PSA2MCB8fCBpICUgMTAwID09PSA4MCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmICghKHYgPT09IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ2hlJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMiAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiAhKG4gPj0gMCAmJiBuIDw9IDEwKSAmJiBuICUgMTAgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnaXMnOlxuICAgICAgICAgICAgICAgIGlmICh0ID09PSAwICYmIGkgJSAxMCA9PT0gMSAmJiAhKGkgJSAxMDAgPT09IDExKSB8fCAhKHQgPT09IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAna3NoJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5aZXJvO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAna3cnOlxuICAgICAgICAgICAgY2FzZSAnbmFxJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlJzpcbiAgICAgICAgICAgIGNhc2UgJ3Ntbic6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnbGFnJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5aZXJvO1xuICAgICAgICAgICAgICAgIGlmICgoaSA9PT0gMCB8fCBpID09PSAxKSAmJiAhKG4gPT09IDApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnbHQnOlxuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDEgJiYgIShuICUgMTAwID49IDExICYmIG4gJSAxMDAgPD0gMTkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiAlIDEwID09PSBNYXRoLmZsb29yKG4gJSAxMCkgJiYgbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShuICUgMTAwID49IDExICYmIG4gJSAxMDAgPD0gMTkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLkZldztcbiAgICAgICAgICAgICAgICBpZiAoIShmID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5NYW55O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdsdic6XG4gICAgICAgICAgICBjYXNlICdwcmcnOlxuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDAgfHwgbiAlIDEwMCA9PT0gTWF0aC5mbG9vcihuICUgMTAwKSAmJiBuICUgMTAwID49IDExICYmIG4gJSAxMDAgPD0gMTkgfHxcbiAgICAgICAgICAgICAgICAgICAgdiA9PT0gMiAmJiBmICUgMTAwID09PSBNYXRoLmZsb29yKGYgJSAxMDApICYmIGYgJSAxMDAgPj0gMTEgJiYgZiAlIDEwMCA8PSAxOSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5aZXJvO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMTAgPT09IDEgJiYgIShuICUgMTAwID09PSAxMSkgfHwgdiA9PT0gMiAmJiBmICUgMTAgPT09IDEgJiYgIShmICUgMTAwID09PSAxMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgISh2ID09PSAyKSAmJiBmICUgMTAgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdtayc6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAxIHx8IGYgJSAxMCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ210JzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDAgfHwgbiAlIDEwMCA9PT0gTWF0aC5mbG9vcihuICUgMTAwKSAmJiBuICUgMTAwID49IDIgJiYgbiAlIDEwMCA8PSAxMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgaWYgKG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxMSAmJiBuICUgMTAwIDw9IDE5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3BsJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSAmJiB2ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gMiAmJiBpICUgMTAgPD0gNCAmJlxuICAgICAgICAgICAgICAgICAgICAhKGkgJSAxMDAgPj0gMTIgJiYgaSAlIDEwMCA8PSAxNCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmICEoaSA9PT0gMSkgJiYgaSAlIDEwID09PSBNYXRoLmZsb29yKGkgJSAxMCkgJiYgaSAlIDEwID49IDAgJiYgaSAlIDEwIDw9IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgdiA9PT0gMCAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gNSAmJiBpICUgMTAgPD0gOSB8fFxuICAgICAgICAgICAgICAgICAgICB2ID09PSAwICYmIGkgJSAxMDAgPT09IE1hdGguZmxvb3IoaSAlIDEwMCkgJiYgaSAlIDEwMCA+PSAxMiAmJiBpICUgMTAwIDw9IDE0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk1hbnk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3B0JzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDAgJiYgbiA8PSAyICYmICEobiA9PT0gMikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT25lO1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdybyc6XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgdiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgaWYgKCEodiA9PT0gMCkgfHwgbiA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAhKG4gPT09IDEpICYmIG4gJSAxMDAgPT09IE1hdGguZmxvb3IobiAlIDEwMCkgJiYgbiAlIDEwMCA+PSAxICYmIG4gJSAxMDAgPD0gMTkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuT3RoZXI7XG4gICAgICAgICAgICBjYXNlICdydSc6XG4gICAgICAgICAgICBjYXNlICd1ayc6XG4gICAgICAgICAgICAgICAgaWYgKHYgPT09IDAgJiYgaSAlIDEwID09PSAxICYmICEoaSAlIDEwMCA9PT0gMTEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAgPT09IE1hdGguZmxvb3IoaSAlIDEwKSAmJiBpICUgMTAgPj0gMiAmJiBpICUgMTAgPD0gNCAmJlxuICAgICAgICAgICAgICAgICAgICAhKGkgJSAxMDAgPj0gMTIgJiYgaSAlIDEwMCA8PSAxNCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuRmV3O1xuICAgICAgICAgICAgICAgIGlmICh2ID09PSAwICYmIGkgJSAxMCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICB2ID09PSAwICYmIGkgJSAxMCA9PT0gTWF0aC5mbG9vcihpICUgMTApICYmIGkgJSAxMCA+PSA1ICYmIGkgJSAxMCA8PSA5IHx8XG4gICAgICAgICAgICAgICAgICAgIHYgPT09IDAgJiYgaSAlIDEwMCA9PT0gTWF0aC5mbG9vcihpICUgMTAwKSAmJiBpICUgMTAwID49IDExICYmIGkgJSAxMDAgPD0gMTQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQbHVyYWwuTWFueTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk90aGVyO1xuICAgICAgICAgICAgY2FzZSAnc2hpJzpcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCB8fCBuID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID49IDIgJiYgbiA8PSAxMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3NpJzpcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMCB8fCBuID09PSAxIHx8IGkgPT09IDAgJiYgZiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3NsJzpcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLk9uZTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSAyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUGx1cmFsLlR3bztcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gMCAmJiBpICUgMTAwID09PSBNYXRoLmZsb29yKGkgJSAxMDApICYmIGkgJSAxMDAgPj0gMyAmJiBpICUgMTAwIDw9IDQgfHwgISh2ID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5GZXc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGNhc2UgJ3R6bSc6XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+PSAwICYmIG4gPD0gMSB8fCBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPj0gMTEgJiYgbiA8PSA5OSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PbmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBsdXJhbC5PdGhlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfY2xlYXJWYWx1ZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoKG5ldyBNYXAoKSkua2V5cygpLm5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBfY2xlYXJWYWx1ZXMobSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlJdGVyYXRvciA9IG0ua2V5cygpO1xuICAgICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICAgIHdoaWxlICghKChrID0ga2V5SXRlcmF0b3IubmV4dCgpKS5kb25lKSkge1xuICAgICAgICAgICAgICAgICAgICBtLnNldChrLnZhbHVlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jbGVhclZhbHVlc1dpdGhGb3JlRWFjaChtKSB7XG4gICAgICAgICAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IG0uc2V0KGssIG51bGwpOyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIC8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgICAvLyBUT0RPKG1sYXZhbCk6IHJlbW92ZSB0aGUgd29yayBhcm91bmQgb25jZSB3ZSBoYXZlIGEgd29ya2luZyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXG4gICAgdmFyIF9hcnJheUZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKChuZXcgTWFwKCkpLnZhbHVlcygpLm5leHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVzID8gQXJyYXkuZnJvbShtLnZhbHVlcygpKSA6IEFycmF5LmZyb20obS5rZXlzKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwV2l0aEZvcmVhY2gobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KG0uc2l6ZSksIGkgPSAwO1xuICAgICAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gZ2V0VmFsdWVzID8gdiA6IGs7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgdmFyIExpc3RXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTGlzdFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgaGFzIG5vIHdheSB0byBleHByZXNzIGEgc3RhdGljYWxseSBmaXhlZCBzaXplIGxpc3QsIGJ1dCBkYXJ0IGRvZXMgc28gd2VcbiAgICAgICAgLy8ga2VlcCBib3RoIG1ldGhvZHMuXG4gICAgICAgIExpc3RXcmFwcGVyLmNyZWF0ZUZpeGVkU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7IHJldHVybiBuZXcgQXJyYXkoc2l6ZSk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmNyZWF0ZUdyb3dhYmxlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7IHJldHVybiBuZXcgQXJyYXkoc2l6ZSk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmNsb25lID0gZnVuY3Rpb24gKGFycmF5KSB7IHJldHVybiBhcnJheS5zbGljZSgwKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZm9yRWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uIChhcnJheSwgZm4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbihhcnJheVtpXSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmZpcnN0ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIWFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5sYXN0ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIWFycmF5IHx8IGFycmF5Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCB2YWx1ZSwgc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IHZvaWQgMCkgeyBzdGFydEluZGV4ID0gMDsgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YodmFsdWUsIHN0YXJ0SW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChsaXN0LCBlbCkgeyByZXR1cm4gbGlzdC5pbmRleE9mKGVsKSAhPT0gLTE7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJldmVyc2VkID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgYSA9IExpc3RXcmFwcGVyLmNsb25lKGFycmF5KTtcbiAgICAgICAgICAgIHJldHVybiBhLnJldmVyc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY29uY2F0ID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5pbnNlcnQgPSBmdW5jdGlvbiAobGlzdCwgaW5kZXgsIHZhbHVlKSB7IGxpc3Quc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUF0ID0gZnVuY3Rpb24gKGxpc3QsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBbGwgPSBmdW5jdGlvbiAobGlzdCwgaXRlbXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoaXRlbXNbaV0pO1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YoZWwpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmNsZWFyID0gZnVuY3Rpb24gKGxpc3QpIHsgbGlzdC5sZW5ndGggPSAwOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5pc0VtcHR5ID0gZnVuY3Rpb24gKGxpc3QpIHsgcmV0dXJuIGxpc3QubGVuZ3RoID09IDA7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmZpbGwgPSBmdW5jdGlvbiAobGlzdCwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gMDsgfVxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IG51bGw7IH1cbiAgICAgICAgICAgIGxpc3QuZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCA9PT0gbnVsbCA/IGxpc3QubGVuZ3RoIDogZW5kKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnNsaWNlID0gZnVuY3Rpb24gKGwsIGZyb20sIHRvKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdm9pZCAwKSB7IGZyb20gPSAwOyB9XG4gICAgICAgICAgICBpZiAodG8gPT09IHZvaWQgMCkgeyB0byA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBsLnNsaWNlKGZyb20sIHRvID09PSBudWxsID8gdW5kZWZpbmVkIDogdG8pO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5zcGxpY2UgPSBmdW5jdGlvbiAobCwgZnJvbSwgbGVuZ3RoKSB7IHJldHVybiBsLnNwbGljZShmcm9tLCBsZW5ndGgpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5zb3J0ID0gZnVuY3Rpb24gKGwsIGNvbXBhcmVGbikge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjb21wYXJlRm4pKSB7XG4gICAgICAgICAgICAgICAgbC5zb3J0KGNvbXBhcmVGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsLnNvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIudG9TdHJpbmcgPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gbC50b1N0cmluZygpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci50b0pTT04gPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkobCk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLm1heGltdW0gPSBmdW5jdGlvbiAobGlzdCwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBsaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNCbGFuayhjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlVmFsdWUgPSBwcmVkaWNhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlVmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbiA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBjYW5kaWRhdGVWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29sdXRpb247XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmZsYXR0ZW4gPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IFtdO1xuICAgICAgICAgICAgX2ZsYXR0ZW5BcnJheShsaXN0LCB0YXJnZXQpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsID0gZnVuY3Rpb24gKGxpc3QsIHNvdXJjZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goc291cmNlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX2ZsYXR0ZW5BcnJheShzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZsYXR0ZW5BcnJheShpdGVtLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTGlzdExpa2VJdGVyYWJsZShvYmopIHtcbiAgICAgICAgaWYgKCFpc0pzT2JqZWN0KG9iaikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBpc0FycmF5KG9iaikgfHxcbiAgICAgICAgICAgICghKG9iaiBpbnN0YW5jZW9mIE1hcCkgJiZcbiAgICAgICAgICAgICAgICBnZXRTeW1ib2xJdGVyYXRvcigpIGluIG9iaik7IC8vIEpTIEl0ZXJhYmxlIGhhdmUgYSBTeW1ib2wuaXRlcmF0b3IgcHJvcFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKlxuICAgICAqIEB3aGF0SXREb2VzIEFkZHMgYW5kIHJlbW92ZXMgQ1NTIGNsYXNzZXMgb24gYW4gSFRNTCBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogICAgIDxzb21lLWVsZW1lbnQgW25nQ2xhc3NdPVwiJ2ZpcnN0IHNlY29uZCdcIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKlxuICAgICAqICAgICA8c29tZS1lbGVtZW50IFtuZ0NsYXNzXT1cIlsnZmlyc3QnLCAnc2Vjb25kJ11cIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKlxuICAgICAqICAgICA8c29tZS1lbGVtZW50IFtuZ0NsYXNzXT1cInsnZmlyc3QnOiB0cnVlLCAnc2Vjb25kJzogdHJ1ZSwgJ3RoaXJkJzogZmFsc2V9XCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICpcbiAgICAgKiAgICAgPHNvbWUtZWxlbWVudCBbbmdDbGFzc109XCJzdHJpbmdFeHB8YXJyYXlFeHB8b2JqRXhwXCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFRoZSBDU1MgY2xhc3NlcyBhcmUgdXBkYXRlZCBhcyBmb2xsb3cgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIHRoZSBleHByZXNzaW9uIGV2YWx1YXRpb246XG4gICAgICogLSBgc3RyaW5nYCAtIHRoZSBDU1MgY2xhc3NlcyBsaXN0ZWQgaW4gYSBzdHJpbmcgKHNwYWNlIGRlbGltaXRlZCkgYXJlIGFkZGVkLFxuICAgICAqIC0gYEFycmF5YCAtIHRoZSBDU1MgY2xhc3NlcyAoQXJyYXkgZWxlbWVudHMpIGFyZSBhZGRlZCxcbiAgICAgKiAtIGBPYmplY3RgIC0ga2V5cyBhcmUgQ1NTIGNsYXNzIG5hbWVzIHRoYXQgZ2V0IGFkZGVkIHdoZW4gdGhlIGV4cHJlc3Npb24gZ2l2ZW4gaW4gdGhlIHZhbHVlXG4gICAgICogICAgICAgICAgICAgIGV2YWx1YXRlcyB0byBhIHRydXRoeSB2YWx1ZSwgb3RoZXJ3aXNlIGNsYXNzIGFyZSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0NsYXNzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdDbGFzcyhfaXRlcmFibGVEaWZmZXJzLCBfa2V5VmFsdWVEaWZmZXJzLCBfbmdFbCwgX3JlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVyYWJsZURpZmZlcnMgPSBfaXRlcmFibGVEaWZmZXJzO1xuICAgICAgICAgICAgdGhpcy5fa2V5VmFsdWVEaWZmZXJzID0gX2tleVZhbHVlRGlmZmVycztcbiAgICAgICAgICAgIHRoaXMuX25nRWwgPSBfbmdFbDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDbGFzcy5wcm90b3R5cGUsIFwia2xhc3NcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5SW5pdGlhbENsYXNzZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB2LnNwbGl0KC9cXHMrLykgOiBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXModGhpcy5fcmF3Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdDbGFzcy5wcm90b3R5cGUsIFwibmdDbGFzc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsYXNzZXModGhpcy5fcmF3Q2xhc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZXJhYmxlRGlmZmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlWYWx1ZURpZmZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmF3Q2xhc3MgPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB2LnNwbGl0KC9cXHMrLykgOiB2O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yYXdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaXN0TGlrZUl0ZXJhYmxlKHRoaXMuX3Jhd0NsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlcmFibGVEaWZmZXIgPSB0aGlzLl9pdGVyYWJsZURpZmZlcnMuZmluZCh0aGlzLl9yYXdDbGFzcykuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5VmFsdWVEaWZmZXIgPSB0aGlzLl9rZXlWYWx1ZURpZmZlcnMuZmluZCh0aGlzLl9yYXdDbGFzcykuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nQ2xhc3MucHJvdG90eXBlLm5nRG9DaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVyYWJsZURpZmZlcikge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5faXRlcmFibGVEaWZmZXIuZGlmZih0aGlzLl9yYXdDbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlJdGVyYWJsZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fa2V5VmFsdWVEaWZmZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHRoaXMuX2tleVZhbHVlRGlmZmVyLmRpZmYodGhpcy5fcmF3Q2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5S2V5VmFsdWVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUuX2NsZWFudXBDbGFzc2VzID0gZnVuY3Rpb24gKHJhd0NsYXNzVmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUNsYXNzZXMocmF3Q2xhc3NWYWwsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlJbml0aWFsQ2xhc3NlcyhmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nQ2xhc3MucHJvdG90eXBlLl9hcHBseUtleVZhbHVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQua2V5LCByZWNvcmQuY3VycmVudFZhbHVlKTsgfSk7XG4gICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hDaGFuZ2VkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLmtleSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlJdGVyYWJsZUNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fdG9nZ2xlQ2xhc3MocmVjb3JkLml0ZW0sIHRydWUpOyB9KTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhyZWNvcmQuaXRlbSwgZmFsc2UpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5wcm90b3R5cGUuX2FwcGx5SW5pdGlhbENsYXNzZXMgPSBmdW5jdGlvbiAoaXNDbGVhbnVwKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoa2xhc3MpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhrbGFzcywgIWlzQ2xlYW51cCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0NsYXNzLnByb3RvdHlwZS5fYXBwbHlDbGFzc2VzID0gZnVuY3Rpb24gKHJhd0NsYXNzVmFsLCBpc0NsZWFudXApIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocmF3Q2xhc3NWYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdDbGFzc1ZhbCkgfHwgcmF3Q2xhc3NWYWwgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3Q2xhc3NWYWwuZm9yRWFjaChmdW5jdGlvbiAoa2xhc3MpIHsgcmV0dXJuIF90aGlzLl90b2dnbGVDbGFzcyhrbGFzcywgIWlzQ2xlYW51cCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmF3Q2xhc3NWYWwpLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHJhd0NsYXNzVmFsW2tsYXNzXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RvZ2dsZUNsYXNzKGtsYXNzLCAhaXNDbGVhbnVwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ0NsYXNzLnByb3RvdHlwZS5fdG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbiAoa2xhc3MsIGVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBrbGFzcyA9IGtsYXNzLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChrbGFzcykge1xuICAgICAgICAgICAgICAgIGtsYXNzLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IF90aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoX3RoaXMuX25nRWwubmF0aXZlRWxlbWVudCwga2xhc3MsIGVuYWJsZWQpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdDbGFzcy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdDbGFzc10nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdDbGFzcy5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JdGVyYWJsZURpZmZlcnMsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuS2V5VmFsdWVEaWZmZXJzLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nQ2xhc3MucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAna2xhc3MnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2NsYXNzJyxdIH0sXSxcbiAgICAgICAgICAgICduZ0NsYXNzJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ0NsYXNzO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgTmdGb3JSb3cgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ0ZvclJvdygkaW1wbGljaXQsIGluZGV4LCBjb3VudCkge1xuICAgICAgICAgICAgdGhpcy4kaW1wbGljaXQgPSAkaW1wbGljaXQ7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yUm93LnByb3RvdHlwZSwgXCJmaXJzdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPT09IDA7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3JSb3cucHJvdG90eXBlLCBcImxhc3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluZGV4ID09PSB0aGlzLmNvdW50IC0gMTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0ZvclJvdy5wcm90b3R5cGUsIFwiZXZlblwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaW5kZXggJSAyID09PSAwOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9yUm93LnByb3RvdHlwZSwgXCJvZGRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5ldmVuOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE5nRm9yUm93O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVGhlIGBOZ0ZvcmAgZGlyZWN0aXZlIGluc3RhbnRpYXRlcyBhIHRlbXBsYXRlIG9uY2UgcGVyIGl0ZW0gZnJvbSBhbiBpdGVyYWJsZS4gVGhlIGNvbnRleHQgZm9yXG4gICAgICogZWFjaCBpbnN0YW50aWF0ZWQgdGVtcGxhdGUgaW5oZXJpdHMgZnJvbSB0aGUgb3V0ZXIgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBsb29wIHZhcmlhYmxlIHNldFxuICAgICAqIHRvIHRoZSBjdXJyZW50IGl0ZW0gZnJvbSB0aGUgaXRlcmFibGUuXG4gICAgICpcbiAgICAgKiAjIyMgTG9jYWwgVmFyaWFibGVzXG4gICAgICpcbiAgICAgKiBgTmdGb3JgIHByb3ZpZGVzIHNldmVyYWwgZXhwb3J0ZWQgdmFsdWVzIHRoYXQgY2FuIGJlIGFsaWFzZWQgdG8gbG9jYWwgdmFyaWFibGVzOlxuICAgICAqXG4gICAgICogKiBgaW5kZXhgIHdpbGwgYmUgc2V0IHRvIHRoZSBjdXJyZW50IGxvb3AgaXRlcmF0aW9uIGZvciBlYWNoIHRlbXBsYXRlIGNvbnRleHQuXG4gICAgICogKiBgZmlyc3RgIHdpbGwgYmUgc2V0IHRvIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGl0ZW0gaXMgdGhlIGZpcnN0IG9uZSBpbiB0aGVcbiAgICAgKiAgIGl0ZXJhdGlvbi5cbiAgICAgKiAqIGBsYXN0YCB3aWxsIGJlIHNldCB0byBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBpdGVtIGlzIHRoZSBsYXN0IG9uZSBpbiB0aGVcbiAgICAgKiAgIGl0ZXJhdGlvbi5cbiAgICAgKiAqIGBldmVuYCB3aWxsIGJlIHNldCB0byBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgaXRlbSBoYXMgYW4gZXZlbiBpbmRleC5cbiAgICAgKiAqIGBvZGRgIHdpbGwgYmUgc2V0IHRvIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpdGVtIGhhcyBhbiBvZGQgaW5kZXguXG4gICAgICpcbiAgICAgKiAjIyMgQ2hhbmdlIFByb3BhZ2F0aW9uXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBjb250ZW50cyBvZiB0aGUgaXRlcmF0b3IgY2hhbmdlcywgYE5nRm9yYCBtYWtlcyB0aGUgY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRvIHRoZSBET006XG4gICAgICpcbiAgICAgKiAqIFdoZW4gYW4gaXRlbSBpcyBhZGRlZCwgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIGlzIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICogKiBXaGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCwgaXRzIHRlbXBsYXRlIGluc3RhbmNlIGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAqICogV2hlbiBpdGVtcyBhcmUgcmVvcmRlcmVkLCB0aGVpciByZXNwZWN0aXZlIHRlbXBsYXRlcyBhcmUgcmVvcmRlcmVkIGluIHRoZSBET00uXG4gICAgICogKiBPdGhlcndpc2UsIHRoZSBET00gZWxlbWVudCBmb3IgdGhhdCBpdGVtIHdpbGwgcmVtYWluIHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogQW5ndWxhciB1c2VzIG9iamVjdCBpZGVudGl0eSB0byB0cmFjayBpbnNlcnRpb25zIGFuZCBkZWxldGlvbnMgd2l0aGluIHRoZSBpdGVyYXRvciBhbmQgcmVwcm9kdWNlXG4gICAgICogdGhvc2UgY2hhbmdlcyBpbiB0aGUgRE9NLiBUaGlzIGhhcyBpbXBvcnRhbnQgaW1wbGljYXRpb25zIGZvciBhbmltYXRpb25zIGFuZCBhbnkgc3RhdGVmdWxcbiAgICAgKiBjb250cm9sc1xuICAgICAqIChzdWNoIGFzIGA8aW5wdXQ+YCBlbGVtZW50cyB3aGljaCBhY2NlcHQgdXNlciBpbnB1dCkgdGhhdCBhcmUgcHJlc2VudC4gSW5zZXJ0ZWQgcm93cyBjYW4gYmVcbiAgICAgKiBhbmltYXRlZCBpbiwgZGVsZXRlZCByb3dzIGNhbiBiZSBhbmltYXRlZCBvdXQsIGFuZCB1bmNoYW5nZWQgcm93cyByZXRhaW4gYW55IHVuc2F2ZWQgc3RhdGUgc3VjaFxuICAgICAqIGFzIHVzZXIgaW5wdXQuXG4gICAgICpcbiAgICAgKiBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIGlkZW50aXRpZXMgb2YgZWxlbWVudHMgaW4gdGhlIGl0ZXJhdG9yIHRvIGNoYW5nZSB3aGlsZSB0aGUgZGF0YSBkb2VzIG5vdC5cbiAgICAgKiBUaGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiB0aGUgaXRlcmF0b3IgcHJvZHVjZWQgZnJvbSBhbiBSUEMgdG8gdGhlIHNlcnZlciwgYW5kIHRoYXRcbiAgICAgKiBSUEMgaXMgcmUtcnVuLiBFdmVuIGlmIHRoZSBkYXRhIGhhc24ndCBjaGFuZ2VkLCB0aGUgc2Vjb25kIHJlc3BvbnNlIHdpbGwgcHJvZHVjZSBvYmplY3RzIHdpdGhcbiAgICAgKiBkaWZmZXJlbnQgaWRlbnRpdGllcywgYW5kIEFuZ3VsYXIgd2lsbCB0ZWFyIGRvd24gdGhlIGVudGlyZSBET00gYW5kIHJlYnVpbGQgaXQgKGFzIGlmIGFsbCBvbGRcbiAgICAgKiBlbGVtZW50cyB3ZXJlIGRlbGV0ZWQgYW5kIGFsbCBuZXcgZWxlbWVudHMgaW5zZXJ0ZWQpLiBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24gYW5kIHNob3VsZFxuICAgICAqIGJlIGF2b2lkZWQgaWYgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBUbyBjdXN0b21pemUgdGhlIGRlZmF1bHQgdHJhY2tpbmcgYWxnb3JpdGhtLCBgTmdGb3JgIHN1cHBvcnRzIGB0cmFja0J5YCBvcHRpb24uXG4gICAgICogYHRyYWNrQnlgIHRha2VzIGEgZnVuY3Rpb24gd2hpY2ggaGFzIHR3byBhcmd1bWVudHM6IGBpbmRleGAgYW5kIGBpdGVtYC5cbiAgICAgKiBJZiBgdHJhY2tCeWAgaXMgZ2l2ZW4sIEFuZ3VsYXIgdHJhY2tzIGNoYW5nZXMgYnkgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAjIyMgU3ludGF4XG4gICAgICpcbiAgICAgKiAtIGA8bGkgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXM7IGxldCBpID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrQnlGblwiPi4uLjwvbGk+YFxuICAgICAqIC0gYDxsaSB0ZW1wbGF0ZT1cIm5nRm9yIGxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaSA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5Rm5cIj4uLi48L2xpPmBcbiAgICAgKlxuICAgICAqIFdpdGggYDx0ZW1wbGF0ZT5gIGVsZW1lbnQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8dGVtcGxhdGUgbmdGb3IgbGV0LWl0ZW0gW25nRm9yT2ZdPVwiaXRlbXNcIiBsZXQtaT1cImluZGV4XCIgW25nRm9yVHJhY2tCeV09XCJ0cmFja0J5Rm5cIj5cbiAgICAgKiAgIDxsaT4uLi48L2xpPlxuICAgICAqIDwvdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogU2VlIGEgW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS1Z1WHhEcDBxaW5HRHlvMzA3UVc/cD1wcmV2aWV3KSBmb3IgYSBtb3JlIGRldGFpbGVkXG4gICAgICogZXhhbXBsZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdGb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ0Zvcihfdmlld0NvbnRhaW5lciwgX3RlbXBsYXRlLCBfZGlmZmVycywgX2Nkcikge1xuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lciA9IF92aWV3Q29udGFpbmVyO1xuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBfdGVtcGxhdGU7XG4gICAgICAgICAgICB0aGlzLl9kaWZmZXJzID0gX2RpZmZlcnM7XG4gICAgICAgICAgICB0aGlzLl9jZHIgPSBfY2RyO1xuICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdGb3IucHJvdG90eXBlLCBcIm5nRm9yVGVtcGxhdGVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdGb3IucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICgnbmdGb3JPZicgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIC8vIFJlYWN0IG9uIG5nRm9yT2YgY2hhbmdlcyBvbmx5IG9uY2UgYWxsIGlucHV0cyBoYXZlIGJlZW4gaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjaGFuZ2VzWyduZ0Zvck9mJ10uY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlmZmVyICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSB0aGlzLl9kaWZmZXJzLmZpbmQodmFsdWUpLmNyZWF0ZSh0aGlzLl9jZHIsIHRoaXMubmdGb3JUcmFja0J5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJ1wiICsgdmFsdWUgKyBcIicgb2YgdHlwZSAnXCIgKyBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh2YWx1ZSkgKyBcIicuIE5nRm9yIG9ubHkgc3VwcG9ydHMgYmluZGluZyB0byBJdGVyYWJsZXMgc3VjaCBhcyBBcnJheXMuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ0Zvci5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5uZ0Zvck9mKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ0Zvci5wcm90b3R5cGUuX2FwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGluc2VydFR1cGxlcyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoT3BlcmF0aW9uKGZ1bmN0aW9uIChpdGVtLCBhZGp1c3RlZFByZXZpb3VzSW5kZXgsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnByZXZpb3VzSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IF90aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhfdGhpcy5fdGVtcGxhdGUsIG5ldyBOZ0ZvclJvdyhudWxsLCBudWxsLCBudWxsKSwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR1cGxlID0gbmV3IFJlY29yZFZpZXdUdXBsZShpdGVtLCB2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VHVwbGVzLnB1c2godHVwbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdmlld0NvbnRhaW5lci5yZW1vdmUoYWRqdXN0ZWRQcmV2aW91c0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gX3RoaXMuX3ZpZXdDb250YWluZXIuZ2V0KGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl92aWV3Q29udGFpbmVyLm1vdmUodmlldywgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR1cGxlID0gbmV3IFJlY29yZFZpZXdUdXBsZShpdGVtLCB2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VHVwbGVzLnB1c2godHVwbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNlcnRUdXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZXJWaWV3Q2hhbmdlKGluc2VydFR1cGxlc1tpXS52aWV3LCBpbnNlcnRUdXBsZXNbaV0ucmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5fdmlld0NvbnRhaW5lci5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlld1JlZiA9IHRoaXMuX3ZpZXdDb250YWluZXIuZ2V0KGkpO1xuICAgICAgICAgICAgICAgIHZpZXdSZWYuY29udGV4dC5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgdmlld1JlZi5jb250ZXh0LmNvdW50ID0gaWxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaElkZW50aXR5Q2hhbmdlKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlld1JlZiA9IF90aGlzLl92aWV3Q29udGFpbmVyLmdldChyZWNvcmQuY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICB2aWV3UmVmLmNvbnRleHQuJGltcGxpY2l0ID0gcmVjb3JkLml0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3IucHJvdG90eXBlLl9wZXJWaWV3Q2hhbmdlID0gZnVuY3Rpb24gKHZpZXcsIHJlY29yZCkge1xuICAgICAgICAgICAgdmlldy5jb250ZXh0LiRpbXBsaWNpdCA9IHJlY29yZC5pdGVtO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdGb3JdW25nRm9yT2ZdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nRm9yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSXRlcmFibGVEaWZmZXJzLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdG9yUmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ0Zvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ0Zvck9mJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICAgICAnbmdGb3JUcmFja0J5JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgICAgICAnbmdGb3JUZW1wbGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdGb3I7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVjb3JkVmlld1R1cGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVjb3JkVmlld1R1cGxlKHJlY29yZCwgdmlldykge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmQgPSByZWNvcmQ7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWNvcmRWaWV3VHVwbGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgb3IgcmVjcmVhdGVzIGEgcG9ydGlvbiBvZiB0aGUgRE9NIHRyZWUgYmFzZWQgb24gYW4ge2V4cHJlc3Npb259LlxuICAgICAqXG4gICAgICogSWYgdGhlIGV4cHJlc3Npb24gYXNzaWduZWQgdG8gYG5nSWZgIGV2YWx1YXRlcyB0byBhIGZhbHNlIHZhbHVlIHRoZW4gdGhlIGVsZW1lbnRcbiAgICAgKiBpcyByZW1vdmVkIGZyb20gdGhlIERPTSwgb3RoZXJ3aXNlIGEgY2xvbmUgb2YgdGhlIGVsZW1lbnQgaXMgcmVpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZmUwa2dlbUZCdG1RT1kzMWI0dHc/cD1wcmV2aWV3KSk6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8ZGl2ICpuZ0lmPVwiZXJyb3JDb3VudCA+IDBcIiBjbGFzcz1cImVycm9yXCI+XG4gICAgICogICA8IS0tIEVycm9yIG1lc3NhZ2UgZGlzcGxheWVkIHdoZW4gdGhlIGVycm9yQ291bnQgcHJvcGVydHkgb24gdGhlIGN1cnJlbnQgY29udGV4dCBpcyBncmVhdGVyXG4gICAgICogdGhhbiAwLiAtLT5cbiAgICAgKiAgIHt7ZXJyb3JDb3VudH19IGVycm9ycyBkZXRlY3RlZFxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIFN5bnRheFxuICAgICAqXG4gICAgICogLSBgPGRpdiAqbmdJZj1cImNvbmRpdGlvblwiPi4uLjwvZGl2PmBcbiAgICAgKiAtIGA8ZGl2IHRlbXBsYXRlPVwibmdJZiBjb25kaXRpb25cIj4uLi48L2Rpdj5gXG4gICAgICogLSBgPHRlbXBsYXRlIFtuZ0lmXT1cImNvbmRpdGlvblwiPjxkaXY+Li4uPC9kaXY+PC90ZW1wbGF0ZT5gXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nSWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ0lmKF92aWV3Q29udGFpbmVyLCBfdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gX3RlbXBsYXRlO1xuICAgICAgICAgICAgdGhpcy5faGFzVmlldyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0lmLnByb3RvdHlwZSwgXCJuZ0lmXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24gJiYgIXRoaXMuX2hhc1ZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzVmlldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNvbmRpdGlvbiAmJiB0aGlzLl9oYXNWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc1ZpZXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ0lmLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ0lmXScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ0lmLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nSWYucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdJZic6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdJZjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIF9DQVNFX0RFRkFVTFQgPSBuZXcgT2JqZWN0KCk7XG4gICAgdmFyIFN3aXRjaFZpZXcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTd2l0Y2hWaWV3KF92aWV3Q29udGFpbmVyUmVmLCBfdGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlUmVmID0gX3RlbXBsYXRlUmVmO1xuICAgICAgICB9XG4gICAgICAgIFN3aXRjaFZpZXcucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYpOyB9O1xuICAgICAgICBTd2l0Y2hWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7IH07XG4gICAgICAgIHJldHVybiBTd2l0Y2hWaWV3O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQWRkcyAvIHJlbW92ZXMgRE9NIHN1Yi10cmVlcyB3aGVuIHRoZSBuZXN0IG1hdGNoIGV4cHJlc3Npb25zIG1hdGNoZXMgdGhlIHN3aXRjaFxuICAgICAqICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiAgICAgPGNvbnRhaW5lci1lbGVtZW50IFtuZ1N3aXRjaF09XCJzd2l0Y2hfZXhwcmVzc2lvblwiPlxuICAgICAqICAgICAgIDxzb21lLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fMVwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqICAgICAgIDxzb21lLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fMlwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqICAgICAgIDxzb21lLW90aGVyLWVsZW1lbnQgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fM1wiPi4uLjwvc29tZS1vdGhlci1lbGVtZW50PlxuICAgICAqICAgICAgIDxuZy1jb250YWluZXIgKm5nU3dpdGNoQ2FzZT1cIm1hdGNoX2V4cHJlc3Npb25fM1wiPlxuICAgICAqICAgICAgICAgPCEtLSB1c2UgYSBuZy1jb250YWluZXIgdG8gZ3JvdXAgbXVsdGlwbGUgcm9vdCBub2RlcyAtLT5cbiAgICAgKiAgICAgICAgIDxpbm5lci1lbGVtZW50PjwvaW5uZXItZWxlbWVudD5cbiAgICAgKiAgICAgICAgIDxpbm5lci1vdGhlci1lbGVtZW50PjwvaW5uZXItb3RoZXItZWxlbWVudD5cbiAgICAgKiAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgKiAgICAgICA8c29tZS1lbGVtZW50ICpuZ1N3aXRjaERlZmF1bHQ+Li4uPC9wPlxuICAgICAqICAgICA8L2NvbnRhaW5lci1lbGVtZW50PlxuICAgICAqIGBgYFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogYE5nU3dpdGNoYCBzdGFtcHMgb3V0IG5lc3RlZCB2aWV3cyB3aGVuIHRoZWlyIG1hdGNoIGV4cHJlc3Npb24gdmFsdWUgbWF0Y2hlcyB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICogc3dpdGNoIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBJbiBvdGhlciB3b3JkczpcbiAgICAgKiAtIHlvdSBkZWZpbmUgYSBjb250YWluZXIgZWxlbWVudCAod2hlcmUgeW91IHBsYWNlIHRoZSBkaXJlY3RpdmUgd2l0aCBhIHN3aXRjaCBleHByZXNzaW9uIG9uIHRoZVxuICAgICAqIGBbbmdTd2l0Y2hdPVwiLi4uXCJgIGF0dHJpYnV0ZSlcbiAgICAgKiAtIHlvdSBkZWZpbmUgaW5uZXIgdmlld3MgaW5zaWRlIHRoZSBgTmdTd2l0Y2hgIGFuZCBwbGFjZSBhIGAqbmdTd2l0Y2hDYXNlYCBhdHRyaWJ1dGUgb24gdGhlIHZpZXdcbiAgICAgKiByb290IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogRWxlbWVudHMgd2l0aGluIGBOZ1N3aXRjaGAgYnV0IG91dHNpZGUgb2YgYSBgTmdTd2l0Y2hDYXNlYCBvciBgTmdTd2l0Y2hEZWZhdWx0YCBkaXJlY3RpdmVzIHdpbGxcbiAgICAgKiBiZVxuICAgICAqIHByZXNlcnZlZCBhdCB0aGUgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYG5nU3dpdGNoQ2FzZWAgZGlyZWN0aXZlIGluZm9ybXMgdGhlIHBhcmVudCBgTmdTd2l0Y2hgIG9mIHdoaWNoIHZpZXcgdG8gZGlzcGxheSB3aGVuIHRoZVxuICAgICAqIGV4cHJlc3Npb24gaXMgZXZhbHVhdGVkLlxuICAgICAqIFdoZW4gbm8gbWF0Y2hpbmcgZXhwcmVzc2lvbiBpcyBmb3VuZCBvbiBhIGBuZ1N3aXRjaENhc2VgIHZpZXcsIHRoZSBgbmdTd2l0Y2hEZWZhdWx0YCB2aWV3IGlzXG4gICAgICogc3RhbXBlZCBvdXQuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nU3dpdGNoID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdTd2l0Y2goKSB7XG4gICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZVZpZXdzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmlld3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTd2l0Y2gucHJvdG90eXBlLCBcIm5nU3dpdGNoXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgdGhlIGN1cnJlbnRseSBhY3RpdmUgVmlld0NvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICB0aGlzLl9lbXB0eUFsbEFjdGl2ZVZpZXdzKCk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBWaWV3Q29udGFpbmVycyBtYXRjaGluZyB0aGUgdmFsdWUgKHdpdGggYSBmYWxsYmFjayB0byBkZWZhdWx0KVxuICAgICAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgdmlld3MgPSB0aGlzLl92YWx1ZVZpZXdzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3MgPSB0aGlzLl92YWx1ZVZpZXdzLmdldChfQ0FTRV9ERUZBVUxUKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZVZpZXdzKHZpZXdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2l0Y2hWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTd2l0Y2gucHJvdG90eXBlLl9vbkNhc2VWYWx1ZUNoYW5nZWQgPSBmdW5jdGlvbiAob2xkQ2FzZSwgbmV3Q2FzZSwgdmlldykge1xuICAgICAgICAgICAgdGhpcy5fZGVyZWdpc3RlclZpZXcob2xkQ2FzZSwgdmlldyk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlclZpZXcobmV3Q2FzZSwgdmlldyk7XG4gICAgICAgICAgICBpZiAob2xkQ2FzZSA9PT0gdGhpcy5fc3dpdGNoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUodGhpcy5fYWN0aXZlVmlld3MsIHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV3Q2FzZSA9PT0gdGhpcy5fc3dpdGNoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXNlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2VEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtcHR5QWxsQWN0aXZlVmlld3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlldy5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3dpdGNoIHRvIGRlZmF1bHQgd2hlbiB0aGVyZSBpcyBubyBtb3JlIGFjdGl2ZSBWaWV3Q29udGFpbmVyc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVZpZXdzLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy5fdXNlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlVmlld3ModGhpcy5fdmFsdWVWaWV3cy5nZXQoX0NBU0VfREVGQVVMVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX2VtcHR5QWxsQWN0aXZlVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlQ29udGFpbmVycyA9IHRoaXMuX2FjdGl2ZVZpZXdzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmVDb250YWluZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlQ29udGFpbmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVWaWV3cyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX2FjdGl2YXRlVmlld3MgPSBmdW5jdGlvbiAodmlld3MpIHtcbiAgICAgICAgICAgIGlmICh2aWV3cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3NbaV0uY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZpZXdzID0gdmlld3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTd2l0Y2gucHJvdG90eXBlLl9yZWdpc3RlclZpZXcgPSBmdW5jdGlvbiAodmFsdWUsIHZpZXcpIHtcbiAgICAgICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX3ZhbHVlVmlld3MuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghdmlld3MpIHtcbiAgICAgICAgICAgICAgICB2aWV3cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlVmlld3Muc2V0KHZhbHVlLCB2aWV3cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1N3aXRjaC5wcm90b3R5cGUuX2RlcmVnaXN0ZXJWaWV3ID0gZnVuY3Rpb24gKHZhbHVlLCB2aWV3KSB7XG4gICAgICAgICAgICAvLyBgX0NBU0VfREVGQVVMVGAgaXMgdXNlZCBhIG1hcmtlciBmb3Igbm9uLXJlZ2lzdGVyZWQgY2FzZXNcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gX0NBU0VfREVGQVVMVClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdmlld3MgPSB0aGlzLl92YWx1ZVZpZXdzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmlld3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZVZpZXdzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUodmlld3MsIHZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1N3aXRjaC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTd2l0Y2hdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU3dpdGNoLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIE5nU3dpdGNoLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nU3dpdGNoJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOZ1N3aXRjaDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKlxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYSB2aWV3IHRoYXQgd2lsbCBiZSBhZGRlZC9yZW1vdmVkIGZyb20gdGhlIHBhcmVudCB7QGxpbmsgTmdTd2l0Y2h9IHdoZW4gdGhlXG4gICAgICogICAgICAgICAgICAgZ2l2ZW4gZXhwcmVzc2lvbiBldmFsdWF0ZSB0byByZXNwZWN0aXZlbHkgdGhlIHNhbWUvZGlmZmVyZW50IHZhbHVlIGFzIHRoZSBzd2l0Y2hcbiAgICAgKiAgICAgICAgICAgICBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogPGNvbnRhaW5lci1lbGVtZW50IFtuZ1N3aXRjaF09XCJzd2l0Y2hfZXhwcmVzc2lvblwiPlxuICAgICAqICAgPHNvbWUtZWxlbWVudCAqbmdTd2l0Y2hDYXNlPVwibWF0Y2hfZXhwcmVzc2lvbl8xXCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICogPC9jb250YWluZXItZWxlbWVudD5cbiAgICAgKmBgYFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogSW5zZXJ0IHRoZSBzdWItdHJlZSB3aGVuIHRoZSBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZW5jbG9zaW5nIHN3aXRjaFxuICAgICAqIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBJZiBtdWx0aXBsZSBtYXRjaCBleHByZXNzaW9ucyBtYXRjaCB0aGUgc3dpdGNoIGV4cHJlc3Npb24gdmFsdWUsIGFsbCBvZiB0aGVtIGFyZSBkaXNwbGF5ZWQuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIE5nU3dpdGNofSBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ1N3aXRjaENhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1N3aXRjaENhc2Uodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYsIG5nU3dpdGNoKSB7XG4gICAgICAgICAgICAvLyBgX0NBU0VfREVGQVVMVGAgaXMgdXNlZCBhcyBhIG1hcmtlciBmb3IgYSBub3QgeWV0IGluaXRpYWxpemVkIHZhbHVlXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IF9DQVNFX0RFRkFVTFQ7XG4gICAgICAgICAgICB0aGlzLl9zd2l0Y2ggPSBuZ1N3aXRjaDtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBuZXcgU3dpdGNoVmlldyh2aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU3dpdGNoQ2FzZS5wcm90b3R5cGUsIFwibmdTd2l0Y2hDYXNlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3dpdGNoLl9vbkNhc2VWYWx1ZUNoYW5nZWQodGhpcy5fdmFsdWUsIHZhbHVlLCB0aGlzLl92aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nU3dpdGNoQ2FzZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdTd2l0Y2hDYXNlXScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1N3aXRjaENhc2UuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogTmdTd2l0Y2gsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdTd2l0Y2hDYXNlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nU3dpdGNoQ2FzZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdTd2l0Y2hDYXNlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYSB2aWV3IHRoYXQgaXMgYWRkZWQgdG8gdGhlIHBhcmVudCB7QGxpbmsgTmdTd2l0Y2h9IHdoZW4gbm8gY2FzZSBleHByZXNzaW9uc1xuICAgICAqIG1hdGNoIHRoZVxuICAgICAqICAgICAgICAgICAgIHN3aXRjaCBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogPGNvbnRhaW5lci1lbGVtZW50IFtuZ1N3aXRjaF09XCJzd2l0Y2hfZXhwcmVzc2lvblwiPlxuICAgICAqICAgPHNvbWUtZWxlbWVudCAqbmdTd2l0Y2hDYXNlPVwibWF0Y2hfZXhwcmVzc2lvbl8xXCI+Li4uPC9zb21lLWVsZW1lbnQ+XG4gICAgICogICA8c29tZS1vdGhlci1lbGVtZW50ICpuZ1N3aXRjaERlZmF1bHQ+Li4uPC9zb21lLW90aGVyLWVsZW1lbnQ+XG4gICAgICogPC9jb250YWluZXItZWxlbWVudD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogSW5zZXJ0IHRoZSBzdWItdHJlZSB3aGVuIG5vIGNhc2UgZXhwcmVzc2lvbnMgZXZhbHVhdGUgdG8gdGhlIHNhbWUgdmFsdWUgYXMgdGhlIGVuY2xvc2luZyBzd2l0Y2hcbiAgICAgKiBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBOZ1N3aXRjaH0gZm9yIG1vcmUgZGV0YWlscyBhbmQgZXhhbXBsZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdTd2l0Y2hEZWZhdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdTd2l0Y2hEZWZhdWx0KHZpZXdDb250YWluZXIsIHRlbXBsYXRlUmVmLCBzc3dpdGNoKSB7XG4gICAgICAgICAgICBzc3dpdGNoLl9yZWdpc3RlclZpZXcoX0NBU0VfREVGQVVMVCwgbmV3IFN3aXRjaFZpZXcodmlld0NvbnRhaW5lciwgdGVtcGxhdGVSZWYpKTtcbiAgICAgICAgfVxuICAgICAgICBOZ1N3aXRjaERlZmF1bHQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nU3dpdGNoRGVmYXVsdF0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdTd2l0Y2hEZWZhdWx0LmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IE5nU3dpdGNoLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBOZ1N3aXRjaERlZmF1bHQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKlxuICAgICAqIEB3aGF0SXREb2VzIEFkZHMgLyByZW1vdmVzIERPTSBzdWItdHJlZXMgYmFzZWQgb24gYSBudW1lcmljIHZhbHVlLiBUYWlsb3JlZCBmb3IgcGx1cmFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIGBgYFxuICAgICAqIDxzb21lLWVsZW1lbnQgW25nUGx1cmFsXT1cInZhbHVlXCI+XG4gICAgICogICA8bmctY29udGFpbmVyICpuZ1BsdXJhbENhc2U9XCInPTAnXCI+dGhlcmUgaXMgbm90aGluZzwvbmctY29udGFpbmVyPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJz0xJ1wiPnRoZXJlIGlzIG9uZTwvbmctY29udGFpbmVyPlxuICAgICAqICAgPG5nLWNvbnRhaW5lciAqbmdQbHVyYWxDYXNlPVwiJ2ZldydcIj50aGVyZSBhcmUgYSBmZXc8L25nLWNvbnRhaW5lcj5cbiAgICAgKiAgIDxuZy1jb250YWluZXIgKm5nUGx1cmFsQ2FzZT1cIidvdGhlcidcIj50aGVyZSBhcmUgZXhhY3RseSAjPC9uZy1jb250YWluZXI+XG4gICAgICogPC9zb21lLWVsZW1lbnQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIERpc3BsYXlzIERPTSBzdWItdHJlZXMgdGhhdCBtYXRjaCB0aGUgc3dpdGNoIGV4cHJlc3Npb24gdmFsdWUsIG9yIGZhaWxpbmcgdGhhdCwgRE9NIHN1Yi10cmVlc1xuICAgICAqIHRoYXQgbWF0Y2ggdGhlIHN3aXRjaCBleHByZXNzaW9uJ3MgcGx1cmFsaXphdGlvbiBjYXRlZ29yeS5cbiAgICAgKlxuICAgICAqIFRvIHVzZSB0aGlzIGRpcmVjdGl2ZSB5b3UgbXVzdCBwcm92aWRlIGEgY29udGFpbmVyIGVsZW1lbnQgdGhhdCBzZXRzIHRoZSBgW25nUGx1cmFsXWAgYXR0cmlidXRlXG4gICAgICogdG8gYSBzd2l0Y2ggZXhwcmVzc2lvbi4gSW5uZXIgZWxlbWVudHMgd2l0aCBhIGBbbmdQbHVyYWxDYXNlXWAgd2lsbCBkaXNwbGF5IGJhc2VkIG9uIHRoZWlyXG4gICAgICogZXhwcmVzc2lvbjpcbiAgICAgKiAtIGlmIGBbbmdQbHVyYWxDYXNlXWAgaXMgc2V0IHRvIGEgdmFsdWUgc3RhcnRpbmcgd2l0aCBgPWAsIGl0IHdpbGwgb25seSBkaXNwbGF5IGlmIHRoZSB2YWx1ZVxuICAgICAqICAgbWF0Y2hlcyB0aGUgc3dpdGNoIGV4cHJlc3Npb24gZXhhY3RseSxcbiAgICAgKiAtIG90aGVyd2lzZSwgdGhlIHZpZXcgd2lsbCBiZSB0cmVhdGVkIGFzIGEgXCJjYXRlZ29yeSBtYXRjaFwiLCBhbmQgd2lsbCBvbmx5IGRpc3BsYXkgaWYgZXhhY3RcbiAgICAgKiAgIHZhbHVlIG1hdGNoZXMgYXJlbid0IGZvdW5kIGFuZCB0aGUgdmFsdWUgbWFwcyB0byBpdHMgY2F0ZWdvcnkgZm9yIHRoZSBkZWZpbmVkIGxvY2FsZS5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwOi8vY2xkci51bmljb2RlLm9yZy9pbmRleC9jbGRyLXNwZWMvcGx1cmFsLXJ1bGVzXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5nUGx1cmFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdQbHVyYWwoX2xvY2FsaXphdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxpemF0aW9uID0gX2xvY2FsaXphdGlvbjtcbiAgICAgICAgICAgIHRoaXMuX2Nhc2VWaWV3cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1BsdXJhbC5wcm90b3R5cGUsIFwibmdQbHVyYWxcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zd2l0Y2hWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZpZXcoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ1BsdXJhbC5wcm90b3R5cGUuYWRkQ2FzZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3dpdGNoVmlldykgeyB0aGlzLl9jYXNlVmlld3NbdmFsdWVdID0gc3dpdGNoVmlldzsgfTtcbiAgICAgICAgTmdQbHVyYWwucHJvdG90eXBlLl91cGRhdGVWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJWaWV3cygpO1xuICAgICAgICAgICAgdmFyIGNhc2VzID0gT2JqZWN0LmtleXModGhpcy5fY2FzZVZpZXdzKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRQbHVyYWxDYXRlZ29yeSh0aGlzLl9zd2l0Y2hWYWx1ZSwgY2FzZXMsIHRoaXMuX2xvY2FsaXphdGlvbik7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZVZpZXcodGhpcy5fY2FzZVZpZXdzW2tleV0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ1BsdXJhbC5wcm90b3R5cGUuX2NsZWFyVmlld3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmlldylcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdQbHVyYWwucHJvdG90eXBlLl9hY3RpdmF0ZVZpZXcgPSBmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVWaWV3ID0gdmlldztcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVWaWV3LmNyZWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1BsdXJhbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdQbHVyYWxdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nUGx1cmFsLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBOZ0xvY2FsaXphdGlvbiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdQbHVyYWwucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdQbHVyYWwnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nUGx1cmFsO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHZpZXcgdGhhdCB3aWxsIGJlIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgcGFyZW50IHtAbGluayBOZ1BsdXJhbH0gd2hlbiB0aGVcbiAgICAgKiAgICAgICAgICAgICBnaXZlbiBleHByZXNzaW9uIG1hdGNoZXMgdGhlIHBsdXJhbCBleHByZXNzaW9uIGFjY29yZGluZyB0byBDTERSIHJ1bGVzLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogPHNvbWUtZWxlbWVudCBbbmdQbHVyYWxdPVwidmFsdWVcIj5cbiAgICAgKiAgIDxuZy1jb250YWluZXIgKm5nUGx1cmFsQ2FzZT1cIic9MCdcIj4uLi48L25nLWNvbnRhaW5lcj5cbiAgICAgKiAgIDxuZy1jb250YWluZXIgKm5nUGx1cmFsQ2FzZT1cIidvdGhlcidcIj4uLi48L25nLWNvbnRhaW5lcj5cbiAgICAgKiA8L3NvbWUtZWxlbWVudD5cbiAgICAgKmBgYFxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBOZ1BsdXJhbH0gZm9yIG1vcmUgZGV0YWlscyBhbmQgZXhhbXBsZS5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdQbHVyYWxDYXNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdQbHVyYWxDYXNlKHZhbHVlLCB0ZW1wbGF0ZSwgdmlld0NvbnRhaW5lciwgbmdQbHVyYWwpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIG5nUGx1cmFsLmFkZENhc2UodmFsdWUsIG5ldyBTd2l0Y2hWaWV3KHZpZXdDb250YWluZXIsIHRlbXBsYXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgTmdQbHVyYWxDYXNlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ1BsdXJhbENhc2VdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nUGx1cmFsQ2FzZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkF0dHJpYnV0ZSwgYXJnczogWyduZ1BsdXJhbENhc2UnLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogTmdQbHVyYWwsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nUGx1cmFsQ2FzZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgVXBkYXRlIGFuIEhUTUwgZWxlbWVudCBzdHlsZXMuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8c29tZS1lbGVtZW50IFtuZ1N0eWxlXT1cInsnZm9udC1zdHlsZSc6IHN0eWxlRXhwfVwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqXG4gICAgICogPHNvbWUtZWxlbWVudCBbbmdTdHlsZV09XCJ7J21heC13aWR0aC5weCc6IHdpZHRoRXhwfVwiPi4uLjwvc29tZS1lbGVtZW50PlxuICAgICAqXG4gICAgICogPHNvbWUtZWxlbWVudCBbbmdTdHlsZV09XCJvYmpFeHBcIj4uLi48L3NvbWUtZWxlbWVudD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogVGhlIHN0eWxlcyBhcmUgdXBkYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIG9mIHRoZSBleHByZXNzaW9uIGV2YWx1YXRpb246XG4gICAgICogLSBrZXlzIGFyZSBzdHlsZSBuYW1lcyB3aXRoIGFuIG9wdGlvbiBgLjx1bml0PmAgc3VmZml4IChpZSAndG9wLnB4JywgJ2ZvbnQtc3R5bGUuZW0nKSxcbiAgICAgKiAtIHZhbHVlcyBhcmUgdGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aG9zZSBwcm9wZXJ0aWVzIChleHByZXNzZWQgaW4gdGhlIGdpdmVuIHVuaXQpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ1N0eWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdTdHlsZShfZGlmZmVycywgX25nRWwsIF9yZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fZGlmZmVycyA9IF9kaWZmZXJzO1xuICAgICAgICAgICAgdGhpcy5fbmdFbCA9IF9uZ0VsO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU3R5bGUucHJvdG90eXBlLCBcIm5nU3R5bGVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHRoaXMuX25nU3R5bGUgPSB2O1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGlmZmVyICYmIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHYpLmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdTdHlsZS5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5fbmdTdHlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdTdHlsZS5wcm90b3R5cGUuX2FwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3NldFN0eWxlKHJlY29yZC5rZXksIG51bGwpOyB9KTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbShmdW5jdGlvbiAocmVjb3JkKSB7IHJldHVybiBfdGhpcy5fc2V0U3R5bGUocmVjb3JkLmtleSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSk7IH0pO1xuICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQ2hhbmdlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCkgeyByZXR1cm4gX3RoaXMuX3NldFN0eWxlKHJlY29yZC5rZXksIHJlY29yZC5jdXJyZW50VmFsdWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdTdHlsZS5wcm90b3R5cGUuX3NldFN0eWxlID0gZnVuY3Rpb24gKG5hbWVBbmRVbml0LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gbmFtZUFuZFVuaXQuc3BsaXQoJy4nKSwgbmFtZSA9IF9hWzBdLCB1bml0ID0gX2FbMV07XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICYmIHVuaXQgPyBcIlwiICsgdmFsdWUgKyB1bml0IDogdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5fbmdFbC5uYXRpdmVFbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nU3R5bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW25nU3R5bGVdJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU3R5bGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuS2V5VmFsdWVEaWZmZXJzLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nU3R5bGUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdTdHlsZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdTdHlsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgSW5zZXJ0cyBhbiBlbWJlZGRlZCB2aWV3IGZyb20gYSBwcmVwYXJlZCBgVGVtcGxhdGVSZWZgXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiBgYGBcbiAgICAgKiA8dGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwidGVtcGxhdGVSZWZFeHByZXNzaW9uXCJcbiAgICAgKiAgICAgICAgICAgW25nT3V0bGV0Q29udGV4dF09XCJvYmplY3RFeHByZXNzaW9uXCI+XG4gICAgICogPC90ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogWW91IGNhbiBhdHRhY2ggYSBjb250ZXh0IG9iamVjdCB0byB0aGUgYEVtYmVkZGVkVmlld1JlZmAgYnkgc2V0dGluZyBgW25nT3V0bGV0Q29udGV4dF1gLlxuICAgICAqIGBbbmdPdXRsZXRDb250ZXh0XWAgc2hvdWxkIGJlIGFuIG9iamVjdCwgdGhlIG9iamVjdCdzIGtleXMgd2lsbCBiZSB0aGUgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGVzXG4gICAgICogYXZhaWxhYmxlIHdpdGhpbiB0aGUgYFRlbXBsYXRlUmVmYC5cbiAgICAgKlxuICAgICAqIE5vdGU6IHVzaW5nIHRoZSBrZXkgYCRpbXBsaWNpdGAgaW4gdGhlIGNvbnRleHQgb2JqZWN0IHdpbGwgc2V0IGl0J3MgdmFsdWUgYXMgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdUZW1wbGF0ZU91dGxldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nVGVtcGxhdGVPdXRsZXQoX3ZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdUZW1wbGF0ZU91dGxldC5wcm90b3R5cGUsIFwibmdPdXRsZXRDb250ZXh0XCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGNvbnRleHQpIHsgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdUZW1wbGF0ZU91dGxldC5wcm90b3R5cGUsIFwibmdUZW1wbGF0ZU91dGxldFwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0ZW1wbGF0ZVJlZikgeyB0aGlzLl90ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdUZW1wbGF0ZU91dGxldC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZpZXdSZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLnJlbW92ZSh0aGlzLl92aWV3Q29udGFpbmVyUmVmLmluZGV4T2YodGhpcy5fdmlld1JlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld1JlZiA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlUmVmLCB0aGlzLl9jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdUZW1wbGF0ZU91dGxldC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbbmdUZW1wbGF0ZU91dGxldF0nIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdUZW1wbGF0ZU91dGxldC5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1RlbXBsYXRlT3V0bGV0LnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25nT3V0bGV0Q29udGV4dCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ25nVGVtcGxhdGVPdXRsZXQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nVGVtcGxhdGVPdXRsZXQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBBbmd1bGFyIGRpcmVjdGl2ZXMgdGhhdCBhcmUgbGlrZWx5IHRvIGJlIHVzZWQgaW4gZWFjaCBhbmQgZXZlcnkgQW5ndWxhclxuICAgICAqIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIHZhciBDT01NT05fRElSRUNUSVZFUyA9IFtcbiAgICAgICAgTmdDbGFzcyxcbiAgICAgICAgTmdGb3IsXG4gICAgICAgIE5nSWYsXG4gICAgICAgIE5nVGVtcGxhdGVPdXRsZXQsXG4gICAgICAgIE5nU3R5bGUsXG4gICAgICAgIE5nU3dpdGNoLFxuICAgICAgICBOZ1N3aXRjaENhc2UsXG4gICAgICAgIE5nU3dpdGNoRGVmYXVsdCxcbiAgICAgICAgTmdQbHVyYWwsXG4gICAgICAgIE5nUGx1cmFsQ2FzZSxcbiAgICBdO1xuXG4gICAgdmFyIGlzUHJvbWlzZSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5pc1Byb21pc2U7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBCYXNlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNChCYXNlRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEJhc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBFcnJvcnMgZG9uJ3QgdXNlIGN1cnJlbnQgdGhpcywgaW5zdGVhZCB0aGV5IGNyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gZG8gZm9yd2FyZCBhbGwgb2Ygb3VyIGFwaSB0byB0aGUgbmF0aXZlSW5zdGFuY2UuXG4gICAgICAgICAgICB2YXIgbmF0aXZlRXJyb3IgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLm1lc3NhZ2U7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHRoaXMuX25hdGl2ZUVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLm5hbWU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLnN0YWNrOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fbmF0aXZlRXJyb3Iuc3RhY2sgPSB2YWx1ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uYXRpdmVFcnJvci50b1N0cmluZygpOyB9O1xuICAgICAgICByZXR1cm4gQmFzZUVycm9yO1xuICAgIH0oRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFdyYXBwZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KFdyYXBwZWRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gV3JhcHBlZEVycm9yKG1lc3NhZ2UsIGVycm9yKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlICsgXCIgY2F1c2VkIGJ5OiBcIiArIChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IGVycm9yKSk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEVycm9yLnByb3RvdHlwZSwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMub3JpZ2luYWxFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gdGhpcy5vcmlnaW5hbEVycm9yIDogdGhpcy5fbmF0aXZlRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIC5zdGFjaztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gV3JhcHBlZEVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIEludmFsaWRQaXBlQXJndW1lbnRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKEludmFsaWRQaXBlQXJndW1lbnRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIkludmFsaWQgYXJndW1lbnQgJ1wiICsgdmFsdWUgKyBcIicgZm9yIHBpcGUgJ1wiICsgc3RyaW5naWZ5KHR5cGUpICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbnZhbGlkUGlwZUFyZ3VtZW50RXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcblxuICAgIHZhciBPYnNlcnZhYmxlU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPYnNlcnZhYmxlU3RyYXRlZ3koKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JzZXJ2YWJsZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoYXN5bmMsIHVwZGF0ZUxhdGVzdFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmMuc3Vic2NyaWJlKHsgbmV4dDogdXBkYXRlTGF0ZXN0VmFsdWUsIGVycm9yOiBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9IH0pO1xuICAgICAgICB9O1xuICAgICAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgICBPYnNlcnZhYmxlU3RyYXRlZ3kucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgUHJvbWlzZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUHJvbWlzZVN0cmF0ZWd5KCkge1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2VTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKGFzeW5jLCB1cGRhdGVMYXRlc3RWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnRoZW4odXBkYXRlTGF0ZXN0VmFsdWUsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBQcm9taXNlU3RyYXRlZ3kucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7IH07XG4gICAgICAgIFByb21pc2VTdHJhdGVneS5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikgeyB9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZVN0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgdmFyIF9wcm9taXNlU3RyYXRlZ3kgPSBuZXcgUHJvbWlzZVN0cmF0ZWd5KCk7XG4gICAgdmFyIF9vYnNlcnZhYmxlU3RyYXRlZ3kgPSBuZXcgT2JzZXJ2YWJsZVN0cmF0ZWd5KCk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIFVud3JhcHMgYSB2YWx1ZSBmcm9tIGFuIGFzeW5jaHJvbm91cyBwcmltaXRpdmUuXG4gICAgICogQGhvd1RvVXNlIGBvYnNlcnZhYmxlX29yX3Byb21pc2VfZXhwcmVzc2lvbiB8IGFzeW5jYFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoZSBgYXN5bmNgIHBpcGUgc3Vic2NyaWJlcyB0byBhbiBgT2JzZXJ2YWJsZWAgb3IgYFByb21pc2VgIGFuZCByZXR1cm5zIHRoZSBsYXRlc3QgdmFsdWUgaXQgaGFzXG4gICAgICogZW1pdHRlZC4gV2hlbiBhIG5ldyB2YWx1ZSBpcyBlbWl0dGVkLCB0aGUgYGFzeW5jYCBwaXBlIG1hcmtzIHRoZSBjb21wb25lbnQgdG8gYmUgY2hlY2tlZCBmb3JcbiAgICAgKiBjaGFuZ2VzLiBXaGVuIHRoZSBjb21wb25lbnQgZ2V0cyBkZXN0cm95ZWQsIHRoZSBgYXN5bmNgIHBpcGUgdW5zdWJzY3JpYmVzIGF1dG9tYXRpY2FsbHkgdG8gYXZvaWRcbiAgICAgKiBwb3RlbnRpYWwgbWVtb3J5IGxlYWtzLlxuICAgICAqXG4gICAgICpcbiAgICAgKiAjIyBFeGFtcGxlc1xuICAgICAqXG4gICAgICogVGhpcyBleGFtcGxlIGJpbmRzIGEgYFByb21pc2VgIHRvIHRoZSB2aWV3LiBDbGlja2luZyB0aGUgYFJlc29sdmVgIGJ1dHRvbiByZXNvbHZlcyB0aGVcbiAgICAgKiBwcm9taXNlLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9hc3luY19waXBlLnRzIHJlZ2lvbj0nQXN5bmNQaXBlUHJvbWlzZSd9XG4gICAgICpcbiAgICAgKiBJdCdzIGFsc28gcG9zc2libGUgdG8gdXNlIGBhc3luY2Agd2l0aCBPYnNlcnZhYmxlcy4gVGhlIGV4YW1wbGUgYmVsb3cgYmluZHMgdGhlIGB0aW1lYCBPYnNlcnZhYmxlXG4gICAgICogdG8gdGhlIHZpZXcuIFRoZSBPYnNlcnZhYmxlIGNvbnRpbnVlc2x5IHVwZGF0ZXMgdGhlIHZpZXcgd2l0aCB0aGUgY3VycmVudCB0aW1lLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9hc3luY19waXBlLnRzIHJlZ2lvbj0nQXN5bmNQaXBlT2JzZXJ2YWJsZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFzeW5jUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFzeW5jUGlwZShfcmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWYgPSBfcmVmO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fb2JqID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBBc3luY1BpcGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXN5bmNQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSB0aGlzLl9sYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZXN0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqICE9PSB0aGlzLl9vYmopIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGF0ZXN0VmFsdWUgPT09IHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSB0aGlzLl9sYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBfYW5ndWxhcl9jb3JlLldyYXBwZWRWYWx1ZS53cmFwKHRoaXMuX2xhdGVzdFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX29iaiA9IG9iajtcbiAgICAgICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gdGhpcy5fc2VsZWN0U3RyYXRlZ3kob2JqKTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3N0cmF0ZWd5LmNyZWF0ZVN1YnNjcmlwdGlvbihvYmosIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuX3VwZGF0ZUxhdGVzdFZhbHVlKG9iaiwgdmFsdWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fc2VsZWN0U3RyYXRlZ3kgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb21pc2VTdHJhdGVneTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmouc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9vYnNlcnZhYmxlU3RyYXRlZ3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKEFzeW5jUGlwZSwgb2JqKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXN5bmNQaXBlLnByb3RvdHlwZS5fZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cmF0ZWd5LmRpc3Bvc2UodGhpcy5fc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX29iaiA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEFzeW5jUGlwZS5wcm90b3R5cGUuX3VwZGF0ZUxhdGVzdFZhbHVlID0gZnVuY3Rpb24gKGFzeW5jLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGFzeW5jID09PSB0aGlzLl9vYmopIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXN5bmNQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ2FzeW5jJywgcHVyZTogZmFsc2UgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBBc3luY1BpcGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0b3JSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBBc3luY1BpcGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgTnVtYmVyRm9ybWF0U3R5bGU7XG4gICAgKGZ1bmN0aW9uIChOdW1iZXJGb3JtYXRTdHlsZSkge1xuICAgICAgICBOdW1iZXJGb3JtYXRTdHlsZVtOdW1iZXJGb3JtYXRTdHlsZVtcIkRlY2ltYWxcIl0gPSAwXSA9IFwiRGVjaW1hbFwiO1xuICAgICAgICBOdW1iZXJGb3JtYXRTdHlsZVtOdW1iZXJGb3JtYXRTdHlsZVtcIlBlcmNlbnRcIl0gPSAxXSA9IFwiUGVyY2VudFwiO1xuICAgICAgICBOdW1iZXJGb3JtYXRTdHlsZVtOdW1iZXJGb3JtYXRTdHlsZVtcIkN1cnJlbmN5XCJdID0gMl0gPSBcIkN1cnJlbmN5XCI7XG4gICAgfSkoTnVtYmVyRm9ybWF0U3R5bGUgfHwgKE51bWJlckZvcm1hdFN0eWxlID0ge30pKTtcbiAgICB2YXIgTnVtYmVyRm9ybWF0dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTnVtYmVyRm9ybWF0dGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIE51bWJlckZvcm1hdHRlci5mb3JtYXQgPSBmdW5jdGlvbiAobnVtLCBsb2NhbGUsIHN0eWxlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1pbmltdW1JbnRlZ2VyRGlnaXRzID0gX2IubWluaW11bUludGVnZXJEaWdpdHMsIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IF9iLm1pbmltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bUZyYWN0aW9uRGlnaXRzID0gX2IubWF4aW11bUZyYWN0aW9uRGlnaXRzLCBjdXJyZW5jeSA9IF9iLmN1cnJlbmN5LCBfYyA9IF9iLmN1cnJlbmN5QXNTeW1ib2wsIGN1cnJlbmN5QXNTeW1ib2wgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYztcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiBtaW5pbXVtSW50ZWdlckRpZ2l0cyxcbiAgICAgICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcbiAgICAgICAgICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG1heGltdW1GcmFjdGlvbkRpZ2l0cyxcbiAgICAgICAgICAgICAgICBzdHlsZTogTnVtYmVyRm9ybWF0U3R5bGVbc3R5bGVdLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc3R5bGUgPT0gTnVtYmVyRm9ybWF0U3R5bGUuQ3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmN1cnJlbmN5ID0gY3VycmVuY3k7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jdXJyZW5jeURpc3BsYXkgPSBjdXJyZW5jeUFzU3ltYm9sID8gJ3N5bWJvbCcgOiAnY29kZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOdW1iZXJGb3JtYXR0ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgREFURV9GT1JNQVRTX1NQTElUID0gLygoPzpbXnlNTGRIaG1zYXpaRXdHakonXSspfCg/OicoPzpbXiddfCcnKSonKXwoPzpFK3x5K3xNK3xMK3xkK3xIK3xoK3xKK3xqK3xtK3xzK3xhfHp8WnxHK3x3KykpKC4qKS87XG4gICAgdmFyIFBBVFRFUk5fQUxJQVNFUyA9IHtcbiAgICAgICAgeU1NTWRqbXM6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShjb21iaW5lKFtcbiAgICAgICAgICAgIGRpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSksXG4gICAgICAgICAgICBuYW1lQ29uZGl0aW9uKCdtb250aCcsIDMpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ2RheScsIDEpLFxuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSxcbiAgICAgICAgICAgIGRpZ2l0Q29uZGl0aW9uKCdtaW51dGUnLCAxKSxcbiAgICAgICAgICAgIGRpZ2l0Q29uZGl0aW9uKCdzZWNvbmQnLCAxKSxcbiAgICAgICAgXSkpLFxuICAgICAgICB5TWRqbTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW1xuICAgICAgICAgICAgZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSwgZGlnaXRDb25kaXRpb24oJ21vbnRoJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKSxcbiAgICAgICAgICAgIGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdtaW51dGUnLCAxKVxuICAgICAgICBdKSksXG4gICAgICAgIHlNTU1NRUVFRWQ6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShjb21iaW5lKFtcbiAgICAgICAgICAgIGRpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSksIG5hbWVDb25kaXRpb24oJ21vbnRoJywgNCksIG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCA0KSxcbiAgICAgICAgICAgIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKVxuICAgICAgICBdKSksXG4gICAgICAgIHlNTU1NZDogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW2RpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSksIG5hbWVDb25kaXRpb24oJ21vbnRoJywgNCksIGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKV0pKSxcbiAgICAgICAgeU1NTWQ6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShjb21iaW5lKFtkaWdpdENvbmRpdGlvbigneWVhcicsIDEpLCBuYW1lQ29uZGl0aW9uKCdtb250aCcsIDMpLCBkaWdpdENvbmRpdGlvbignZGF5JywgMSldKSksXG4gICAgICAgIHlNZDogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW2RpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdtb250aCcsIDEpLCBkaWdpdENvbmRpdGlvbignZGF5JywgMSldKSksXG4gICAgICAgIGptczogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW2RpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdzZWNvbmQnLCAxKSwgZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDEpXSkpLFxuICAgICAgICBqbTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGNvbWJpbmUoW2RpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSksIGRpZ2l0Q29uZGl0aW9uKCdtaW51dGUnLCAxKV0pKVxuICAgIH07XG4gICAgdmFyIERBVEVfRk9STUFUUyA9IHtcbiAgICAgICAgeXl5eTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgNCkpLFxuICAgICAgICB5eTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCd5ZWFyJywgMikpLFxuICAgICAgICB5OiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3llYXInLCAxKSksXG4gICAgICAgIE1NTU06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCdtb250aCcsIDQpKSxcbiAgICAgICAgTU1NOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignbW9udGgnLCAzKSksXG4gICAgICAgIE1NOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ21vbnRoJywgMikpLFxuICAgICAgICBNOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ21vbnRoJywgMSkpLFxuICAgICAgICBMTExMOiBkYXRlUGFydEdldHRlckZhY3RvcnkobmFtZUNvbmRpdGlvbignbW9udGgnLCA0KSksXG4gICAgICAgIGRkOiBkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ2RheScsIDIpKSxcbiAgICAgICAgZDogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdkYXknLCAxKSksXG4gICAgICAgIEhIOiBkaWdpdE1vZGlmaWVyKGhvdXJFeHRyYWN0ZXIoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDIpLCBmYWxzZSkpKSksXG4gICAgICAgIEg6IGhvdXJFeHRyYWN0ZXIoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCBmYWxzZSkpKSxcbiAgICAgICAgaGg6IGRpZ2l0TW9kaWZpZXIoaG91ckV4dHJhY3RlcihkYXRlUGFydEdldHRlckZhY3RvcnkoaG91cjEyTW9kaWZ5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMiksIHRydWUpKSkpLFxuICAgICAgICBoOiBob3VyRXh0cmFjdGVyKGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShob3VyMTJNb2RpZnkoZGlnaXRDb25kaXRpb24oJ2hvdXInLCAxKSwgdHJ1ZSkpKSxcbiAgICAgICAgamo6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignaG91cicsIDIpKSxcbiAgICAgICAgajogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdob3VyJywgMSkpLFxuICAgICAgICBtbTogZGlnaXRNb2RpZmllcihkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ21pbnV0ZScsIDIpKSksXG4gICAgICAgIG06IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignbWludXRlJywgMSkpLFxuICAgICAgICBzczogZGlnaXRNb2RpZmllcihkYXRlUGFydEdldHRlckZhY3RvcnkoZGlnaXRDb25kaXRpb24oJ3NlY29uZCcsIDIpKSksXG4gICAgICAgIHM6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShkaWdpdENvbmRpdGlvbignc2Vjb25kJywgMSkpLFxuICAgICAgICAvLyB3aGlsZSBJU08gODYwMSByZXF1aXJlcyBmcmFjdGlvbnMgdG8gYmUgcHJlZml4ZWQgd2l0aCBgLmAgb3IgYCxgXG4gICAgICAgIC8vIHdlIGNhbiBiZSBqdXN0IHNhZmVseSByZWx5IG9uIHVzaW5nIGBzc3NgIHNpbmNlIHdlIGN1cnJlbnRseSBkb24ndCBzdXBwb3J0IHNpbmdsZSBvciB0d28gZGlnaXRcbiAgICAgICAgLy8gZnJhY3Rpb25zXG4gICAgICAgIHNzczogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGRpZ2l0Q29uZGl0aW9uKCdzZWNvbmQnLCAzKSksXG4gICAgICAgIEVFRUU6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgNCkpLFxuICAgICAgICBFRUU6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgMykpLFxuICAgICAgICBFRTogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ3dlZWtkYXknLCAyKSksXG4gICAgICAgIEU6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCd3ZWVrZGF5JywgMSkpLFxuICAgICAgICBhOiBob3VyQ2xvY2tFeHRyYWN0ZXIoZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KGhvdXIxMk1vZGlmeShkaWdpdENvbmRpdGlvbignaG91cicsIDEpLCB0cnVlKSkpLFxuICAgICAgICBaOiB0aW1lWm9uZUdldHRlcignc2hvcnQnKSxcbiAgICAgICAgejogdGltZVpvbmVHZXR0ZXIoJ2xvbmcnKSxcbiAgICAgICAgd3c6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeSh7fSksXG4gICAgICAgIC8vIGZpcnN0IFRodXJzZGF5IG9mIHRoZSB5ZWFyLiBub3Qgc3VwcG9ydCA/XG4gICAgICAgIHc6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeSh7fSksXG4gICAgICAgIC8vIG9mIHRoZSB5ZWFyIG5vdCBzdXBwb3J0ID9cbiAgICAgICAgRzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ2VyYScsIDEpKSxcbiAgICAgICAgR0c6IGRhdGVQYXJ0R2V0dGVyRmFjdG9yeShuYW1lQ29uZGl0aW9uKCdlcmEnLCAyKSksXG4gICAgICAgIEdHRzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ2VyYScsIDMpKSxcbiAgICAgICAgR0dHRzogZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KG5hbWVDb25kaXRpb24oJ2VyYScsIDQpKVxuICAgIH07XG4gICAgZnVuY3Rpb24gZGlnaXRNb2RpZmllcihpbm5lcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGlubmVyKGRhdGUsIGxvY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PSAxID8gJzAnICsgcmVzdWx0IDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBob3VyQ2xvY2tFeHRyYWN0ZXIoaW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbm5lcihkYXRlLCBsb2NhbGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zcGxpdCgnICcpWzFdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBob3VyRXh0cmFjdGVyKGlubmVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5uZXIoZGF0ZSwgbG9jYWxlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50bERhdGVGb3JtYXQoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChkYXRlKS5yZXBsYWNlKC9bXFx1MjAwZVxcdTIwMGZdL2csICcnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGltZVpvbmVHZXR0ZXIodGltZXpvbmUpIHtcbiAgICAgICAgLy8gVG8gd29ya2Fyb3VuZCBgSW50bGAgQVBJIHJlc3RyaWN0aW9uIGZvciBzaW5nbGUgdGltZXpvbmUgbGV0IGZvcm1hdCB3aXRoIDI0IGhvdXJzXG4gICAgICAgIHZhciBvcHRpb25zID0geyBob3VyOiAnMi1kaWdpdCcsIGhvdXIxMjogZmFsc2UsIHRpbWVab25lTmFtZTogdGltZXpvbmUgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbnRsRGF0ZUZvcm1hdChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gVGhlbiBleHRyYWN0IGZpcnN0IDMgbGV0dGVycyB0aGF0IHJlbGF0ZWQgdG8gaG91cnNcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQuc3Vic3RyaW5nKDMpIDogJyc7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhvdXIxMk1vZGlmeShvcHRpb25zLCB2YWx1ZSkge1xuICAgICAgICBvcHRpb25zLmhvdXIxMiA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlnaXRDb25kaXRpb24ocHJvcCwgbGVuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgcmVzdWx0W3Byb3BdID0gbGVuID09IDIgPyAnMi1kaWdpdCcgOiAnbnVtZXJpYyc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5hbWVDb25kaXRpb24ocHJvcCwgbGVuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgcmVzdWx0W3Byb3BdID0gbGVuIDwgNCA/ICdzaG9ydCcgOiAnbG9uZyc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbWJpbmUob3B0aW9ucykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIG9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7IE9iamVjdC5hc3NpZ24ocmVzdWx0LCBvcHRpb24pOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGF0ZVBhcnRHZXR0ZXJGYWN0b3J5KHJldCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkgeyByZXR1cm4gaW50bERhdGVGb3JtYXQoZGF0ZSwgbG9jYWxlLCByZXQpOyB9O1xuICAgIH1cbiAgICB2YXIgZGF0ZVBhcnRzRm9ybWF0dGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gZGF0ZUZvcm1hdHRlcihmb3JtYXQsIGRhdGUsIGxvY2FsZSkge1xuICAgICAgICB2YXIgdGV4dCA9ICcnO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHZhciBmbjtcbiAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgIGlmIChQQVRURVJOX0FMSUFTRVNbZm9ybWF0XSkge1xuICAgICAgICAgICAgcmV0dXJuIFBBVFRFUk5fQUxJQVNFU1tmb3JtYXRdKGRhdGUsIGxvY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGVQYXJ0c0Zvcm1hdHRlckNhY2hlLmhhcyhmb3JtYXQpKSB7XG4gICAgICAgICAgICBwYXJ0cyA9IGRhdGVQYXJ0c0Zvcm1hdHRlckNhY2hlLmdldChmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBEQVRFX0ZPUk1BVFNfU1BMSVQuZXhlYyhmb3JtYXQpO1xuICAgICAgICAgICAgd2hpbGUgKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gREFURV9GT1JNQVRTX1NQTElULmV4ZWMoZm9ybWF0KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMgPSBjb25jYXQocGFydHMsIG1hdGNoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0ZVBhcnRzRm9ybWF0dGVyQ2FjaGUuc2V0KGZvcm1hdCwgcGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgIGZuID0gREFURV9GT1JNQVRTW3BhcnRdO1xuICAgICAgICAgICAgdGV4dCArPSBmbiA/IGZuKGRhdGUsIGxvY2FsZSkgOlxuICAgICAgICAgICAgICAgIHBhcnQgPT09ICdcXCdcXCcnID8gJ1xcJycgOiBwYXJ0LnJlcGxhY2UoLyheJ3wnJCkvZywgJycpLnJlcGxhY2UoLycnL2csICdcXCcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcbiAgICBmdW5jdGlvbiBjb25jYXQoYXJyYXkxIC8qKiBUT0RPICM5MTAwICovLCBhcnJheTIgLyoqIFRPRE8gIzkxMDAgKi8sIGluZGV4IC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgIHJldHVybiBhcnJheTEuY29uY2F0KHNsaWNlLmNhbGwoYXJyYXkyLCBpbmRleCkpO1xuICAgIH1cbiAgICB2YXIgRGF0ZUZvcm1hdHRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERhdGVGb3JtYXR0ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgRGF0ZUZvcm1hdHRlci5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlLCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUZvcm1hdHRlcihwYXR0ZXJuLCBkYXRlLCBsb2NhbGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRGF0ZUZvcm1hdHRlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIEZvcm1hdHMgYSBkYXRlIGFjY29yZGluZyB0byBsb2NhbGUgcnVsZXMuXG4gICAgICogQGhvd1RvVXNlIGBkYXRlX2V4cHJlc3Npb24gfCBkYXRlWzpmb3JtYXRdYFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogV2hlcmU6XG4gICAgICogLSBgZXhwcmVzc2lvbmAgaXMgYSBkYXRlIG9iamVjdCBvciBhIG51bWJlciAobWlsbGlzZWNvbmRzIHNpbmNlIFVUQyBlcG9jaCkgb3IgYW4gSVNPIHN0cmluZ1xuICAgICAqIChodHRwczovL3d3dy53My5vcmcvVFIvTk9URS1kYXRldGltZSkuXG4gICAgICogLSBgZm9ybWF0YCBpbmRpY2F0ZXMgd2hpY2ggZGF0ZS90aW1lIGNvbXBvbmVudHMgdG8gaW5jbHVkZS4gVGhlIGZvcm1hdCBjYW4gYmUgcHJlZGlmaW5lZCBhc1xuICAgICAqICAgc2hvd24gYmVsb3cgb3IgY3VzdG9tIGFzIHNob3duIGluIHRoZSB0YWJsZS5cbiAgICAgKiAgIC0gYCdtZWRpdW0nYDogZXF1aXZhbGVudCB0byBgJ3lNTU1kam1zJ2AgKGUuZy4gYFNlcCAzLCAyMDEwLCAxMjowNTowOCBQTWAgZm9yIGBlbi1VU2ApXG4gICAgICogICAtIGAnc2hvcnQnYDogZXF1aXZhbGVudCB0byBgJ3lNZGptJ2AgKGUuZy4gYDkvMy8yMDEwLCAxMjowNSBQTWAgZm9yIGBlbi1VU2ApXG4gICAgICogICAtIGAnZnVsbERhdGUnYDogZXF1aXZhbGVudCB0byBgJ3lNTU1NRUVFRWQnYCAoZS5nLiBgRnJpZGF5LCBTZXB0ZW1iZXIgMywgMjAxMGAgZm9yIGBlbi1VU2ApXG4gICAgICogICAtIGAnbG9uZ0RhdGUnYDogZXF1aXZhbGVudCB0byBgJ3lNTU1NZCdgIChlLmcuIGBTZXB0ZW1iZXIgMywgMjAxMGAgZm9yIGBlbi1VU2ApXG4gICAgICogICAtIGAnbWVkaXVtRGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1NTWQnYCAoZS5nLiBgU2VwIDMsIDIwMTBgIGZvciBgZW4tVVNgKVxuICAgICAqICAgLSBgJ3Nob3J0RGF0ZSdgOiBlcXVpdmFsZW50IHRvIGAneU1kJ2AgKGUuZy4gYDkvMy8yMDEwYCBmb3IgYGVuLVVTYClcbiAgICAgKiAgIC0gYCdtZWRpdW1UaW1lJ2A6IGVxdWl2YWxlbnQgdG8gYCdqbXMnYCAoZS5nLiBgMTI6MDU6MDggUE1gIGZvciBgZW4tVVNgKVxuICAgICAqICAgLSBgJ3Nob3J0VGltZSdgOiBlcXVpdmFsZW50IHRvIGAnam0nYCAoZS5nLiBgMTI6MDUgUE1gIGZvciBgZW4tVVNgKVxuICAgICAqXG4gICAgICpcbiAgICAgKiAgfCBDb21wb25lbnQgfCBTeW1ib2wgfCBTaG9ydCBGb3JtICAgfCBMb25nIEZvcm0gICAgICAgICB8IE51bWVyaWMgICB8IDItZGlnaXQgICB8XG4gICAgICogIHwtLS0tLS0tLS0tLXw6LS0tLS0tOnwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tfFxuICAgICAqICB8IGVyYSAgICAgICB8ICAgRyAgICB8IEcgKEFEKSAgICAgICB8IEdHR0cgKEFubm8gRG9taW5pKXwgLSAgICAgICAgIHwgLSAgICAgICAgIHxcbiAgICAgKiAgfCB5ZWFyICAgICAgfCAgIHkgICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IHkgKDIwMTUpICB8IHl5ICgxNSkgICB8XG4gICAgICogIHwgbW9udGggICAgIHwgICBNICAgIHwgTU1NIChTZXApICAgIHwgTU1NTSAoU2VwdGVtYmVyKSAgfCBNICg5KSAgICAgfCBNTSAoMDkpICAgfFxuICAgICAqICB8IGRheSAgICAgICB8ICAgZCAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgZCAoMykgICAgIHwgZGQgKDAzKSAgIHxcbiAgICAgKiAgfCB3ZWVrZGF5ICAgfCAgIEUgICAgfCBFRUUgKFN1bikgICAgfCBFRUVFIChTdW5kYXkpICAgICB8IC0gICAgICAgICB8IC0gICAgICAgICB8XG4gICAgICogIHwgaG91ciAgICAgIHwgICBqICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBqICgxMykgICAgfCBqaiAoMTMpICAgfFxuICAgICAqICB8IGhvdXIxMiAgICB8ICAgaCAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgaCAoMSBQTSkgIHwgaGggKDAxIFBNKXxcbiAgICAgKiAgfCBob3VyMjQgICAgfCAgIEggICAgfCAtICAgICAgICAgICAgfCAtICAgICAgICAgICAgICAgICB8IEggKDEzKSAgICB8IEhIICgxMykgICB8XG4gICAgICogIHwgbWludXRlICAgIHwgICBtICAgIHwgLSAgICAgICAgICAgIHwgLSAgICAgICAgICAgICAgICAgfCBtICg1KSAgICAgfCBtbSAoMDUpICAgfFxuICAgICAqICB8IHNlY29uZCAgICB8ICAgcyAgICB8IC0gICAgICAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgcyAoOSkgICAgIHwgc3MgKDA5KSAgIHxcbiAgICAgKiAgfCB0aW1lem9uZSAgfCAgIHogICAgfCAtICAgICAgICAgICAgfCB6IChQYWNpZmljIFN0YW5kYXJkIFRpbWUpfCAtICB8IC0gICAgICAgICB8XG4gICAgICogIHwgdGltZXpvbmUgIHwgICBaICAgIHwgWiAoR01ULTg6MDApIHwgLSAgICAgICAgICAgICAgICAgfCAtICAgICAgICAgfCAtICAgICAgICAgfFxuICAgICAqICB8IHRpbWV6b25lICB8ICAgYSAgICB8IGEgKFBNKSAgICAgICB8IC0gICAgICAgICAgICAgICAgIHwgLSAgICAgICAgIHwgLSAgICAgICAgIHxcbiAgICAgKlxuICAgICAqIEluIGphdmFzY3JpcHQsIG9ubHkgdGhlIGNvbXBvbmVudHMgc3BlY2lmaWVkIHdpbGwgYmUgcmVzcGVjdGVkIChub3QgdGhlIG9yZGVyaW5nLFxuICAgICAqIHB1bmN0dWF0aW9ucywgLi4uKSBhbmQgZGV0YWlscyBvZiB0aGUgZm9ybWF0dGluZyB3aWxsIGJlIGRlcGVuZGVudCBvbiB0aGUgbG9jYWxlLlxuICAgICAqXG4gICAgICogVGltZXpvbmUgb2YgdGhlIGZvcm1hdHRlZCB0ZXh0IHdpbGwgYmUgdGhlIGxvY2FsIHN5c3RlbSB0aW1lem9uZSBvZiB0aGUgZW5kLXVzZXIncyBtYWNoaW5lLlxuICAgICAqXG4gICAgICogV0FSTklOR1M6XG4gICAgICogLSB0aGlzIHBpcGUgaXMgbWFya2VkIGFzIHB1cmUgaGVuY2UgaXQgd2lsbCBub3QgYmUgcmUtZXZhbHVhdGVkIHdoZW4gdGhlIGlucHV0IGlzIG11dGF0ZWQuXG4gICAgICogICBJbnN0ZWFkIHVzZXJzIHNob3VsZCB0cmVhdCB0aGUgZGF0ZSBhcyBhbiBpbW11dGFibGUgb2JqZWN0IGFuZCBjaGFuZ2UgdGhlIHJlZmVyZW5jZSB3aGVuIHRoZVxuICAgICAqICAgcGlwZSBuZWVkcyB0byByZS1ydW4gKHRoaXMgaXMgdG8gYXZvaWQgcmVmb3JtYXR0aW5nIHRoZSBkYXRlIG9uIGV2ZXJ5IGNoYW5nZSBkZXRlY3Rpb24gcnVuXG4gICAgICogICB3aGljaCB3b3VsZCBiZSBhbiBleHBlbnNpdmUgb3BlcmF0aW9uKS5cbiAgICAgKiAtIHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkuIFRoZXJlZm9yZSBpdCBpcyBvbmx5IHJlbGlhYmxlIGluIENocm9tZSBhbmQgT3BlcmFcbiAgICAgKiAgIGJyb3dzZXJzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVzXG4gICAgICpcbiAgICAgKiBBc3N1bWluZyBgZGF0ZU9iamAgaXMgKHllYXI6IDIwMTUsIG1vbnRoOiA2LCBkYXk6IDE1LCBob3VyOiAyMSwgbWludXRlOiA0Mywgc2Vjb25kOiAxMSlcbiAgICAgKiBpbiB0aGUgX2xvY2FsXyB0aW1lIGFuZCBsb2NhbGUgaXMgJ2VuLVVTJzpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZSB9fSAgICAgICAgICAgICAgIC8vIG91dHB1dCBpcyAnSnVuIDE1LCAyMDE1J1xuICAgICAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZTonbWVkaXVtJyB9fSAgICAgIC8vIG91dHB1dCBpcyAnSnVuIDE1LCAyMDE1LCA5OjQzOjExIFBNJ1xuICAgICAqICAgICB7eyBkYXRlT2JqIHwgZGF0ZTonc2hvcnRUaW1lJyB9fSAgIC8vIG91dHB1dCBpcyAnOTo0MyBQTSdcbiAgICAgKiAgICAge3sgZGF0ZU9iaiB8IGRhdGU6J21tc3MnIH19ICAgICAgICAvLyBvdXRwdXQgaXMgJzQzOjExJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9kYXRlX3BpcGUudHMgcmVnaW9uPSdEYXRlUGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIERhdGVQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGF0ZVBpcGUoX2xvY2FsZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gX2xvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBEYXRlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA9PT0gdm9pZCAwKSB7IHBhdHRlcm4gPSAnbWVkaXVtRGF0ZSc7IH1cbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKERhdGVQaXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTnVtYmVyV3JhcHBlci5pc051bWVyaWModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBEYXRlRm9ybWF0dGVyLmZvcm1hdChuZXcgRGF0ZSh2YWx1ZSksIHRoaXMuX2xvY2FsZSwgRGF0ZVBpcGUuX0FMSUFTRVNbcGF0dGVybl0gfHwgcGF0dGVybik7XG4gICAgICAgIH07XG4gICAgICAgIERhdGVQaXBlLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RhdGUob2JqKSB8fCBOdW1iZXJXcmFwcGVyLmlzTnVtZXJpYyhvYmopIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnICYmIGlzRGF0ZShuZXcgRGF0ZShvYmopKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGF0ZVBpcGUuX0FMSUFTRVMgPSB7XG4gICAgICAgICAgICAnbWVkaXVtJzogJ3lNTU1kam1zJyxcbiAgICAgICAgICAgICdzaG9ydCc6ICd5TWRqbScsXG4gICAgICAgICAgICAnZnVsbERhdGUnOiAneU1NTU1FRUVFZCcsXG4gICAgICAgICAgICAnbG9uZ0RhdGUnOiAneU1NTU1kJyxcbiAgICAgICAgICAgICdtZWRpdW1EYXRlJzogJ3lNTU1kJyxcbiAgICAgICAgICAgICdzaG9ydERhdGUnOiAneU1kJyxcbiAgICAgICAgICAgICdtZWRpdW1UaW1lJzogJ2ptcycsXG4gICAgICAgICAgICAnc2hvcnRUaW1lJzogJ2ptJ1xuICAgICAgICB9O1xuICAgICAgICBEYXRlUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdkYXRlJywgcHVyZTogdHJ1ZSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIERhdGVQaXBlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5MT0NBTEVfSUQsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIERhdGVQaXBlO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgX0lOVEVSUE9MQVRJT05fUkVHRVhQID0gLyMvZztcbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgTWFwcyBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgcGx1cmFsaXplcyB0aGUgdmFsdWUgYWNjb3JkaW5nIHRvIGxvY2FsZSBydWxlcy5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCBpMThuUGx1cmFsOm1hcHBpbmdgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiAgV2hlcmU6XG4gICAgICogIC0gYGV4cHJlc3Npb25gIGlzIGEgbnVtYmVyLlxuICAgICAqICAtIGBtYXBwaW5nYCBpcyBhbiBvYmplY3QgdGhhdCBtaW1pY3MgdGhlIElDVSBmb3JtYXQsIHNlZVxuICAgICAqICAgIGh0dHA6Ly91c2VyZ3VpZGUuaWN1LXByb2plY3Qub3JnL2Zvcm1hdHBhcnNlL21lc3NhZ2VzXG4gICAgICpcbiAgICAgKiAgIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9pMThuX3BpcGUudHMgcmVnaW9uPSdJMThuUGx1cmFsUGlwZUNvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEkxOG5QbHVyYWxQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSTE4blBsdXJhbFBpcGUoX2xvY2FsaXphdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxpemF0aW9uID0gX2xvY2FsaXphdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBJMThuUGx1cmFsUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlLCBwbHVyYWxNYXApIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBpZiAoIWlzU3RyaW5nTWFwKHBsdXJhbE1hcCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKEkxOG5QbHVyYWxQaXBlLCBwbHVyYWxNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IGdldFBsdXJhbENhdGVnb3J5KHZhbHVlLCBPYmplY3Qua2V5cyhwbHVyYWxNYXApLCB0aGlzLl9sb2NhbGl6YXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHBsdXJhbE1hcFtrZXldLnJlcGxhY2UoX0lOVEVSUE9MQVRJT05fUkVHRVhQLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSTE4blBsdXJhbFBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnaTE4blBsdXJhbCcsIHB1cmU6IHRydWUgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBJMThuUGx1cmFsUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdMb2NhbGl6YXRpb24sIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBJMThuUGx1cmFsUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIEdlbmVyaWMgc2VsZWN0b3IgdGhhdCBkaXNwbGF5cyB0aGUgc3RyaW5nIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCBpMThuU2VsZWN0Om1hcHBpbmdgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiAgV2hlcmU6XG4gICAgICogIC0gYG1hcHBpbmdgOiBpcyBhbiBvYmplY3QgdGhhdCBpbmRpY2F0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkXG4gICAgICogIGZvciBkaWZmZXJlbnQgdmFsdWVzIG9mIHRoZSBwcm92aWRlZCBgZXhwcmVzc2lvbmAuXG4gICAgICpcbiAgICAgKiAgIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9pMThuX3BpcGUudHMgcmVnaW9uPSdJMThuU2VsZWN0UGlwZUNvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBJMThuU2VsZWN0UGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEkxOG5TZWxlY3RQaXBlKCkge1xuICAgICAgICB9XG4gICAgICAgIEkxOG5TZWxlY3RQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIG1hcHBpbmcpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBpZiAoIWlzU3RyaW5nTWFwKG1hcHBpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihJMThuU2VsZWN0UGlwZSwgbWFwcGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwcGluZy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgPyBtYXBwaW5nW3ZhbHVlXSA6ICcnO1xuICAgICAgICB9O1xuICAgICAgICBJMThuU2VsZWN0UGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdpMThuU2VsZWN0JywgcHVyZTogdHJ1ZSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEkxOG5TZWxlY3RQaXBlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBJMThuU2VsZWN0UGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIENvbnZlcnRzIHZhbHVlIGludG8gSlNPTiBzdHJpbmcuXG4gICAgICogQGhvd1RvVXNlIGBleHByZXNzaW9uIHwganNvbmBcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIENvbnZlcnRzIHZhbHVlIGludG8gc3RyaW5nIHVzaW5nIGBKU09OLnN0cmluZ2lmeWAuIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2pzb25fcGlwZS50cyByZWdpb249J0pzb25QaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSnNvblBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBKc29uUGlwZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBKc29uUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBKc29uLnN0cmluZ2lmeSh2YWx1ZSk7IH07XG4gICAgICAgIEpzb25QaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ2pzb24nLCBwdXJlOiBmYWxzZSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEpzb25QaXBlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBKc29uUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIFRyYW5zZm9ybXMgc3RyaW5nIHRvIGxvd2VyY2FzZS5cbiAgICAgKiBAaG93VG9Vc2UgYGV4cHJlc3Npb24gfCBsb3dlcmNhc2VgXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBDb252ZXJ0cyB2YWx1ZSBpbnRvIGxvd2VyY2FzZSBzdHJpbmcgdXNpbmcgYFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UoKWAuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9sb3dlcnVwcGVyX3BpcGUudHMgcmVnaW9uPSdMb3dlclVwcGVyUGlwZSd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIExvd2VyQ2FzZVBpcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBMb3dlckNhc2VQaXBlKCkge1xuICAgICAgICB9XG4gICAgICAgIExvd2VyQ2FzZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQaXBlQXJndW1lbnRFcnJvcihMb3dlckNhc2VQaXBlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTG93ZXJDYXNlUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdsb3dlcmNhc2UnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTG93ZXJDYXNlUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gTG93ZXJDYXNlUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgdmFyIF9OVU1CRVJfRk9STUFUX1JFR0VYUCA9IC9eKFxcZCspP1xcLigoXFxkKykoLShcXGQrKSk/KT8kLztcbiAgICBmdW5jdGlvbiBmb3JtYXROdW1iZXIocGlwZSwgbG9jYWxlLCB2YWx1ZSwgc3R5bGUsIGRpZ2l0cywgY3VycmVuY3ksIGN1cnJlbmN5QXNTeW1ib2wpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09PSB2b2lkIDApIHsgY3VycmVuY3kgPSBudWxsOyB9XG4gICAgICAgIGlmIChjdXJyZW5jeUFzU3ltYm9sID09PSB2b2lkIDApIHsgY3VycmVuY3lBc1N5bWJvbCA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBDb252ZXJ0IHN0cmluZ3MgdG8gbnVtYmVyc1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgTnVtYmVyV3JhcHBlci5pc051bWVyaWModmFsdWUpID8gK3ZhbHVlIDogdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKHBpcGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluSW50O1xuICAgICAgICB2YXIgbWluRnJhY3Rpb247XG4gICAgICAgIHZhciBtYXhGcmFjdGlvbjtcbiAgICAgICAgaWYgKHN0eWxlICE9PSBOdW1iZXJGb3JtYXRTdHlsZS5DdXJyZW5jeSkge1xuICAgICAgICAgICAgLy8gcmVseSBvbiBJbnRsIGRlZmF1bHQgZm9yIGN1cnJlbmN5XG4gICAgICAgICAgICBtaW5JbnQgPSAxO1xuICAgICAgICAgICAgbWluRnJhY3Rpb24gPSAwO1xuICAgICAgICAgICAgbWF4RnJhY3Rpb24gPSAzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWdpdHMpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IGRpZ2l0cy5tYXRjaChfTlVNQkVSX0ZPUk1BVF9SRUdFWFApO1xuICAgICAgICAgICAgaWYgKHBhcnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRpZ2l0cyArIFwiIGlzIG5vdCBhIHZhbGlkIGRpZ2l0IGluZm8gZm9yIG51bWJlciBwaXBlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFydHNbMV0pKSB7XG4gICAgICAgICAgICAgICAgbWluSW50ID0gTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeChwYXJ0c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcnRzWzNdKSkge1xuICAgICAgICAgICAgICAgIG1pbkZyYWN0aW9uID0gTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeChwYXJ0c1szXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcnRzWzVdKSkge1xuICAgICAgICAgICAgICAgIG1heEZyYWN0aW9uID0gTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeChwYXJ0c1s1XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlckZvcm1hdHRlci5mb3JtYXQodmFsdWUsIGxvY2FsZSwgc3R5bGUsIHtcbiAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiBtaW5JbnQsXG4gICAgICAgICAgICBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG1pbkZyYWN0aW9uLFxuICAgICAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBtYXhGcmFjdGlvbixcbiAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeSxcbiAgICAgICAgICAgIGN1cnJlbmN5QXNTeW1ib2w6IGN1cnJlbmN5QXNTeW1ib2wsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgRm9ybWF0cyBhIG51bWJlciBhY2NvcmRpbmcgdG8gbG9jYWxlIHJ1bGVzLlxuICAgICAqIEBob3dUb1VzZSBgbnVtYmVyX2V4cHJlc3Npb24gfCBudW1iZXJbOmRpZ2l0SW5mb11gXG4gICAgICpcbiAgICAgKiBGb3JtYXRzIGEgbnVtYmVyIGFzIHRleHQuIEdyb3VwIHNpemluZyBhbmQgc2VwYXJhdG9yIGFuZCBvdGhlciBsb2NhbGUtc3BlY2lmaWNcbiAgICAgKiBjb25maWd1cmF0aW9ucyBhcmUgYmFzZWQgb24gdGhlIGFjdGl2ZSBsb2NhbGUuXG4gICAgICpcbiAgICAgKiB3aGVyZSBgZXhwcmVzc2lvbmAgaXMgYSBudW1iZXI6XG4gICAgICogIC0gYGRpZ2l0SW5mb2AgaXMgYSBgc3RyaW5nYCB3aGljaCBoYXMgYSBmb2xsb3dpbmcgZm9ybWF0OiA8YnI+XG4gICAgICogICAgIDxjb2RlPnttaW5JbnRlZ2VyRGlnaXRzfS57bWluRnJhY3Rpb25EaWdpdHN9LXttYXhGcmFjdGlvbkRpZ2l0c308L2NvZGU+XG4gICAgICogICAtIGBtaW5JbnRlZ2VyRGlnaXRzYCBpcyB0aGUgbWluaW11bSBudW1iZXIgb2YgaW50ZWdlciBkaWdpdHMgdG8gdXNlLiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICogICAtIGBtaW5GcmFjdGlvbkRpZ2l0c2AgaXMgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciBmcmFjdGlvbi4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqICAgLSBgbWF4RnJhY3Rpb25EaWdpdHNgIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgZnJhY3Rpb24uIERlZmF1bHRzIHRvIGAzYC5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBhY2NlcHRhYmxlIHJhbmdlIGZvciBlYWNoIG9mIHRoZXNlIG51bWJlcnMgYW5kIG90aGVyXG4gICAgICogZGV0YWlscyBzZWUgeW91ciBuYXRpdmUgaW50ZXJuYXRpb25hbGl6YXRpb24gbGlicmFyeS5cbiAgICAgKlxuICAgICAqIFdBUk5JTkc6IHRoaXMgcGlwZSB1c2VzIHRoZSBJbnRlcm5hdGlvbmFsaXphdGlvbiBBUEkgd2hpY2ggaXMgbm90IHlldCBhdmFpbGFibGUgaW4gYWxsIGJyb3dzZXJzXG4gICAgICogYW5kIG1heSByZXF1aXJlIGEgcG9seWZpbGwuIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2Jyb3dzZXItc3VwcG9ydH0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9udW1iZXJfcGlwZS50cyByZWdpb249J051bWJlclBpcGUnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBEZWNpbWFsUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlY2ltYWxQaXBlKF9sb2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgRGVjaW1hbFBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGlnaXRzKSB7XG4gICAgICAgICAgICBpZiAoZGlnaXRzID09PSB2b2lkIDApIHsgZGlnaXRzID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcihEZWNpbWFsUGlwZSwgdGhpcy5fbG9jYWxlLCB2YWx1ZSwgTnVtYmVyRm9ybWF0U3R5bGUuRGVjaW1hbCwgZGlnaXRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVjaW1hbFBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnbnVtYmVyJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIERlY2ltYWxQaXBlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5MT0NBTEVfSUQsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIERlY2ltYWxQaXBlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQG5nTW9kdWxlIENvbW1vbk1vZHVsZVxuICAgICAqIEB3aGF0SXREb2VzIEZvcm1hdHMgYSBudW1iZXIgYXMgYSBwZXJjZW50YWdlIGFjY29yZGluZyB0byBsb2NhbGUgcnVsZXMuXG4gICAgICogQGhvd1RvVXNlIGBudW1iZXJfZXhwcmVzc2lvbiB8IHBlcmNlbnRbOmRpZ2l0SW5mb11gXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEZvcm1hdHMgYSBudW1iZXIgYXMgcGVyY2VudGFnZS5cbiAgICAgKlxuICAgICAqIC0gYGRpZ2l0SW5mb2AgU2VlIHtAbGluayBEZWNpbWFsUGlwZX0gZm9yIGRldGFpbGVkIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogV0FSTklORzogdGhpcyBwaXBlIHVzZXMgdGhlIEludGVybmF0aW9uYWxpemF0aW9uIEFQSSB3aGljaCBpcyBub3QgeWV0IGF2YWlsYWJsZSBpbiBhbGwgYnJvd3NlcnNcbiAgICAgKiBhbmQgbWF5IHJlcXVpcmUgYSBwb2x5ZmlsbC4gU2VlIHtAbGlua0RvY3MgZ3VpZGUvYnJvd3Nlci1zdXBwb3J0fSBmb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL251bWJlcl9waXBlLnRzIHJlZ2lvbj0nUGVyY2VudFBpcGUnfVxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBQZXJjZW50UGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBlcmNlbnRQaXBlKF9sb2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgUGVyY2VudFBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgZGlnaXRzKSB7XG4gICAgICAgICAgICBpZiAoZGlnaXRzID09PSB2b2lkIDApIHsgZGlnaXRzID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcihQZXJjZW50UGlwZSwgdGhpcy5fbG9jYWxlLCB2YWx1ZSwgTnVtYmVyRm9ybWF0U3R5bGUuUGVyY2VudCwgZGlnaXRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGVyY2VudFBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAncGVyY2VudCcgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBQZXJjZW50UGlwZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuTE9DQUxFX0lELF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBQZXJjZW50UGlwZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBuZ01vZHVsZSBDb21tb25Nb2R1bGVcbiAgICAgKiBAd2hhdEl0RG9lcyBGb3JtYXRzIGEgbnVtYmVyIGFzIGN1cnJlbmN5IHVzaW5nIGxvY2FsZSBydWxlcy5cbiAgICAgKiBAaG93VG9Vc2UgYG51bWJlcl9leHByZXNzaW9uIHwgY3VycmVuY3lbOmN1cnJlbmN5Q29kZVs6c3ltYm9sRGlzcGxheVs6ZGlnaXRJbmZvXV1dYFxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogVXNlIGBjdXJyZW5jeWAgdG8gZm9ybWF0IGEgbnVtYmVyIGFzIGN1cnJlbmN5LlxuICAgICAqXG4gICAgICogLSBgY3VycmVuY3lDb2RlYCBpcyB0aGUgW0lTTyA0MjE3XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fNDIxNykgY3VycmVuY3kgY29kZSwgc3VjaFxuICAgICAqICAgIGFzIGBVU0RgIGZvciB0aGUgVVMgZG9sbGFyIGFuZCBgRVVSYCBmb3IgdGhlIGV1cm8uXG4gICAgICogLSBgc3ltYm9sRGlzcGxheWAgaXMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0byB1c2UgdGhlIGN1cnJlbmN5IHN5bWJvbCBvciBjb2RlLlxuICAgICAqICAgLSBgdHJ1ZWA6IHVzZSBzeW1ib2wgKGUuZy4gYCRgKS5cbiAgICAgKiAgIC0gYGZhbHNlYChkZWZhdWx0KTogdXNlIGNvZGUgKGUuZy4gYFVTRGApLlxuICAgICAqIC0gYGRpZ2l0SW5mb2AgU2VlIHtAbGluayBEZWNpbWFsUGlwZX0gZm9yIGRldGFpbGVkIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogV0FSTklORzogdGhpcyBwaXBlIHVzZXMgdGhlIEludGVybmF0aW9uYWxpemF0aW9uIEFQSSB3aGljaCBpcyBub3QgeWV0IGF2YWlsYWJsZSBpbiBhbGwgYnJvd3NlcnNcbiAgICAgKiBhbmQgbWF5IHJlcXVpcmUgYSBwb2x5ZmlsbC4gU2VlIHtAbGlua0RvY3MgZ3VpZGUvYnJvd3Nlci1zdXBwb3J0fSBmb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL251bWJlcl9waXBlLnRzIHJlZ2lvbj0nQ3VycmVuY3lQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ3VycmVuY3lQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ3VycmVuY3lQaXBlKF9sb2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgQ3VycmVuY3lQaXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodmFsdWUsIGN1cnJlbmN5Q29kZSwgc3ltYm9sRGlzcGxheSwgZGlnaXRzKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3lDb2RlID09PSB2b2lkIDApIHsgY3VycmVuY3lDb2RlID0gJ1VTRCc7IH1cbiAgICAgICAgICAgIGlmIChzeW1ib2xEaXNwbGF5ID09PSB2b2lkIDApIHsgc3ltYm9sRGlzcGxheSA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAoZGlnaXRzID09PSB2b2lkIDApIHsgZGlnaXRzID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcihDdXJyZW5jeVBpcGUsIHRoaXMuX2xvY2FsZSwgdmFsdWUsIE51bWJlckZvcm1hdFN0eWxlLkN1cnJlbmN5LCBkaWdpdHMsIGN1cnJlbmN5Q29kZSwgc3ltYm9sRGlzcGxheSk7XG4gICAgICAgIH07XG4gICAgICAgIEN1cnJlbmN5UGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlBpcGUsIGFyZ3M6IFt7IG5hbWU6ICdjdXJyZW5jeScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBDdXJyZW5jeVBpcGUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtfYW5ndWxhcl9jb3JlLkxPQ0FMRV9JRCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQ3VycmVuY3lQaXBlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIG5ldyBMaXN0IG9yIFN0cmluZyBjb250YWluaW5nIGEgc3Vic2V0IChzbGljZSkgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIEBob3dUb1VzZSBgYXJyYXlfb3Jfc3RyaW5nX2V4cHJlc3Npb24gfCBzbGljZTpzdGFydFs6ZW5kXWBcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIFdoZXJlIHRoZSBpbnB1dCBleHByZXNzaW9uIGlzIGEgYExpc3RgIG9yIGBTdHJpbmdgLCBhbmQ6XG4gICAgICogLSBgc3RhcnRgOiBUaGUgc3RhcnRpbmcgaW5kZXggb2YgdGhlIHN1YnNldCB0byByZXR1cm4uXG4gICAgICogICAtICoqYSBwb3NpdGl2ZSBpbnRlZ2VyKio6IHJldHVybiB0aGUgaXRlbSBhdCBgc3RhcnRgIGluZGV4IGFuZCBhbGwgaXRlbXMgYWZ0ZXJcbiAgICAgKiAgICAgaW4gdGhlIGxpc3Qgb3Igc3RyaW5nIGV4cHJlc3Npb24uXG4gICAgICogICAtICoqYSBuZWdhdGl2ZSBpbnRlZ2VyKio6IHJldHVybiB0aGUgaXRlbSBhdCBgc3RhcnRgIGluZGV4IGZyb20gdGhlIGVuZCBhbmQgYWxsIGl0ZW1zIGFmdGVyXG4gICAgICogICAgIGluIHRoZSBsaXN0IG9yIHN0cmluZyBleHByZXNzaW9uLlxuICAgICAqICAgLSAqKmlmIHBvc2l0aXZlIGFuZCBncmVhdGVyIHRoYW4gdGhlIHNpemUgb2YgdGhlIGV4cHJlc3Npb24qKjogcmV0dXJuIGFuIGVtcHR5IGxpc3Qgb3Igc3RyaW5nLlxuICAgICAqICAgLSAqKmlmIG5lZ2F0aXZlIGFuZCBncmVhdGVyIHRoYW4gdGhlIHNpemUgb2YgdGhlIGV4cHJlc3Npb24qKjogcmV0dXJuIGVudGlyZSBsaXN0IG9yIHN0cmluZy5cbiAgICAgKiAtIGBlbmRgOiBUaGUgZW5kaW5nIGluZGV4IG9mIHRoZSBzdWJzZXQgdG8gcmV0dXJuLlxuICAgICAqICAgLSAqKm9taXR0ZWQqKjogcmV0dXJuIGFsbCBpdGVtcyB1bnRpbCB0aGUgZW5kLlxuICAgICAqICAgLSAqKmlmIHBvc2l0aXZlKio6IHJldHVybiBhbGwgaXRlbXMgYmVmb3JlIGBlbmRgIGluZGV4IG9mIHRoZSBsaXN0IG9yIHN0cmluZy5cbiAgICAgKiAgIC0gKippZiBuZWdhdGl2ZSoqOiByZXR1cm4gYWxsIGl0ZW1zIGJlZm9yZSBgZW5kYCBpbmRleCBmcm9tIHRoZSBlbmQgb2YgdGhlIGxpc3Qgb3Igc3RyaW5nLlxuICAgICAqXG4gICAgICogQWxsIGJlaGF2aW9yIGlzIGJhc2VkIG9uIHRoZSBleHBlY3RlZCBiZWhhdmlvciBvZiB0aGUgSmF2YVNjcmlwdCBBUEkgYEFycmF5LnByb3RvdHlwZS5zbGljZSgpYFxuICAgICAqIGFuZCBgU3RyaW5nLnByb3RvdHlwZS5zbGljZSgpYC5cbiAgICAgKlxuICAgICAqIFdoZW4gb3BlcmF0aW5nIG9uIGEgW0xpc3RdLCB0aGUgcmV0dXJuZWQgbGlzdCBpcyBhbHdheXMgYSBjb3B5IGV2ZW4gd2hlbiBhbGxcbiAgICAgKiB0aGUgZWxlbWVudHMgYXJlIGJlaW5nIHJldHVybmVkLlxuICAgICAqXG4gICAgICogV2hlbiBvcGVyYXRpbmcgb24gYSBibGFuayB2YWx1ZSwgdGhlIHBpcGUgcmV0dXJucyB0aGUgYmxhbmsgdmFsdWUuXG4gICAgICpcbiAgICAgKiAjIyBMaXN0IEV4YW1wbGVcbiAgICAgKlxuICAgICAqIFRoaXMgYG5nRm9yYCBleGFtcGxlOlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9zbGljZV9waXBlLnRzIHJlZ2lvbj0nU2xpY2VQaXBlX2xpc3QnfVxuICAgICAqXG4gICAgICogcHJvZHVjZXMgdGhlIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqICAgICA8bGk+YjwvbGk+XG4gICAgICogICAgIDxsaT5jPC9saT5cbiAgICAgKlxuICAgICAqICMjIFN0cmluZyBFeGFtcGxlc1xuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvbW1vbi9waXBlcy90cy9zbGljZV9waXBlLnRzIHJlZ2lvbj0nU2xpY2VQaXBlX3N0cmluZyd9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNsaWNlUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNsaWNlUGlwZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBTbGljZVBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKFNsaWNlUGlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9O1xuICAgICAgICBTbGljZVBpcGUucHJvdG90eXBlLnN1cHBvcnRzID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShvYmopOyB9O1xuICAgICAgICBTbGljZVBpcGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5QaXBlLCBhcmdzOiBbeyBuYW1lOiAnc2xpY2UnLCBwdXJlOiBmYWxzZSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFNsaWNlUGlwZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gU2xpY2VQaXBlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmdNb2R1bGUgQ29tbW9uTW9kdWxlXG4gICAgICogQHdoYXRJdERvZXMgVHJhbnNmb3JtcyBzdHJpbmcgdG8gdXBwZXJjYXNlLlxuICAgICAqIEBob3dUb1VzZSBgZXhwcmVzc2lvbiB8IHVwcGVyY2FzZWBcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIENvbnZlcnRzIHZhbHVlIGludG8gbG93ZXJjYXNlIHN0cmluZyB1c2luZyBgU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZSgpYC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL3BpcGVzL3RzL2xvd2VydXBwZXJfcGlwZS50cyByZWdpb249J0xvd2VyVXBwZXJQaXBlJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVXBwZXJDYXNlUGlwZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFVwcGVyQ2FzZVBpcGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgVXBwZXJDYXNlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBpcGVBcmd1bWVudEVycm9yKFVwcGVyQ2FzZVBpcGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBVcHBlckNhc2VQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUGlwZSwgYXJnczogW3sgbmFtZTogJ3VwcGVyY2FzZScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBVcHBlckNhc2VQaXBlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBVcHBlckNhc2VQaXBlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIGNvbGxlY3Rpb24gb2YgQW5ndWxhciBwaXBlcyB0aGF0IGFyZSBsaWtlbHkgdG8gYmUgdXNlZCBpbiBlYWNoIGFuZCBldmVyeSBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgQ09NTU9OX1BJUEVTID0gW1xuICAgICAgICBBc3luY1BpcGUsXG4gICAgICAgIFVwcGVyQ2FzZVBpcGUsXG4gICAgICAgIExvd2VyQ2FzZVBpcGUsXG4gICAgICAgIEpzb25QaXBlLFxuICAgICAgICBTbGljZVBpcGUsXG4gICAgICAgIERlY2ltYWxQaXBlLFxuICAgICAgICBQZXJjZW50UGlwZSxcbiAgICAgICAgQ3VycmVuY3lQaXBlLFxuICAgICAgICBEYXRlUGlwZSxcbiAgICAgICAgSTE4blBsdXJhbFBpcGUsXG4gICAgICAgIEkxOG5TZWxlY3RQaXBlLFxuICAgIF07XG5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXMgbm90IGNvbnRhaW4gdGhlIGxvY2F0aW9uIHByb3ZpZGVycyxcbiAgICAvLyBhcyB0aGV5IG5lZWQgc29tZSBwbGF0Zm9ybSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnMgdG8gd29yay5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kdWxlIHRoYXQgaW5jbHVkZXMgYWxsIHRoZSBiYXNpYyBBbmd1bGFyIGRpcmVjdGl2ZXMgbGlrZSB7QGxpbmsgTmdJZn0sIHtAbGluayBOZ0Zvcn0sIC4uLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21tb25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb21tb25Nb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQ29tbW9uTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtDT01NT05fRElSRUNUSVZFUywgQ09NTU9OX1BJUEVTXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDT01NT05fRElSRUNUSVZFUywgQ09NTU9OX1BJUEVTXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTmdMb2NhbGl6YXRpb24sIHVzZUNsYXNzOiBOZ0xvY2FsZUxvY2FsaXphdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBDb21tb25Nb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIENvbW1vbk1vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgZXhwb3J0cy5OZ0xvY2FsaXphdGlvbiA9IE5nTG9jYWxpemF0aW9uO1xuICAgIGV4cG9ydHMuQ29tbW9uTW9kdWxlID0gQ29tbW9uTW9kdWxlO1xuICAgIGV4cG9ydHMuTmdDbGFzcyA9IE5nQ2xhc3M7XG4gICAgZXhwb3J0cy5OZ0ZvciA9IE5nRm9yO1xuICAgIGV4cG9ydHMuTmdJZiA9IE5nSWY7XG4gICAgZXhwb3J0cy5OZ1BsdXJhbCA9IE5nUGx1cmFsO1xuICAgIGV4cG9ydHMuTmdQbHVyYWxDYXNlID0gTmdQbHVyYWxDYXNlO1xuICAgIGV4cG9ydHMuTmdTdHlsZSA9IE5nU3R5bGU7XG4gICAgZXhwb3J0cy5OZ1N3aXRjaCA9IE5nU3dpdGNoO1xuICAgIGV4cG9ydHMuTmdTd2l0Y2hDYXNlID0gTmdTd2l0Y2hDYXNlO1xuICAgIGV4cG9ydHMuTmdTd2l0Y2hEZWZhdWx0ID0gTmdTd2l0Y2hEZWZhdWx0O1xuICAgIGV4cG9ydHMuTmdUZW1wbGF0ZU91dGxldCA9IE5nVGVtcGxhdGVPdXRsZXQ7XG4gICAgZXhwb3J0cy5Bc3luY1BpcGUgPSBBc3luY1BpcGU7XG4gICAgZXhwb3J0cy5EYXRlUGlwZSA9IERhdGVQaXBlO1xuICAgIGV4cG9ydHMuSTE4blBsdXJhbFBpcGUgPSBJMThuUGx1cmFsUGlwZTtcbiAgICBleHBvcnRzLkkxOG5TZWxlY3RQaXBlID0gSTE4blNlbGVjdFBpcGU7XG4gICAgZXhwb3J0cy5Kc29uUGlwZSA9IEpzb25QaXBlO1xuICAgIGV4cG9ydHMuTG93ZXJDYXNlUGlwZSA9IExvd2VyQ2FzZVBpcGU7XG4gICAgZXhwb3J0cy5DdXJyZW5jeVBpcGUgPSBDdXJyZW5jeVBpcGU7XG4gICAgZXhwb3J0cy5EZWNpbWFsUGlwZSA9IERlY2ltYWxQaXBlO1xuICAgIGV4cG9ydHMuUGVyY2VudFBpcGUgPSBQZXJjZW50UGlwZTtcbiAgICBleHBvcnRzLlNsaWNlUGlwZSA9IFNsaWNlUGlwZTtcbiAgICBleHBvcnRzLlVwcGVyQ2FzZVBpcGUgPSBVcHBlckNhc2VQaXBlO1xuICAgIGV4cG9ydHMuUGxhdGZvcm1Mb2NhdGlvbiA9IFBsYXRmb3JtTG9jYXRpb247XG4gICAgZXhwb3J0cy5Mb2NhdGlvblN0cmF0ZWd5ID0gTG9jYXRpb25TdHJhdGVneTtcbiAgICBleHBvcnRzLkFQUF9CQVNFX0hSRUYgPSBBUFBfQkFTRV9IUkVGO1xuICAgIGV4cG9ydHMuSGFzaExvY2F0aW9uU3RyYXRlZ3kgPSBIYXNoTG9jYXRpb25TdHJhdGVneTtcbiAgICBleHBvcnRzLlBhdGhMb2NhdGlvblN0cmF0ZWd5ID0gUGF0aExvY2F0aW9uU3RyYXRlZ3k7XG4gICAgZXhwb3J0cy5Mb2NhdGlvbiA9IExvY2F0aW9uO1xuXG59KSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMC4yXG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmNvbXBpbGVyID0gZ2xvYmFsLm5nLmNvbXBpbGVyIHx8IHt9KSxnbG9iYWwubmcuY29yZSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBnbG9iYWxTY29wZTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGFueSB3aXRoIFdvcmtlckdsb2JhbFNjb3BlIGZyb20gbGliLndlYndvcmtlci5kLnRzICMzNDkyXG4gICAgICAgICAgZ2xvYmFsU2NvcGUgPSBzZWxmO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgZ2xvYmFsU2NvcGUgPSBnbG9iYWw7XG4gICAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbiAgfVxuICAvLyBOZWVkIHRvIGRlY2xhcmUgYSBuZXcgdmFyaWFibGUgZm9yIGdsb2JhbCBoZXJlIHNpbmNlIFR5cGVTY3JpcHRcbiAgLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbiAgdmFyIGdsb2JhbCQxID0gZ2xvYmFsU2NvcGU7XG4gIC8vIFRPRE86IHJlbW92ZSBjYWxscyB0byBhc3NlcnQgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudFxuICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgLy8gYXMgYGFzc2VydGAgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGluIERhcnRcbiAgZ2xvYmFsJDEuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgLy8gVE9ETzogdG8gYmUgZml4ZWQgcHJvcGVybHkgdmlhICMyODMwLCBub29wIGZvciBub3dcbiAgfTtcbiAgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcbiAgfVxuICBmdW5jdGlvbiBpc1N0cmluZ01hcChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGw7XG4gIH1cbiAgdmFyIFNUUklOR19NQVBfUFJPVE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xuICBmdW5jdGlvbiBpc1N0cmljdFN0cmluZ01hcChvYmopIHtcbiAgICAgIHJldHVybiBpc1N0cmluZ01hcChvYmopICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBTVFJJTkdfTUFQX1BST1RPO1xuICB9XG4gIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPT09IHVuZGVmaW5lZCB8fCB0b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuLm92ZXJyaWRkZW5OYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXMgPSB0b2tlbi50b1N0cmluZygpO1xuICAgICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKCdcXG4nKTtcbiAgICAgIHJldHVybiBuZXdMaW5lSW5kZXggPT09IC0xID8gcmVzIDogcmVzLnN1YnN0cmluZygwLCBuZXdMaW5lSW5kZXgpO1xuICB9XG4gIHZhciBTdHJpbmdXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0cmluZ1dyYXBwZXIoKSB7XG4gICAgICB9XG4gICAgICBTdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpOyB9O1xuICAgICAgU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0ID0gZnVuY3Rpb24gKHMsIGluZGV4KSB7IHJldHVybiBzLmNoYXJDb2RlQXQoaW5kZXgpOyB9O1xuICAgICAgU3RyaW5nV3JhcHBlci5zcGxpdCA9IGZ1bmN0aW9uIChzLCByZWdFeHApIHsgcmV0dXJuIHMuc3BsaXQocmVnRXhwKTsgfTtcbiAgICAgIFN0cmluZ1dyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKHMsIHMyKSB7IHJldHVybiBzID09PSBzMjsgfTtcbiAgICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBMZWZ0ID0gZnVuY3Rpb24gKHMsIGNoYXJWYWwpIHtcbiAgICAgICAgICBpZiAocyAmJiBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPSBjaGFyVmFsKVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgfTtcbiAgICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBSaWdodCA9IGZ1bmN0aW9uIChzLCBjaGFyVmFsKSB7XG4gICAgICAgICAgaWYgKHMgJiYgcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHBvcyA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNbaV0gIT0gY2hhclZhbClcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgIH07XG4gICAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgcmVwbGFjZSkge1xuICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoZnJvbSwgcmVwbGFjZSk7XG4gICAgICB9O1xuICAgICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcbiAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIHJlcGxhY2UpO1xuICAgICAgfTtcbiAgICAgIFN0cmluZ1dyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgdG8pIHtcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gdm9pZCAwKSB7IGZyb20gPSAwOyB9XG4gICAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHMuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgICB9O1xuICAgICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkID0gZnVuY3Rpb24gKHMsIGZyb20sIGNiKSB7XG4gICAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBvZmZzZXQgJiBzdHJpbmcgZnJvbSB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKC0yLCAyKTtcbiAgICAgICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIHJlY2VpdmVzIG1hdGNoLCBwMSwgLi4uLCBwblxuICAgICAgICAgICAgICByZXR1cm4gY2IobWF0Y2hlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgU3RyaW5nV3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChzLCBzdWJzdHIpIHsgcmV0dXJuIHMuaW5kZXhPZihzdWJzdHIpICE9IC0xOyB9O1xuICAgICAgU3RyaW5nV3JhcHBlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhID4gYikge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gU3RyaW5nV3JhcHBlcjtcbiAgfSgpKTtcbiAgdmFyIFN0cmluZ0pvaW5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHJpbmdKb2luZXIocGFydHMpIHtcbiAgICAgICAgICBpZiAocGFydHMgPT09IHZvaWQgMCkgeyBwYXJ0cyA9IFtdOyB9XG4gICAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgfVxuICAgICAgU3RyaW5nSm9pbmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocGFydCkgeyB0aGlzLnBhcnRzLnB1c2gocGFydCk7IH07XG4gICAgICBTdHJpbmdKb2luZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJ0cy5qb2luKCcnKTsgfTtcbiAgICAgIHJldHVybiBTdHJpbmdKb2luZXI7XG4gIH0oKSk7XG4gIHZhciBOdW1iZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE51bWJlcldyYXBwZXIoKSB7XG4gICAgICB9XG4gICAgICBOdW1iZXJXcmFwcGVyLnRvRml4ZWQgPSBmdW5jdGlvbiAobiwgZnJhY3Rpb25EaWdpdHMpIHsgcmV0dXJuIG4udG9GaXhlZChmcmFjdGlvbkRpZ2l0cyk7IH07XG4gICAgICBOdW1iZXJXcmFwcGVyLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT09IGI7IH07XG4gICAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50QXV0b1JhZGl4ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XG4gICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgJyArIHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnQgPSBmdW5jdGlvbiAodGV4dCwgcmFkaXgpIHtcbiAgICAgICAgICBpZiAocmFkaXggPT0gMTApIHtcbiAgICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTldKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocmFkaXggPT0gMTYpIHtcbiAgICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTlBQkNERUZhYmNkZWZdKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCArICcgaW4gYmFzZSAnICsgcmFkaXgpO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJXcmFwcGVyLCBcIk5hTlwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBOYU47IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgTnVtYmVyV3JhcHBlci5pc051bWVyaWMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTsgfTtcbiAgICAgIE51bWJlcldyYXBwZXIuaXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzTmFOKHZhbHVlKTsgfTtcbiAgICAgIE51bWJlcldyYXBwZXIuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTsgfTtcbiAgICAgIHJldHVybiBOdW1iZXJXcmFwcGVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBub3JtYWxpemVCbGFuayhvYmopIHtcbiAgICAgIHJldHVybiBpc0JsYW5rKG9iaikgPyBudWxsIDogb2JqO1xuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUJvb2wob2JqKSB7XG4gICAgICByZXR1cm4gaXNCbGFuayhvYmopID8gZmFsc2UgOiBvYmo7XG4gIH1cbiAgZnVuY3Rpb24gaXNKc09iamVjdChvKSB7XG4gICAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiAodHlwZW9mIG8gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG8gPT09ICdvYmplY3QnKTtcbiAgfVxuICBmdW5jdGlvbiBldmFsRXhwcmVzc2lvbihzb3VyY2VVcmwsIGV4cHIsIGRlY2xhcmF0aW9ucywgdmFycykge1xuICAgICAgdmFyIGZuQm9keSA9IGRlY2xhcmF0aW9ucyArIFwiXFxucmV0dXJuIFwiICsgZXhwciArIFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArIHNvdXJjZVVybDtcbiAgICAgIHZhciBmbkFyZ05hbWVzID0gW107XG4gICAgICB2YXIgZm5BcmdWYWx1ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGFyZ05hbWUgaW4gdmFycykge1xuICAgICAgICAgIGZuQXJnTmFtZXMucHVzaChhcmdOYW1lKTtcbiAgICAgICAgICBmbkFyZ1ZhbHVlcy5wdXNoKHZhcnNbYXJnTmFtZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShGdW5jdGlvbiwgW3ZvaWQgMF0uY29uY2F0KGZuQXJnTmFtZXMuY29uY2F0KGZuQm9keSkpKSkoKS5hcHBseSh2b2lkIDAsIGZuQXJnVmFsdWVzKTtcbiAgfVxuICBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgICAgIHJldHVybiAhaXNKc09iamVjdChvYmopO1xuICB9XG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzKSB7XG4gICAgICByZXR1cm4gcy5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xcXVxcL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzZWdtZW50IG9mIHRleHQgd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAgICovXG4gIHZhciBUZXh0QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRleHRBc3QodmFsdWUsIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gVGV4dEFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgYm91bmQgZXhwcmVzc2lvbiB3aXRoaW4gdGhlIHRleHQgb2YgYSB0ZW1wbGF0ZS5cbiAgICovXG4gIHZhciBCb3VuZFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQm91bmRUZXh0QXN0KHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEJvdW5kVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Qm91bmRUZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCb3VuZFRleHRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIHBsYWluIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LlxuICAgKi9cbiAgdmFyIEF0dHJBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQXR0ckFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBBdHRyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBBdHRyQXN0O1xuICB9KCkpO1xuICAvKipcbiAgICogQSBiaW5kaW5nIGZvciBhbiBlbGVtZW50IHByb3BlcnR5IChlLmcuIGBbcHJvcGVydHldPVwiZXhwcmVzc2lvblwiYCkgb3IgYW4gYW5pbWF0aW9uIHRyaWdnZXIgKGUuZy5cbiAgICogYFtAdHJpZ2dlcl09XCJzdGF0ZUV4cFwiYClcbiAgICovXG4gIHZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChuYW1lLCB0eXBlLCBzZWN1cml0eUNvbnRleHQsIHZhbHVlLCB1bml0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHlDb250ZXh0O1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudFByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdC5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09PSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgYmluZGluZyBmb3IgYW4gZWxlbWVudCBldmVudCAoZS5nLiBgKGV2ZW50KT1cImhhbmRsZXIoKVwiYCkgb3IgYW4gYW5pbWF0aW9uIHRyaWdnZXIgZXZlbnQgKGUuZy5cbiAgICogYChAdHJpZ2dlci5waGFzZSk9XCJjYWxsYmFjaygkZXZlbnQpXCJgKS5cbiAgICovXG4gIHZhciBCb3VuZEV2ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEJvdW5kRXZlbnRBc3QobmFtZSwgdGFyZ2V0LCBwaGFzZSwgaGFuZGxlciwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICAgICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEV2ZW50QXN0LnByb3RvdHlwZSwgXCJmdWxsTmFtZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQgKyBcIjpcIiArIHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCb3VuZEV2ZW50QXN0LnByb3RvdHlwZSwgXCJpc0FuaW1hdGlvblwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMucGhhc2U7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEJvdW5kRXZlbnRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSBkZWNsYXJhdGlvbiBvbiBhbiBlbGVtZW50IChlLmcuIGBsZXQgc29tZU5hbWU9XCJleHByZXNzaW9uXCJgKS5cbiAgICovXG4gIHZhciBSZWZlcmVuY2VBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmVmZXJlbmNlQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIFJlZmVyZW5jZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVmZXJlbmNlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBSZWZlcmVuY2VBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG9uIGEgPHRlbXBsYXRlPiAoZS5nLiBgdmFyLXNvbWVOYW1lPVwic29tZUxvY2FsTmFtZVwiYCkuXG4gICAqL1xuICB2YXIgVmFyaWFibGVBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmFyaWFibGVBc3QobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgVmFyaWFibGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFZhcmlhYmxlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBWYXJpYWJsZUFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEFuIGVsZW1lbnQgZGVjbGFyYXRpb24gaW4gYSB0ZW1wbGF0ZS5cbiAgICovXG4gIHZhciBFbGVtZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEVsZW1lbnRBc3QobmFtZSwgYXR0cnMsIGlucHV0cywgb3V0cHV0cywgcmVmZXJlbmNlcywgZGlyZWN0aXZlcywgcHJvdmlkZXJzLCBoYXNWaWV3Q29udGFpbmVyLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgICB0aGlzLmhhc1ZpZXdDb250YWluZXIgPSBoYXNWaWV3Q29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEVsZW1lbnRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGA8dGVtcGxhdGU+YCBlbGVtZW50IGluY2x1ZGVkIGluIGFuIEFuZ3VsYXIgdGVtcGxhdGUuXG4gICAqL1xuICB2YXIgRW1iZWRkZWRUZW1wbGF0ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRW1iZWRkZWRUZW1wbGF0ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIEEgZGlyZWN0aXZlIHByb3BlcnR5IHdpdGggYSBib3VuZCB2YWx1ZSAoZS5nLiBgKm5nSWY9XCJjb25kaXRpb25cIikuXG4gICAqL1xuICB2YXIgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0KGRpcmVjdGl2ZU5hbWUsIHRlbXBsYXRlTmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLmRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOYW1lO1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlUHJvcGVydHkodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIGRpcmVjdGl2ZSBkZWNsYXJlZCBvbiBhbiBlbGVtZW50LlxuICAgKi9cbiAgdmFyIERpcmVjdGl2ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBpbnB1dHMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5kaXJlY3RpdmUgPSBkaXJlY3RpdmU7XG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICAgIHRoaXMuaG9zdEV2ZW50cyA9IGhvc3RFdmVudHM7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIERpcmVjdGl2ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGlyZWN0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBEaXJlY3RpdmVBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBBIHByb3ZpZGVyIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnRcbiAgICovXG4gIHZhciBQcm92aWRlckFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcm92aWRlckFzdCh0b2tlbiwgbXVsdGlQcm92aWRlciwgZWFnZXIsIHByb3ZpZGVycywgcHJvdmlkZXJUeXBlLCBsaWZlY3ljbGVIb29rcywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICB0aGlzLm11bHRpUHJvdmlkZXIgPSBtdWx0aVByb3ZpZGVyO1xuICAgICAgICAgIHRoaXMuZWFnZXIgPSBlYWdlcjtcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgICB0aGlzLnByb3ZpZGVyVHlwZSA9IHByb3ZpZGVyVHlwZTtcbiAgICAgICAgICB0aGlzLmxpZmVjeWNsZUhvb2tzID0gbGlmZWN5Y2xlSG9va3M7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIFByb3ZpZGVyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gTm8gdmlzaXQgbWV0aG9kIGluIHRoZSB2aXNpdG9yIGZvciBub3cuLi5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJvdmlkZXJBc3Q7XG4gIH0oKSk7XG4gIGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlO1xuICAoZnVuY3Rpb24gKFByb3ZpZGVyQXN0VHlwZSkge1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIlB1YmxpY1NlcnZpY2VcIl0gPSAwXSA9IFwiUHVibGljU2VydmljZVwiO1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIlByaXZhdGVTZXJ2aWNlXCJdID0gMV0gPSBcIlByaXZhdGVTZXJ2aWNlXCI7XG4gICAgICBQcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlW1wiQ29tcG9uZW50XCJdID0gMl0gPSBcIkNvbXBvbmVudFwiO1xuICAgICAgUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZVtcIkRpcmVjdGl2ZVwiXSA9IDNdID0gXCJEaXJlY3RpdmVcIjtcbiAgICAgIFByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGVbXCJCdWlsdGluXCJdID0gNF0gPSBcIkJ1aWx0aW5cIjtcbiAgfSkoZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUgfHwgKGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlID0ge30pKTtcbiAgLyoqXG4gICAqIFBvc2l0aW9uIHdoZXJlIGNvbnRlbnQgaXMgdG8gYmUgcHJvamVjdGVkIChpbnN0YW5jZSBvZiBgPG5nLWNvbnRlbnQ+YCBpbiBhIHRlbXBsYXRlKS5cbiAgICovXG4gIHZhciBOZ0NvbnRlbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTmdDb250ZW50QXN0KGluZGV4LCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIE5nQ29udGVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TmdDb250ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOZ0NvbnRlbnRBc3Q7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBFbnVtZXJhdGlvbiBvZiB0eXBlcyBvZiBwcm9wZXJ0eSBiaW5kaW5ncy5cbiAgICovXG4gIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZTtcbiAgKGZ1bmN0aW9uIChQcm9wZXJ0eUJpbmRpbmdUeXBlKSB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbm9ybWFsIGJpbmRpbmcgdG8gYSBwcm9wZXJ0eSAoZS5nLiBgW3Byb3BlcnR5XT1cImV4cHJlc3Npb25cImApLlxuICAgICAgICovXG4gICAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJQcm9wZXJ0eVwiXSA9IDBdID0gXCJQcm9wZXJ0eVwiO1xuICAgICAgLyoqXG4gICAgICAgKiBBIGJpbmRpbmcgdG8gYW4gZWxlbWVudCBhdHRyaWJ1dGUgKGUuZy4gYFthdHRyLm5hbWVdPVwiZXhwcmVzc2lvblwiYCkuXG4gICAgICAgKi9cbiAgICAgIFByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZVtcIkF0dHJpYnV0ZVwiXSA9IDFdID0gXCJBdHRyaWJ1dGVcIjtcbiAgICAgIC8qKlxuICAgICAgICogQSBiaW5kaW5nIHRvIGEgQ1NTIGNsYXNzIChlLmcuIGBbY2xhc3MubmFtZV09XCJjb25kaXRpb25cImApLlxuICAgICAgICovXG4gICAgICBQcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGVbXCJDbGFzc1wiXSA9IDJdID0gXCJDbGFzc1wiO1xuICAgICAgLyoqXG4gICAgICAgKiBBIGJpbmRpbmcgdG8gYSBzdHlsZSBydWxlIChlLmcuIGBbc3R5bGUucnVsZV09XCJleHByZXNzaW9uXCJgKS5cbiAgICAgICAqL1xuICAgICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiU3R5bGVcIl0gPSAzXSA9IFwiU3R5bGVcIjtcbiAgICAgIC8qKlxuICAgICAgICogQSBiaW5kaW5nIHRvIGFuIGFuaW1hdGlvbiByZWZlcmVuY2UgKGUuZy4gYFthbmltYXRlLmtleV09XCJleHByZXNzaW9uXCJgKS5cbiAgICAgICAqL1xuICAgICAgUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlW1wiQW5pbWF0aW9uXCJdID0gNF0gPSBcIkFuaW1hdGlvblwiO1xuICB9KShleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUgfHwgKGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZSA9IHt9KSk7XG4gIC8qKlxuICAgKiBWaXNpdCBldmVyeSBub2RlIGluIGEgbGlzdCBvZiB7QGxpbmsgVGVtcGxhdGVBc3R9cyB3aXRoIHRoZSBnaXZlbiB7QGxpbmsgVGVtcGxhdGVBc3RWaXNpdG9yfS5cbiAgICovXG4gIGZ1bmN0aW9uIHRlbXBsYXRlVmlzaXRBbGwodmlzaXRvciwgYXN0cywgY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgYXN0UmVzdWx0ID0gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0UmVzdWx0KSkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBhbmQgSW50ZXJuZXQgRXhwbG9yZXIgZG8gbm90IHN1cHBvcnQgdGhlIGl0ZXJhYmxlIHBhcmFtZXRlciB0byB0aGVcbiAgLy8gTWFwIGNvbnN0cnVjdG9yLiAgV2Ugd29yayBhcm91bmQgdGhhdCBieSBtYW51YWxseSBhZGRpbmcgdGhlIGl0ZW1zLlxuICB2YXIgY3JlYXRlTWFwRnJvbVBhaXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG5ldyBNYXAoW1sxLCAyXV0pLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU1hcEZyb21QYWlycyhwYWlycykgeyByZXR1cm4gbmV3IE1hcChwYWlycyk7IH07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXBBbmRQb3B1bGF0ZUZyb21QYWlycyhwYWlycykge1xuICAgICAgICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfTtcbiAgfSkoKTtcbiAgdmFyIF9jbGVhclZhbHVlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoKG5ldyBNYXAoKSkua2V5cygpLm5leHQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2NsZWFyVmFsdWVzKG0pIHtcbiAgICAgICAgICAgICAgdmFyIGtleUl0ZXJhdG9yID0gbS5rZXlzKCk7XG4gICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICB3aGlsZSAoISgoayA9IGtleUl0ZXJhdG9yLm5leHQoKSkuZG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgIG0uc2V0KGsudmFsdWUsIG51bGwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBfY2xlYXJWYWx1ZXNXaXRoRm9yZUVhY2gobSkge1xuICAgICAgICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHsgbS5zZXQoaywgbnVsbCk7IH0pO1xuICAgICAgICAgIH07XG4gICAgICB9XG4gIH0pKCk7XG4gIC8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgLy8gVE9ETyhtbGF2YWwpOiByZW1vdmUgdGhlIHdvcmsgYXJvdW5kIG9uY2Ugd2UgaGF2ZSBhIHdvcmtpbmcgcG9seWZpbGwgb2YgQXJyYXkuZnJvbVxuICB2YXIgX2FycmF5RnJvbU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmICgobmV3IE1hcCgpKS52YWx1ZXMoKS5uZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXAobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVzID8gQXJyYXkuZnJvbShtLnZhbHVlcygpKSA6IEFycmF5LmZyb20obS5rZXlzKCkpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWFwV2l0aEZvcmVhY2gobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShtLnNpemUpLCBpID0gMDtcbiAgICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgcmVzW2ldID0gZ2V0VmFsdWVzID8gdiA6IGs7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfTtcbiAgfSkoKTtcbiAgdmFyIE1hcFdyYXBwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTWFwV3JhcHBlcigpIHtcbiAgICAgIH1cbiAgICAgIE1hcFdyYXBwZXIuY3JlYXRlRnJvbVN0cmluZ01hcCA9IGZ1bmN0aW9uIChzdHJpbmdNYXApIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3RyaW5nTWFwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5zZXQocHJvcCwgc3RyaW5nTWFwW3Byb3BdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBNYXBXcmFwcGVyLnRvU3RyaW5nTWFwID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gcltrXSA9IHY7IH0pO1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICAgIE1hcFdyYXBwZXIuY3JlYXRlRnJvbVBhaXJzID0gZnVuY3Rpb24gKHBhaXJzKSB7IHJldHVybiBjcmVhdGVNYXBGcm9tUGFpcnMocGFpcnMpOyB9O1xuICAgICAgTWFwV3JhcHBlci5pdGVyYWJsZSA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtOyB9O1xuICAgICAgTWFwV3JhcHBlci5rZXlzID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIF9hcnJheUZyb21NYXAobSwgZmFsc2UpOyB9O1xuICAgICAgTWFwV3JhcHBlci52YWx1ZXMgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gX2FycmF5RnJvbU1hcChtLCB0cnVlKTsgfTtcbiAgICAgIHJldHVybiBNYXBXcmFwcGVyO1xuICB9KCkpO1xuICAvKipcbiAgICogV3JhcHMgSmF2YXNjcmlwdCBPYmplY3RzXG4gICAqL1xuICB2YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHJpbmdNYXBXcmFwcGVyKCkge1xuICAgICAgfVxuICAgICAgU3RyaW5nTWFwV3JhcHBlci5tZXJnZSA9IGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgICB2YXIgbSA9IHt9O1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gX2FbX2ldO1xuICAgICAgICAgICAgICBtW2tdID0gbTFba107XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBPYmplY3Qua2V5cyhtMik7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gX2NbX2JdO1xuICAgICAgICAgICAgICBtW2tdID0gbTJba107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgfTtcbiAgICAgIFN0cmluZ01hcFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgIHZhciBrMSA9IE9iamVjdC5rZXlzKG0xKTtcbiAgICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgaWYgKGsxLmxlbmd0aCAhPSBrMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGsxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBrMVtpXTtcbiAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgfSgpKTtcbiAgdmFyIExpc3RXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgfVxuICAgICAgLy8gSlMgaGFzIG5vIHdheSB0byBleHByZXNzIGEgc3RhdGljYWxseSBmaXhlZCBzaXplIGxpc3QsIGJ1dCBkYXJ0IGRvZXMgc28gd2VcbiAgICAgIC8vIGtlZXAgYm90aCBtZXRob2RzLlxuICAgICAgTGlzdFdyYXBwZXIuY3JlYXRlRml4ZWRTaXplID0gZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIG5ldyBBcnJheShzaXplKTsgfTtcbiAgICAgIExpc3RXcmFwcGVyLmNyZWF0ZUdyb3dhYmxlU2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7IHJldHVybiBuZXcgQXJyYXkoc2l6ZSk7IH07XG4gICAgICBMaXN0V3JhcHBlci5jbG9uZSA9IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCk7IH07XG4gICAgICBMaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24gKGFycmF5LCBmbikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZm4oYXJyYXlbaV0sIGkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5maXJzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgIGlmICghYXJyYXkpXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5sYXN0ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLmluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIHZhbHVlLCBzdGFydEluZGV4KSB7XG4gICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IHZvaWQgMCkgeyBzdGFydEluZGV4ID0gMDsgfVxuICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlLCBzdGFydEluZGV4KTtcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChsaXN0LCBlbCkgeyByZXR1cm4gbGlzdC5pbmRleE9mKGVsKSAhPT0gLTE7IH07XG4gICAgICBMaXN0V3JhcHBlci5yZXZlcnNlZCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgIHZhciBhID0gTGlzdFdyYXBwZXIuY2xvbmUoYXJyYXkpO1xuICAgICAgICAgIHJldHVybiBhLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5jb25jYXQgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH07XG4gICAgICBMaXN0V3JhcHBlci5pbnNlcnQgPSBmdW5jdGlvbiAobGlzdCwgaW5kZXgsIHZhbHVlKSB7IGxpc3Quc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7IH07XG4gICAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCkge1xuICAgICAgICAgIHZhciByZXMgPSBsaXN0W2luZGV4XTtcbiAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci5yZW1vdmVBbGwgPSBmdW5jdGlvbiAobGlzdCwgaXRlbXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihpdGVtc1tpXSk7XG4gICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlID0gZnVuY3Rpb24gKGxpc3QsIGVsKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgTGlzdFdyYXBwZXIuY2xlYXIgPSBmdW5jdGlvbiAobGlzdCkgeyBsaXN0Lmxlbmd0aCA9IDA7IH07XG4gICAgICBMaXN0V3JhcHBlci5pc0VtcHR5ID0gZnVuY3Rpb24gKGxpc3QpIHsgcmV0dXJuIGxpc3QubGVuZ3RoID09IDA7IH07XG4gICAgICBMaXN0V3JhcHBlci5maWxsID0gZnVuY3Rpb24gKGxpc3QsIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IG51bGw7IH1cbiAgICAgICAgICBsaXN0LmZpbGwodmFsdWUsIHN0YXJ0LCBlbmQgPT09IG51bGwgPyBsaXN0Lmxlbmd0aCA6IGVuZCk7XG4gICAgICB9O1xuICAgICAgTGlzdFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLnNsaWNlID0gZnVuY3Rpb24gKGwsIGZyb20sIHRvKSB7XG4gICAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICAgIGlmICh0byA9PT0gdm9pZCAwKSB7IHRvID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiBsLnNsaWNlKGZyb20sIHRvID09PSBudWxsID8gdW5kZWZpbmVkIDogdG8pO1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLnNwbGljZSA9IGZ1bmN0aW9uIChsLCBmcm9tLCBsZW5ndGgpIHsgcmV0dXJuIGwuc3BsaWNlKGZyb20sIGxlbmd0aCk7IH07XG4gICAgICBMaXN0V3JhcHBlci5zb3J0ID0gZnVuY3Rpb24gKGwsIGNvbXBhcmVGbikge1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29tcGFyZUZuKSkge1xuICAgICAgICAgICAgICBsLnNvcnQoY29tcGFyZUZuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGwuc29ydCgpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBMaXN0V3JhcHBlci50b1N0cmluZyA9IGZ1bmN0aW9uIChsKSB7IHJldHVybiBsLnRvU3RyaW5nKCk7IH07XG4gICAgICBMaXN0V3JhcHBlci50b0pTT04gPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gSlNPTi5zdHJpbmdpZnkobCk7IH07XG4gICAgICBMaXN0V3JhcHBlci5tYXhpbXVtID0gZnVuY3Rpb24gKGxpc3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc29sdXRpb24gPSBudWxsO1xuICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IC1JbmZpbml0eTtcbiAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoaXNCbGFuayhjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlVmFsdWUgPSBwcmVkaWNhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHNvbHV0aW9uID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBjYW5kaWRhdGVWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc29sdXRpb247XG4gICAgICB9O1xuICAgICAgTGlzdFdyYXBwZXIuZmxhdHRlbiA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IFtdO1xuICAgICAgICAgIF9mbGF0dGVuQXJyYXkobGlzdCwgdGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfTtcbiAgICAgIExpc3RXcmFwcGVyLmFkZEFsbCA9IGZ1bmN0aW9uIChsaXN0LCBzb3VyY2UpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsaXN0LnB1c2goc291cmNlW2ldKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpc3RXcmFwcGVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfZmxhdHRlbkFycmF5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoaXNQcmVzZW50KHNvdXJjZSkpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkoaXRlbSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIFRhZ0NvbnRlbnRUeXBlO1xuICAoZnVuY3Rpb24gKFRhZ0NvbnRlbnRUeXBlKSB7XG4gICAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIlJBV19URVhUXCJdID0gMF0gPSBcIlJBV19URVhUXCI7XG4gICAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiXSA9IDFdID0gXCJFU0NBUEFCTEVfUkFXX1RFWFRcIjtcbiAgICAgIFRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlW1wiUEFSU0FCTEVfREFUQVwiXSA9IDJdID0gXCJQQVJTQUJMRV9EQVRBXCI7XG4gIH0pKFRhZ0NvbnRlbnRUeXBlIHx8IChUYWdDb250ZW50VHlwZSA9IHt9KSk7XG4gIGZ1bmN0aW9uIHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKSB7XG4gICAgICBpZiAoZWxlbWVudE5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgICAgcmV0dXJuIFtudWxsLCBlbGVtZW50TmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgY29sb25JbmRleCA9IGVsZW1lbnROYW1lLmluZGV4T2YoJzonLCAxKTtcbiAgICAgIGlmIChjb2xvbkluZGV4ID09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZm9ybWF0IFxcXCJcIiArIGVsZW1lbnROYW1lICsgXCJcXFwiIGV4cGVjdGluZyBcXFwiOm5hbWVzcGFjZTpuYW1lXFxcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZWxlbWVudE5hbWUuc2xpY2UoMSwgY29sb25JbmRleCksIGVsZW1lbnROYW1lLnNsaWNlKGNvbG9uSW5kZXggKyAxKV07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TnNQcmVmaXgoZnVsbE5hbWUpIHtcbiAgICAgIHJldHVybiBmdWxsTmFtZSA9PT0gbnVsbCA/IG51bGwgOiBzcGxpdE5zTmFtZShmdWxsTmFtZSlbMF07XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VOc0FuZE5hbWUocHJlZml4LCBsb2NhbE5hbWUpIHtcbiAgICAgIHJldHVybiBwcmVmaXggPyBcIjpcIiArIHByZWZpeCArIFwiOlwiICsgbG9jYWxOYW1lIDogbG9jYWxOYW1lO1xuICB9XG4gIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZXNcbiAgLy8gc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VudGl0aWVzLmpzb25cbiAgLy8gVGhpcyBsaXN0IGlzIG5vdCBleGhhdXN0aXZlIHRvIGtlZXAgdGhlIGNvbXBpbGVyIGZvb3RwcmludCBsb3cuXG4gIC8vIFRoZSBgJiMxMjM7YCAvIGAmI3gxYWI7YCBzeW50YXggc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSBkb2VzIG5vdCBleGlzdC5cbiAgdmFyIE5BTUVEX0VOVElUSUVTID0ge1xuICAgICAgJ0FhY3V0ZSc6ICdcXHUwMEMxJyxcbiAgICAgICdhYWN1dGUnOiAnXFx1MDBFMScsXG4gICAgICAnQWNpcmMnOiAnXFx1MDBDMicsXG4gICAgICAnYWNpcmMnOiAnXFx1MDBFMicsXG4gICAgICAnYWN1dGUnOiAnXFx1MDBCNCcsXG4gICAgICAnQUVsaWcnOiAnXFx1MDBDNicsXG4gICAgICAnYWVsaWcnOiAnXFx1MDBFNicsXG4gICAgICAnQWdyYXZlJzogJ1xcdTAwQzAnLFxuICAgICAgJ2FncmF2ZSc6ICdcXHUwMEUwJyxcbiAgICAgICdhbGVmc3ltJzogJ1xcdTIxMzUnLFxuICAgICAgJ0FscGhhJzogJ1xcdTAzOTEnLFxuICAgICAgJ2FscGhhJzogJ1xcdTAzQjEnLFxuICAgICAgJ2FtcCc6ICcmJyxcbiAgICAgICdhbmQnOiAnXFx1MjIyNycsXG4gICAgICAnYW5nJzogJ1xcdTIyMjAnLFxuICAgICAgJ2Fwb3MnOiAnXFx1MDAyNycsXG4gICAgICAnQXJpbmcnOiAnXFx1MDBDNScsXG4gICAgICAnYXJpbmcnOiAnXFx1MDBFNScsXG4gICAgICAnYXN5bXAnOiAnXFx1MjI0OCcsXG4gICAgICAnQXRpbGRlJzogJ1xcdTAwQzMnLFxuICAgICAgJ2F0aWxkZSc6ICdcXHUwMEUzJyxcbiAgICAgICdBdW1sJzogJ1xcdTAwQzQnLFxuICAgICAgJ2F1bWwnOiAnXFx1MDBFNCcsXG4gICAgICAnYmRxdW8nOiAnXFx1MjAxRScsXG4gICAgICAnQmV0YSc6ICdcXHUwMzkyJyxcbiAgICAgICdiZXRhJzogJ1xcdTAzQjInLFxuICAgICAgJ2JydmJhcic6ICdcXHUwMEE2JyxcbiAgICAgICdidWxsJzogJ1xcdTIwMjInLFxuICAgICAgJ2NhcCc6ICdcXHUyMjI5JyxcbiAgICAgICdDY2VkaWwnOiAnXFx1MDBDNycsXG4gICAgICAnY2NlZGlsJzogJ1xcdTAwRTcnLFxuICAgICAgJ2NlZGlsJzogJ1xcdTAwQjgnLFxuICAgICAgJ2NlbnQnOiAnXFx1MDBBMicsXG4gICAgICAnQ2hpJzogJ1xcdTAzQTcnLFxuICAgICAgJ2NoaSc6ICdcXHUwM0M3JyxcbiAgICAgICdjaXJjJzogJ1xcdTAyQzYnLFxuICAgICAgJ2NsdWJzJzogJ1xcdTI2NjMnLFxuICAgICAgJ2NvbmcnOiAnXFx1MjI0NScsXG4gICAgICAnY29weSc6ICdcXHUwMEE5JyxcbiAgICAgICdjcmFycic6ICdcXHUyMUI1JyxcbiAgICAgICdjdXAnOiAnXFx1MjIyQScsXG4gICAgICAnY3VycmVuJzogJ1xcdTAwQTQnLFxuICAgICAgJ2RhZ2dlcic6ICdcXHUyMDIwJyxcbiAgICAgICdEYWdnZXInOiAnXFx1MjAyMScsXG4gICAgICAnZGFycic6ICdcXHUyMTkzJyxcbiAgICAgICdkQXJyJzogJ1xcdTIxRDMnLFxuICAgICAgJ2RlZyc6ICdcXHUwMEIwJyxcbiAgICAgICdEZWx0YSc6ICdcXHUwMzk0JyxcbiAgICAgICdkZWx0YSc6ICdcXHUwM0I0JyxcbiAgICAgICdkaWFtcyc6ICdcXHUyNjY2JyxcbiAgICAgICdkaXZpZGUnOiAnXFx1MDBGNycsXG4gICAgICAnRWFjdXRlJzogJ1xcdTAwQzknLFxuICAgICAgJ2VhY3V0ZSc6ICdcXHUwMEU5JyxcbiAgICAgICdFY2lyYyc6ICdcXHUwMENBJyxcbiAgICAgICdlY2lyYyc6ICdcXHUwMEVBJyxcbiAgICAgICdFZ3JhdmUnOiAnXFx1MDBDOCcsXG4gICAgICAnZWdyYXZlJzogJ1xcdTAwRTgnLFxuICAgICAgJ2VtcHR5JzogJ1xcdTIyMDUnLFxuICAgICAgJ2Vtc3AnOiAnXFx1MjAwMycsXG4gICAgICAnZW5zcCc6ICdcXHUyMDAyJyxcbiAgICAgICdFcHNpbG9uJzogJ1xcdTAzOTUnLFxuICAgICAgJ2Vwc2lsb24nOiAnXFx1MDNCNScsXG4gICAgICAnZXF1aXYnOiAnXFx1MjI2MScsXG4gICAgICAnRXRhJzogJ1xcdTAzOTcnLFxuICAgICAgJ2V0YSc6ICdcXHUwM0I3JyxcbiAgICAgICdFVEgnOiAnXFx1MDBEMCcsXG4gICAgICAnZXRoJzogJ1xcdTAwRjAnLFxuICAgICAgJ0V1bWwnOiAnXFx1MDBDQicsXG4gICAgICAnZXVtbCc6ICdcXHUwMEVCJyxcbiAgICAgICdldXJvJzogJ1xcdTIwQUMnLFxuICAgICAgJ2V4aXN0JzogJ1xcdTIyMDMnLFxuICAgICAgJ2Zub2YnOiAnXFx1MDE5MicsXG4gICAgICAnZm9yYWxsJzogJ1xcdTIyMDAnLFxuICAgICAgJ2ZyYWMxMic6ICdcXHUwMEJEJyxcbiAgICAgICdmcmFjMTQnOiAnXFx1MDBCQycsXG4gICAgICAnZnJhYzM0JzogJ1xcdTAwQkUnLFxuICAgICAgJ2ZyYXNsJzogJ1xcdTIwNDQnLFxuICAgICAgJ0dhbW1hJzogJ1xcdTAzOTMnLFxuICAgICAgJ2dhbW1hJzogJ1xcdTAzQjMnLFxuICAgICAgJ2dlJzogJ1xcdTIyNjUnLFxuICAgICAgJ2d0JzogJz4nLFxuICAgICAgJ2hhcnInOiAnXFx1MjE5NCcsXG4gICAgICAnaEFycic6ICdcXHUyMUQ0JyxcbiAgICAgICdoZWFydHMnOiAnXFx1MjY2NScsXG4gICAgICAnaGVsbGlwJzogJ1xcdTIwMjYnLFxuICAgICAgJ0lhY3V0ZSc6ICdcXHUwMENEJyxcbiAgICAgICdpYWN1dGUnOiAnXFx1MDBFRCcsXG4gICAgICAnSWNpcmMnOiAnXFx1MDBDRScsXG4gICAgICAnaWNpcmMnOiAnXFx1MDBFRScsXG4gICAgICAnaWV4Y2wnOiAnXFx1MDBBMScsXG4gICAgICAnSWdyYXZlJzogJ1xcdTAwQ0MnLFxuICAgICAgJ2lncmF2ZSc6ICdcXHUwMEVDJyxcbiAgICAgICdpbWFnZSc6ICdcXHUyMTExJyxcbiAgICAgICdpbmZpbic6ICdcXHUyMjFFJyxcbiAgICAgICdpbnQnOiAnXFx1MjIyQicsXG4gICAgICAnSW90YSc6ICdcXHUwMzk5JyxcbiAgICAgICdpb3RhJzogJ1xcdTAzQjknLFxuICAgICAgJ2lxdWVzdCc6ICdcXHUwMEJGJyxcbiAgICAgICdpc2luJzogJ1xcdTIyMDgnLFxuICAgICAgJ0l1bWwnOiAnXFx1MDBDRicsXG4gICAgICAnaXVtbCc6ICdcXHUwMEVGJyxcbiAgICAgICdLYXBwYSc6ICdcXHUwMzlBJyxcbiAgICAgICdrYXBwYSc6ICdcXHUwM0JBJyxcbiAgICAgICdMYW1iZGEnOiAnXFx1MDM5QicsXG4gICAgICAnbGFtYmRhJzogJ1xcdTAzQkInLFxuICAgICAgJ2xhbmcnOiAnXFx1MjdFOCcsXG4gICAgICAnbGFxdW8nOiAnXFx1MDBBQicsXG4gICAgICAnbGFycic6ICdcXHUyMTkwJyxcbiAgICAgICdsQXJyJzogJ1xcdTIxRDAnLFxuICAgICAgJ2xjZWlsJzogJ1xcdTIzMDgnLFxuICAgICAgJ2xkcXVvJzogJ1xcdTIwMUMnLFxuICAgICAgJ2xlJzogJ1xcdTIyNjQnLFxuICAgICAgJ2xmbG9vcic6ICdcXHUyMzBBJyxcbiAgICAgICdsb3dhc3QnOiAnXFx1MjIxNycsXG4gICAgICAnbG96JzogJ1xcdTI1Q0EnLFxuICAgICAgJ2xybSc6ICdcXHUyMDBFJyxcbiAgICAgICdsc2FxdW8nOiAnXFx1MjAzOScsXG4gICAgICAnbHNxdW8nOiAnXFx1MjAxOCcsXG4gICAgICAnbHQnOiAnPCcsXG4gICAgICAnbWFjcic6ICdcXHUwMEFGJyxcbiAgICAgICdtZGFzaCc6ICdcXHUyMDE0JyxcbiAgICAgICdtaWNybyc6ICdcXHUwMEI1JyxcbiAgICAgICdtaWRkb3QnOiAnXFx1MDBCNycsXG4gICAgICAnbWludXMnOiAnXFx1MjIxMicsXG4gICAgICAnTXUnOiAnXFx1MDM5QycsXG4gICAgICAnbXUnOiAnXFx1MDNCQycsXG4gICAgICAnbmFibGEnOiAnXFx1MjIwNycsXG4gICAgICAnbmJzcCc6ICdcXHUwMEEwJyxcbiAgICAgICduZGFzaCc6ICdcXHUyMDEzJyxcbiAgICAgICduZSc6ICdcXHUyMjYwJyxcbiAgICAgICduaSc6ICdcXHUyMjBCJyxcbiAgICAgICdub3QnOiAnXFx1MDBBQycsXG4gICAgICAnbm90aW4nOiAnXFx1MjIwOScsXG4gICAgICAnbnN1Yic6ICdcXHUyMjg0JyxcbiAgICAgICdOdGlsZGUnOiAnXFx1MDBEMScsXG4gICAgICAnbnRpbGRlJzogJ1xcdTAwRjEnLFxuICAgICAgJ051JzogJ1xcdTAzOUQnLFxuICAgICAgJ251JzogJ1xcdTAzQkQnLFxuICAgICAgJ09hY3V0ZSc6ICdcXHUwMEQzJyxcbiAgICAgICdvYWN1dGUnOiAnXFx1MDBGMycsXG4gICAgICAnT2NpcmMnOiAnXFx1MDBENCcsXG4gICAgICAnb2NpcmMnOiAnXFx1MDBGNCcsXG4gICAgICAnT0VsaWcnOiAnXFx1MDE1MicsXG4gICAgICAnb2VsaWcnOiAnXFx1MDE1MycsXG4gICAgICAnT2dyYXZlJzogJ1xcdTAwRDInLFxuICAgICAgJ29ncmF2ZSc6ICdcXHUwMEYyJyxcbiAgICAgICdvbGluZSc6ICdcXHUyMDNFJyxcbiAgICAgICdPbWVnYSc6ICdcXHUwM0E5JyxcbiAgICAgICdvbWVnYSc6ICdcXHUwM0M5JyxcbiAgICAgICdPbWljcm9uJzogJ1xcdTAzOUYnLFxuICAgICAgJ29taWNyb24nOiAnXFx1MDNCRicsXG4gICAgICAnb3BsdXMnOiAnXFx1MjI5NScsXG4gICAgICAnb3InOiAnXFx1MjIyOCcsXG4gICAgICAnb3JkZic6ICdcXHUwMEFBJyxcbiAgICAgICdvcmRtJzogJ1xcdTAwQkEnLFxuICAgICAgJ09zbGFzaCc6ICdcXHUwMEQ4JyxcbiAgICAgICdvc2xhc2gnOiAnXFx1MDBGOCcsXG4gICAgICAnT3RpbGRlJzogJ1xcdTAwRDUnLFxuICAgICAgJ290aWxkZSc6ICdcXHUwMEY1JyxcbiAgICAgICdvdGltZXMnOiAnXFx1MjI5NycsXG4gICAgICAnT3VtbCc6ICdcXHUwMEQ2JyxcbiAgICAgICdvdW1sJzogJ1xcdTAwRjYnLFxuICAgICAgJ3BhcmEnOiAnXFx1MDBCNicsXG4gICAgICAncGVybWlsJzogJ1xcdTIwMzAnLFxuICAgICAgJ3BlcnAnOiAnXFx1MjJBNScsXG4gICAgICAnUGhpJzogJ1xcdTAzQTYnLFxuICAgICAgJ3BoaSc6ICdcXHUwM0M2JyxcbiAgICAgICdQaSc6ICdcXHUwM0EwJyxcbiAgICAgICdwaSc6ICdcXHUwM0MwJyxcbiAgICAgICdwaXYnOiAnXFx1MDNENicsXG4gICAgICAncGx1c21uJzogJ1xcdTAwQjEnLFxuICAgICAgJ3BvdW5kJzogJ1xcdTAwQTMnLFxuICAgICAgJ3ByaW1lJzogJ1xcdTIwMzInLFxuICAgICAgJ1ByaW1lJzogJ1xcdTIwMzMnLFxuICAgICAgJ3Byb2QnOiAnXFx1MjIwRicsXG4gICAgICAncHJvcCc6ICdcXHUyMjFEJyxcbiAgICAgICdQc2knOiAnXFx1MDNBOCcsXG4gICAgICAncHNpJzogJ1xcdTAzQzgnLFxuICAgICAgJ3F1b3QnOiAnXFx1MDAyMicsXG4gICAgICAncmFkaWMnOiAnXFx1MjIxQScsXG4gICAgICAncmFuZyc6ICdcXHUyN0U5JyxcbiAgICAgICdyYXF1byc6ICdcXHUwMEJCJyxcbiAgICAgICdyYXJyJzogJ1xcdTIxOTInLFxuICAgICAgJ3JBcnInOiAnXFx1MjFEMicsXG4gICAgICAncmNlaWwnOiAnXFx1MjMwOScsXG4gICAgICAncmRxdW8nOiAnXFx1MjAxRCcsXG4gICAgICAncmVhbCc6ICdcXHUyMTFDJyxcbiAgICAgICdyZWcnOiAnXFx1MDBBRScsXG4gICAgICAncmZsb29yJzogJ1xcdTIzMEInLFxuICAgICAgJ1Jobyc6ICdcXHUwM0ExJyxcbiAgICAgICdyaG8nOiAnXFx1MDNDMScsXG4gICAgICAncmxtJzogJ1xcdTIwMEYnLFxuICAgICAgJ3JzYXF1byc6ICdcXHUyMDNBJyxcbiAgICAgICdyc3F1byc6ICdcXHUyMDE5JyxcbiAgICAgICdzYnF1byc6ICdcXHUyMDFBJyxcbiAgICAgICdTY2Fyb24nOiAnXFx1MDE2MCcsXG4gICAgICAnc2Nhcm9uJzogJ1xcdTAxNjEnLFxuICAgICAgJ3Nkb3QnOiAnXFx1MjJDNScsXG4gICAgICAnc2VjdCc6ICdcXHUwMEE3JyxcbiAgICAgICdzaHknOiAnXFx1MDBBRCcsXG4gICAgICAnU2lnbWEnOiAnXFx1MDNBMycsXG4gICAgICAnc2lnbWEnOiAnXFx1MDNDMycsXG4gICAgICAnc2lnbWFmJzogJ1xcdTAzQzInLFxuICAgICAgJ3NpbSc6ICdcXHUyMjNDJyxcbiAgICAgICdzcGFkZXMnOiAnXFx1MjY2MCcsXG4gICAgICAnc3ViJzogJ1xcdTIyODInLFxuICAgICAgJ3N1YmUnOiAnXFx1MjI4NicsXG4gICAgICAnc3VtJzogJ1xcdTIyMTEnLFxuICAgICAgJ3N1cCc6ICdcXHUyMjgzJyxcbiAgICAgICdzdXAxJzogJ1xcdTAwQjknLFxuICAgICAgJ3N1cDInOiAnXFx1MDBCMicsXG4gICAgICAnc3VwMyc6ICdcXHUwMEIzJyxcbiAgICAgICdzdXBlJzogJ1xcdTIyODcnLFxuICAgICAgJ3N6bGlnJzogJ1xcdTAwREYnLFxuICAgICAgJ1RhdSc6ICdcXHUwM0E0JyxcbiAgICAgICd0YXUnOiAnXFx1MDNDNCcsXG4gICAgICAndGhlcmU0JzogJ1xcdTIyMzQnLFxuICAgICAgJ1RoZXRhJzogJ1xcdTAzOTgnLFxuICAgICAgJ3RoZXRhJzogJ1xcdTAzQjgnLFxuICAgICAgJ3RoZXRhc3ltJzogJ1xcdTAzRDEnLFxuICAgICAgJ3RoaW5zcCc6ICdcXHUyMDA5JyxcbiAgICAgICdUSE9STic6ICdcXHUwMERFJyxcbiAgICAgICd0aG9ybic6ICdcXHUwMEZFJyxcbiAgICAgICd0aWxkZSc6ICdcXHUwMkRDJyxcbiAgICAgICd0aW1lcyc6ICdcXHUwMEQ3JyxcbiAgICAgICd0cmFkZSc6ICdcXHUyMTIyJyxcbiAgICAgICdVYWN1dGUnOiAnXFx1MDBEQScsXG4gICAgICAndWFjdXRlJzogJ1xcdTAwRkEnLFxuICAgICAgJ3VhcnInOiAnXFx1MjE5MScsXG4gICAgICAndUFycic6ICdcXHUyMUQxJyxcbiAgICAgICdVY2lyYyc6ICdcXHUwMERCJyxcbiAgICAgICd1Y2lyYyc6ICdcXHUwMEZCJyxcbiAgICAgICdVZ3JhdmUnOiAnXFx1MDBEOScsXG4gICAgICAndWdyYXZlJzogJ1xcdTAwRjknLFxuICAgICAgJ3VtbCc6ICdcXHUwMEE4JyxcbiAgICAgICd1cHNpaCc6ICdcXHUwM0QyJyxcbiAgICAgICdVcHNpbG9uJzogJ1xcdTAzQTUnLFxuICAgICAgJ3Vwc2lsb24nOiAnXFx1MDNDNScsXG4gICAgICAnVXVtbCc6ICdcXHUwMERDJyxcbiAgICAgICd1dW1sJzogJ1xcdTAwRkMnLFxuICAgICAgJ3dlaWVycCc6ICdcXHUyMTE4JyxcbiAgICAgICdYaSc6ICdcXHUwMzlFJyxcbiAgICAgICd4aSc6ICdcXHUwM0JFJyxcbiAgICAgICdZYWN1dGUnOiAnXFx1MDBERCcsXG4gICAgICAneWFjdXRlJzogJ1xcdTAwRkQnLFxuICAgICAgJ3llbic6ICdcXHUwMEE1JyxcbiAgICAgICd5dW1sJzogJ1xcdTAwRkYnLFxuICAgICAgJ1l1bWwnOiAnXFx1MDE3OCcsXG4gICAgICAnWmV0YSc6ICdcXHUwMzk2JyxcbiAgICAgICd6ZXRhJzogJ1xcdTAzQjYnLFxuICAgICAgJ3p3aic6ICdcXHUyMDBEJyxcbiAgICAgICd6d25qJzogJ1xcdTIwMEMnLFxuICB9O1xuXG4gIHZhciBIdG1sVGFnRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBIdG1sVGFnRGVmaW5pdGlvbihfYSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGNsb3NlZEJ5Q2hpbGRyZW4gPSBfYi5jbG9zZWRCeUNoaWxkcmVuLCByZXF1aXJlZFBhcmVudHMgPSBfYi5yZXF1aXJlZFBhcmVudHMsIGltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gX2IuaW1wbGljaXROYW1lc3BhY2VQcmVmaXgsIF9jID0gX2IuY29udGVudFR5cGUsIGNvbnRlbnRUeXBlID0gX2MgPT09IHZvaWQgMCA/IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEgOiBfYywgX2QgPSBfYi5jbG9zZWRCeVBhcmVudCwgY2xvc2VkQnlQYXJlbnQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYi5pc1ZvaWQsIGlzVm9pZCA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lLCBfZiA9IF9iLmlnbm9yZUZpcnN0TGYsIGlnbm9yZUZpcnN0TGYgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZjtcbiAgICAgICAgICB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW4gPSB7fTtcbiAgICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoY2xvc2VkQnlDaGlsZHJlbiAmJiBjbG9zZWRCeUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY2xvc2VkQnlDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7IHJldHVybiBfdGhpcy5jbG9zZWRCeUNoaWxkcmVuW3RhZ05hbWVdID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaXNWb2lkID0gaXNWb2lkO1xuICAgICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBjbG9zZWRCeVBhcmVudCB8fCBpc1ZvaWQ7XG4gICAgICAgICAgaWYgKHJlcXVpcmVkUGFyZW50cyAmJiByZXF1aXJlZFBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLnJlcXVpcmVkUGFyZW50cyA9IHt9O1xuICAgICAgICAgICAgICAvLyBUaGUgZmlyc3QgcGFyZW50IGlzIHRoZSBsaXN0IGlzIGF1dG9tYXRpY2FsbHkgd2hlbiBub25lIG9mIHRoZSBsaXN0ZWQgcGFyZW50cyBhcmUgcHJlc2VudFxuICAgICAgICAgICAgICB0aGlzLnBhcmVudFRvQWRkID0gcmVxdWlyZWRQYXJlbnRzWzBdO1xuICAgICAgICAgICAgICByZXF1aXJlZFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFnTmFtZSkgeyByZXR1cm4gX3RoaXMucmVxdWlyZWRQYXJlbnRzW3RhZ05hbWVdID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaW1wbGljaXROYW1lc3BhY2VQcmVmaXggPSBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDtcbiAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gY29udGVudFR5cGU7XG4gICAgICAgICAgdGhpcy5pZ25vcmVGaXJzdExmID0gaWdub3JlRmlyc3RMZjtcbiAgICAgIH1cbiAgICAgIEh0bWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5yZXF1aXJlRXh0cmFQYXJlbnQgPSBmdW5jdGlvbiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICAgIGlmICghdGhpcy5yZXF1aXJlZFBhcmVudHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsY1BhcmVudCA9IGN1cnJlbnRQYXJlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlZFBhcmVudHNbbGNQYXJlbnRdICE9IHRydWUgJiYgbGNQYXJlbnQgIT0gJ3RlbXBsYXRlJztcbiAgICAgIH07XG4gICAgICBIdG1sVGFnRGVmaW5pdGlvbi5wcm90b3R5cGUuaXNDbG9zZWRCeUNoaWxkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZvaWQgfHwgbmFtZS50b0xvd2VyQ2FzZSgpIGluIHRoaXMuY2xvc2VkQnlDaGlsZHJlbjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSHRtbFRhZ0RlZmluaXRpb247XG4gIH0oKSk7XG4gIC8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjb3B0aW9uYWwtdGFnc1xuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGZ1bGx5IGNvbmZvcm0gdG8gdGhlIEhUTUw1IHNwZWMuXG4gIHZhciBUQUdfREVGSU5JVElPTlMgPSB7XG4gICAgICAnYmFzZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdtZXRhJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ2FyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnZW1iZWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnbGluayc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdpbWcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnaW5wdXQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAncGFyYW0nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnaHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnYnInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAnc291cmNlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ3RyYWNrJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ3dicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICdwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHtcbiAgICAgICAgICBjbG9zZWRCeUNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICdhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdkaXYnLCAnZGwnLCAnZmllbGRzZXQnLCAnZm9vdGVyJywgJ2Zvcm0nLFxuICAgICAgICAgICAgICAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsXG4gICAgICAgICAgICAgICdtYWluJywgJ25hdicsICdvbCcsICdwJywgJ3ByZScsICdzZWN0aW9uJywgJ3RhYmxlJywgJ3VsJ1xuICAgICAgICAgIF0sXG4gICAgICAgICAgY2xvc2VkQnlQYXJlbnQ6IHRydWVcbiAgICAgIH0pLFxuICAgICAgJ3RoZWFkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddIH0pLFxuICAgICAgJ3Rib2R5JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICd0Zm9vdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAndHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFsndHInXSxcbiAgICAgICAgICByZXF1aXJlZFBhcmVudHM6IFsndGJvZHknLCAndGZvb3QnLCAndGhlYWQnXSxcbiAgICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgICAgfSksXG4gICAgICAndGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RkJywgJ3RoJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3RoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdjb2wnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyByZXF1aXJlZFBhcmVudHM6IFsnY29sZ3JvdXAnXSwgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgJ3N2Zyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGltcGxpY2l0TmFtZXNwYWNlUHJlZml4OiAnc3ZnJyB9KSxcbiAgICAgICdtYXRoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdtYXRoJyB9KSxcbiAgICAgICdsaSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnbGknXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAnZHQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10gfSksXG4gICAgICAnZGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ3JiJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAncnQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdydGMnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdycCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgJ29wdGdyb3VwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdvcHRpb24nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGlvbicsICdvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICdwcmUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICAgICAgJ2xpc3RpbmcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICAgICAgJ3N0eWxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUIH0pLFxuICAgICAgJ3NjcmlwdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5SQVdfVEVYVCB9KSxcbiAgICAgICd0aXRsZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNvbnRlbnRUeXBlOiBUYWdDb250ZW50VHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQgfSksXG4gICAgICAndGV4dGFyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhULCBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICB9O1xuICB2YXIgX0RFRkFVTFRfVEFHX0RFRklOSVRJT04gPSBuZXcgSHRtbFRhZ0RlZmluaXRpb24oKTtcbiAgZnVuY3Rpb24gZ2V0SHRtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgICAgcmV0dXJuIFRBR19ERUZJTklUSU9OU1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IF9ERUZBVUxUX1RBR19ERUZJTklUSU9OO1xuICB9XG5cbiAgdmFyIF9TRUxFQ1RPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCcoXFxcXDpub3RcXFxcKCl8JyArXG4gICAgICAnKFstXFxcXHddKyl8JyArXG4gICAgICAnKD86XFxcXC4oWy1cXFxcd10rKSl8JyArXG4gICAgICAnKD86XFxcXFsoWy1cXFxcdypdKykoPzo9KFteXFxcXF1dKikpP1xcXFxdKXwnICtcbiAgICAgICcoXFxcXCkpfCcgK1xuICAgICAgJyhcXFxccyosXFxcXHMqKScsIC8vIFwiLFwiXG4gICdnJyk7XG4gIC8qKlxuICAgKiBBIGNzcyBzZWxlY3RvciBjb250YWlucyBhbiBlbGVtZW50IG5hbWUsXG4gICAqIGNzcyBjbGFzc2VzIGFuZCBhdHRyaWJ1dGUvdmFsdWUgcGFpcnMgd2l0aCB0aGUgcHVycG9zZVxuICAgKiBvZiBzZWxlY3Rpbmcgc3Vic2V0cyBvdXQgb2YgdGhlbS5cbiAgICovXG4gIHZhciBDc3NTZWxlY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDc3NTZWxlY3RvcigpIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSBbXTtcbiAgICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IFtdO1xuICAgICAgfVxuICAgICAgQ3NzU2VsZWN0b3IucGFyc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIHZhciBfYWRkUmVzdWx0ID0gZnVuY3Rpb24gKHJlcywgY3NzU2VsKSB7XG4gICAgICAgICAgICAgIGlmIChjc3NTZWwubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgIWNzc1NlbC5lbGVtZW50ICYmIGNzc1NlbC5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICBjc3NTZWwuYXR0cnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNzc1NlbC5lbGVtZW50ID0gJyonO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcy5wdXNoKGNzc1NlbCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgY3NzU2VsZWN0b3IgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgICB2YXIgaW5Ob3QgPSBmYWxzZTtcbiAgICAgICAgICBfU0VMRUNUT1JfUkVHRVhQLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKG1hdGNoID0gX1NFTEVDVE9SX1JFR0VYUC5leGVjKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVzdGluZyA6bm90IGlzIG5vdCBhbGxvd2VkIGluIGEgc2VsZWN0b3InKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluTm90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yLm5vdFNlbGVjdG9ycy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudC5zZXRFbGVtZW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQ2xhc3NOYW1lKG1hdGNoWzNdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQXR0cmlidXRlKG1hdGNoWzRdLCBtYXRjaFs1XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1hdGNoWzZdKSB7XG4gICAgICAgICAgICAgICAgICBpbk5vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXRjaFs3XSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGluTm90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBzZWxlY3RvcnMgaW4gOm5vdCBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX2FkZFJlc3VsdChyZXN1bHRzLCBjc3NTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICBjc3NTZWxlY3RvciA9IGN1cnJlbnQgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfYWRkUmVzdWx0KHJlc3VsdHMsIGNzc1NlbGVjdG9yKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH07XG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuaXNFbGVtZW50U2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzRWxlbWVudFNlbGVjdG9yKCkgJiYgdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmIHRoaXMuYXR0cnMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICAgICAgfTtcbiAgICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5oYXNFbGVtZW50U2VsZWN0b3IgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMuZWxlbWVudDsgfTtcbiAgICAgIENzc1NlbGVjdG9yLnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7IGVsZW1lbnQgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIH07XG4gICAgICAvKiogR2V0cyBhIHRlbXBsYXRlIHN0cmluZyBmb3IgYW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNlbGVjdG9yLiAqL1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmdldE1hdGNoaW5nRWxlbWVudFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciB0YWdOYW1lID0gdGhpcy5lbGVtZW50IHx8ICdkaXYnO1xuICAgICAgICAgIHZhciBjbGFzc0F0dHIgPSB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID4gMCA/IFwiIGNsYXNzPVxcXCJcIiArIHRoaXMuY2xhc3NOYW1lcy5qb2luKCcgJykgKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICAgIHZhciBhdHRycyA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSB0aGlzLmF0dHJzW2ldO1xuICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5hdHRyc1tpICsgMV0gIT09ICcnID8gXCI9XFxcIlwiICsgdGhpcy5hdHRyc1tpICsgMV0gKyBcIlxcXCJcIiA6ICcnO1xuICAgICAgICAgICAgICBhdHRycyArPSBcIiBcIiArIGF0dHJOYW1lICsgYXR0clZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0SHRtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkuaXNWb2lkID8gXCI8XCIgKyB0YWdOYW1lICsgY2xhc3NBdHRyICsgYXR0cnMgKyBcIi8+XCIgOlxuICAgICAgICAgICAgICBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiPjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgICB9O1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gJyc7IH1cbiAgICAgICAgICB0aGlzLmF0dHJzLnB1c2gobmFtZSwgdmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSB8fCAnJyk7XG4gICAgICB9O1xuICAgICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7IH07XG4gICAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlcyA9IHRoaXMuZWxlbWVudCB8fCAnJztcbiAgICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrbGFzcykgeyByZXR1cm4gcmVzICs9IFwiLlwiICsga2xhc3M7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5hdHRycykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLmF0dHJzW2ldO1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICByZXMgKz0gXCJbXCIgKyBuYW1lXzEgKyAodmFsdWUgPyAnPScgKyB2YWx1ZSA6ICcnKSArIFwiXVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubm90U2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKG5vdFNlbGVjdG9yKSB7IHJldHVybiByZXMgKz0gXCI6bm90KFwiICsgbm90U2VsZWN0b3IgKyBcIilcIjsgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ3NzU2VsZWN0b3I7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBSZWFkcyBhIGxpc3Qgb2YgQ3NzU2VsZWN0b3JzIGFuZCBhbGxvd3MgdG8gY2FsY3VsYXRlIHdoaWNoIG9uZXNcbiAgICogYXJlIGNvbnRhaW5lZCBpbiBhIGdpdmVuIENzc1NlbGVjdG9yLlxuICAgKi9cbiAgdmFyIFNlbGVjdG9yTWF0Y2hlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTZWxlY3Rvck1hdGNoZXIoKSB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudE1hcCA9IHt9O1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnRQYXJ0aWFsTWFwID0ge307XG4gICAgICAgICAgdGhpcy5fY2xhc3NNYXAgPSB7fTtcbiAgICAgICAgICB0aGlzLl9jbGFzc1BhcnRpYWxNYXAgPSB7fTtcbiAgICAgICAgICB0aGlzLl9hdHRyVmFsdWVNYXAgPSB7fTtcbiAgICAgICAgICB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwID0ge307XG4gICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzID0gW107XG4gICAgICB9XG4gICAgICBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlciA9IGZ1bmN0aW9uIChub3RTZWxlY3RvcnMpIHtcbiAgICAgICAgICB2YXIgbm90TWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICBub3RNYXRjaGVyLmFkZFNlbGVjdGFibGVzKG5vdFNlbGVjdG9ycywgbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIG5vdE1hdGNoZXI7XG4gICAgICB9O1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5hZGRTZWxlY3RhYmxlcyA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvcnMsIGNhbGxiYWNrQ3R4dCkge1xuICAgICAgICAgIHZhciBsaXN0Q29udGV4dCA9IG51bGw7XG4gICAgICAgICAgaWYgKGNzc1NlbGVjdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGxpc3RDb250ZXh0ID0gbmV3IFNlbGVjdG9yTGlzdENvbnRleHQoY3NzU2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzLnB1c2gobGlzdENvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRTZWxlY3RhYmxlKGNzc1NlbGVjdG9yc1tpXSwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQWRkIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBmb3VuZCBsYXRlciBvbiBieSBjYWxsaW5nIGBtYXRjaGAuXG4gICAgICAgKiBAcGFyYW0gY3NzU2VsZWN0b3IgQSBjc3Mgc2VsZWN0b3JcbiAgICAgICAqIEBwYXJhbSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFNlbGVjdGFibGUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlciA9IHRoaXM7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcbiAgICAgICAgICB2YXIgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgICB2YXIgc2VsZWN0YWJsZSA9IG5ldyBTZWxlY3RvckNvbnRleHQoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xuICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwobWF0Y2hlci5fZWxlbWVudE1hcCwgZWxlbWVudCwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChtYXRjaGVyLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaXNUZXJtaW5hbCA9IGF0dHJzLmxlbmd0aCA9PT0gMCAmJiBpID09PSBjbGFzc05hbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGVybWluYWwobWF0Y2hlci5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gdGhpcy5fYWRkUGFydGlhbChtYXRjaGVyLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1Rlcm1pbmFsID0gaSA9PT0gYXR0cnMubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICAgIHZhciBuYW1lXzIgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlTWFwO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtaW5hbFZhbHVlc01hcCA9IHRlcm1pbmFsTWFwW25hbWVfMl07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbFZhbHVlc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbFZhbHVlc01hcCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbE1hcFtuYW1lXzJdID0gdGVybWluYWxWYWx1ZXNNYXA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbE1hcCA9IG1hdGNoZXIuX2F0dHJWYWx1ZVBhcnRpYWxNYXA7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxWYWx1ZXNNYXAgPSBwYXJ0aWFsTWFwW25hbWVfMl07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxWYWx1ZXNNYXAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE1hcFtuYW1lXzJdID0gcGFydGlhbFZhbHVlc01hcDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHZhciB0ZXJtaW5hbExpc3QgPSBtYXBbbmFtZV07XG4gICAgICAgICAgaWYgKCF0ZXJtaW5hbExpc3QpIHtcbiAgICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICAgIG1hcFtuYW1lXSA9IHRlcm1pbmFsTGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgICB9O1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkUGFydGlhbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlciA9IG1hcFtuYW1lXTtcbiAgICAgICAgICBpZiAoIW1hdGNoZXIpIHtcbiAgICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgICAgbWFwW25hbWVdID0gbWF0Y2hlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHZpYSBgYWRkU2VsZWN0YWJsZWBcbiAgICAgICAqIHdob3NlIGNzcyBzZWxlY3RvciBpcyBjb250YWluZWQgaW4gdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cbiAgICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAgICogQHBhcmFtIG1hdGNoZWRDYWxsYmFjayBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG9iamVjdCBoYW5kZWQgaW50byBgYWRkU2VsZWN0YWJsZWBcbiAgICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAqL1xuICAgICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcbiAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGNzc1NlbGVjdG9yLmNsYXNzTmFtZXM7XG4gICAgICAgICAgdmFyIGF0dHJzID0gY3NzU2VsZWN0b3IuYXR0cnM7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzW2ldLmFscmVhZHlNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fZWxlbWVudE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9lbGVtZW50UGFydGlhbE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMyA9IGF0dHJzW2ldO1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgdmFyIHRlcm1pbmFsVmFsdWVzTWFwID0gdGhpcy5fYXR0clZhbHVlTWFwW25hbWVfM107XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwW25hbWVfM107XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgJycsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsIHZhbHVlLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICAvKiogQGludGVybmFsICovXG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzZWxlY3RhYmxlcyA9IG1hcFtuYW1lXTtcbiAgICAgICAgICB2YXIgc3RhclNlbGVjdGFibGVzID0gbWFwWycqJ107XG4gICAgICAgICAgaWYgKHN0YXJTZWxlY3RhYmxlcykge1xuICAgICAgICAgICAgICBzZWxlY3RhYmxlcyA9IHNlbGVjdGFibGVzLmNvbmNhdChzdGFyU2VsZWN0YWJsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGVjdGFibGVzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlbGVjdGFibGU7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2ldO1xuICAgICAgICAgICAgICByZXN1bHQgPSBzZWxlY3RhYmxlLmZpbmFsaXplKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICAvKiogQGludGVybmFsICovXG4gICAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFBhcnRpYWwgPSBmdW5jdGlvbiAobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFtYXAgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5lc3RlZFNlbGVjdG9yID0gbWFwW25hbWVdO1xuICAgICAgICAgIGlmICghbmVzdGVkU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPKHBlcmYpOiBnZXQgcmlkIG9mIHJlY3Vyc2lvbiBhbmQgbWVhc3VyZSBhZ2FpblxuICAgICAgICAgIC8vIFRPRE8ocGVyZik6IGRvbid0IHBhc3MgdGhlIHdob2xlIHNlbGVjdG9yIGludG8gdGhlIHJlY3Vyc2lvbixcbiAgICAgICAgICAvLyBidXQgb25seSB0aGUgbm90IHByb2Nlc3NlZCBwYXJ0c1xuICAgICAgICAgIHJldHVybiBuZXN0ZWRTZWxlY3Rvci5tYXRjaChjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2VsZWN0b3JNYXRjaGVyO1xuICB9KCkpO1xuICB2YXIgU2VsZWN0b3JMaXN0Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTZWxlY3Rvckxpc3RDb250ZXh0KHNlbGVjdG9ycykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgICAgICAgIHRoaXMuYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTZWxlY3Rvckxpc3RDb250ZXh0O1xuICB9KCkpO1xuICAvLyBTdG9yZSBjb250ZXh0IHRvIHBhc3MgYmFjayBzZWxlY3RvciBhbmQgY29udGV4dCB3aGVuIGEgc2VsZWN0b3IgaXMgbWF0Y2hlZFxuICB2YXIgU2VsZWN0b3JDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNlbGVjdG9yQ29udGV4dChzZWxlY3RvciwgY2JDb250ZXh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICB0aGlzLmNiQ29udGV4dCA9IGNiQ29udGV4dDtcbiAgICAgICAgICB0aGlzLmxpc3RDb250ZXh0ID0gbGlzdENvbnRleHQ7XG4gICAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBzZWxlY3Rvci5ub3RTZWxlY3RvcnM7XG4gICAgICB9XG4gICAgICBTZWxlY3RvckNvbnRleHQucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgICAgdmFyIG5vdE1hdGNoZXIgPSBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlcih0aGlzLm5vdFNlbGVjdG9ycyk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9ICFub3RNYXRjaGVyLm1hdGNoKGNzc1NlbGVjdG9yLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCAmJiBjYWxsYmFjayAmJiAoIXRoaXMubGlzdENvbnRleHQgfHwgIXRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmxpc3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLnNlbGVjdG9yLCB0aGlzLmNiQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFNlbGVjdG9yQ29udGV4dDtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLy8vLyBUeXBlc1xuICB2YXIgVHlwZU1vZGlmaWVyO1xuICAoZnVuY3Rpb24gKFR5cGVNb2RpZmllcikge1xuICAgICAgVHlwZU1vZGlmaWVyW1R5cGVNb2RpZmllcltcIkNvbnN0XCJdID0gMF0gPSBcIkNvbnN0XCI7XG4gIH0pKFR5cGVNb2RpZmllciB8fCAoVHlwZU1vZGlmaWVyID0ge30pKTtcbiAgdmFyIFR5cGUkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUeXBlKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBUeXBlLnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gdGhpcy5tb2RpZmllcnMuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgICAgcmV0dXJuIFR5cGU7XG4gIH0oKSk7XG4gIHZhciBCdWlsdGluVHlwZU5hbWU7XG4gIChmdW5jdGlvbiAoQnVpbHRpblR5cGVOYW1lKSB7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiRHluYW1pY1wiXSA9IDBdID0gXCJEeW5hbWljXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiQm9vbFwiXSA9IDFdID0gXCJCb29sXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiU3RyaW5nXCJdID0gMl0gPSBcIlN0cmluZ1wiO1xuICAgICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkludFwiXSA9IDNdID0gXCJJbnRcIjtcbiAgICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJOdW1iZXJcIl0gPSA0XSA9IFwiTnVtYmVyXCI7XG4gICAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiRnVuY3Rpb25cIl0gPSA1XSA9IFwiRnVuY3Rpb25cIjtcbiAgfSkoQnVpbHRpblR5cGVOYW1lIHx8IChCdWlsdGluVHlwZU5hbWUgPSB7fSkpO1xuICB2YXIgQnVpbHRpblR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQnVpbHRpblR5cGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBCdWlsdGluVHlwZShuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIH1cbiAgICAgIEJ1aWx0aW5UeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QnVpbHRpbnRUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCdWlsdGluVHlwZTtcbiAgfShUeXBlJDEpKTtcbiAgdmFyIEV4dGVybmFsVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihFeHRlcm5hbFR5cGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBFeHRlcm5hbFR5cGUodmFsdWUsIHR5cGVQYXJhbXMsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMudHlwZVBhcmFtcyA9IHR5cGVQYXJhbXM7XG4gICAgICB9XG4gICAgICBFeHRlcm5hbFR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHRlcm5hbFR5cGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEV4dGVybmFsVHlwZTtcbiAgfShUeXBlJDEpKTtcbiAgdmFyIEFycmF5VHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihBcnJheVR5cGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBcnJheVR5cGUob2YsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm9mID0gb2Y7XG4gICAgICB9XG4gICAgICBBcnJheVR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheVR5cGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFycmF5VHlwZTtcbiAgfShUeXBlJDEpKTtcbiAgdmFyIE1hcFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoTWFwVHlwZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIE1hcFR5cGUodmFsdWVUeXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy52YWx1ZVR5cGUgPSB2YWx1ZVR5cGU7XG4gICAgICB9XG4gICAgICBNYXBUeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdE1hcFR5cGUodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gTWFwVHlwZTtcbiAgfShUeXBlJDEpKTtcbiAgdmFyIERZTkFNSUNfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuRHluYW1pYyk7XG4gIHZhciBCT09MX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkJvb2wpO1xuICB2YXIgSU5UX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkludCk7XG4gIHZhciBOVU1CRVJfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuTnVtYmVyKTtcbiAgdmFyIFNUUklOR19UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5TdHJpbmcpO1xuICB2YXIgRlVOQ1RJT05fVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb24pO1xuICAvLy8vLyBFeHByZXNzaW9uc1xuICB2YXIgQmluYXJ5T3BlcmF0b3I7XG4gIChmdW5jdGlvbiAoQmluYXJ5T3BlcmF0b3IpIHtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiRXF1YWxzXCJdID0gMF0gPSBcIkVxdWFsc1wiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOb3RFcXVhbHNcIl0gPSAxXSA9IFwiTm90RXF1YWxzXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIklkZW50aWNhbFwiXSA9IDJdID0gXCJJZGVudGljYWxcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTm90SWRlbnRpY2FsXCJdID0gM10gPSBcIk5vdElkZW50aWNhbFwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNaW51c1wiXSA9IDRdID0gXCJNaW51c1wiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJQbHVzXCJdID0gNV0gPSBcIlBsdXNcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiRGl2aWRlXCJdID0gNl0gPSBcIkRpdmlkZVwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNdWx0aXBseVwiXSA9IDddID0gXCJNdWx0aXBseVwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNb2R1bG9cIl0gPSA4XSA9IFwiTW9kdWxvXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkFuZFwiXSA9IDldID0gXCJBbmRcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiT3JcIl0gPSAxMF0gPSBcIk9yXCI7XG4gICAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkxvd2VyXCJdID0gMTFdID0gXCJMb3dlclwiO1xuICAgICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJMb3dlckVxdWFsc1wiXSA9IDEyXSA9IFwiTG93ZXJFcXVhbHNcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQmlnZ2VyXCJdID0gMTNdID0gXCJCaWdnZXJcIjtcbiAgICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQmlnZ2VyRXF1YWxzXCJdID0gMTRdID0gXCJCaWdnZXJFcXVhbHNcIjtcbiAgfSkoQmluYXJ5T3BlcmF0b3IgfHwgKEJpbmFyeU9wZXJhdG9yID0ge30pKTtcbiAgdmFyIEV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvbih0eXBlKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnByb3AgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmV3IFJlYWRQcm9wRXhwcih0aGlzLCBuYW1lKTsgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmtleSA9IGZ1bmN0aW9uIChpbmRleCwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gbmV3IFJlYWRLZXlFeHByKHRoaXMsIGluZGV4LCB0eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYWxsTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtcykge1xuICAgICAgICAgIHJldHVybiBuZXcgSW52b2tlTWV0aG9kRXhwcih0aGlzLCBuYW1lLCBwYXJhbXMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhbGxGbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuIG5ldyBJbnZva2VGdW5jdGlvbkV4cHIodGhpcywgcGFyYW1zKTsgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmluc3RhbnRpYXRlID0gZnVuY3Rpb24gKHBhcmFtcywgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gbmV3IEluc3RhbnRpYXRlRXhwcih0aGlzLCBwYXJhbXMsIHR5cGUpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNvbmRpdGlvbmFsID0gZnVuY3Rpb24gKHRydWVDYXNlLCBmYWxzZUNhc2UpIHtcbiAgICAgICAgICBpZiAoZmFsc2VDYXNlID09PSB2b2lkIDApIHsgZmFsc2VDYXNlID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByKHRoaXMsIHRydWVDYXNlLCBmYWxzZUNhc2UpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5FcXVhbHMsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFscywgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pZGVudGljYWwgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm5vdElkZW50aWNhbCA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWwsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubWludXMgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTWludXMsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucGx1cyA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5QbHVzLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5EaXZpZGUsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHksIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1vZHVsbywgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAocmhzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQW5kLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk9yLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmxvd2VyID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkxvd2VyLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmxvd2VyRXF1YWxzID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzLCB0aGlzLCByaHMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmJpZ2dlciA9IGZ1bmN0aW9uIChyaHMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5CaWdnZXIsIHRoaXMsIHJocyk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYmlnZ2VyRXF1YWxzID0gZnVuY3Rpb24gKHJocykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscywgdGhpcywgcmhzKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pc0JsYW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIE5vdGU6IFdlIHVzZSBlcXVhbHMgYnkgcHVycG9zZSBoZXJlIHRvIGNvbXBhcmUgdG8gbnVsbCBhbmQgdW5kZWZpbmVkIGluIEpTLlxuICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhOVUxMX0VYUFIpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gbmV3IENhc3RFeHByKHRoaXMsIHR5cGUpOyB9O1xuICAgICAgRXhwcmVzc2lvbi5wcm90b3R5cGUudG9TdG10ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodGhpcyk7IH07XG4gICAgICByZXR1cm4gRXhwcmVzc2lvbjtcbiAgfSgpKTtcbiAgdmFyIEJ1aWx0aW5WYXI7XG4gIChmdW5jdGlvbiAoQnVpbHRpblZhcikge1xuICAgICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiVGhpc1wiXSA9IDBdID0gXCJUaGlzXCI7XG4gICAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJTdXBlclwiXSA9IDFdID0gXCJTdXBlclwiO1xuICAgICAgQnVpbHRpblZhcltCdWlsdGluVmFyW1wiQ2F0Y2hFcnJvclwiXSA9IDJdID0gXCJDYXRjaEVycm9yXCI7XG4gICAgICBCdWlsdGluVmFyW0J1aWx0aW5WYXJbXCJDYXRjaFN0YWNrXCJdID0gM10gPSBcIkNhdGNoU3RhY2tcIjtcbiAgfSkoQnVpbHRpblZhciB8fCAoQnVpbHRpblZhciA9IHt9KSk7XG4gIHZhciBSZWFkVmFyRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihSZWFkVmFyRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFJlYWRWYXJFeHByKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdHlwZSk7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgIHRoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLmJ1aWx0aW4gPSBuYW1lO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZFZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVhZFZhckV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcih0aGlzLm5hbWUsIHZhbHVlKTsgfTtcbiAgICAgIHJldHVybiBSZWFkVmFyRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBXcml0ZVZhckV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoV3JpdGVWYXJFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gV3JpdGVWYXJFeHByKG5hbWUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGlzUHJlc2VudCh0eXBlKSA/IHR5cGUgOiB2YWx1ZS50eXBlKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFdyaXRlVmFyRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlVmFyRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBXcml0ZVZhckV4cHIucHJvdG90eXBlLnRvRGVjbFN0bXQgPSBmdW5jdGlvbiAodHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJlVmFyU3RtdCh0aGlzLm5hbWUsIHRoaXMudmFsdWUsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFdyaXRlVmFyRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBXcml0ZUtleUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoV3JpdGVLZXlFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gV3JpdGVLZXlFeHByKHJlY2VpdmVyLCBpbmRleCwgdmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaXNQcmVzZW50KHR5cGUpID8gdHlwZSA6IHZhbHVlLnR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgV3JpdGVLZXlFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVLZXlFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBXcml0ZUtleUV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgV3JpdGVQcm9wRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihXcml0ZVByb3BFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gV3JpdGVQcm9wRXhwcihyZWNlaXZlciwgbmFtZSwgdmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaXNQcmVzZW50KHR5cGUpID8gdHlwZSA6IHZhbHVlLnR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFdyaXRlUHJvcEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBXcml0ZVByb3BFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIEJ1aWx0aW5NZXRob2Q7XG4gIChmdW5jdGlvbiAoQnVpbHRpbk1ldGhvZCkge1xuICAgICAgQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kW1wiQ29uY2F0QXJyYXlcIl0gPSAwXSA9IFwiQ29uY2F0QXJyYXlcIjtcbiAgICAgIEJ1aWx0aW5NZXRob2RbQnVpbHRpbk1ldGhvZFtcIlN1YnNjcmliZU9ic2VydmFibGVcIl0gPSAxXSA9IFwiU3Vic2NyaWJlT2JzZXJ2YWJsZVwiO1xuICAgICAgQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kW1wiQmluZFwiXSA9IDJdID0gXCJCaW5kXCI7XG4gIH0pKEJ1aWx0aW5NZXRob2QgfHwgKEJ1aWx0aW5NZXRob2QgPSB7fSkpO1xuICB2YXIgSW52b2tlTWV0aG9kRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihJbnZva2VNZXRob2RFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW52b2tlTWV0aG9kRXhwcihyZWNlaXZlciwgbWV0aG9kLCBhcmdzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICAgIGlmIChpc1N0cmluZyhtZXRob2QpKSB7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgdGhpcy5idWlsdGluID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuYnVpbHRpbiA9IG1ldGhvZDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBJbnZva2VNZXRob2RFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW52b2tlTWV0aG9kRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSW52b2tlTWV0aG9kRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBJbnZva2VGdW5jdGlvbkV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoSW52b2tlRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gSW52b2tlRnVuY3Rpb25FeHByKGZuLCBhcmdzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgSW52b2tlRnVuY3Rpb25FeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBJbnZva2VGdW5jdGlvbkV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgSW5zdGFudGlhdGVFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKEluc3RhbnRpYXRlRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEluc3RhbnRpYXRlRXhwcihjbGFzc0V4cHIsIGFyZ3MsIHR5cGUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLmNsYXNzRXhwciA9IGNsYXNzRXhwcjtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgSW5zdGFudGlhdGVFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW5zdGFudGlhdGVFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBJbnN0YW50aWF0ZUV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgTGl0ZXJhbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoTGl0ZXJhbEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsRXhwcih2YWx1ZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBMaXRlcmFsRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBMaXRlcmFsRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBFeHRlcm5hbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoRXh0ZXJuYWxFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRXh0ZXJuYWxFeHByKHZhbHVlLCB0eXBlLCB0eXBlUGFyYW1zKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICAgIH1cbiAgICAgIEV4dGVybmFsRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4dGVybmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRXh0ZXJuYWxFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIENvbmRpdGlvbmFsRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihDb25kaXRpb25hbEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb25kaXRpb25hbEV4cHIoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaXNQcmVzZW50KHR5cGUpID8gdHlwZSA6IHRydWVDYXNlLnR5cGUpO1xuICAgICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICAgIHRoaXMuZmFsc2VDYXNlID0gZmFsc2VDYXNlO1xuICAgICAgICAgIHRoaXMudHJ1ZUNhc2UgPSB0cnVlQ2FzZTtcbiAgICAgIH1cbiAgICAgIENvbmRpdGlvbmFsRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29uZGl0aW9uYWxFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIE5vdEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoTm90RXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIE5vdEV4cHIoY29uZGl0aW9uKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgQk9PTF9UWVBFKTtcbiAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgIH1cbiAgICAgIE5vdEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXROb3RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBOb3RFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIENhc3RFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKENhc3RFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2FzdEV4cHIodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBDYXN0RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhc3RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBDYXN0RXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBGblBhcmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEZuUGFyYW0obmFtZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gRm5QYXJhbTtcbiAgfSgpKTtcbiAgdmFyIEZ1bmN0aW9uRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihGdW5jdGlvbkV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBGdW5jdGlvbkV4cHIocGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICB9XG4gICAgICBGdW5jdGlvbkV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKG5hbWUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJlRnVuY3Rpb25TdG10KG5hbWUsIHRoaXMucGFyYW1zLCB0aGlzLnN0YXRlbWVudHMsIHRoaXMudHlwZSwgbW9kaWZpZXJzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRnVuY3Rpb25FeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIEJpbmFyeU9wZXJhdG9yRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihCaW5hcnlPcGVyYXRvckV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBCaW5hcnlPcGVyYXRvckV4cHIob3BlcmF0b3IsIGxocywgcmhzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGlzUHJlc2VudCh0eXBlKSA/IHR5cGUgOiBsaHMudHlwZSk7XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICAgIHRoaXMubGhzID0gbGhzO1xuICAgICAgfVxuICAgICAgQmluYXJ5T3BlcmF0b3JFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBCaW5hcnlPcGVyYXRvckV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgUmVhZFByb3BFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFJlYWRQcm9wRXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFJlYWRQcm9wRXhwcihyZWNlaXZlciwgbmFtZSwgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIH1cbiAgICAgIFJlYWRQcm9wRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRQcm9wRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBSZWFkUHJvcEV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVQcm9wRXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLm5hbWUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUmVhZFByb3BFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIFJlYWRLZXlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFJlYWRLZXlFeHByLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUmVhZEtleUV4cHIocmVjZWl2ZXIsIGluZGV4LCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRLZXlFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFJlYWRLZXlFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlS2V5RXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLmluZGV4LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFJlYWRLZXlFeHByO1xuICB9KEV4cHJlc3Npb24pKTtcbiAgdmFyIExpdGVyYWxBcnJheUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoTGl0ZXJhbEFycmF5RXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIExpdGVyYWxBcnJheUV4cHIoZW50cmllcywgdHlwZSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgfVxuICAgICAgTGl0ZXJhbEFycmF5RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxBcnJheUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpdGVyYWxBcnJheUV4cHI7XG4gIH0oRXhwcmVzc2lvbikpO1xuICB2YXIgTGl0ZXJhbE1hcEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoTGl0ZXJhbE1hcEV4cHIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsTWFwRXhwcihlbnRyaWVzLCB0eXBlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgICAgdGhpcy52YWx1ZVR5cGUgPSBudWxsO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQodHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZVR5cGUgPSB0eXBlLnZhbHVlVHlwZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBMaXRlcmFsTWFwRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxNYXBFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBMaXRlcmFsTWFwRXhwcjtcbiAgfShFeHByZXNzaW9uKSk7XG4gIHZhciBUSElTX0VYUFIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5UaGlzKTtcbiAgdmFyIFNVUEVSX0VYUFIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5TdXBlcik7XG4gIHZhciBDQVRDSF9FUlJPUl9WQVIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5DYXRjaEVycm9yKTtcbiAgdmFyIENBVENIX1NUQUNLX1ZBUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLkNhdGNoU3RhY2spO1xuICB2YXIgTlVMTF9FWFBSID0gbmV3IExpdGVyYWxFeHByKG51bGwsIG51bGwpO1xuICAvLy8vIFN0YXRlbWVudHNcbiAgdmFyIFN0bXRNb2RpZmllcjtcbiAgKGZ1bmN0aW9uIChTdG10TW9kaWZpZXIpIHtcbiAgICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJGaW5hbFwiXSA9IDBdID0gXCJGaW5hbFwiO1xuICAgICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIlByaXZhdGVcIl0gPSAxXSA9IFwiUHJpdmF0ZVwiO1xuICB9KShTdG10TW9kaWZpZXIgfHwgKFN0bXRNb2RpZmllciA9IHt9KSk7XG4gIHZhciBTdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3RhdGVtZW50KG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBTdGF0ZW1lbnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgICByZXR1cm4gU3RhdGVtZW50O1xuICB9KCkpO1xuICB2YXIgRGVjbGFyZVZhclN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoRGVjbGFyZVZhclN0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBEZWNsYXJlVmFyU3RtdChuYW1lLCB2YWx1ZSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBpc1ByZXNlbnQodHlwZSkgPyB0eXBlIDogdmFsdWUudHlwZTtcbiAgICAgIH1cbiAgICAgIERlY2xhcmVWYXJTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlVmFyU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRGVjbGFyZVZhclN0bXQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBEZWNsYXJlRnVuY3Rpb25TdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKERlY2xhcmVGdW5jdGlvblN0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBEZWNsYXJlRnVuY3Rpb25TdG10KG5hbWUsIHBhcmFtcywgc3RhdGVtZW50cywgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIH1cbiAgICAgIERlY2xhcmVGdW5jdGlvblN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIERlY2xhcmVGdW5jdGlvblN0bXQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBFeHByZXNzaW9uU3RhdGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKEV4cHJlc3Npb25TdGF0ZW1lbnQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgICAgfVxuICAgICAgRXhwcmVzc2lvblN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwcmVzc2lvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBSZXR1cm5TdGF0ZW1lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoUmV0dXJuU3RhdGVtZW50LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUmV0dXJuU3RhdGVtZW50KHZhbHVlKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgUmV0dXJuU3RhdGVtZW50LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZXR1cm5TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBSZXR1cm5TdGF0ZW1lbnQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBBYnN0cmFjdENsYXNzUGFydCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBYnN0cmFjdENsYXNzUGFydCh0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgICBpZiAoIW1vZGlmaWVycykge1xuICAgICAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEFic3RyYWN0Q2xhc3NQYXJ0LnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gdGhpcy5tb2RpZmllcnMuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgICAgcmV0dXJuIEFic3RyYWN0Q2xhc3NQYXJ0O1xuICB9KCkpO1xuICB2YXIgQ2xhc3NGaWVsZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihDbGFzc0ZpZWxkLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2xhc3NGaWVsZChuYW1lLCB0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ2xhc3NGaWVsZDtcbiAgfShBYnN0cmFjdENsYXNzUGFydCkpO1xuICB2YXIgQ2xhc3NNZXRob2QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQ2xhc3NNZXRob2QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDbGFzc01ldGhvZChuYW1lLCBwYXJhbXMsIGJvZHksIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIENsYXNzTWV0aG9kO1xuICB9KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG4gIHZhciBDbGFzc0dldHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihDbGFzc0dldHRlciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENsYXNzR2V0dGVyKG5hbWUsIGJvZHksIHR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIENsYXNzR2V0dGVyO1xuICB9KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG4gIHZhciBDbGFzc1N0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQ2xhc3NTdG10LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ2xhc3NTdG10KG5hbWUsIHBhcmVudCwgZmllbGRzLCBnZXR0ZXJzLCBjb25zdHJ1Y3Rvck1ldGhvZCwgbWV0aG9kcywgbW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgICAgdGhpcy5nZXR0ZXJzID0gZ2V0dGVycztcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yTWV0aG9kID0gY29uc3RydWN0b3JNZXRob2Q7XG4gICAgICAgICAgdGhpcy5tZXRob2RzID0gbWV0aG9kcztcbiAgICAgIH1cbiAgICAgIENsYXNzU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ2xhc3NTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgSWZTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKElmU3RtdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIElmU3RtdChjb25kaXRpb24sIHRydWVDYXNlLCBmYWxzZUNhc2UpIHtcbiAgICAgICAgICBpZiAoZmFsc2VDYXNlID09PSB2b2lkIDApIHsgZmFsc2VDYXNlID0gW107IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgICB0aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgICAgdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICB9XG4gICAgICBJZlN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdElmU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSWZTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgQ29tbWVudFN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoQ29tbWVudFN0bXQsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21tZW50U3RtdChjb21tZW50KSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbiAgICAgIH1cbiAgICAgIENvbW1lbnRTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb21tZW50U3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tbWVudFN0bXQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBUcnlDYXRjaFN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDIoVHJ5Q2F0Y2hTdG10LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gVHJ5Q2F0Y2hTdG10KGJvZHlTdG10cywgY2F0Y2hTdG10cykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keVN0bXRzID0gYm9keVN0bXRzO1xuICAgICAgICAgIHRoaXMuY2F0Y2hTdG10cyA9IGNhdGNoU3RtdHM7XG4gICAgICB9XG4gICAgICBUcnlDYXRjaFN0bXQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRyeUNhdGNoU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVHJ5Q2F0Y2hTdG10O1xuICB9KFN0YXRlbWVudCkpO1xuICB2YXIgVGhyb3dTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQyKFRocm93U3RtdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFRocm93U3RtdChlcnJvcikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICAgIFRocm93U3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGhyb3dTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUaHJvd1N0bXQ7XG4gIH0oU3RhdGVtZW50KSk7XG4gIHZhciBFeHByZXNzaW9uVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvblRyYW5zZm9ybWVyKCkge1xuICAgICAgfVxuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVZhckV4cHIoZXhwci5uYW1lLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZUtleUV4cHIoZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVQcm9wRXhwcihleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci5uYW1lLCBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIG1ldGhvZCA9IGlzUHJlc2VudChhc3QuYnVpbHRpbikgPyBhc3QuYnVpbHRpbiA6IGFzdC5uYW1lO1xuICAgICAgICAgIHJldHVybiBuZXcgSW52b2tlTWV0aG9kRXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBtZXRob2QsIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCksIGFzdC50eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSW52b2tlRnVuY3Rpb25FeHByKGFzdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCksIGFzdC50eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgSW5zdGFudGlhdGVFeHByKGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbEV4cHIoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE5vdEV4cHIoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENhc3RFeHByKGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoYXN0Lm9wZXJhdG9yLCBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVhZFByb3BFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5uYW1lLCBhc3QudHlwZSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVhZEtleUV4cHIoYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnR5cGUpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXBFeHByKGFzdC5lbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIFtlbnRyeVswXSwgZW50cnlbMV0udmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KV07IH0pKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBleHBycy5tYXAoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHN0bXQudHlwZSwgc3RtdC5tb2RpZmllcnMpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJldHVyblN0YXRlbWVudChzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgRXhwcmVzc2lvblRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBJZlN0bXQoc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRyeUNhdGNoU3RtdCh0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY29udGV4dCkpO1xuICAgICAgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgVGhyb3dTdG10KHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIH07XG4gICAgICBFeHByZXNzaW9uVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICAgIEV4cHJlc3Npb25UcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gc3RtdHMubWFwKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEV4cHJlc3Npb25UcmFuc2Zvcm1lcjtcbiAgfSgpKTtcbiAgdmFyIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW52b2tlTWV0aG9kRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5WzFdLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGV4cHJzLmZvckVhY2goZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIC8vIERvbid0IGRlc2NlbmQgaW50byBuZXN0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gRG9uJ3QgZGVzY2VuZCBpbnRvIG5lc3RlZCBmdW5jdGlvbnNcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlRXhwcmVzc2lvblZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gc3RtdDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAgIHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBzdG10O1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIHN0bXQ7IH07XG4gICAgICBSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBzdG10cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFJlY3Vyc2l2ZUV4cHJlc3Npb25WaXNpdG9yO1xuICB9KCkpO1xuICBmdW5jdGlvbiByZXBsYWNlVmFySW5FeHByZXNzaW9uKHZhck5hbWUsIG5ld1ZhbHVlLCBleHByZXNzaW9uKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZXIgPSBuZXcgX1JlcGxhY2VWYXJpYWJsZVRyYW5zZm9ybWVyKHZhck5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uLnZpc2l0RXhwcmVzc2lvbih0cmFuc2Zvcm1lciwgbnVsbCk7XG4gIH1cbiAgdmFyIF9SZXBsYWNlVmFyaWFibGVUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXIoX3Zhck5hbWUsIF9uZXdWYWx1ZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuX3Zhck5hbWUgPSBfdmFyTmFtZTtcbiAgICAgICAgICB0aGlzLl9uZXdWYWx1ZSA9IF9uZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIF9SZXBsYWNlVmFyaWFibGVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gYXN0Lm5hbWUgPT0gdGhpcy5fdmFyTmFtZSA/IHRoaXMuX25ld1ZhbHVlIDogYXN0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfUmVwbGFjZVZhcmlhYmxlVHJhbnNmb3JtZXI7XG4gIH0oRXhwcmVzc2lvblRyYW5zZm9ybWVyKSk7XG4gIGZ1bmN0aW9uIGZpbmRSZWFkVmFyTmFtZXMoc3RtdHMpIHtcbiAgICAgIHZhciBmaW5kZXIgPSBuZXcgX1ZhcmlhYmxlRmluZGVyKCk7XG4gICAgICBmaW5kZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBudWxsKTtcbiAgICAgIHJldHVybiBmaW5kZXIudmFyTmFtZXM7XG4gIH1cbiAgdmFyIF9WYXJpYWJsZUZpbmRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMihfVmFyaWFibGVGaW5kZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBfVmFyaWFibGVGaW5kZXIoKSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdGhpcy52YXJOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIF9WYXJpYWJsZUZpbmRlci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLnZhck5hbWVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9WYXJpYWJsZUZpbmRlcjtcbiAgfShSZWN1cnNpdmVFeHByZXNzaW9uVmlzaXRvcikpO1xuICBmdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICByZXR1cm4gbmV3IFJlYWRWYXJFeHByKG5hbWUsIHR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMpIHtcbiAgICAgIGlmICh0eXBlUGFyYW1zID09PSB2b2lkIDApIHsgdHlwZVBhcmFtcyA9IG51bGw7IH1cbiAgICAgIHJldHVybiBuZXcgRXh0ZXJuYWxFeHByKGlkLCBudWxsLCB0eXBlUGFyYW1zKTtcbiAgfVxuICBmdW5jdGlvbiBpbXBvcnRUeXBlKGlkLCB0eXBlUGFyYW1zLCB0eXBlTW9kaWZpZXJzKSB7XG4gICAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgICBpZiAodHlwZU1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IHR5cGVNb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICByZXR1cm4gaXNQcmVzZW50KGlkKSA/IG5ldyBFeHRlcm5hbFR5cGUoaWQsIHR5cGVQYXJhbXMsIHR5cGVNb2RpZmllcnMpIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBsaXRlcmFsQXJyKHZhbHVlcywgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXlFeHByKHZhbHVlcywgdHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gbGl0ZXJhbE1hcCh2YWx1ZXMsIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIodmFsdWVzLCB0eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBub3QoZXhwcikge1xuICAgICAgcmV0dXJuIG5ldyBOb3RFeHByKGV4cHIpO1xuICB9XG4gIGZ1bmN0aW9uIGZuKHBhcmFtcywgYm9keSwgdHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbkV4cHIocGFyYW1zLCBib2R5LCB0eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBsaXRlcmFsKHZhbHVlLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByKHZhbHVlLCB0eXBlKTtcbiAgfVxuXG4gIHZhciBNT0RVTEVfU1VGRklYID0gJyc7XG4gIHZhciBDQU1FTF9DQVNFX1JFR0VYUCA9IC8oW0EtWl0pL2c7XG4gIGZ1bmN0aW9uIGNhbWVsQ2FzZVRvRGFzaENhc2UoaW5wdXQpIHtcbiAgICAgIHJldHVybiBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoaW5wdXQsIENBTUVMX0NBU0VfUkVHRVhQLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gJy0nICsgbVsxXS50b0xvd2VyQ2FzZSgpOyB9KTtcbiAgfVxuICBmdW5jdGlvbiBzcGxpdEF0Q29sb24oaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICAgIHJldHVybiBfc3BsaXRBdChpbnB1dCwgJzonLCBkZWZhdWx0VmFsdWVzKTtcbiAgfVxuICBmdW5jdGlvbiBzcGxpdEF0UGVyaW9kKGlucHV0LCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgICByZXR1cm4gX3NwbGl0QXQoaW5wdXQsICcuJywgZGVmYXVsdFZhbHVlcyk7XG4gIH1cbiAgZnVuY3Rpb24gX3NwbGl0QXQoaW5wdXQsIGNoYXJhY3RlciwgZGVmYXVsdFZhbHVlcykge1xuICAgICAgdmFyIGNoYXJhY3RlckluZGV4ID0gaW5wdXQuaW5kZXhPZihjaGFyYWN0ZXIpO1xuICAgICAgaWYgKGNoYXJhY3RlckluZGV4ID09IC0xKVxuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVzO1xuICAgICAgcmV0dXJuIFtpbnB1dC5zbGljZSgwLCBjaGFyYWN0ZXJJbmRleCkudHJpbSgpLCBpbnB1dC5zbGljZShjaGFyYWN0ZXJJbmRleCArIDEpLnRyaW0oKV07XG4gIH1cbiAgZnVuY3Rpb24gc2FuaXRpemVJZGVudGlmaWVyKG5hbWUpIHtcbiAgICAgIHJldHVybiBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwobmFtZSwgL1xcVy9nLCAnXycpO1xuICB9XG4gIGZ1bmN0aW9uIHZpc2l0VmFsdWUodmFsdWUsIHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXkodmFsdWUsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNTdHJpY3RTdHJpbmdNYXAodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJpbmdNYXAodmFsdWUsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCbGFuayh2YWx1ZSkgfHwgaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmltaXRpdmUodmFsdWUsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRPdGhlcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICB9XG4gIH1cbiAgdmFyIFZhbHVlVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmFsdWVUcmFuc2Zvcm1lcigpIHtcbiAgICAgIH1cbiAgICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gYXJyLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICB9O1xuICAgICAgVmFsdWVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmVzdWx0W2tleV0gPSB2aXNpdFZhbHVlKG1hcFtrZXldLCBfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgVmFsdWVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmltaXRpdmUgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgICAgVmFsdWVUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkgeyByZXR1cm4gdmFsdWU7IH07XG4gICAgICByZXR1cm4gVmFsdWVUcmFuc2Zvcm1lcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gYXNzZXRVcmwocGtnLCBwYXRoLCB0eXBlKSB7XG4gICAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSAnc3JjJzsgfVxuICAgICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBcImFzc2V0OkBhbmd1bGFyL2xpYi9cIiArIHBrZyArIFwiL2luZGV4XCI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJhc3NldDpAYW5ndWxhci9saWIvXCIgKyBwa2cgKyBcIi9zcmMvXCIgKyBwYXRoO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHRva2VuKSB7XG4gICAgICBpZiAoaXNQcmVzZW50KHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsKHRva2VuLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRva2VuLmlkZW50aWZpZXJJc0luc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIodG9rZW4uaWRlbnRpZmllcilcbiAgICAgICAgICAgICAgLmluc3RhbnRpYXRlKFtdLCBpbXBvcnRUeXBlKHRva2VuLmlkZW50aWZpZXIsIFtdLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIodG9rZW4uaWRlbnRpZmllcik7XG4gICAgICB9XG4gIH1cbiAgdmFyIFN5bmNBc3luY1Jlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTeW5jQXN5bmNSZXN1bHQoc3luY1Jlc3VsdCwgYXN5bmNSZXN1bHQpIHtcbiAgICAgICAgICBpZiAoYXN5bmNSZXN1bHQgPT09IHZvaWQgMCkgeyBhc3luY1Jlc3VsdCA9IG51bGw7IH1cbiAgICAgICAgICB0aGlzLnN5bmNSZXN1bHQgPSBzeW5jUmVzdWx0O1xuICAgICAgICAgIHRoaXMuYXN5bmNSZXN1bHQgPSBhc3luY1Jlc3VsdDtcbiAgICAgICAgICBpZiAoIWFzeW5jUmVzdWx0KSB7XG4gICAgICAgICAgICAgIHRoaXMuYXN5bmNSZXN1bHQgPSBQcm9taXNlLnJlc29sdmUoc3luY1Jlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFN5bmNBc3luY1Jlc3VsdDtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgZnVuY3Rpb24gdW5pbXBsZW1lbnRlZCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCcpO1xuICB9XG4gIC8vIGdyb3VwIDA6IFwiW3Byb3BdIG9yIChldmVudCkgb3IgQHRyaWdnZXJcIlxuICAvLyBncm91cCAxOiBcInByb3BcIiBmcm9tIFwiW3Byb3BdXCJcbiAgLy8gZ3JvdXAgMjogXCJldmVudFwiIGZyb20gXCIoZXZlbnQpXCJcbiAgLy8gZ3JvdXAgMzogXCJAdHJpZ2dlclwiIGZyb20gXCJAdHJpZ2dlclwiXG4gIHZhciBIT1NUX1JFR19FWFAgPSAvXig/Oig/OlxcWyhbXlxcXV0rKVxcXSl8KD86XFwoKFteXFwpXSspXFwpKSl8KFxcQFstXFx3XSspJC87XG4gIHZhciBDb21waWxlTWV0YWRhdGFXaXRoSWRlbnRpZmllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlTWV0YWRhdGFXaXRoSWRlbnRpZmllcigpIHtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlTWV0YWRhdGFXaXRoSWRlbnRpZmllci5wcm90b3R5cGUsIFwiaWRlbnRpZmllclwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvbkVudHJ5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbkVudHJ5TWV0YWRhdGEobmFtZSwgZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKGRlZmluaXRpb25zID09PSB2b2lkIDApIHsgZGVmaW5pdGlvbnMgPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvbkVudHJ5TWV0YWRhdGE7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSgpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3RhdGVNZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEoc3RhdGVOYW1lRXhwciwgc3R5bGVzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGF0ZU5hbWVFeHByID0gc3RhdGVOYW1lRXhwcjtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlRXhwciA9IHN0YXRlQ2hhbmdlRXhwcjtcbiAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKCkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25NZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEoc3RlcHMpIHtcbiAgICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IFtdOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YShvZmZzZXQsIHN0eWxlcykge1xuICAgICAgICAgIGlmIChzdHlsZXMgPT09IHZvaWQgMCkgeyBzdHlsZXMgPSBudWxsOyB9XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKHRpbWluZ3MsIHN0eWxlcykge1xuICAgICAgICAgIGlmICh0aW1pbmdzID09PSB2b2lkIDApIHsgdGltaW5ncyA9IDA7IH1cbiAgICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMudGltaW5ncyA9IHRpbWluZ3M7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEoc3RlcHMpIHtcbiAgICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhO1xuICB9KENvbXBpbGVBbmltYXRpb25NZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEoQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcykge1xuICAgICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHN0ZXBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbiAgfShDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpKTtcbiAgdmFyIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEoc3RlcHMpIHtcbiAgICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IG51bGw7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzdGVwcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgcmVmZXJlbmNlID0gX2IucmVmZXJlbmNlLCBuYW1lID0gX2IubmFtZSwgbW9kdWxlVXJsID0gX2IubW9kdWxlVXJsLCBwcmVmaXggPSBfYi5wcmVmaXgsIHZhbHVlID0gX2IudmFsdWU7XG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2U7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YS5wcm90b3R5cGUsIFwiaWRlbnRpZmllclwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBpc0F0dHJpYnV0ZSA9IF9iLmlzQXR0cmlidXRlLCBpc1NlbGYgPSBfYi5pc1NlbGYsIGlzSG9zdCA9IF9iLmlzSG9zdCwgaXNTa2lwU2VsZiA9IF9iLmlzU2tpcFNlbGYsIGlzT3B0aW9uYWwgPSBfYi5pc09wdGlvbmFsLCBpc1ZhbHVlID0gX2IuaXNWYWx1ZSwgcXVlcnkgPSBfYi5xdWVyeSwgdmlld1F1ZXJ5ID0gX2Iudmlld1F1ZXJ5LCB0b2tlbiA9IF9iLnRva2VuLCB2YWx1ZSA9IF9iLnZhbHVlO1xuICAgICAgICAgIHRoaXMuaXNBdHRyaWJ1dGUgPSBub3JtYWxpemVCb29sKGlzQXR0cmlidXRlKTtcbiAgICAgICAgICB0aGlzLmlzU2VsZiA9IG5vcm1hbGl6ZUJvb2woaXNTZWxmKTtcbiAgICAgICAgICB0aGlzLmlzSG9zdCA9IG5vcm1hbGl6ZUJvb2woaXNIb3N0KTtcbiAgICAgICAgICB0aGlzLmlzU2tpcFNlbGYgPSBub3JtYWxpemVCb29sKGlzU2tpcFNlbGYpO1xuICAgICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IG5vcm1hbGl6ZUJvb2woaXNPcHRpb25hbCk7XG4gICAgICAgICAgdGhpcy5pc1ZhbHVlID0gbm9ybWFsaXplQm9vbChpc1ZhbHVlKTtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgdGhpcy52aWV3UXVlcnkgPSB2aWV3UXVlcnk7XG4gICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGE7XG4gIH0oKSk7XG4gIHZhciBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlUHJvdmlkZXJNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IF9hLnRva2VuLCB1c2VDbGFzcyA9IF9hLnVzZUNsYXNzLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VGYWN0b3J5ID0gX2EudXNlRmFjdG9yeSwgZGVwcyA9IF9hLmRlcHMsIG11bHRpID0gX2EubXVsdGk7XG4gICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICAgIHRoaXMudXNlQ2xhc3MgPSB1c2VDbGFzcztcbiAgICAgICAgICB0aGlzLnVzZVZhbHVlID0gdXNlVmFsdWU7XG4gICAgICAgICAgdGhpcy51c2VFeGlzdGluZyA9IHVzZUV4aXN0aW5nO1xuICAgICAgICAgIHRoaXMudXNlRmFjdG9yeSA9IHVzZUZhY3Rvcnk7XG4gICAgICAgICAgdGhpcy5kZXBzID0gbm9ybWFsaXplQmxhbmsoZGVwcyk7XG4gICAgICAgICAgdGhpcy5tdWx0aSA9IG5vcm1hbGl6ZUJvb2wobXVsdGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVQcm92aWRlck1ldGFkYXRhO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZUZhY3RvcnlNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMShDb21waWxlRmFjdG9yeU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZUZhY3RvcnlNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciByZWZlcmVuY2UgPSBfYS5yZWZlcmVuY2UsIG5hbWUgPSBfYS5uYW1lLCBtb2R1bGVVcmwgPSBfYS5tb2R1bGVVcmwsIHByZWZpeCA9IF9hLnByZWZpeCwgZGlEZXBzID0gX2EuZGlEZXBzLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHsgcmVmZXJlbmNlOiByZWZlcmVuY2UsIG5hbWU6IG5hbWUsIHByZWZpeDogcHJlZml4LCBtb2R1bGVVcmw6IG1vZHVsZVVybCwgdmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICAgIHRoaXMuZGlEZXBzID0gX25vcm1hbGl6ZUFycmF5KGRpRGVwcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUZhY3RvcnlNZXRhZGF0YTtcbiAgfShDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKSk7XG4gIHZhciBDb21waWxlVG9rZW5NZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlVG9rZW5NZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlLCBpZGVudGlmaWVyID0gX2EuaWRlbnRpZmllciwgaWRlbnRpZmllcklzSW5zdGFuY2UgPSBfYS5pZGVudGlmaWVySXNJbnN0YW5jZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgICAgICB0aGlzLmlkZW50aWZpZXJJc0luc3RhbmNlID0gbm9ybWFsaXplQm9vbChpZGVudGlmaWVySXNJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZVRva2VuTWV0YWRhdGEucHJvdG90eXBlLCBcInJlZmVyZW5jZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpZmllci5yZWZlcmVuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVUb2tlbk1ldGFkYXRhLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnZhbHVlKSA/IHNhbml0aXplSWRlbnRpZmllcih0aGlzLnZhbHVlKSA6IHRoaXMuaWRlbnRpZmllci5uYW1lO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIENvbXBpbGVUb2tlbk1ldGFkYXRhO1xuICB9KCkpO1xuICAvKipcbiAgICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgdHlwZS5cbiAgICovXG4gIHZhciBDb21waWxlVHlwZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxKENvbXBpbGVUeXBlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBDb21waWxlVHlwZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHJlZmVyZW5jZSA9IF9iLnJlZmVyZW5jZSwgbmFtZSA9IF9iLm5hbWUsIG1vZHVsZVVybCA9IF9iLm1vZHVsZVVybCwgcHJlZml4ID0gX2IucHJlZml4LCBpc0hvc3QgPSBfYi5pc0hvc3QsIHZhbHVlID0gX2IudmFsdWUsIGRpRGVwcyA9IF9iLmRpRGVwcywgbGlmZWN5Y2xlSG9va3MgPSBfYi5saWZlY3ljbGVIb29rcztcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB7IHJlZmVyZW5jZTogcmVmZXJlbmNlLCBuYW1lOiBuYW1lLCBtb2R1bGVVcmw6IG1vZHVsZVVybCwgcHJlZml4OiBwcmVmaXgsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB0aGlzLmlzSG9zdCA9IG5vcm1hbGl6ZUJvb2woaXNIb3N0KTtcbiAgICAgICAgICB0aGlzLmRpRGVwcyA9IF9ub3JtYWxpemVBcnJheShkaURlcHMpO1xuICAgICAgICAgIHRoaXMubGlmZWN5Y2xlSG9va3MgPSBfbm9ybWFsaXplQXJyYXkobGlmZWN5Y2xlSG9va3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVUeXBlTWV0YWRhdGE7XG4gIH0oQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSkpO1xuICB2YXIgQ29tcGlsZVF1ZXJ5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVF1ZXJ5TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgc2VsZWN0b3JzID0gX2Iuc2VsZWN0b3JzLCBkZXNjZW5kYW50cyA9IF9iLmRlc2NlbmRhbnRzLCBmaXJzdCA9IF9iLmZpcnN0LCBwcm9wZXJ0eU5hbWUgPSBfYi5wcm9wZXJ0eU5hbWUsIHJlYWQgPSBfYi5yZWFkO1xuICAgICAgICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgICAgICAgIHRoaXMuZGVzY2VuZGFudHMgPSBub3JtYWxpemVCb29sKGRlc2NlbmRhbnRzKTtcbiAgICAgICAgICB0aGlzLmZpcnN0ID0gbm9ybWFsaXplQm9vbChmaXJzdCk7XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgICAgdGhpcy5yZWFkID0gcmVhZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlUXVlcnlNZXRhZGF0YTtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIE1ldGFkYXRhIGFib3V0IGEgc3R5bGVzaGVldFxuICAgKi9cbiAgdmFyIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtb2R1bGVVcmwgPSBfYi5tb2R1bGVVcmwsIHN0eWxlcyA9IF9iLnN0eWxlcywgc3R5bGVVcmxzID0gX2Iuc3R5bGVVcmxzO1xuICAgICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVVcmxzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhO1xuICB9KCkpO1xuICAvKipcbiAgICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgdGVtcGxhdGUuXG4gICAqL1xuICB2YXIgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgZW5jYXBzdWxhdGlvbiA9IF9iLmVuY2Fwc3VsYXRpb24sIHRlbXBsYXRlID0gX2IudGVtcGxhdGUsIHRlbXBsYXRlVXJsID0gX2IudGVtcGxhdGVVcmwsIHN0eWxlcyA9IF9iLnN0eWxlcywgc3R5bGVVcmxzID0gX2Iuc3R5bGVVcmxzLCBleHRlcm5hbFN0eWxlc2hlZXRzID0gX2IuZXh0ZXJuYWxTdHlsZXNoZWV0cywgYW5pbWF0aW9ucyA9IF9iLmFuaW1hdGlvbnMsIG5nQ29udGVudFNlbGVjdG9ycyA9IF9iLm5nQ29udGVudFNlbGVjdG9ycywgaW50ZXJwb2xhdGlvbiA9IF9iLmludGVycG9sYXRpb247XG4gICAgICAgICAgdGhpcy5lbmNhcHN1bGF0aW9uID0gZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IHRlbXBsYXRlVXJsO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVVcmxzKTtcbiAgICAgICAgICB0aGlzLmV4dGVybmFsU3R5bGVzaGVldHMgPSBfbm9ybWFsaXplQXJyYXkoZXh0ZXJuYWxTdHlsZXNoZWV0cyk7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb25zID0gaXNQcmVzZW50KGFuaW1hdGlvbnMpID8gTGlzdFdyYXBwZXIuZmxhdHRlbihhbmltYXRpb25zKSA6IFtdO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzID0gaXNQcmVzZW50KG5nQ29udGVudFNlbGVjdG9ycykgPyBuZ0NvbnRlbnRTZWxlY3RvcnMgOiBbXTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGludGVycG9sYXRpb24pICYmIGludGVycG9sYXRpb24ubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2ludGVycG9sYXRpb24nIHNob3VsZCBoYXZlIGEgc3RhcnQgYW5kIGFuIGVuZCBzeW1ib2wuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhO1xuICB9KCkpO1xuICAvKipcbiAgICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgZGlyZWN0aXZlLlxuICAgKi9cbiAgdmFyIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIGlzQ29tcG9uZW50ID0gX2IuaXNDb21wb25lbnQsIHNlbGVjdG9yID0gX2Iuc2VsZWN0b3IsIGV4cG9ydEFzID0gX2IuZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbiA9IF9iLmNoYW5nZURldGVjdGlvbiwgaW5wdXRzID0gX2IuaW5wdXRzLCBvdXRwdXRzID0gX2Iub3V0cHV0cywgaG9zdExpc3RlbmVycyA9IF9iLmhvc3RMaXN0ZW5lcnMsIGhvc3RQcm9wZXJ0aWVzID0gX2IuaG9zdFByb3BlcnRpZXMsIGhvc3RBdHRyaWJ1dGVzID0gX2IuaG9zdEF0dHJpYnV0ZXMsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgdmlld1Byb3ZpZGVycyA9IF9iLnZpZXdQcm92aWRlcnMsIHF1ZXJpZXMgPSBfYi5xdWVyaWVzLCB2aWV3UXVlcmllcyA9IF9iLnZpZXdRdWVyaWVzLCBlbnRyeUNvbXBvbmVudHMgPSBfYi5lbnRyeUNvbXBvbmVudHMsIHRlbXBsYXRlID0gX2IudGVtcGxhdGU7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLmlzQ29tcG9uZW50ID0gaXNDb21wb25lbnQ7XG4gICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgIHRoaXMuZXhwb3J0QXMgPSBleHBvcnRBcztcbiAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdGlvbiA9IGNoYW5nZURldGVjdGlvbjtcbiAgICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICAgIHRoaXMuaG9zdExpc3RlbmVycyA9IGhvc3RMaXN0ZW5lcnM7XG4gICAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICAgIHRoaXMuaG9zdEF0dHJpYnV0ZXMgPSBob3N0QXR0cmlidXRlcztcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheShwcm92aWRlcnMpO1xuICAgICAgICAgIHRoaXMudmlld1Byb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheSh2aWV3UHJvdmlkZXJzKTtcbiAgICAgICAgICB0aGlzLnF1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkocXVlcmllcyk7XG4gICAgICAgICAgdGhpcy52aWV3UXVlcmllcyA9IF9ub3JtYWxpemVBcnJheSh2aWV3UXVlcmllcyk7XG4gICAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBfbm9ybWFsaXplQXJyYXkoZW50cnlDb21wb25lbnRzKTtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICB9XG4gICAgICBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHR5cGUgPSBfYi50eXBlLCBpc0NvbXBvbmVudCA9IF9iLmlzQ29tcG9uZW50LCBzZWxlY3RvciA9IF9iLnNlbGVjdG9yLCBleHBvcnRBcyA9IF9iLmV4cG9ydEFzLCBjaGFuZ2VEZXRlY3Rpb24gPSBfYi5jaGFuZ2VEZXRlY3Rpb24sIGlucHV0cyA9IF9iLmlucHV0cywgb3V0cHV0cyA9IF9iLm91dHB1dHMsIGhvc3QgPSBfYi5ob3N0LCBwcm92aWRlcnMgPSBfYi5wcm92aWRlcnMsIHZpZXdQcm92aWRlcnMgPSBfYi52aWV3UHJvdmlkZXJzLCBxdWVyaWVzID0gX2IucXVlcmllcywgdmlld1F1ZXJpZXMgPSBfYi52aWV3UXVlcmllcywgZW50cnlDb21wb25lbnRzID0gX2IuZW50cnlDb21wb25lbnRzLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlO1xuICAgICAgICAgIHZhciBob3N0TGlzdGVuZXJzID0ge307XG4gICAgICAgICAgdmFyIGhvc3RQcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgdmFyIGhvc3RBdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChob3N0KSkge1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhob3N0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvc3Rba2V5XTtcbiAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0ga2V5Lm1hdGNoKEhPU1RfUkVHX0VYUCk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChtYXRjaGVzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzW21hdGNoZXNbMV1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQobWF0Y2hlc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBob3N0TGlzdGVuZXJzW21hdGNoZXNbMl1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5wdXRzTWFwID0ge307XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChpbnB1dHMpKSB7XG4gICAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XG4gICAgICAgICAgICAgICAgICBpbnB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3V0cHV0c01hcCA9IHt9O1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQob3V0cHV0cykpIHtcbiAgICAgICAgICAgICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRzTWFwW3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBpc0NvbXBvbmVudDogbm9ybWFsaXplQm9vbChpc0NvbXBvbmVudCksIHNlbGVjdG9yOiBzZWxlY3RvciwgZXhwb3J0QXM6IGV4cG9ydEFzLCBjaGFuZ2VEZXRlY3Rpb246IGNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNNYXAsXG4gICAgICAgICAgICAgIG91dHB1dHM6IG91dHB1dHNNYXAsXG4gICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IGhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBob3N0UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXM6IGhvc3RBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgICAgcXVlcmllczogcXVlcmllcyxcbiAgICAgICAgICAgICAgdmlld1F1ZXJpZXM6IHZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGE7XG4gIH0oKSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Qge0BsaW5rIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YX0gZnJvbSB7QGxpbmsgQ29tcG9uZW50VHlwZU1ldGFkYXRhfSBhbmQgYSBzZWxlY3Rvci5cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhKGNvbXBNZXRhKSB7XG4gICAgICB2YXIgdGVtcGxhdGUgPSBDc3NTZWxlY3Rvci5wYXJzZShjb21wTWV0YS5zZWxlY3RvcilbMF0uZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUoKTtcbiAgICAgIHJldHVybiBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEuY3JlYXRlKHtcbiAgICAgICAgICB0eXBlOiBuZXcgQ29tcGlsZVR5cGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHJlZmVyZW5jZTogT2JqZWN0LFxuICAgICAgICAgICAgICBuYW1lOiBjb21wTWV0YS50eXBlLm5hbWUgKyBcIl9Ib3N0XCIsXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogY29tcE1ldGEudHlwZS5tb2R1bGVVcmwsXG4gICAgICAgICAgICAgIGlzSG9zdDogdHJ1ZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRlbXBsYXRlOiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICcnLFxuICAgICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdLFxuICAgICAgICAgICAgICBhbmltYXRpb25zOiBbXVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgICAgaG9zdDoge30sXG4gICAgICAgICAgaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgICAgc2VsZWN0b3I6ICcqJyxcbiAgICAgICAgICBwcm92aWRlcnM6IFtdLFxuICAgICAgICAgIHZpZXdQcm92aWRlcnM6IFtdLFxuICAgICAgICAgIHF1ZXJpZXM6IFtdLFxuICAgICAgICAgIHZpZXdRdWVyaWVzOiBbXVxuICAgICAgfSk7XG4gIH1cbiAgdmFyIENvbXBpbGVQaXBlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZVBpcGVNZXRhZGF0YShfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgbmFtZSA9IF9iLm5hbWUsIHB1cmUgPSBfYi5wdXJlO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnB1cmUgPSBub3JtYWxpemVCb29sKHB1cmUpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVQaXBlTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlUGlwZU1ldGFkYXRhO1xuICB9KCkpO1xuICAvKipcbiAgICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgZGlyZWN0aXZlLlxuICAgKi9cbiAgdmFyIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIHR5cGUgPSBfYi50eXBlLCBwcm92aWRlcnMgPSBfYi5wcm92aWRlcnMsIGRlY2xhcmVkRGlyZWN0aXZlcyA9IF9iLmRlY2xhcmVkRGlyZWN0aXZlcywgZXhwb3J0ZWREaXJlY3RpdmVzID0gX2IuZXhwb3J0ZWREaXJlY3RpdmVzLCBkZWNsYXJlZFBpcGVzID0gX2IuZGVjbGFyZWRQaXBlcywgZXhwb3J0ZWRQaXBlcyA9IF9iLmV4cG9ydGVkUGlwZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9iLmVudHJ5Q29tcG9uZW50cywgYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9iLmJvb3RzdHJhcENvbXBvbmVudHMsIGltcG9ydGVkTW9kdWxlcyA9IF9iLmltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzID0gX2IuZXhwb3J0ZWRNb2R1bGVzLCBzY2hlbWFzID0gX2Iuc2NoZW1hcywgdHJhbnNpdGl2ZU1vZHVsZSA9IF9iLnRyYW5zaXRpdmVNb2R1bGUsIGlkID0gX2IuaWQ7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICB0aGlzLmRlY2xhcmVkRGlyZWN0aXZlcyA9IF9ub3JtYWxpemVBcnJheShkZWNsYXJlZERpcmVjdGl2ZXMpO1xuICAgICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzID0gX25vcm1hbGl6ZUFycmF5KGV4cG9ydGVkRGlyZWN0aXZlcyk7XG4gICAgICAgICAgdGhpcy5kZWNsYXJlZFBpcGVzID0gX25vcm1hbGl6ZUFycmF5KGRlY2xhcmVkUGlwZXMpO1xuICAgICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlcyA9IF9ub3JtYWxpemVBcnJheShleHBvcnRlZFBpcGVzKTtcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IF9ub3JtYWxpemVBcnJheShwcm92aWRlcnMpO1xuICAgICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGVudHJ5Q29tcG9uZW50cyk7XG4gICAgICAgICAgdGhpcy5ib290c3RyYXBDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGJvb3RzdHJhcENvbXBvbmVudHMpO1xuICAgICAgICAgIHRoaXMuaW1wb3J0ZWRNb2R1bGVzID0gX25vcm1hbGl6ZUFycmF5KGltcG9ydGVkTW9kdWxlcyk7XG4gICAgICAgICAgdGhpcy5leHBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgICB0aGlzLnNjaGVtYXMgPSBfbm9ybWFsaXplQXJyYXkoc2NoZW1hcyk7XG4gICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgIHRoaXMudHJhbnNpdGl2ZU1vZHVsZSA9IHRyYW5zaXRpdmVNb2R1bGU7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLCBcImlkZW50aWZpZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbiAgfSgpKTtcbiAgdmFyIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEobW9kdWxlcywgcHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudHMsIGRpcmVjdGl2ZXMsIHBpcGVzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLm1vZHVsZXMgPSBtb2R1bGVzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gZW50cnlDb21wb25lbnRzO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgICAgdGhpcy5waXBlcyA9IHBpcGVzO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLnBpcGVzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBfdGhpcy5kaXJlY3RpdmVzU2V0LmFkZChkaXIudHlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICBwaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5waXBlc1NldC5hZGQocGlwZS50eXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gcmVtb3ZlSWRlbnRpZmllckR1cGxpY2F0ZXMoaXRlbXMpIHtcbiAgICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgaWYgKCFtYXAuZ2V0KGl0ZW0uaWRlbnRpZmllci5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgIG1hcC5zZXQoaXRlbS5pZGVudGlmaWVyLnJlZmVyZW5jZSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gTWFwV3JhcHBlci52YWx1ZXMobWFwKTtcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplQXJyYXkob2JqKSB7XG4gICAgICByZXR1cm4gaXNQcmVzZW50KG9iaikgPyBvYmogOiBbXTtcbiAgfVxuICBmdW5jdGlvbiBpc1N0YXRpY1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzU3RyaW5nTWFwKHZhbHVlKSAmJiBpc1ByZXNlbnQodmFsdWVbJ25hbWUnXSkgJiYgaXNQcmVzZW50KHZhbHVlWydmaWxlUGF0aCddKTtcbiAgfVxuICB2YXIgUHJvdmlkZXJNZXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFByb3ZpZGVyTWV0YSh0b2tlbiwgX2EpIHtcbiAgICAgICAgICB2YXIgdXNlQ2xhc3MgPSBfYS51c2VDbGFzcywgdXNlVmFsdWUgPSBfYS51c2VWYWx1ZSwgdXNlRXhpc3RpbmcgPSBfYS51c2VFeGlzdGluZywgdXNlRmFjdG9yeSA9IF9hLnVzZUZhY3RvcnksIGRlcHMgPSBfYS5kZXBzLCBtdWx0aSA9IF9hLm11bHRpO1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICB0aGlzLnVzZUNsYXNzID0gdXNlQ2xhc3M7XG4gICAgICAgICAgdGhpcy51c2VWYWx1ZSA9IHVzZVZhbHVlO1xuICAgICAgICAgIHRoaXMudXNlRXhpc3RpbmcgPSB1c2VFeGlzdGluZztcbiAgICAgICAgICB0aGlzLnVzZUZhY3RvcnkgPSB1c2VGYWN0b3J5O1xuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwcztcbiAgICAgICAgICB0aGlzLm11bHRpID0gISFtdWx0aTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm92aWRlck1ldGE7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBQYXJzZXJFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQYXJzZXJFcnJvcihtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICAgIHRoaXMuZXJyTG9jYXRpb24gPSBlcnJMb2NhdGlvbjtcbiAgICAgICAgICB0aGlzLmN0eExvY2F0aW9uID0gY3R4TG9jYXRpb247XG4gICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJQYXJzZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIFwiICsgZXJyTG9jYXRpb24gKyBcIiBbXCIgKyBpbnB1dCArIFwiXSBpbiBcIiArIGN0eExvY2F0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFBhcnNlckVycm9yO1xuICB9KCkpO1xuICB2YXIgUGFyc2VTcGFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlU3BhbihzdGFydCwgZW5kKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFBhcnNlU3BhbjtcbiAgfSgpKTtcbiAgdmFyIEFTVCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBU1Qoc3Bhbikge1xuICAgICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICB9XG4gICAgICBBU1QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQVNULnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdBU1QnOyB9O1xuICAgICAgcmV0dXJuIEFTVDtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBxdW90ZWQgZXhwcmVzc2lvbiBvZiB0aGUgZm9ybTpcbiAgICpcbiAgICogcXVvdGUgPSBwcmVmaXggYDpgIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uXG4gICAqIHByZWZpeCA9IGlkZW50aWZpZXJcbiAgICogdW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSBhcmJpdHJhcnkgc3RyaW5nXG4gICAqXG4gICAqIEEgcXVvdGVkIGV4cHJlc3Npb24gaXMgbWVhbnQgdG8gYmUgcHJlLXByb2Nlc3NlZCBieSBhbiBBU1QgdHJhbnNmb3JtZXIgdGhhdFxuICAgKiBjb252ZXJ0cyBpdCBpbnRvIGFub3RoZXIgQVNUIHRoYXQgbm8gbG9uZ2VyIGNvbnRhaW5zIHF1b3RlZCBleHByZXNzaW9ucy5cbiAgICogSXQgaXMgbWVhbnQgdG8gYWxsb3cgdGhpcmQtcGFydHkgZGV2ZWxvcGVycyB0byBleHRlbmQgQW5ndWxhciB0ZW1wbGF0ZVxuICAgKiBleHByZXNzaW9uIGxhbmd1YWdlLiBUaGUgYHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uYCBwYXJ0IG9mIHRoZSBxdW90ZSBpc1xuICAgKiB0aGVyZWZvcmUgbm90IGludGVycHJldGVkIGJ5IHRoZSBBbmd1bGFyJ3Mgb3duIGV4cHJlc3Npb24gcGFyc2VyLlxuICAgKi9cbiAgdmFyIFF1b3RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKFF1b3RlLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gUXVvdGUoc3BhbiwgcHJlZml4LCB1bmludGVycHJldGVkRXhwcmVzc2lvbiwgbG9jYXRpb24pIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgICB0aGlzLnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gdW5pbnRlcnByZXRlZEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgfVxuICAgICAgUXVvdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRRdW90ZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBRdW90ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnUXVvdGUnOyB9O1xuICAgICAgcmV0dXJuIFF1b3RlO1xuICB9KEFTVCkpO1xuICB2YXIgRW1wdHlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKEVtcHR5RXhwciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEVtcHR5RXhwcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIEVtcHR5RXhwci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICB9O1xuICAgICAgcmV0dXJuIEVtcHR5RXhwcjtcbiAgfShBU1QpKTtcbiAgdmFyIEltcGxpY2l0UmVjZWl2ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoSW1wbGljaXRSZWNlaXZlciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEltcGxpY2l0UmVjZWl2ZXIoKSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBJbXBsaWNpdFJlY2VpdmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW1wbGljaXRSZWNlaXZlcih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSW1wbGljaXRSZWNlaXZlcjtcbiAgfShBU1QpKTtcbiAgLyoqXG4gICAqIE11bHRpcGxlIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbi5cbiAgICovXG4gIHZhciBDaGFpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhDaGFpbiwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENoYWluKHNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgfVxuICAgICAgQ2hhaW4ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGFpbih0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ2hhaW47XG4gIH0oQVNUKSk7XG4gIHZhciBDb25kaXRpb25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhDb25kaXRpb25hbCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsKHNwYW4sIGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgICB0aGlzLnRydWVFeHAgPSB0cnVlRXhwO1xuICAgICAgICAgIHRoaXMuZmFsc2VFeHAgPSBmYWxzZUV4cDtcbiAgICAgIH1cbiAgICAgIENvbmRpdGlvbmFsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWwodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIENvbmRpdGlvbmFsO1xuICB9KEFTVCkpO1xuICB2YXIgUHJvcGVydHlSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKFByb3BlcnR5UmVhZCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByb3BlcnR5UmVhZChzcGFuLCByZWNlaXZlciwgbmFtZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuICAgICAgUHJvcGVydHlSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQcm9wZXJ0eVJlYWQ7XG4gIH0oQVNUKSk7XG4gIHZhciBQcm9wZXJ0eVdyaXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKFByb3BlcnR5V3JpdGUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBQcm9wZXJ0eVdyaXRlKHNwYW4sIHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFByb3BlcnR5V3JpdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQcm9wZXJ0eVdyaXRlO1xuICB9KEFTVCkpO1xuICB2YXIgU2FmZVByb3BlcnR5UmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhTYWZlUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gU2FmZVByb3BlcnR5UmVhZChzcGFuLCByZWNlaXZlciwgbmFtZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuICAgICAgU2FmZVByb3BlcnR5UmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFNhZmVQcm9wZXJ0eVJlYWQ7XG4gIH0oQVNUKSk7XG4gIHZhciBLZXllZFJlYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoS2V5ZWRSZWFkLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gS2V5ZWRSZWFkKHNwYW4sIG9iaiwga2V5KSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB9XG4gICAgICBLZXllZFJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEtleWVkUmVhZDtcbiAgfShBU1QpKTtcbiAgdmFyIEtleWVkV3JpdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoS2V5ZWRXcml0ZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEtleWVkV3JpdGUoc3Bhbiwgb2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgS2V5ZWRXcml0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkV3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEtleWVkV3JpdGU7XG4gIH0oQVNUKSk7XG4gIHZhciBCaW5kaW5nUGlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhCaW5kaW5nUGlwZSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEJpbmRpbmdQaXBlKHNwYW4sIGV4cCwgbmFtZSwgYXJncykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuZXhwID0gZXhwO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgIH1cbiAgICAgIEJpbmRpbmdQaXBlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQmluZGluZ1BpcGU7XG4gIH0oQVNUKSk7XG4gIHZhciBMaXRlcmFsUHJpbWl0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKExpdGVyYWxQcmltaXRpdmUsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsUHJpbWl0aXZlKHNwYW4sIHZhbHVlKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgTGl0ZXJhbFByaW1pdGl2ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxQcmltaXRpdmUodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIExpdGVyYWxQcmltaXRpdmU7XG4gIH0oQVNUKSk7XG4gIHZhciBMaXRlcmFsQXJyYXkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoTGl0ZXJhbEFycmF5LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gTGl0ZXJhbEFycmF5KHNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgfVxuICAgICAgTGl0ZXJhbEFycmF5LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5KHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBMaXRlcmFsQXJyYXk7XG4gIH0oQVNUKSk7XG4gIHZhciBMaXRlcmFsTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKExpdGVyYWxNYXAsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBMaXRlcmFsTWFwKHNwYW4sIGtleXMsIHZhbHVlcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB9XG4gICAgICBMaXRlcmFsTWFwLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gTGl0ZXJhbE1hcDtcbiAgfShBU1QpKTtcbiAgdmFyIEludGVycG9sYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoSW50ZXJwb2xhdGlvbiwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEludGVycG9sYXRpb24oc3Bhbiwgc3RyaW5ncywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgIH1cbiAgICAgIEludGVycG9sYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnRlcnBvbGF0aW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uO1xuICB9KEFTVCkpO1xuICB2YXIgQmluYXJ5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKEJpbmFyeSwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEJpbmFyeShzcGFuLCBvcGVyYXRpb24sIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICB9XG4gICAgICBCaW5hcnkucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5hcnkodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEJpbmFyeTtcbiAgfShBU1QpKTtcbiAgdmFyIFByZWZpeE5vdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhQcmVmaXhOb3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBQcmVmaXhOb3Qoc3BhbiwgZXhwcmVzc2lvbikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pO1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICB9XG4gICAgICBQcmVmaXhOb3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcmVmaXhOb3QodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFByZWZpeE5vdDtcbiAgfShBU1QpKTtcbiAgdmFyIE1ldGhvZENhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDMoTWV0aG9kQ2FsbCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIE1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgTWV0aG9kQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE1ldGhvZENhbGwodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIE1ldGhvZENhbGw7XG4gIH0oQVNUKSk7XG4gIHZhciBTYWZlTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMyhTYWZlTWV0aG9kQ2FsbCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFNhZmVNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3Bhbik7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgIH1cbiAgICAgIFNhZmVNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U2FmZU1ldGhvZENhbGwodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFNhZmVNZXRob2RDYWxsO1xuICB9KEFTVCkpO1xuICB2YXIgRnVuY3Rpb25DYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKEZ1bmN0aW9uQ2FsbCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEZ1bmN0aW9uQ2FsbChzcGFuLCB0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKTtcbiAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgfVxuICAgICAgRnVuY3Rpb25DYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25DYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBGdW5jdGlvbkNhbGw7XG4gIH0oQVNUKSk7XG4gIHZhciBBU1RXaXRoU291cmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQzKEFTVFdpdGhTb3VyY2UsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBU1RXaXRoU291cmNlKGFzdCwgc291cmNlLCBsb2NhdGlvbiwgZXJyb3JzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbmV3IFBhcnNlU3BhbigwLCBpc0JsYW5rKHNvdXJjZSkgPyAwIDogc291cmNlLmxlbmd0aCkpO1xuICAgICAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIEFTVFdpdGhTb3VyY2UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIEFTVFdpdGhTb3VyY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zb3VyY2UgKyBcIiBpbiBcIiArIHRoaXMubG9jYXRpb247IH07XG4gICAgICByZXR1cm4gQVNUV2l0aFNvdXJjZTtcbiAgfShBU1QpKTtcbiAgdmFyIFRlbXBsYXRlQmluZGluZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZUJpbmRpbmcoa2V5LCBrZXlJc1ZhciwgbmFtZSwgZXhwcmVzc2lvbikge1xuICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgIHRoaXMua2V5SXNWYXIgPSBrZXlJc1ZhcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICB9XG4gICAgICByZXR1cm4gVGVtcGxhdGVCaW5kaW5nO1xuICB9KCkpO1xuICB2YXIgUmVjdXJzaXZlQXN0VmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZWN1cnNpdmVBc3RWaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LmxlZnQudmlzaXQodGhpcyk7XG4gICAgICAgICAgYXN0LnJpZ2h0LnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7IH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5jb25kaXRpb24udmlzaXQodGhpcyk7XG4gICAgICAgICAgYXN0LnRydWVFeHAudmlzaXQodGhpcyk7XG4gICAgICAgICAgYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QuZXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC50YXJnZXQudmlzaXQodGhpcyk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5vYmoudmlzaXQodGhpcyk7XG4gICAgICAgICAgYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0Lm9iai52aXNpdCh0aGlzKTtcbiAgICAgICAgICBhc3Qua2V5LnZpc2l0KHRoaXMpO1xuICAgICAgICAgIGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcywgY29udGV4dCk7IH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgICAgYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlTWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFF1b3RlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIHJldHVybiBSZWN1cnNpdmVBc3RWaXNpdG9yO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyICRFT0YgPSAwO1xuICB2YXIgJFRBQiA9IDk7XG4gIHZhciAkTEYgPSAxMDtcbiAgdmFyICRWVEFCID0gMTE7XG4gIHZhciAkRkYgPSAxMjtcbiAgdmFyICRDUiA9IDEzO1xuICB2YXIgJFNQQUNFID0gMzI7XG4gIHZhciAkQkFORyA9IDMzO1xuICB2YXIgJERRID0gMzQ7XG4gIHZhciAkSEFTSCA9IDM1O1xuICB2YXIgJCQgPSAzNjtcbiAgdmFyICRQRVJDRU5UID0gMzc7XG4gIHZhciAkQU1QRVJTQU5EID0gMzg7XG4gIHZhciAkU1EgPSAzOTtcbiAgdmFyICRMUEFSRU4gPSA0MDtcbiAgdmFyICRSUEFSRU4gPSA0MTtcbiAgdmFyICRTVEFSID0gNDI7XG4gIHZhciAkUExVUyA9IDQzO1xuICB2YXIgJENPTU1BID0gNDQ7XG4gIHZhciAkTUlOVVMgPSA0NTtcbiAgdmFyICRQRVJJT0QgPSA0NjtcbiAgdmFyICRTTEFTSCA9IDQ3O1xuICB2YXIgJENPTE9OID0gNTg7XG4gIHZhciAkU0VNSUNPTE9OID0gNTk7XG4gIHZhciAkTFQgPSA2MDtcbiAgdmFyICRFUSA9IDYxO1xuICB2YXIgJEdUID0gNjI7XG4gIHZhciAkUVVFU1RJT04gPSA2MztcbiAgdmFyICQwID0gNDg7XG4gIHZhciAkOSA9IDU3O1xuICB2YXIgJEEgPSA2NTtcbiAgdmFyICRFID0gNjk7XG4gIHZhciAkRiA9IDcwO1xuICB2YXIgJFggPSA4ODtcbiAgdmFyICRaID0gOTA7XG4gIHZhciAkTEJSQUNLRVQgPSA5MTtcbiAgdmFyICRCQUNLU0xBU0ggPSA5MjtcbiAgdmFyICRSQlJBQ0tFVCA9IDkzO1xuICB2YXIgJENBUkVUID0gOTQ7XG4gIHZhciAkXyA9IDk1O1xuICB2YXIgJGEgPSA5NztcbiAgdmFyICRlID0gMTAxO1xuICB2YXIgJGYgPSAxMDI7XG4gIHZhciAkbiA9IDExMDtcbiAgdmFyICRyID0gMTE0O1xuICB2YXIgJHQgPSAxMTY7XG4gIHZhciAkdSA9IDExNztcbiAgdmFyICR2ID0gMTE4O1xuICB2YXIgJHggPSAxMjA7XG4gIHZhciAkeiA9IDEyMjtcbiAgdmFyICRMQlJBQ0UgPSAxMjM7XG4gIHZhciAkQkFSID0gMTI0O1xuICB2YXIgJFJCUkFDRSA9IDEyNTtcbiAgdmFyICROQlNQID0gMTYwO1xuICB2YXIgJEJUID0gOTY7XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjb2RlKSB7XG4gICAgICByZXR1cm4gKGNvZGUgPj0gJFRBQiAmJiBjb2RlIDw9ICRTUEFDRSkgfHwgKGNvZGUgPT0gJE5CU1ApO1xuICB9XG4gIGZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICAgICAgcmV0dXJuICQwIDw9IGNvZGUgJiYgY29kZSA8PSAkOTtcbiAgfVxuICBmdW5jdGlvbiBpc0FzY2lpTGV0dGVyKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRaO1xuICB9XG4gIGZ1bmN0aW9uIGlzQXNjaWlIZXhEaWdpdChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA+PSAkYSAmJiBjb2RlIDw9ICRmIHx8IGNvZGUgPj0gJEEgJiYgY29kZSA8PSAkRiB8fCBpc0RpZ2l0KGNvZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0QXJyYXlPZlN0cmluZ3MoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICAgIGlmICghX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSB8fCBpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmICghaXNTdHJpbmcodmFsdWVbaV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIHZhciBJTlRFUlBPTEFUSU9OX0JMQUNLTElTVF9SRUdFWFBTID0gW1xuICAgICAgL15cXHMqJC8sXG4gICAgICAvWzw+XS8sXG4gICAgICAvXlt7fV0kLyxcbiAgICAgIC8mKCN8W2Etel0pL2ksXG4gICAgICAvXlxcL1xcLy8sXG4gIF07XG4gIGZ1bmN0aW9uIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSAmJiAhKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PSAyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXksIFtzdGFydCwgZW5kXS5cIik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgIHZhciBzdGFydF8xID0gdmFsdWVbMF07XG4gICAgICAgICAgdmFyIGVuZF8xID0gdmFsdWVbMV07XG4gICAgICAgICAgLy8gYmxhY2sgbGlzdCBjaGVja2luZ1xuICAgICAgICAgIElOVEVSUE9MQVRJT05fQkxBQ0tMSVNUX1JFR0VYUFMuZm9yRWFjaChmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChzdGFydF8xKSB8fCByZWdleHAudGVzdChlbmRfMSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlsnXCIgKyBzdGFydF8xICsgXCInLCAnXCIgKyBlbmRfMSArIFwiJ10gY29udGFpbnMgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2wuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gIH1cblxuICB2YXIgSW50ZXJwb2xhdGlvbkNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJbnRlcnBvbGF0aW9uQ29uZmlnKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICB9XG4gICAgICBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheSA9IGZ1bmN0aW9uIChtYXJrZXJzKSB7XG4gICAgICAgICAgaWYgKCFtYXJrZXJzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scygnaW50ZXJwb2xhdGlvbicsIG1hcmtlcnMpO1xuICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZyhtYXJrZXJzWzBdLCBtYXJrZXJzWzFdKTtcbiAgICAgIH07XG4gICAgICA7XG4gICAgICByZXR1cm4gSW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgfSgpKTtcbiAgdmFyIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcgPSBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZygne3snLCAnfX0nKTtcblxuICB2YXIgVG9rZW5UeXBlO1xuICAoZnVuY3Rpb24gKFRva2VuVHlwZSkge1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNoYXJhY3RlclwiXSA9IDBdID0gXCJDaGFyYWN0ZXJcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJJZGVudGlmaWVyXCJdID0gMV0gPSBcIklkZW50aWZpZXJcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJLZXl3b3JkXCJdID0gMl0gPSBcIktleXdvcmRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiT3BlcmF0b3JcIl0gPSA0XSA9IFwiT3BlcmF0b3JcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJOdW1iZXJcIl0gPSA1XSA9IFwiTnVtYmVyXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRXJyb3JcIl0gPSA2XSA9IFwiRXJyb3JcIjtcbiAgfSkoVG9rZW5UeXBlIHx8IChUb2tlblR5cGUgPSB7fSkpO1xuICB2YXIgS0VZV09SRFMgPSBbJ3ZhcicsICdsZXQnLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJywgJ3RoaXMnXTtcbiAgdmFyIExleGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIExleGVyKCkge1xuICAgICAgfVxuICAgICAgTGV4ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICB2YXIgc2Nhbm5lciA9IG5ldyBfU2Nhbm5lcih0ZXh0KTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgICAgdmFyIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgICB3aGlsZSAodG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgIH07XG4gICAgICBMZXhlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBMZXhlci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgcmV0dXJuIExleGVyO1xuICB9KCkpO1xuICB2YXIgVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVG9rZW4oaW5kZXgsIHR5cGUsIG51bVZhbHVlLCBzdHJWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMubnVtVmFsdWUgPSBudW1WYWx1ZTtcbiAgICAgICAgICB0aGlzLnN0clZhbHVlID0gc3RyVmFsdWU7XG4gICAgICB9XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLkNoYXJhY3RlciAmJiB0aGlzLm51bVZhbHVlID09IGNvZGU7XG4gICAgICB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzTnVtYmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5OdW1iZXI7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNTdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLlN0cmluZzsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc09wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IgJiYgdGhpcy5zdHJWYWx1ZSA9PSBvcGVyYXRlcjtcbiAgICAgIH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5JZGVudGlmaWVyOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZDsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRMZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnbGV0JzsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmROdWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ251bGwnOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFVuZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgICB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFRydWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndHJ1ZSc7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkRmFsc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnZmFsc2UnOyB9O1xuICAgICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndGhpcyc7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUuaXNFcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuRXJyb3I7IH07XG4gICAgICBUb2tlbi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk51bWJlciA/IHRoaXMubnVtVmFsdWUgOiAtMTsgfTtcbiAgICAgIFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5DaGFyYWN0ZXI6XG4gICAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLklkZW50aWZpZXI6XG4gICAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLktleXdvcmQ6XG4gICAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLk9wZXJhdG9yOlxuICAgICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLkVycm9yOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyVmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLk51bWJlcjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFRva2VuO1xuICB9KCkpO1xuICBmdW5jdGlvbiBuZXdDaGFyYWN0ZXJUb2tlbihpbmRleCwgY29kZSkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLkNoYXJhY3RlciwgY29kZSwgU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld0lkZW50aWZpZXJUb2tlbihpbmRleCwgdGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLklkZW50aWZpZXIsIDAsIHRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld0tleXdvcmRUb2tlbihpbmRleCwgdGV4dCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLktleXdvcmQsIDAsIHRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld09wZXJhdG9yVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5PcGVyYXRvciwgMCwgdGV4dCk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3U3RyaW5nVG9rZW4oaW5kZXgsIHRleHQpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5TdHJpbmcsIDAsIHRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIG5ld051bWJlclRva2VuKGluZGV4LCBuKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuTnVtYmVyLCBuLCAnJyk7XG4gIH1cbiAgZnVuY3Rpb24gbmV3RXJyb3JUb2tlbihpbmRleCwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLkVycm9yLCAwLCBtZXNzYWdlKTtcbiAgfVxuICB2YXIgRU9GID0gbmV3IFRva2VuKC0xLCBUb2tlblR5cGUuQ2hhcmFjdGVyLCAwLCAnJyk7XG4gIHZhciBfU2Nhbm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfU2Nhbm5lcihpbnB1dCkge1xuICAgICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgICB0aGlzLnBlZWsgPSAwO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgIH1cbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMucGVlayA9XG4gICAgICAgICAgICAgICsrdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aCA/ICRFT0YgOiBTdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQodGhpcy5pbnB1dCwgdGhpcy5pbmRleCk7XG4gICAgICB9O1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Ub2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LCBsZW5ndGggPSB0aGlzLmxlbmd0aCwgcGVlayA9IHRoaXMucGVlaywgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZS5cbiAgICAgICAgICB3aGlsZSAocGVlayA8PSAkU1BBQ0UpIHtcbiAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBwZWVrID0gJEVPRjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVlayA9IFN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdChpbnB1dCwgaW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGVlayA9IHBlZWs7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEhhbmRsZSBpZGVudGlmaWVycyBhbmQgbnVtYmVycy5cbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQocGVlaykpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKGlzRGlnaXQocGVlaykpXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1iZXIoaW5kZXgpO1xuICAgICAgICAgIHZhciBzdGFydCA9IGluZGV4O1xuICAgICAgICAgIHN3aXRjaCAocGVlaykge1xuICAgICAgICAgICAgICBjYXNlICRQRVJJT0Q6XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc0RpZ2l0KHRoaXMucGVlaykgPyB0aGlzLnNjYW5OdW1iZXIoc3RhcnQpIDpcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgJFBFUklPRCk7XG4gICAgICAgICAgICAgIGNhc2UgJExQQVJFTjpcbiAgICAgICAgICAgICAgY2FzZSAkUlBBUkVOOlxuICAgICAgICAgICAgICBjYXNlICRMQlJBQ0U6XG4gICAgICAgICAgICAgIGNhc2UgJFJCUkFDRTpcbiAgICAgICAgICAgICAgY2FzZSAkTEJSQUNLRVQ6XG4gICAgICAgICAgICAgIGNhc2UgJFJCUkFDS0VUOlxuICAgICAgICAgICAgICBjYXNlICRDT01NQTpcbiAgICAgICAgICAgICAgY2FzZSAkQ09MT046XG4gICAgICAgICAgICAgIGNhc2UgJFNFTUlDT0xPTjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5DaGFyYWN0ZXIoc3RhcnQsIHBlZWspO1xuICAgICAgICAgICAgICBjYXNlICRTUTpcbiAgICAgICAgICAgICAgY2FzZSAkRFE6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuU3RyaW5nKCk7XG4gICAgICAgICAgICAgIGNhc2UgJEhBU0g6XG4gICAgICAgICAgICAgIGNhc2UgJFBMVVM6XG4gICAgICAgICAgICAgIGNhc2UgJE1JTlVTOlxuICAgICAgICAgICAgICBjYXNlICRTVEFSOlxuICAgICAgICAgICAgICBjYXNlICRTTEFTSDpcbiAgICAgICAgICAgICAgY2FzZSAkUEVSQ0VOVDpcbiAgICAgICAgICAgICAgY2FzZSAkQ0FSRVQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuT3BlcmF0b3Ioc3RhcnQsIFN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKHBlZWspKTtcbiAgICAgICAgICAgICAgY2FzZSAkUVVFU1RJT046XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnPycsICRQRVJJT0QsICcuJyk7XG4gICAgICAgICAgICAgIGNhc2UgJExUOlxuICAgICAgICAgICAgICBjYXNlICRHVDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIFN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9Jyk7XG4gICAgICAgICAgICAgIGNhc2UgJEJBTkc6XG4gICAgICAgICAgICAgIGNhc2UgJEVROlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUocGVlayksICRFUSwgJz0nLCAkRVEsICc9Jyk7XG4gICAgICAgICAgICAgIGNhc2UgJEFNUEVSU0FORDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICcmJywgJEFNUEVSU0FORCwgJyYnKTtcbiAgICAgICAgICAgICAgY2FzZSAkQkFSOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJ3wnLCAkQkFSLCAnfCcpO1xuICAgICAgICAgICAgICBjYXNlICROQlNQOlxuICAgICAgICAgICAgICAgICAgd2hpbGUgKGlzV2hpdGVzcGFjZSh0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRva2VuKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgW1wiICsgU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUocGVlaykgKyBcIl1cIiwgMCk7XG4gICAgICB9O1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5DaGFyYWN0ZXIgPSBmdW5jdGlvbiAoc3RhcnQsIGNvZGUpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICByZXR1cm4gbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsIGNvZGUpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuT3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIHN0cikge1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogVG9rZW5pemUgYSAyLzMgY2hhciBsb25nIG9wZXJhdG9yXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHN0YXJ0IHN0YXJ0IGluZGV4IGluIHRoZSBleHByZXNzaW9uXG4gICAgICAgKiBAcGFyYW0gb25lIGZpcnN0IHN5bWJvbCAoYWx3YXlzIHBhcnQgb2YgdGhlIG9wZXJhdG9yKVxuICAgICAgICogQHBhcmFtIHR3b0NvZGUgY29kZSBwb2ludCBmb3IgdGhlIHNlY29uZCBzeW1ib2xcbiAgICAgICAqIEBwYXJhbSB0d28gc2Vjb25kIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiB0aGUgc2Vjb25kIGNvZGUgcG9pbnQgbWF0Y2hlcylcbiAgICAgICAqIEBwYXJhbSB0aHJlZUNvZGUgY29kZSBwb2ludCBmb3IgdGhlIHRoaXJkIHN5bWJvbFxuICAgICAgICogQHBhcmFtIHRocmVlIHRoaXJkIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiBwcm92aWRlZCBhbmQgbWF0Y2hlcyBzb3VyY2UgZXhwcmVzc2lvbilcbiAgICAgICAqIEByZXR1cm5zIHtUb2tlbn1cbiAgICAgICAqL1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Db21wbGV4T3BlcmF0b3IgPSBmdW5jdGlvbiAoc3RhcnQsIG9uZSwgdHdvQ29kZSwgdHdvLCB0aHJlZUNvZGUsIHRocmVlKSB7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIHN0ciA9IG9uZTtcbiAgICAgICAgICBpZiAodGhpcy5wZWVrID09IHR3b0NvZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHN0ciArPSB0d287XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhyZWVDb2RlKSAmJiB0aGlzLnBlZWsgPT0gdGhyZWVDb2RlKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICBzdHIgKz0gdGhyZWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KHRoaXMucGVlaykpXG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgcmV0dXJuIEtFWVdPUkRTLmluZGV4T2Yoc3RyKSA+IC0xID8gbmV3S2V5d29yZFRva2VuKHN0YXJ0LCBzdHIpIDpcbiAgICAgICAgICAgICAgbmV3SWRlbnRpZmllclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgICAgfTtcbiAgICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuTnVtYmVyID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIHNpbXBsZSA9ICh0aGlzLmluZGV4ID09PSBzdGFydCk7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBkaWdpdC5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAoaXNEaWdpdCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRQRVJJT0QpIHtcbiAgICAgICAgICAgICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGlzRXhwb25lbnRTdGFydCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc0V4cG9uZW50U2lnbih0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc0RpZ2l0KHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgZXhwb25lbnQnLCAtMSk7XG4gICAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNpbXBsZSA/IE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXgoc3RyKSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgICAgICByZXR1cm4gbmV3TnVtYmVyVG9rZW4oc3RhcnQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICAgIHZhciBxdW90ZSA9IHRoaXMucGVlaztcbiAgICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIHF1b3RlLlxuICAgICAgICAgIHZhciBidWZmZXI7XG4gICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgICB3aGlsZSAodGhpcy5wZWVrICE9IHF1b3RlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGJ1ZmZlciA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBTdHJpbmdKb2luZXIoKTtcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hZGQoaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgdW5lc2NhcGVkQ29kZTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJHUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyA0IGNoYXJhY3RlciBoZXggY29kZSBmb3IgdW5pY29kZSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGhleCA9IGlucHV0LnN1YnN0cmluZyh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZENvZGUgPSBOdW1iZXJXcmFwcGVyLnBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIkludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1XCIgKyBoZXggKyBcIl1cIiwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZENvZGUgPSB1bmVzY2FwZSh0aGlzLnBlZWspO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnVmZmVyLmFkZChTdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZSh1bmVzY2FwZWRDb2RlKSk7XG4gICAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVlayA9PSAkRU9GKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignVW50ZXJtaW5hdGVkIHF1b3RlJywgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdCA9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIHRlcm1pbmF0aW5nIHF1b3RlLlxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHVuZXNjYXBlZCBzdHJpbmcgdmFsdWUuXG4gICAgICAgICAgdmFyIHVuZXNjYXBlZCA9IGxhc3Q7XG4gICAgICAgICAgaWYgKGJ1ZmZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGJ1ZmZlci5hZGQobGFzdCk7XG4gICAgICAgICAgICAgIHVuZXNjYXBlZCA9IGJ1ZmZlci50b1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3U3RyaW5nVG9rZW4oc3RhcnQsIHVuZXNjYXBlZCk7XG4gICAgICB9O1xuICAgICAgX1NjYW5uZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9mZnNldCkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuIG5ld0Vycm9yVG9rZW4ocG9zaXRpb24sIFwiTGV4ZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIGF0IGNvbHVtbiBcIiArIHBvc2l0aW9uICsgXCIgaW4gZXhwcmVzc2lvbiBbXCIgKyB0aGlzLmlucHV0ICsgXCJdXCIpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfU2Nhbm5lcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICAgICAgcmV0dXJuICgkYSA8PSBjb2RlICYmIGNvZGUgPD0gJHopIHx8ICgkQSA8PSBjb2RlICYmIGNvZGUgPD0gJFopIHx8XG4gICAgICAgICAgKGNvZGUgPT0gJF8pIHx8IChjb2RlID09ICQkKTtcbiAgfVxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXIoaW5wdXQpIHtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPT0gMClcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgc2Nhbm5lciA9IG5ldyBfU2Nhbm5lcihpbnB1dCk7XG4gICAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgc2Nhbm5lci5hZHZhbmNlKCk7XG4gICAgICB3aGlsZSAoc2Nhbm5lci5wZWVrICE9PSAkRU9GKSB7XG4gICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY29kZSkge1xuICAgICAgcmV0dXJuIGlzQXNjaWlMZXR0ZXIoY29kZSkgfHwgaXNEaWdpdChjb2RlKSB8fCAoY29kZSA9PSAkXykgfHxcbiAgICAgICAgICAoY29kZSA9PSAkJCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNFeHBvbmVudFN0YXJ0KGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID09ICRlIHx8IGNvZGUgPT0gJEU7XG4gIH1cbiAgZnVuY3Rpb24gaXNFeHBvbmVudFNpZ24oY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPT0gJE1JTlVTIHx8IGNvZGUgPT0gJFBMVVM7XG4gIH1cbiAgZnVuY3Rpb24gaXNRdW90ZShjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA9PT0gJFNRIHx8IGNvZGUgPT09ICREUSB8fCBjb2RlID09PSAkQlQ7XG4gIH1cbiAgZnVuY3Rpb24gdW5lc2NhcGUoY29kZSkge1xuICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgY2FzZSAkbjpcbiAgICAgICAgICAgICAgcmV0dXJuICRMRjtcbiAgICAgICAgICBjYXNlICRmOlxuICAgICAgICAgICAgICByZXR1cm4gJEZGO1xuICAgICAgICAgIGNhc2UgJHI6XG4gICAgICAgICAgICAgIHJldHVybiAkQ1I7XG4gICAgICAgICAgY2FzZSAkdDpcbiAgICAgICAgICAgICAgcmV0dXJuICRUQUI7XG4gICAgICAgICAgY2FzZSAkdjpcbiAgICAgICAgICAgICAgcmV0dXJuICRWVEFCO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIFNwbGl0SW50ZXJwb2xhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTcGxpdEludGVycG9sYXRpb24oc3RyaW5ncywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiBTcGxpdEludGVycG9sYXRpb247XG4gIH0oKSk7XG4gIHZhciBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdCh0ZW1wbGF0ZUJpbmRpbmdzLCB3YXJuaW5ncywgZXJyb3JzKSB7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdzID0gdGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQ7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9jcmVhdGVJbnRlcnBvbGF0ZVJlZ0V4cChjb25maWcpIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gZXNjYXBlUmVnRXhwKGNvbmZpZy5zdGFydCkgKyAnKFtcXFxcc1xcXFxTXSo/KScgKyBlc2NhcGVSZWdFeHAoY29uZmlnLmVuZCk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnZycpO1xuICB9XG4gIHZhciBQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VyKF9sZXhlcikge1xuICAgICAgICAgIHRoaXMuX2xleGVyID0gX2xleGVyO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICB9XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlQWN0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZSh0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KSk7XG4gICAgICAgICAgdmFyIGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIHRydWUsIHRoaXMuZXJyb3JzKS5wYXJzZUNoYWluKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmdBc3QoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2ltcGxlQmluZGluZyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmICghU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIuY2hlY2soYXN0KSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcignSG9zdCBiaW5kaW5nIGV4cHJlc3Npb24gY2FuIG9ubHkgY29udGFpbiBmaWVsZCBhY2Nlc3MgYW5kIGNvbnN0YW50cycsIGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcihtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCaW5kaW5nQXN0ID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIC8vIFF1b3RlcyBleHByZXNzaW9ucyB1c2UgM3JkLXBhcnR5IGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFdlIGRvbid0IHdhbnQgdG8gdXNlXG4gICAgICAgICAgLy8gb3VyIGxleGVyIG9yIHBhcnNlciBmb3IgdGhhdCwgc28gd2UgY2hlY2sgZm9yIHRoYXQgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgICB2YXIgcXVvdGUgPSB0aGlzLl9wYXJzZVF1b3RlKGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChxdW90ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZSh0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIGZhbHNlLCB0aGlzLmVycm9ycykucGFyc2VDaGFpbigpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlUXVvdGUgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgICAgaWYgKGlzQmxhbmsoaW5wdXQpKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgcHJlZml4U2VwYXJhdG9ySW5kZXggPSBpbnB1dC5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgaWYgKHByZWZpeFNlcGFyYXRvckluZGV4ID09IC0xKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gaW5wdXQuc3Vic3RyaW5nKDAsIHByZWZpeFNlcGFyYXRvckluZGV4KS50cmltKCk7XG4gICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXIocHJlZml4KSlcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gaW5wdXQuc3Vic3RyaW5nKHByZWZpeFNlcGFyYXRvckluZGV4ICsgMSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShuZXcgUGFyc2VTcGFuKDAsIGlucHV0Lmxlbmd0aCksIHByZWZpeCwgdW5pbnRlcnByZXRlZEV4cHJlc3Npb24sIGxvY2F0aW9uKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoaW5wdXQpO1xuICAgICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBmYWxzZSwgdGhpcy5lcnJvcnMpLnBhcnNlVGVtcGxhdGVCaW5kaW5ncygpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLnNwbGl0SW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmIChzcGxpdCA9PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGl0LmV4cHJlc3Npb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZSh0aGlzLl9zdHJpcENvbW1lbnRzKHNwbGl0LmV4cHJlc3Npb25zW2ldKSk7XG4gICAgICAgICAgICAgIHZhciBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBmYWxzZSwgdGhpcy5lcnJvcnMpLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChhc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UobmV3IEludGVycG9sYXRpb24obmV3IFBhcnNlU3BhbigwLCBpc0JsYW5rKGlucHV0KSA/IDAgOiBpbnB1dC5sZW5ndGgpLCBzcGxpdC5zdHJpbmdzLCBleHByZXNzaW9ucyksIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuc3BsaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgICB2YXIgcmVnZXhwID0gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFN0cmluZ1dyYXBwZXIuc3BsaXQoaW5wdXQsIHJlZ2V4cCk7XG4gICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RyaW5ncyA9IFtdO1xuICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBmaXhlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0LnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoJ0JsYW5rIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBpbnRlcnBvbGF0ZWQgc3RyaW5ncycsIGlucHV0LCBcImF0IGNvbHVtbiBcIiArIHRoaXMuX2ZpbmRJbnRlcnBvbGF0aW9uRXJyb3JDb2x1bW4ocGFydHMsIGksIGludGVycG9sYXRpb25Db25maWcpICsgXCIgaW5cIiwgbG9jYXRpb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zKTtcbiAgICAgIH07XG4gICAgICBQYXJzZXIucHJvdG90eXBlLndyYXBMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgTGl0ZXJhbFByaW1pdGl2ZShuZXcgUGFyc2VTcGFuKDAsIGlzQmxhbmsoaW5wdXQpID8gMCA6IGlucHV0Lmxlbmd0aCksIGlucHV0KSwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fc3RyaXBDb21tZW50cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBpID0gdGhpcy5fY29tbWVudFN0YXJ0KGlucHV0KTtcbiAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGkpID8gaW5wdXQuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKSA6IGlucHV0O1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX2NvbW1lbnRTdGFydCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY2hhciA9IFN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdChpbnB1dCwgaSk7XG4gICAgICAgICAgICAgIHZhciBuZXh0Q2hhciA9IFN0cmluZ1dyYXBwZXIuY2hhckNvZGVBdChpbnB1dCwgaSArIDEpO1xuICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJFNMQVNIICYmIG5leHRDaGFyID09ICRTTEFTSCAmJiBpc0JsYW5rKG91dGVyUXVvdGUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgIGlmIChvdXRlclF1b3RlID09PSBjaGFyKSB7XG4gICAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc0JsYW5rKG91dGVyUXVvdGUpICYmIGlzUXVvdGUoY2hhcikpIHtcbiAgICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBjaGFyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUuX2NoZWNrTm9JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHZhciByZWdleHAgPSBfY3JlYXRlSW50ZXJwb2xhdGVSZWdFeHAoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gU3RyaW5nV3JhcHBlci5zcGxpdChpbnB1dCwgcmVnZXhwKTtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkdvdCBpbnRlcnBvbGF0aW9uIChcIiArIGludGVycG9sYXRpb25Db25maWcuc3RhcnQgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCArIFwiKSB3aGVyZSBleHByZXNzaW9uIHdhcyBleHBlY3RlZFwiLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCAxLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgUGFyc2VyLnByb3RvdHlwZS5fZmluZEludGVycG9sYXRpb25FcnJvckNvbHVtbiA9IGZ1bmN0aW9uIChwYXJ0cywgcGFydEluRXJySWR4LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdmFyIGVyckxvY2F0aW9uID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0SW5FcnJJZHg7IGorKykge1xuICAgICAgICAgICAgICBlcnJMb2NhdGlvbiArPSBqICUgMiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgICBwYXJ0c1tqXSA6XG4gICAgICAgICAgICAgICAgICBcIlwiICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCArIHBhcnRzW2pdICsgaW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlcnJMb2NhdGlvbi5sZW5ndGg7XG4gICAgICB9O1xuICAgICAgUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFBhcnNlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IExleGVyLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKSk7XG4gIHZhciBfUGFyc2VBU1QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBwYXJzZUFjdGlvbiwgZXJyb3JzKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgICB0aGlzLnBhcnNlQWN0aW9uID0gcGFyc2VBY3Rpb247XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQgPSAwO1xuICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPSAwO1xuICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkID0gMDtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgICAgcmV0dXJuIGkgPCB0aGlzLnRva2Vucy5sZW5ndGggPyB0aGlzLnRva2Vuc1tpXSA6IEVPRjtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJuZXh0XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGVlaygwKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX1BhcnNlQVNULnByb3RvdHlwZSwgXCJpbnB1dEluZGV4XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSA/IHRoaXMubmV4dC5pbmRleCA6IHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5zcGFuID0gZnVuY3Rpb24gKHN0YXJ0KSB7IHJldHVybiBuZXcgUGFyc2VTcGFuKHN0YXJ0LCB0aGlzLmlucHV0SW5kZXgpOyB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLmluZGV4Kys7IH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLm9wdGlvbmFsQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGNvZGUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wZWVrS2V5d29yZExldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmV4dC5pc0tleXdvcmRMZXQoKTsgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0Q2hhcmFjdGVyID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3Rlcihjb2RlKSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHRoaXMuZXJyb3IoXCJNaXNzaW5nIGV4cGVjdGVkIFwiICsgU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxPcGVyYXRvciA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNPcGVyYXRvcihvcCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdE9wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcihvcGVyYXRvcikpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB0aGlzLmVycm9yKFwiTWlzc2luZyBleHBlY3RlZCBvcGVyYXRvciBcIiArIG9wZXJhdG9yKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmRcIik7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkgJiYgIW4uaXNTdHJpbmcoKSkge1xuICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIG4gKyBcIiwgZXhwZWN0ZWQgaWRlbnRpZmllciwga2V5d29yZCwgb3Igc3RyaW5nXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBleHBycyA9IFtdO1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgIGV4cHJzLnB1c2goZXhwcik7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdCaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gY2hhaW5lZCBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgfSAvLyByZWFkIGFsbCBzZW1pY29sb25zXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgdGhpcy5uZXh0ICsgXCInXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gZXhwcnNbMF07XG4gICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbih0aGlzLnNwYW4oc3RhcnQpLCBleHBycyk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignfCcpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdDYW5ub3QgaGF2ZSBhIHBpcGUgaW4gYW4gYWN0aW9uIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluZGluZ1BpcGUodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCd8JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7IH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTG9naWNhbE9yKCk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPycpKSB7XG4gICAgICAgICAgICAgIHZhciB5ZXMgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICB2YXIgbm8gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJDb25kaXRpb25hbCBleHByZXNzaW9uIFwiICsgZXhwcmVzc2lvbiArIFwiIHJlcXVpcmVzIGFsbCAzIGV4cHJlc3Npb25zXCIpO1xuICAgICAgICAgICAgICAgICAgbm8gPSBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbm8gPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWwodGhpcy5zcGFuKHN0YXJ0KSwgcmVzdWx0LCB5ZXMsIG5vKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMb2dpY2FsT3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gJ3x8J1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTG9naWNhbEFuZCgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3x8JykpIHtcbiAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCAnfHwnLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbEFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAnJiYnXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJyYmJykpIHtcbiAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgJyYmJywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUVxdWFsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICc9PScsJyE9JywnPT09JywnIT09J1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VSZWxhdGlvbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICc8JywgJz4nLCAnPD0nLCAnPj0nXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VBZGRpdGl2ZSgpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VBZGRpdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBZGRpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAnKycsICctJ1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTXVsdGlwbGljYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gJyonLCAnJScsICcvJ1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4ocmVzdWx0LnNwYW4uc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5uZXh0LnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIG9wZXJhdG9yLCBuZXcgTGl0ZXJhbFByaW1pdGl2ZShuZXcgUGFyc2VTcGFuKHN0YXJ0LCBzdGFydCksIDApLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJlZml4Tm90KHRoaXMuc3BhbihzdGFydCksIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDYWxsQ2hhaW4oKTtcbiAgICAgIH07XG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbENoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRQRVJJT0QpKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPy4nKSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChyZXN1bHQsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkLS07XG4gICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNLRVQpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEtleWVkV3JpdGUodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBLZXllZFJlYWQodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VDYWxsQXJndW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgRnVuY3Rpb25DYWxsKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwgYXJncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQcmltYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmROdWxsKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFVuZGVmaW5lZCgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRydWUoKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkRmFsc2UoKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRoaXMoKSkge1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbkxpc3QoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNLRVQpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheSh0aGlzLnNwYW4oc3RhcnQpLCBlbGVtZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkTEJSQUNFKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWxNYXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCkpLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc051bWJlcigpKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubmV4dC50b051bWJlcigpO1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgdmFyIGxpdGVyYWxWYWx1ZSA9IHRoaXMubmV4dC50b1N0cmluZygpO1xuICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIGxpdGVyYWxWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIGVuZCBvZiBleHByZXNzaW9uOiBcIiArIHRoaXMuaW5wdXQpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgdGhpcy5uZXh0KTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uICh0ZXJtaW5hdG9yKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGlmICghdGhpcy5uZXh0LmlzQ2hhcmFjdGVyKHRlcm1pbmF0b3IpKSB7XG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VMaXRlcmFsTWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkTEJSQUNFKTtcbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFJCUkFDRSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRDT0xPTik7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDRSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcCh0aGlzLnNwYW4oc3RhcnQpLCBrZXlzLCB2YWx1ZXMpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIGlzU2FmZSkge1xuICAgICAgICAgIGlmIChpc1NhZmUgPT09IHZvaWQgMCkgeyBpc1NhZmUgPSBmYWxzZTsgfVxuICAgICAgICAgIHZhciBzdGFydCA9IHJlY2VpdmVyLnNwYW4uc3RhcnQ7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCk7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLnNwYW4oc3RhcnQpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNTYWZlID8gbmV3IFNhZmVNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncykgOlxuICAgICAgICAgICAgICAgICAgbmV3IE1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIGlkLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpc1NhZmUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1RoZSBcXCc/LlxcJyBvcGVyYXRvciBjYW5ub3QgYmUgdXNlZCBpbiB0aGUgYXNzaWdubWVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKHRoaXMuc3BhbihzdGFydCksIHJlY2VpdmVyLCBpZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQmluZGluZ3MgY2Fubm90IGNvbnRhaW4gYXNzaWdubWVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZSh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlSZWFkKHRoaXMuc3BhbihzdGFydCksIHJlY2VpdmVyLCBpZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNhbGxBcmd1bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkUlBBUkVOKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIHZhciBwb3NpdGlvbmFscyA9IFtdO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICAgIHJldHVybiBwb3NpdGlvbmFscztcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEFuIGlkZW50aWZpZXIsIGEga2V5d29yZCwgYSBzdHJpbmcgd2l0aCBhbiBvcHRpb25hbCBgLWAgaW5iZXR3ZWVuLlxuICAgICAgICovXG4gICAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgdmFyIG9wZXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZygpO1xuICAgICAgICAgICAgICBvcGVyYXRvckZvdW5kID0gdGhpcy5vcHRpb25hbE9wZXJhdG9yKCctJyk7XG4gICAgICAgICAgICAgIGlmIChvcGVyYXRvckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJy0nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAob3BlcmF0b3JGb3VuZCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBiaW5kaW5ncyA9IFtdO1xuICAgICAgICAgIHZhciBwcmVmaXggPSBudWxsO1xuICAgICAgICAgIHZhciB3YXJuaW5ncyA9IFtdO1xuICAgICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBrZXlJc1ZhciA9IHRoaXMucGVla0tleXdvcmRMZXQoKTtcbiAgICAgICAgICAgICAgaWYgKGtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgICAgICAgaWYgKCFrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAga2V5ID0gcHJlZml4ICsga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKTtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gJ1xcJGltcGxpY2l0JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQgIT09IEVPRiAmJiAhdGhpcy5wZWVrS2V5d29yZExldCgpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbnB1dEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIHNvdXJjZSwgdGhpcy5sb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IFRlbXBsYXRlQmluZGluZyhrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSk7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQoYmluZGluZ3MsIHdhcm5pbmdzLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgX1BhcnNlQVNULnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBpbmRleCkge1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KGluZGV4KSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgfTtcbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUubG9jYXRpb25UZXh0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XG4gICAgICAgICAgaWYgKGlzQmxhbmsoaW5kZXgpKVxuICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyBcImF0IGNvbHVtbiBcIiArICh0aGlzLnRva2Vuc1tpbmRleF0uaW5kZXggKyAxKSArIFwiIGluXCIgOlxuICAgICAgICAgICAgICBcImF0IHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb25cIjtcbiAgICAgIH07XG4gICAgICAvLyBFcnJvciByZWNvdmVyeSBzaG91bGQgc2tpcCB0b2tlbnMgdW50aWwgaXQgZW5jb3VudGVycyBhIHJlY292ZXJ5IHBvaW50LiBza2lwKCkgdHJlYXRzXG4gICAgICAvLyB0aGUgZW5kIG9mIGlucHV0IGFuZCBhICc7JyBhcyB1bmNvbmRpdGlvbmFsbHkgYSByZWNvdmVyeSBwb2ludC4gSXQgYWxzbyB0cmVhdHMgJyknLFxuICAgICAgLy8gJ30nIGFuZCAnXScgYXMgY29uZGl0aW9uYWwgcmVjb3ZlcnkgcG9pbnRzIGlmIG9uZSBvZiBjYWxsaW5nIHByb2R1Y3Rpb25zIGlzIGV4cGVjdGluZ1xuICAgICAgLy8gb25lIG9mIHRoZXNlIHN5bWJvbHMuIFRoaXMgYWxsb3dzIHNraXAoKSB0byByZWNvdmVyIGZyb20gZXJyb3JzIHN1Y2ggYXMgJyhhLikgKyAxJyBhbGxvd2luZ1xuICAgICAgLy8gbW9yZSBvZiB0aGUgQVNUIHRvIGJlIHJldGFpbmVkIChpdCBkb2Vzbid0IHNraXAgYW55IHRva2VucyBhcyB0aGUgJyknIGlzIHJldGFpbmVkIGJlY2F1c2VcbiAgICAgIC8vIG9mIHRoZSAnKCcgYmVnaW5zIGFuICcoJyA8ZXhwcj4gJyknIHByb2R1Y3Rpb24pLiBUaGUgcmVjb3ZlcnkgcG9pbnRzIG9mIGdyb3VwaW5nIHN5bWJvbHNcbiAgICAgIC8vIG11c3QgYmUgY29uZGl0aW9uYWwgYXMgdGhleSBtdXN0IGJlIHNraXBwZWQgaWYgbm9uZSBvZiB0aGUgY2FsbGluZyBwcm9kdWN0aW9ucyBhcmUgbm90XG4gICAgICAvLyBleHBlY3RpbmcgdGhlIGNsb3NpbmcgdG9rZW4gZWxzZSB3ZSB3aWxsIG5ldmVyIG1ha2UgcHJvZ3Jlc3MgaW4gdGhlIGNhc2Ugb2YgYW5cbiAgICAgIC8vIGV4dHJhbmVvdXMgZ3JvdXAgY2xvc2luZyBzeW1ib2wgKHN1Y2ggYXMgYSBzdHJheSAnKScpLiBUaGlzIGlzIG5vdCB0aGUgY2FzZSBmb3IgJzsnIGJlY2F1c2VcbiAgICAgIC8vIHBhcnNlQ2hhaW4oKSBpcyBhbHdheXMgdGhlIHJvb3QgcHJvZHVjdGlvbiBhbmQgaXQgZXhwZWN0cyBhICc7Jy5cbiAgICAgIC8vIElmIGEgcHJvZHVjdGlvbiBleHBlY3RzIG9uZSBvZiB0aGVzZSB0b2tlbiBpdCBpbmNyZW1lbnRzIHRoZSBjb3JyZXNwb25kaW5nIG5lc3RpbmcgY291bnQsXG4gICAgICAvLyBhbmQgdGhlbiBkZWNyZW1lbnRzIGl0IGp1c3QgcHJpb3IgdG8gY2hlY2tpbmcgaWYgdGhlIHRva2VuIGlzIGluIHRoZSBpbnB1dC5cbiAgICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAmJiAhbi5pc0NoYXJhY3RlcigkU0VNSUNPTE9OKSAmJlxuICAgICAgICAgICAgICAodGhpcy5ycGFyZW5zRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUlBBUkVOKSkgJiZcbiAgICAgICAgICAgICAgKHRoaXMucmJyYWNlc0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJCUkFDRSkpICYmXG4gICAgICAgICAgICAgICh0aGlzLnJicmFja2V0c0V4cGVjdGVkIDw9IDAgfHwgIW4uaXNDaGFyYWN0ZXIoJFJCUkFDS0VUKSkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dC5pc0Vycm9yKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKHRoaXMubmV4dC50b1N0cmluZygpLCB0aGlzLmlucHV0LCB0aGlzLmxvY2F0aW9uVGV4dCgpLCB0aGlzLmxvY2F0aW9uKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfUGFyc2VBU1Q7XG4gIH0oKSk7XG4gIHZhciBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpIHtcbiAgICAgICAgICB0aGlzLnNpbXBsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5jaGVjayA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgcyA9IG5ldyBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICAgIGFzdC52aXNpdChzKTtcbiAgICAgICAgICByZXR1cm4gcy5zaW1wbGU7XG4gICAgICB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcyk7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy5zaW1wbGUgPSBmYWxzZTsgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRLZXllZFdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBhc3RzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgfTtcbiAgICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnNpbXBsZSA9IGZhbHNlOyB9O1xuICAgICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuc2ltcGxlID0gZmFsc2U7IH07XG4gICAgICByZXR1cm4gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XG4gIH0oKSk7XG5cbiAgdmFyIFBhcnNlTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VMb2NhdGlvbihmaWxlLCBvZmZzZXQsIGxpbmUsIGNvbCkge1xuICAgICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICAgIH1cbiAgICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5vZmZzZXQpID8gdGhpcy5maWxlLnVybCArIFwiQFwiICsgdGhpcy5saW5lICsgXCI6XCIgKyB0aGlzLmNvbCA6IHRoaXMuZmlsZS51cmw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBhcnNlTG9jYXRpb247XG4gIH0oKSk7XG4gIHZhciBQYXJzZVNvdXJjZUZpbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VGaWxlKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICB9XG4gICAgICByZXR1cm4gUGFyc2VTb3VyY2VGaWxlO1xuICB9KCkpO1xuICB2YXIgUGFyc2VTb3VyY2VTcGFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kLCBkZXRhaWxzKSB7XG4gICAgICAgICAgaWYgKGRldGFpbHMgPT09IHZvaWQgMCkgeyBkZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgfVxuICAgICAgUGFyc2VTb3VyY2VTcGFuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5maWxlLmNvbnRlbnQuc3Vic3RyaW5nKHRoaXMuc3RhcnQub2Zmc2V0LCB0aGlzLmVuZC5vZmZzZXQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBQYXJzZVNvdXJjZVNwYW47XG4gIH0oKSk7XG4gIHZhciBQYXJzZUVycm9yTGV2ZWw7XG4gIChmdW5jdGlvbiAoUGFyc2VFcnJvckxldmVsKSB7XG4gICAgICBQYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsW1wiV0FSTklOR1wiXSA9IDBdID0gXCJXQVJOSU5HXCI7XG4gICAgICBQYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsW1wiRkFUQUxcIl0gPSAxXSA9IFwiRkFUQUxcIjtcbiAgfSkoUGFyc2VFcnJvckxldmVsIHx8IChQYXJzZUVycm9yTGV2ZWwgPSB7fSkpO1xuICB2YXIgUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQYXJzZUVycm9yKHNwYW4sIG1zZywgbGV2ZWwpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IFBhcnNlRXJyb3JMZXZlbC5GQVRBTDsgfVxuICAgICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgfVxuICAgICAgUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgdmFyIGN0eFN0YXJ0ID0gdGhpcy5zcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICB2YXIgY29udGV4dFN0ciA9ICcnO1xuICAgICAgICAgIHZhciBkZXRhaWxzID0gJyc7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChjdHhTdGFydCkpIHtcbiAgICAgICAgICAgICAgaWYgKGN0eFN0YXJ0ID4gc291cmNlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIGN0eFN0YXJ0ID0gc291cmNlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGN0eEVuZCA9IGN0eFN0YXJ0O1xuICAgICAgICAgICAgICB2YXIgY3R4TGVuID0gMDtcbiAgICAgICAgICAgICAgdmFyIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGN0eExlbiA8IDEwMCAmJiBjdHhTdGFydCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eFN0YXJ0LS07XG4gICAgICAgICAgICAgICAgICBjdHhMZW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbY3R4U3RhcnRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY3R4TGluZXMgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3R4TGVuID0gMDtcbiAgICAgICAgICAgICAgY3R4TGluZXMgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAoY3R4TGVuIDwgMTAwICYmIGN0eEVuZCA8IHNvdXJjZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICBjdHhFbmQrKztcbiAgICAgICAgICAgICAgICAgIGN0eExlbisrO1xuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtjdHhFbmRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCsrY3R4TGluZXMgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKGN0eFN0YXJ0LCB0aGlzLnNwYW4uc3RhcnQub2Zmc2V0KSArICdbRVJST1IgLT5dJyArXG4gICAgICAgICAgICAgICAgICBzb3VyY2Uuc3Vic3RyaW5nKHRoaXMuc3Bhbi5zdGFydC5vZmZzZXQsIGN0eEVuZCArIDEpO1xuICAgICAgICAgICAgICBjb250ZXh0U3RyID0gXCIgKFxcXCJcIiArIGNvbnRleHQgKyBcIlxcXCIpXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnNwYW4uZGV0YWlscykge1xuICAgICAgICAgICAgICBkZXRhaWxzID0gXCIsIFwiICsgdGhpcy5zcGFuLmRldGFpbHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlwiICsgdGhpcy5tc2cgKyBjb250ZXh0U3RyICsgXCI6IFwiICsgdGhpcy5zcGFuLnN0YXJ0ICsgZGV0YWlscztcbiAgICAgIH07XG4gICAgICByZXR1cm4gUGFyc2VFcnJvcjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRleHQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIFRleHQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIFRleHQ7XG4gIH0oKSk7XG4gIHZhciBFeHBhbnNpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXhwYW5zaW9uKHN3aXRjaFZhbHVlLCB0eXBlLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWVTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZSA9IHN3aXRjaFZhbHVlO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4gPSBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBFeHBhbnNpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHBhbnNpb24odGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gRXhwYW5zaW9uO1xuICB9KCkpO1xuICB2YXIgRXhwYW5zaW9uQ2FzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFeHBhbnNpb25DYXNlKHZhbHVlLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB2YWx1ZVNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMudmFsdWVTb3VyY2VTcGFuID0gdmFsdWVTb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuZXhwU291cmNlU3BhbiA9IGV4cFNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBFeHBhbnNpb25DYXNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uQ2FzZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBFeHBhbnNpb25DYXNlO1xuICB9KCkpO1xuICB2YXIgQXR0cmlidXRlJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgIH1cbiAgICAgIEF0dHJpYnV0ZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEF0dHJpYnV0ZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBBdHRyaWJ1dGU7XG4gIH0oKSk7XG4gIHZhciBFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEVsZW1lbnQobmFtZSwgYXR0cnMsIGNoaWxkcmVuLCBzb3VyY2VTcGFuLCBzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgRWxlbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gRWxlbWVudDtcbiAgfSgpKTtcbiAgdmFyIENvbW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tbWVudCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQ29tbWVudC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdENvbW1lbnQodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gQ29tbWVudDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gdmlzaXRBbGwodmlzaXRvciwgbm9kZXMsIGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgIHZhciBhc3RSZXN1bHQgPSBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgVG9rZW5UeXBlJDE7XG4gIChmdW5jdGlvbiAoVG9rZW5UeXBlKSB7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX09QRU5fU1RBUlRcIl0gPSAwXSA9IFwiVEFHX09QRU5fU1RBUlRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJUQUdfT1BFTl9FTkRcIl0gPSAxXSA9IFwiVEFHX09QRU5fRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEFHX09QRU5fRU5EX1ZPSURcIl0gPSAyXSA9IFwiVEFHX09QRU5fRU5EX1ZPSURcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJUQUdfQ0xPU0VcIl0gPSAzXSA9IFwiVEFHX0NMT1NFXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiVEVYVFwiXSA9IDRdID0gXCJURVhUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVNDQVBBQkxFX1JBV19URVhUXCJdID0gNV0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlJBV19URVhUXCJdID0gNl0gPSBcIlJBV19URVhUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ09NTUVOVF9TVEFSVFwiXSA9IDddID0gXCJDT01NRU5UX1NUQVJUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ09NTUVOVF9FTkRcIl0gPSA4XSA9IFwiQ09NTUVOVF9FTkRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJDREFUQV9TVEFSVFwiXSA9IDldID0gXCJDREFUQV9TVEFSVFwiO1xuICAgICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNEQVRBX0VORFwiXSA9IDEwXSA9IFwiQ0RBVEFfRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQVRUUl9OQU1FXCJdID0gMTFdID0gXCJBVFRSX05BTUVcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJBVFRSX1ZBTFVFXCJdID0gMTJdID0gXCJBVFRSX1ZBTFVFXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRE9DX1RZUEVcIl0gPSAxM10gPSBcIkRPQ19UWVBFXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0ZPUk1fU1RBUlRcIl0gPSAxNF0gPSBcIkVYUEFOU0lPTl9GT1JNX1NUQVJUXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfVkFMVUVcIl0gPSAxNV0gPSBcIkVYUEFOU0lPTl9DQVNFX1ZBTFVFXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXCJdID0gMTZdID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFWFBBTlNJT05fQ0FTRV9FWFBfRU5EXCJdID0gMTddID0gXCJFWFBBTlNJT05fQ0FTRV9FWFBfRU5EXCI7XG4gICAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRVhQQU5TSU9OX0ZPUk1fRU5EXCJdID0gMThdID0gXCJFWFBBTlNJT05fRk9STV9FTkRcIjtcbiAgICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFT0ZcIl0gPSAxOV0gPSBcIkVPRlwiO1xuICB9KShUb2tlblR5cGUkMSB8fCAoVG9rZW5UeXBlJDEgPSB7fSkpO1xuICB2YXIgVG9rZW4kMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUb2tlbih0eXBlLCBwYXJ0cywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICByZXR1cm4gVG9rZW47XG4gIH0oKSk7XG4gIHZhciBUb2tlbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ1KFRva2VuRXJyb3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBUb2tlbkVycm9yKGVycm9yTXNnLCB0b2tlblR5cGUsIHNwYW4pIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBlcnJvck1zZyk7XG4gICAgICAgICAgdGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gVG9rZW5FcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBUb2tlbml6ZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUb2tlbml6ZVJlc3VsdCh0b2tlbnMsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRva2VuaXplUmVzdWx0O1xuICB9KCkpO1xuICBmdW5jdGlvbiB0b2tlbml6ZShzb3VyY2UsIHVybCwgZ2V0VGFnRGVmaW5pdGlvbiwgdG9rZW5pemVFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgaWYgKHRva2VuaXplRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgIHJldHVybiBuZXcgX1Rva2VuaXplcihuZXcgUGFyc2VTb3VyY2VGaWxlKHNvdXJjZSwgdXJsKSwgZ2V0VGFnRGVmaW5pdGlvbiwgdG9rZW5pemVFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZylcbiAgICAgICAgICAudG9rZW5pemUoKTtcbiAgfVxuICB2YXIgX0NSX09SX0NSTEZfUkVHRVhQID0gL1xcclxcbj8vZztcbiAgZnVuY3Rpb24gX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyhjaGFyQ29kZSkge1xuICAgICAgdmFyIGNoYXIgPSBjaGFyQ29kZSA9PT0gJEVPRiA/ICdFT0YnIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgICByZXR1cm4gXCJVbmV4cGVjdGVkIGNoYXJhY3RlciBcXFwiXCIgKyBjaGFyICsgXCJcXFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gX3Vua25vd25FbnRpdHlFcnJvck1zZyhlbnRpdHlTcmMpIHtcbiAgICAgIHJldHVybiBcIlVua25vd24gZW50aXR5IFxcXCJcIiArIGVudGl0eVNyYyArIFwiXFxcIiAtIHVzZSB0aGUgXFxcIiYjPGRlY2ltYWw+O1xcXCIgb3IgIFxcXCImI3g8aGV4PjtcXFwiIHN5bnRheFwiO1xuICB9XG4gIHZhciBfQ29udHJvbEZsb3dFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfQ29udHJvbEZsb3dFcnJvcihlcnJvcikge1xuICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfQ29udHJvbEZsb3dFcnJvcjtcbiAgfSgpKTtcbiAgLy8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCN3cml0aW5nXG4gIHZhciBfVG9rZW5pemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIF9maWxlIFRoZSBodG1sIHNvdXJjZVxuICAgICAgICogQHBhcmFtIF9nZXRUYWdEZWZpbml0aW9uXG4gICAgICAgKiBAcGFyYW0gX3Rva2VuaXplSWN1IFdoZXRoZXIgdG8gdG9rZW5pemUgSUNVIG1lc3NhZ2VzIChjb25zaWRlcmVkIGFzIHRleHQgbm9kZXMgd2hlbiBmYWxzZSlcbiAgICAgICAqIEBwYXJhbSBfaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBfVG9rZW5pemVyKF9maWxlLCBfZ2V0VGFnRGVmaW5pdGlvbiwgX3Rva2VuaXplSWN1LCBfaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChfaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IF9pbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHRoaXMuX2ZpbGUgPSBfZmlsZTtcbiAgICAgICAgICB0aGlzLl9nZXRUYWdEZWZpbml0aW9uID0gX2dldFRhZ0RlZmluaXRpb247XG4gICAgICAgICAgdGhpcy5fdG9rZW5pemVJY3UgPSBfdG9rZW5pemVJY3U7XG4gICAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICAgIC8vIE5vdGU6IHRoaXMgaXMgYWx3YXlzIGxvd2VyY2FzZSFcbiAgICAgICAgICB0aGlzLl9wZWVrID0gLTE7XG4gICAgICAgICAgdGhpcy5fbmV4dFBlZWsgPSAtMTtcbiAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IC0xO1xuICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjayA9IFtdO1xuICAgICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9pbnB1dCA9IF9maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgdGhpcy5fbGVuZ3RoID0gX2ZpbGUuY29udGVudC5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgfVxuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuICAgICAgICAgIC8vIEluIG9yZGVyIHRvIGtlZXAgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UsIHdlIGNhbiBub3RcbiAgICAgICAgICAvLyBwcmUtcHJvY2VzcyBpdC5cbiAgICAgICAgICAvLyBJbnN0ZWFkIENScyBhcmUgcHJvY2Vzc2VkIHJpZ2h0IGJlZm9yZSBpbnN0YW50aWF0aW5nIHRoZSB0b2tlbnMuXG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZShfQ1JfT1JfQ1JMRl9SRUdFWFAsICdcXG4nKTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gJEVPRikge1xuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkQkFORykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTUlOVVMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRG9jVHlwZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ0Nsb3NlKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5fdG9rZW5pemVJY3UgfHwgIXRoaXMuX3Rva2VuaXplRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBfQ29udHJvbEZsb3dFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRU9GKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUb2tlbml6ZVJlc3VsdChtZXJnZVRleHRUb2tlbnModGhpcy50b2tlbnMpLCB0aGlzLmVycm9ycyk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBhbiBJQ1UgdG9rZW4gaGFzIGJlZW4gY3JlYXRlZFxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl90b2tlbml6ZUV4cGFuc2lvbkZvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGlzRXhwYW5zaW9uRm9ybVN0YXJ0KHRoaXMuX2lucHV0LCB0aGlzLl9pbmRleCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRXhwYW5zaW9uQ2FzZVN0YXJ0KHRoaXMuX3BlZWspICYmIHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRSQlJBQ0UpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25DYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1FbmQoKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUxvY2F0aW9uKHRoaXMuX2ZpbGUsIHRoaXMuX2luZGV4LCB0aGlzLl9saW5lLCB0aGlzLl9jb2x1bW4pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9nZXRTcGFuID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9iZWdpblRva2VuID0gZnVuY3Rpb24gKHR5cGUsIHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpOyB9XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gdHlwZTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZW5kVG9rZW4gPSBmdW5jdGlvbiAocGFydHMsIGVuZCkge1xuICAgICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSB0aGlzLl9nZXRMb2NhdGlvbigpOyB9XG4gICAgICAgICAgdmFyIHRva2VuID0gbmV3IFRva2VuJDEodGhpcy5fY3VycmVudFRva2VuVHlwZSwgcGFydHMsIG5ldyBQYXJzZVNvdXJjZVNwYW4odGhpcy5fY3VycmVudFRva2VuU3RhcnQsIGVuZCkpO1xuICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NyZWF0ZUVycm9yID0gZnVuY3Rpb24gKG1zZywgc3Bhbikge1xuICAgICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICAgIG1zZyArPSBcIiAoRG8geW91IGhhdmUgYW4gdW5lc2NhcGVkIFxcXCJ7XFxcIiBpbiB5b3VyIHRlbXBsYXRlPyBVc2UgXFxcInt7ICd7JyB9fVxcXCIpIHRvIGVzY2FwZSBpdC4pXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBUb2tlbkVycm9yKG1zZywgdGhpcy5fY3VycmVudFRva2VuVHlwZSwgc3Bhbik7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBuZXcgX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZygkRU9GKSwgdGhpcy5fZ2V0U3BhbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRMRikge1xuICAgICAgICAgICAgICB0aGlzLl9saW5lKys7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsgIT09ICRMRiAmJiB0aGlzLl9wZWVrICE9PSAkQ1IpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY29sdW1uKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgICAgdGhpcy5fcGVlayA9IHRoaXMuX2luZGV4ID49IHRoaXMuX2xlbmd0aCA/ICRFT0YgOiB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMuX2luZGV4KTtcbiAgICAgICAgICB0aGlzLl9uZXh0UGVlayA9XG4gICAgICAgICAgICAgIHRoaXMuX2luZGV4ICsgMSA+PSB0aGlzLl9sZW5ndGggPyAkRU9GIDogdGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLl9pbmRleCArIDEpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKHRoaXMuX3BlZWssIGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVDaGFyQ29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoY2hhckNvZGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4obG9jYXRpb24sIGxvY2F0aW9uKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0U3RyID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgICBpZiAodGhpcy5faW5kZXggKyBsZW4gPiB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5pdGlhbFBvc2l0aW9uID0gdGhpcy5fc2F2ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgYXR0ZW1wdGluZyB0byBwYXJzZSB0aGUgc3RyaW5nIGZhaWxzLCB3ZSB3YW50IHRvIHJlc2V0IHRoZSBwYXJzZXJcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHdoZXJlIGl0IHdhcyBiZWZvcmUgdGhlIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihpbml0aWFsUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXF1aXJlU3RyID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgICAgdmFyIGxvY2F0aW9uID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRTdHIoY2hhcnMpKSB7XG4gICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4obG9jYXRpb24pKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4gPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgd2hpbGUgKCFwcmVkaWNhdGUodGhpcy5fcGVlaykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGxlbikge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihwcmVkaWNhdGUpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbmRleCAtIHN0YXJ0Lm9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKHN0YXJ0LCBzdGFydCkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdFVudGlsQ2hhciA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVhZENoYXIgPSBmdW5jdGlvbiAoZGVjb2RlRW50aXRpZXMpIHtcbiAgICAgICAgICBpZiAoZGVjb2RlRW50aXRpZXMgJiYgdGhpcy5fcGVlayA9PT0gJEFNUEVSU0FORCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlRW50aXR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRbaW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZGVjb2RlRW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEhBU0gpKSB7XG4gICAgICAgICAgICAgIHZhciBpc0hleCA9IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkeCkgfHwgdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRYKTtcbiAgICAgICAgICAgICAgdmFyIG51bWJlclN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKS5vZmZzZXQ7XG4gICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNEaWdpdEVudGl0eUVuZCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB2YXIgc3RyTnVtID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG51bWJlclN0YXJ0LCB0aGlzLl9pbmRleCAtIDEpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyTnVtLCBpc0hleCA/IDE2IDogMTApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW50aXR5ID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCArIDEsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKGVudGl0eSksIHRoaXMuX2dldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05hbWVkRW50aXR5RW5kKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsgIT0gJFNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzdG9yZVBvc2l0aW9uKHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICcmJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMSwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgdmFyIGNoYXIgPSBOQU1FRF9FTlRJVElFU1tuYW1lXzFdO1xuICAgICAgICAgICAgICBpZiAoIWNoYXIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2cobmFtZV8xKSwgdGhpcy5fZ2V0U3BhbihzdGFydCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjaGFyO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVJhd1RleHQgPSBmdW5jdGlvbiAoZGVjb2RlRW50aXRpZXMsIGZpcnN0Q2hhck9mRW5kLCBhdHRlbXB0RW5kUmVzdCkge1xuICAgICAgICAgIHZhciB0YWdDbG9zZVN0YXJ0O1xuICAgICAgICAgIHZhciB0ZXh0U3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oZGVjb2RlRW50aXRpZXMgPyBUb2tlblR5cGUkMS5FU0NBUEFCTEVfUkFXX1RFWFQgOiBUb2tlblR5cGUkMS5SQVdfVEVYVCwgdGV4dFN0YXJ0KTtcbiAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICB0YWdDbG9zZVN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZShmaXJzdENoYXJPZkVuZCkgJiYgYXR0ZW1wdEVuZFJlc3QoKSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2luZGV4ID4gdGFnQ2xvc2VTdGFydC5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgY2hhcmFjdGVycyBjb25zdW1lZCBieSB0aGUgcHJldmlvdXMgaWYgc3RhdGVtZW50IHRvIHRoZSBvdXRwdXRcbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW5wdXQuc3Vic3RyaW5nKHRhZ0Nsb3NlU3RhcnQub2Zmc2V0LCB0aGlzLl9pbmRleCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSBmaXJzdENoYXJPZkVuZCkge1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcihkZWNvZGVFbnRpdGllcykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldLCB0YWdDbG9zZVN0YXJ0KTtcbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUNvbW1lbnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ09NTUVOVF9TVEFSVCwgc3RhcnQpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTUlOVVMpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgICB2YXIgdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZmFsc2UsICRNSU5VUywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJy0+Jyk7IH0pO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ09NTUVOVF9FTkQsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQ2RhdGEgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCdDREFUQVsnKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgdmFyIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGZhbHNlLCAkUkJSQUNLRVQsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9hdHRlbXB0U3RyKCddPicpOyB9KTtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNEQVRBX0VORCwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVEb2NUeXBlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5ET0NfVFlQRSwgc3RhcnQpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoJEdUKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydC5vZmZzZXQgKyAyLCB0aGlzLl9pbmRleCAtIDEpXSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVQcmVmaXhBbmROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuYW1lT3JQcmVmaXhTdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgIHZhciBwcmVmaXggPSBudWxsO1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSAkQ09MT04gJiYgIWlzUHJlZml4RW5kKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWVTdGFydDtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJENPTE9OKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG5hbWVPclByZWZpeFN0YXJ0LCB0aGlzLl9pbmRleCAtIDEpO1xuICAgICAgICAgICAgICBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWVTdGFydCA9IG5hbWVPclByZWZpeFN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuKGlzTmFtZUVuZCwgdGhpcy5faW5kZXggPT09IG5hbWVTdGFydCA/IDEgOiAwKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhuYW1lU3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUYWdPcGVuID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgdmFyIHNhdmVkUG9zID0gdGhpcy5fc2F2ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgdmFyIHRhZ05hbWU7XG4gICAgICAgICAgdmFyIGxvd2VyY2FzZVRhZ05hbWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFpc0FzY2lpTGV0dGVyKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW5TdGFydChzdGFydCk7XG4gICAgICAgICAgICAgIHRhZ05hbWUgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcobmFtZVN0YXJ0LCB0aGlzLl9pbmRleCk7XG4gICAgICAgICAgICAgIGxvd2VyY2FzZVRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09ICRTTEFTSCAmJiB0aGlzLl9wZWVrICE9PSAkR1QpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVOYW1lKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRFUSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW5FbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBfQ29udHJvbEZsb3dFcnJvcikge1xuICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgc3RhcnQgdGFnIGlzIGludmFsaWQsIGFzc3VtZSB3ZSB3YW50IGEgXCI8XCJcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihzYXZlZFBvcyk7XG4gICAgICAgICAgICAgICAgICAvLyBCYWNrIHRvIGJhY2sgdGV4dCB0b2tlbnMgYXJlIG1lcmdlZCBhdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFsnPCddKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY29udGVudFRva2VuVHlwZSA9IHRoaXMuX2dldFRhZ0RlZmluaXRpb24odGFnTmFtZSkuY29udGVudFR5cGU7XG4gICAgICAgICAgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKGxvd2VyY2FzZVRhZ05hbWUsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoY29udGVudFRva2VuVHlwZSA9PT0gVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKGxvd2VyY2FzZVRhZ05hbWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVJhd1RleHRXaXRoVGFnQ2xvc2UgPSBmdW5jdGlvbiAobG93ZXJjYXNlVGFnTmFtZSwgZGVjb2RlRW50aXRpZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciB0ZXh0VG9rZW4gPSB0aGlzLl9jb25zdW1lUmF3VGV4dChkZWNvZGVFbnRpdGllcywgJExULCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlKGxvd2VyY2FzZVRhZ05hbWUpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICBfdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkR1QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEFHX0NMT1NFLCB0ZXh0VG9rZW4uc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtudWxsLCBsb3dlcmNhc2VUYWdOYW1lXSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUYWdPcGVuU3RhcnQgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJULCBzdGFydCk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihwYXJ0cyk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQVRUUl9OQU1FKTtcbiAgICAgICAgICB2YXIgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4ocHJlZml4QW5kTmFtZSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpO1xuICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJFNRIHx8IHRoaXMuX3BlZWsgPT09ICREUSkge1xuICAgICAgICAgICAgICB2YXIgcXVvdGVDaGFyID0gdGhpcy5fcGVlaztcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IHF1b3RlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcih0cnVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihpc05hbWVFbmQsIDEpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyh2YWx1ZVN0YXJ0LCB0aGlzLl9pbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHZhbHVlKV0pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnT3BlbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdG9rZW5UeXBlID0gdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkgPyBUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkRfVk9JRCA6IFRva2VuVHlwZSQxLlRBR19PUEVOX0VORDtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKHRva2VuVHlwZSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGFnQ2xvc2UgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19DTE9TRSwgc3RhcnQpO1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICB2YXIgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLnB1c2goVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLl9yZWFkVW50aWwoJENPTU1BKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbY29uZGl0aW9uXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRDT01NQSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3R5cGVdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9WQUxVRSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fcmVhZFVudGlsKCRMQlJBQ0UpLnRyaW0oKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbdmFsdWVdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wdXNoKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRSQlJBQ0UpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLnBvcCgpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lRXhwYW5zaW9uRm9ybUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRSQlJBQ0UpO1xuICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucG9wKCk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5URVhULCBzdGFydCk7XG4gICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyAmJiB0aGlzLl9hdHRlbXB0U3RyKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnICYmIHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQpICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX3JlYWRDaGFyKHRydWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKCF0aGlzLl9pc1RleHRFbmQoKSk7XG4gICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzVGV4dEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJExUIHx8IHRoaXMuX3BlZWsgPT09ICRFT0YpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl90b2tlbml6ZUljdSAmJiAhdGhpcy5faW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChpc0V4cGFuc2lvbkZvcm1TdGFydCh0aGlzLl9pbnB1dCwgdGhpcy5faW5kZXgsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzdGFydCBvZiBhbiBleHBhbnNpb24gZm9ybVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRSQlJBQ0UgJiYgdGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgLy8gZW5kIG9mIGFuZCBleHBhbnNpb24gY2FzZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9zYXZlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFt0aGlzLl9wZWVrLCB0aGlzLl9pbmRleCwgdGhpcy5fY29sdW1uLCB0aGlzLl9saW5lLCB0aGlzLnRva2Vucy5sZW5ndGhdO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZWFkVW50aWwgPSBmdW5jdGlvbiAoY2hhcikge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoY2hhcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgfTtcbiAgICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXN0b3JlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgICB0aGlzLl9wZWVrID0gcG9zaXRpb25bMF07XG4gICAgICAgICAgdGhpcy5faW5kZXggPSBwb3NpdGlvblsxXTtcbiAgICAgICAgICB0aGlzLl9jb2x1bW4gPSBwb3NpdGlvblsyXTtcbiAgICAgICAgICB0aGlzLl9saW5lID0gcG9zaXRpb25bM107XG4gICAgICAgICAgdmFyIG5iVG9rZW5zID0gcG9zaXRpb25bNF07XG4gICAgICAgICAgaWYgKG5iVG9rZW5zIDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgZXh0cmEgdG9rZW5zXG4gICAgICAgICAgICAgIHRoaXMudG9rZW5zID0gdGhpcy50b2tlbnMuc2xpY2UoMCwgbmJUb2tlbnMpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNJbkV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFja1t0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoIC0gMV0gPT09XG4gICAgICAgICAgICAgICAgICBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQ7XG4gICAgICB9O1xuICAgICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzSW5FeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgICAgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9Ub2tlbml6ZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGlzTm90V2hpdGVzcGFjZShjb2RlKSB7XG4gICAgICByZXR1cm4gIWlzV2hpdGVzcGFjZShjb2RlKSB8fCBjb2RlID09PSAkRU9GO1xuICB9XG4gIGZ1bmN0aW9uIGlzTmFtZUVuZChjb2RlKSB7XG4gICAgICByZXR1cm4gaXNXaGl0ZXNwYWNlKGNvZGUpIHx8IGNvZGUgPT09ICRHVCB8fCBjb2RlID09PSAkU0xBU0ggfHxcbiAgICAgICAgICBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRFUTtcbiAgfVxuICBmdW5jdGlvbiBpc1ByZWZpeEVuZChjb2RlKSB7XG4gICAgICByZXR1cm4gKGNvZGUgPCAkYSB8fCAkeiA8IGNvZGUpICYmIChjb2RlIDwgJEEgfHwgJFogPCBjb2RlKSAmJlxuICAgICAgICAgIChjb2RlIDwgJDAgfHwgY29kZSA+ICQ5KTtcbiAgfVxuICBmdW5jdGlvbiBpc0RpZ2l0RW50aXR5RW5kKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID09ICRTRU1JQ09MT04gfHwgY29kZSA9PSAkRU9GIHx8ICFpc0FzY2lpSGV4RGlnaXQoY29kZSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNOYW1lZEVudGl0eUVuZChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA9PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT0gJEVPRiB8fCAhaXNBc2NpaUxldHRlcihjb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBpc0V4cGFuc2lvbkZvcm1TdGFydChpbnB1dCwgb2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICB2YXIgaXNJbnRlcnBvbGF0aW9uU3RhcnQgPSBpbnRlcnBvbGF0aW9uQ29uZmlnID8gaW5wdXQuaW5kZXhPZihpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0LCBvZmZzZXQpID09IG9mZnNldCA6IGZhbHNlO1xuICAgICAgcmV0dXJuIGlucHV0LmNoYXJDb2RlQXQob2Zmc2V0KSA9PSAkTEJSQUNFICYmICFpc0ludGVycG9sYXRpb25TdGFydDtcbiAgfVxuICBmdW5jdGlvbiBpc0V4cGFuc2lvbkNhc2VTdGFydChwZWVrKSB7XG4gICAgICByZXR1cm4gcGVlayA9PT0gJEVRIHx8IGlzQXNjaWlMZXR0ZXIocGVlayk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKGNvZGUxLCBjb2RlMikge1xuICAgICAgcmV0dXJuIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTEpID09IHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTIpO1xuICB9XG4gIGZ1bmN0aW9uIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiA/IGNvZGUgLSAkYSArICRBIDogY29kZTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZVRleHRUb2tlbnMoc3JjVG9rZW5zKSB7XG4gICAgICB2YXIgZHN0VG9rZW5zID0gW107XG4gICAgICB2YXIgbGFzdERzdFRva2VuO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmNUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBzcmNUb2tlbnNbaV07XG4gICAgICAgICAgaWYgKGxhc3REc3RUb2tlbiAmJiBsYXN0RHN0VG9rZW4udHlwZSA9PSBUb2tlblR5cGUkMS5URVhUICYmIHRva2VuLnR5cGUgPT0gVG9rZW5UeXBlJDEuVEVYVCkge1xuICAgICAgICAgICAgICBsYXN0RHN0VG9rZW4ucGFydHNbMF0gKz0gdG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgICAgIGxhc3REc3RUb2tlbi5zb3VyY2VTcGFuLmVuZCA9IHRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdERzdFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgIGRzdFRva2Vucy5wdXNoKGxhc3REc3RUb2tlbik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRzdFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgVHJlZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ0KFRyZWVFcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbXNnKTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnROYW1lID0gZWxlbWVudE5hbWU7XG4gICAgICB9XG4gICAgICBUcmVlRXJyb3IuY3JlYXRlID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBzcGFuLCBtc2cpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gVHJlZUVycm9yO1xuICB9KFBhcnNlRXJyb3IpKTtcbiAgdmFyIFBhcnNlVHJlZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQYXJzZVRyZWVSZXN1bHQocm9vdE5vZGVzLCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLnJvb3ROb2RlcyA9IHJvb3ROb2RlcztcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBQYXJzZVRyZWVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBQYXJzZXIkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQYXJzZXIoZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbiA9IGdldFRhZ0RlZmluaXRpb247XG4gICAgICB9XG4gICAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgaWYgKHBhcnNlRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyBwYXJzZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgdmFyIHRva2Vuc0FuZEVycm9ycyA9IHRva2VuaXplKHNvdXJjZSwgdXJsLCB0aGlzLmdldFRhZ0RlZmluaXRpb24sIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciB0cmVlQW5kRXJyb3JzID0gbmV3IF9UcmVlQnVpbGRlcih0b2tlbnNBbmRFcnJvcnMudG9rZW5zLCB0aGlzLmdldFRhZ0RlZmluaXRpb24pLmJ1aWxkKCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodHJlZUFuZEVycm9ycy5yb290Tm9kZXMsIHRva2Vuc0FuZEVycm9ycy5lcnJvcnMuY29uY2F0KHRyZWVBbmRFcnJvcnMuZXJyb3JzKSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBhcnNlcjtcbiAgfSgpKTtcbiAgdmFyIF9UcmVlQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfVHJlZUJ1aWxkZXIodG9rZW5zLCBnZXRUYWdEZWZpbml0aW9uKSB7XG4gICAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICAgIHRoaXMuX3Jvb3ROb2RlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgIH1cbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlJDEuRU9GKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lU3RhcnRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19DTE9TRSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUVuZFRhZyh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDZGF0YSh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuQ09NTUVOVF9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRFWFQgfHwgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5SQVdfVEVYVCB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FU0NBUEFCTEVfUkFXX1RFWFQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbih0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gU2tpcCBhbGwgb3RoZXIgdG9rZW5zLi4uXG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodGhpcy5fcm9vdE5vZGVzLCB0aGlzLl9lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkdmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9wZWVrO1xuICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgLy8gTm90ZTogdGhlcmUgaXMgYWx3YXlzIGFuIEVPRiB0b2tlbiBhdCB0aGUgZW5kXG4gICAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3BlZWsgPSB0aGlzLnRva2Vuc1t0aGlzLl9pbmRleF07XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fYWR2YW5jZUlmID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVDZGF0YSA9IGZ1bmN0aW9uIChzdGFydFRva2VuKSB7XG4gICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuQ0RBVEFfRU5EKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQ29tbWVudCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5fYWR2YW5jZUlmKFRva2VuVHlwZSQxLlJBV19URVhUKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuQ09NTUVOVF9FTkQpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGlzUHJlc2VudCh0ZXh0KSA/IHRleHQucGFydHNbMF0udHJpbSgpIDogbnVsbDtcbiAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgQ29tbWVudCh2YWx1ZSwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb24gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgc3dpdGNoVmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGNhc2VzID0gW107XG4gICAgICAgICAgLy8gcmVhZCA9XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfVkFMVUUpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cENhc2UgPSB0aGlzLl9wYXJzZUV4cGFuc2lvbkNhc2UoKTtcbiAgICAgICAgICAgICAgaWYgKCFleHBDYXNlKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlcnJvclxuICAgICAgICAgICAgICBjYXNlcy5wdXNoKGV4cENhc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZWFkIHRoZSBmaW5hbCB9XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHRva2VuLnNvdXJjZVNwYW4uc3RhcnQsIHRoaXMuX3BlZWsuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBFeHBhbnNpb24oc3dpdGNoVmFsdWUucGFydHNbMF0sIHR5cGUucGFydHNbMF0sIGNhc2VzLCBzb3VyY2VTcGFuLCBzd2l0Y2hWYWx1ZS5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3BhcnNlRXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgLy8gcmVhZCB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ3snLlwiKSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByZWFkIHVudGlsIH1cbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGV4cCA9IHRoaXMuX2NvbGxlY3RFeHBhbnNpb25FeHBUb2tlbnMoc3RhcnQpO1xuICAgICAgICAgIGlmICghZXhwKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgZW5kID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIGV4cC5wdXNoKG5ldyBUb2tlbiQxKFRva2VuVHlwZSQxLkVPRiwgW10sIGVuZC5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgLy8gcGFyc2UgZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHsgYW5kIH1cbiAgICAgICAgICB2YXIgcGFyc2VkRXhwID0gbmV3IF9UcmVlQnVpbGRlcihleHAsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbikuYnVpbGQoKTtcbiAgICAgICAgICBpZiAocGFyc2VkRXhwLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IHRoaXMuX2Vycm9ycy5jb25jYXQocGFyc2VkRXhwLmVycm9ycyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odmFsdWUuc291cmNlU3Bhbi5zdGFydCwgZW5kLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICB2YXIgZXhwU291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnQuc291cmNlU3Bhbi5zdGFydCwgZW5kLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEV4cGFuc2lvbkNhc2UodmFsdWUucGFydHNbMF0sIHBhcnNlZEV4cC5yb290Tm9kZXMsIHNvdXJjZVNwYW4sIHZhbHVlLnNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbGxlY3RFeHBhbnNpb25FeHBUb2tlbnMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICB2YXIgZXhwID0gW107XG4gICAgICAgICAgdmFyIGV4cGFuc2lvbkZvcm1TdGFjayA9IFtUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlRdO1xuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUIHx8XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnB1c2godGhpcy5fcGVlay50eXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfRU5EKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBhbnNpb25Gb3JtU3RhY2subGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9FTkQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsYXN0T25TdGFjayhleHBhbnNpb25Gb3JtU3RhY2ssIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVPRikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBleHAucHVzaCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciB0ZXh0ID0gdG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiB0ZXh0WzBdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnRfMSkgJiYgcGFyZW50XzEuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnRfMS5uYW1lKS5pZ25vcmVGaXJzdExmKSB7XG4gICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgVGV4dCh0ZXh0LCB0b2tlbi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2Nsb3NlVm9pZEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBlbCA9IExpc3RXcmFwcGVyLmxhc3QodGhpcy5fZWxlbWVudFN0YWNrKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKS5pc1ZvaWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lU3RhcnRUYWcgPSBmdW5jdGlvbiAoc3RhcnRUYWdUb2tlbikge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBzdGFydFRhZ1Rva2VuLnBhcnRzWzBdO1xuICAgICAgICAgIHZhciBuYW1lID0gc3RhcnRUYWdUb2tlbi5wYXJ0c1sxXTtcbiAgICAgICAgICB2YXIgYXR0cnMgPSBbXTtcbiAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5BVFRSX05BTUUpIHtcbiAgICAgICAgICAgICAgYXR0cnMucHVzaCh0aGlzLl9jb25zdW1lQXR0cih0aGlzLl9hZHZhbmNlKCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5fZ2V0RWxlbWVudEZ1bGxOYW1lKHByZWZpeCwgbmFtZSwgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKTtcbiAgICAgICAgICB2YXIgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAvLyBOb3RlOiBUaGVyZSBjb3VsZCBoYXZlIGJlZW4gYSB0b2tlbml6ZXIgZXJyb3JcbiAgICAgICAgICAvLyBzbyB0aGF0IHdlIGRvbid0IGdldCBhIHRva2VuIGZvciB0aGUgZW5kIHRhZy4uLlxuICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgc2VsZkNsb3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgdGFnRGVmID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKTtcbiAgICAgICAgICAgICAgaWYgKCEodGFnRGVmLmNhblNlbGZDbG9zZSB8fCBnZXROc1ByZWZpeChmdWxsTmFtZSkgIT09IG51bGwgfHwgdGFnRGVmLmlzVm9pZCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIHN0YXJ0VGFnVG9rZW4uc291cmNlU3BhbiwgXCJPbmx5IHZvaWQgYW5kIGZvcmVpZ24gZWxlbWVudHMgY2FuIGJlIHNlbGYgY2xvc2VkIFxcXCJcIiArIHN0YXJ0VGFnVG9rZW4ucGFydHNbMV0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVuZCA9IHRoaXMuX3BlZWsuc291cmNlU3Bhbi5zdGFydDtcbiAgICAgICAgICB2YXIgc3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQpO1xuICAgICAgICAgIHZhciBlbCA9IG5ldyBFbGVtZW50KGZ1bGxOYW1lLCBhdHRycywgW10sIHNwYW4sIHNwYW4sIG51bGwpO1xuICAgICAgICAgIHRoaXMuX3B1c2hFbGVtZW50KGVsKTtcbiAgICAgICAgICBpZiAoc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSk7XG4gICAgICAgICAgICAgIGVsLmVuZFNvdXJjZVNwYW4gPSBzcGFuO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9wdXNoRWxlbWVudCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50RWwgPSBMaXN0V3JhcHBlci5sYXN0KHRoaXMuX2VsZW1lbnRTdGFjayk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50RWwubmFtZSkuaXNDbG9zZWRCeUNoaWxkKGVsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRhZ0RlZiA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKTtcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50U2tpcHBpbmdDb250YWluZXJzKCksIHBhcmVudCA9IF9hLnBhcmVudCwgY29udGFpbmVyID0gX2EuY29udGFpbmVyO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSAmJiB0YWdEZWYucmVxdWlyZUV4dHJhUGFyZW50KHBhcmVudC5uYW1lKSkge1xuICAgICAgICAgICAgICB2YXIgbmV3UGFyZW50ID0gbmV3IEVsZW1lbnQodGFnRGVmLnBhcmVudFRvQWRkLCBbXSwgW10sIGVsLnNvdXJjZVNwYW4sIGVsLnN0YXJ0U291cmNlU3BhbiwgZWwuZW5kU291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHRoaXMuX2luc2VydEJlZm9yZUNvbnRhaW5lcihwYXJlbnQsIGNvbnRhaW5lciwgbmV3UGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQoZWwpO1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wdXNoKGVsKTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lRW5kVGFnID0gZnVuY3Rpb24gKGVuZFRhZ1Rva2VuKSB7XG4gICAgICAgICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5fZ2V0RWxlbWVudEZ1bGxOYW1lKGVuZFRhZ1Rva2VuLnBhcnRzWzBdLCBlbmRUYWdUb2tlbi5wYXJ0c1sxXSwgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKTtcbiAgICAgICAgICBpZiAodGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKS5lbmRTb3VyY2VTcGFuID0gZW5kVGFnVG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihmdWxsTmFtZSkuaXNWb2lkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiVm9pZCBlbGVtZW50cyBkbyBub3QgaGF2ZSBlbmQgdGFncyBcXFwiXCIgKyBlbmRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9wb3BFbGVtZW50KGZ1bGxOYW1lKSkge1xuICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuLCBcIlVuZXhwZWN0ZWQgY2xvc2luZyB0YWcgXFxcIlwiICsgZW5kVGFnVG9rZW4ucGFydHNbMV0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9wb3BFbGVtZW50ID0gZnVuY3Rpb24gKGZ1bGxOYW1lKSB7XG4gICAgICAgICAgZm9yICh2YXIgc3RhY2tJbmRleCA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBzdGFja0luZGV4ID49IDA7IHN0YWNrSW5kZXgtLSkge1xuICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9lbGVtZW50U3RhY2tbc3RhY2tJbmRleF07XG4gICAgICAgICAgICAgIGlmIChlbC5uYW1lID09IGZ1bGxOYW1lKSB7XG4gICAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5zcGxpY2UodGhpcy5fZWxlbWVudFN0YWNrLCBzdGFja0luZGV4LCB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gc3RhY2tJbmRleCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKS5jbG9zZWRCeVBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQXR0ciA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICAgIHZhciBmdWxsTmFtZSA9IG1lcmdlTnNBbmROYW1lKGF0dHJOYW1lLnBhcnRzWzBdLCBhdHRyTmFtZS5wYXJ0c1sxXSk7XG4gICAgICAgICAgdmFyIGVuZCA9IGF0dHJOYW1lLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgICAgZW5kID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGUkMShmdWxsTmFtZSwgdmFsdWUsIG5ldyBQYXJzZVNvdXJjZVNwYW4oYXR0ck5hbWUuc291cmNlU3Bhbi5zdGFydCwgZW5kKSk7XG4gICAgICB9O1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UGFyZW50RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCA+IDAgPyBMaXN0V3JhcHBlci5sYXN0KHRoaXMuX2VsZW1lbnRTdGFjaykgOiBudWxsO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0aGUgcGFyZW50IGluIHRoZSBET00gYW5kIHRoZSBjb250YWluZXIuXG4gICAgICAgKlxuICAgICAgICogYDxuZy1jb250YWluZXI+YCBlbGVtZW50cyBhcmUgc2tpcHBlZCBhcyB0aGV5IGFyZSBub3QgcmVuZGVyZWQgYXMgRE9NIGVsZW1lbnQuXG4gICAgICAgKi9cbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnRTa2lwcGluZ0NvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudFN0YWNrW2ldLm5hbWUgIT09ICduZy1jb250YWluZXInKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geyBwYXJlbnQ6IHRoaXMuX2VsZW1lbnRTdGFja1tpXSwgY29udGFpbmVyOiBjb250YWluZXIgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLl9lbGVtZW50U3RhY2tbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IHBhcmVudDogTGlzdFdyYXBwZXIubGFzdCh0aGlzLl9lbGVtZW50U3RhY2spLCBjb250YWluZXI6IGNvbnRhaW5lciB9O1xuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2FkZFRvUGFyZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIG5vZGUgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY29udGFpbmVyLlxuICAgICAgICogV2hlbiBubyBjb250YWluZXIgaXMgZ2l2ZW4sIHRoZSBub2RlIGlzIGFwcGVuZGVkIGFzIGEgY2hpbGQgb2YgdGhlIHBhcmVudC5cbiAgICAgICAqIEFsc28gdXBkYXRlcyB0aGUgZWxlbWVudCBzdGFjayBhY2NvcmRpbmdseS5cbiAgICAgICAqXG4gICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAqL1xuICAgICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5faW5zZXJ0QmVmb3JlQ29udGFpbmVyID0gZnVuY3Rpb24gKHBhcmVudCwgY29udGFpbmVyLCBub2RlKSB7XG4gICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobm9kZSk7XG4gICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgY29udGFpbmVyIHdpdGggdGhlIG5ldyBub2RlIGluIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5zcGxpY2UodGhpcy5fZWxlbWVudFN0YWNrLmluZGV4T2YoY29udGFpbmVyKSwgMCwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldEVsZW1lbnRGdWxsTmFtZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGxvY2FsTmFtZSwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIGlmIChpc0JsYW5rKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGxvY2FsTmFtZSkuaW1wbGljaXROYW1lc3BhY2VQcmVmaXg7XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHByZWZpeCkgJiYgaXNQcmVzZW50KHBhcmVudEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICBwcmVmaXggPSBnZXROc1ByZWZpeChwYXJlbnRFbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9UcmVlQnVpbGRlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gbGFzdE9uU3RhY2soc3RhY2ssIGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBzdGFjay5sZW5ndGggPiAwICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBlbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICBmdW5jdGlvbiBkaWdlc3RNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBzaGExKHNlcmlhbGl6ZU5vZGVzKG1lc3NhZ2Uubm9kZXMpLmpvaW4oJycpICsgKFwiW1wiICsgbWVzc2FnZS5tZWFuaW5nICsgXCJdXCIpKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBpMThuIGFzdCB0byBzb21ldGhpbmcgeG1sLWxpa2UgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgYW4gVUlELlxuICAgKlxuICAgKiBUaGUgdmlzaXRvciBpcyBhbHNvIHVzZWQgaW4gdGhlIGkxOG4gcGFyc2VyIHRlc3RzXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIF9TZXJpYWxpemVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfU2VyaWFsaXplclZpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBcIltcIiArIGNvbnRhaW5lci5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pLmpvaW4oJywgJykgKyBcIl1cIjtcbiAgICAgIH07XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIChrICsgXCIge1wiICsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKSArIFwifVwiKTsgfSk7XG4gICAgICAgICAgcmV0dXJuIFwie1wiICsgaWN1LmV4cHJlc3Npb24gKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIiArIHN0ckNhc2VzLmpvaW4oJywgJykgKyBcIn1cIjtcbiAgICAgIH07XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBwaC5pc1ZvaWQgP1xuICAgICAgICAgICAgICBcIjxwaCB0YWcgbmFtZT1cXFwiXCIgKyBwaC5zdGFydE5hbWUgKyBcIlxcXCIvPlwiIDpcbiAgICAgICAgICAgICAgXCI8cGggdGFnIG5hbWU9XFxcIlwiICsgcGguc3RhcnROYW1lICsgXCJcXFwiPlwiICsgcGguY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcsICcpICsgXCI8L3BoIG5hbWU9XFxcIlwiICsgcGguY2xvc2VOYW1lICsgXCJcXFwiPlwiO1xuICAgICAgfTtcbiAgICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBcIjxwaCBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCI+XCIgKyBwaC52YWx1ZSArIFwiPC9waD5cIjtcbiAgICAgIH07XG4gICAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gXCI8cGggaWN1IG5hbWU9XFxcIlwiICsgcGgubmFtZSArIFwiXFxcIj5cIiArIHBoLnZhbHVlLnZpc2l0KHRoaXMpICsgXCI8L3BoPlwiO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfU2VyaWFsaXplclZpc2l0b3I7XG4gIH0oKSk7XG4gIHZhciBzZXJpYWxpemVyVmlzaXRvciA9IG5ldyBfU2VyaWFsaXplclZpc2l0b3IoKTtcbiAgZnVuY3Rpb24gc2VyaWFsaXplTm9kZXMobm9kZXMpIHtcbiAgICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudmlzaXQoc2VyaWFsaXplclZpc2l0b3IsIG51bGwpOyB9KTtcbiAgfVxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgU0hBMSBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gICAqXG4gICAqIHNlZSBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTQvZmlwcy0xODAtNC5wZGZcbiAgICpcbiAgICogV0FSTklORzogdGhpcyBmdW5jdGlvbiBoYXMgbm90IGJlZW4gZGVzaWduZWQgbm90IHRlc3RlZCB3aXRoIHNlY3VyaXR5IGluIG1pbmQuXG4gICAqICAgICAgICAgIERPIE5PVCBVU0UgSVQgSU4gQSBTRUNVUklUWSBTRU5TSVRJVkUgQ09OVEVYVC5cbiAgICovXG4gIGZ1bmN0aW9uIHNoYTEoc3RyKSB7XG4gICAgICB2YXIgdXRmOCA9IHV0ZjhFbmNvZGUoc3RyKTtcbiAgICAgIHZhciB3b3JkczMyID0gc3RyaW5nVG9Xb3JkczMyKHV0ZjgpO1xuICAgICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoICogODtcbiAgICAgIHZhciB3ID0gbmV3IEFycmF5KDgwKTtcbiAgICAgIHZhciBfYSA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXSwgYSA9IF9hWzBdLCBiID0gX2FbMV0sIGMgPSBfYVsyXSwgZCA9IF9hWzNdLCBlID0gX2FbNF07XG4gICAgICB3b3JkczMyW2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgICAgIHdvcmRzMzJbKChsZW4gKyA2NCA+PiA5KSA8PCA0KSArIDE1XSA9IGxlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMzMi5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICB2YXIgX2IgPSBbYSwgYiwgYywgZCwgZV0sIGgwID0gX2JbMF0sIGgxID0gX2JbMV0sIGgyID0gX2JbMl0sIGgzID0gX2JbM10sIGg0ID0gX2JbNF07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgIHdbal0gPSB3b3JkczMyW2kgKyBqXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdbal0gPSByb2wzMih3W2ogLSAzXSBeIHdbaiAtIDhdIF4gd1tqIC0gMTRdIF4gd1tqIC0gMTZdLCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgX2MgPSBmayhqLCBiLCBjLCBkKSwgZiA9IF9jWzBdLCBrID0gX2NbMV07XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gW3JvbDMyKGEsIDUpLCBmLCBlLCBrLCB3W2pdXS5yZWR1Y2UoYWRkMzIpO1xuICAgICAgICAgICAgICBfZCA9IFtkLCBjLCByb2wzMihiLCAzMCksIGEsIHRlbXBdLCBlID0gX2RbMF0sIGQgPSBfZFsxXSwgYyA9IF9kWzJdLCBiID0gX2RbM10sIGEgPSBfZFs0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2UgPSBbYWRkMzIoYSwgaDApLCBhZGQzMihiLCBoMSksIGFkZDMyKGMsIGgyKSwgYWRkMzIoZCwgaDMpLCBhZGQzMihlLCBoNCldLCBhID0gX2VbMF0sIGIgPSBfZVsxXSwgYyA9IF9lWzJdLCBkID0gX2VbM10sIGUgPSBfZVs0XTtcbiAgICAgIH1cbiAgICAgIHZhciBzaGExID0gd29yZHMzMlRvU3RyaW5nKFthLCBiLCBjLCBkLCBlXSk7XG4gICAgICB2YXIgaGV4ID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYTEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgYl8xID0gc2hhMS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgIGhleCArPSAoYl8xID4+PiA0ICYgMHgwZikudG9TdHJpbmcoMTYpICsgKGJfMSAmIDB4MGYpLnRvU3RyaW5nKDE2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZXgudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBfZCwgX2U7XG4gIH1cbiAgZnVuY3Rpb24gdXRmOEVuY29kZShzdHIpIHtcbiAgICAgIHZhciBlbmNvZGVkID0gJyc7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBkZWNvZGVTdXJyb2dhdGVQYWlycyhzdHIsIGluZGV4KTtcbiAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDdmZikge1xuICAgICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IGNvZGVQb2ludCA+Pj4gNiwgMHg4MCB8IGNvZGVQb2ludCAmIDB4M2YpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgY29kZVBvaW50ID4+PiAxMiwgMHg4MCB8IGNvZGVQb2ludCA+Pj4gNiAmIDB4M2YsIDB4ODAgfCBjb2RlUG9pbnQgJiAweDNmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgY29kZVBvaW50ID4+PiAxOCwgMHg4MCB8IGNvZGVQb2ludCA+Pj4gMTIgJiAweDNmLCAweDgwIHwgY29kZVBvaW50ID4+PiA2ICYgMHgzZiwgMHg4MCB8IGNvZGVQb2ludCAmIDB4M2YpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGVkO1xuICB9XG4gIC8vIHNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgZnVuY3Rpb24gZGVjb2RlU3Vycm9nYXRlUGFpcnMoc3RyLCBpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXg9XCIgKyBpbmRleCArIFwiIGlzIG91dCBvZiByYW5nZSBpbiBcXFwiXCIgKyBzdHIgKyBcIlxcXCJcIik7XG4gICAgICB9XG4gICAgICB2YXIgaGlnaCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgIHZhciBsb3c7XG4gICAgICBpZiAoaGlnaCA+PSAweGQ4MDAgJiYgaGlnaCA8PSAweGRmZmYgJiYgc3RyLmxlbmd0aCA+IGluZGV4ICsgMSkge1xuICAgICAgICAgIGxvdyA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgaWYgKGxvdyA+PSAweGRjMDAgJiYgbG93IDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICByZXR1cm4gKGhpZ2ggLSAweGQ4MDApICogMHg0MDAgKyBsb3cgLSAweGRjMDAgKyAweDEwMDAwO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoaWdoO1xuICB9XG4gIGZ1bmN0aW9uIHN0cmluZ1RvV29yZHMzMihzdHIpIHtcbiAgICAgIHZhciB3b3JkczMyID0gQXJyYXkoc3RyLmxlbmd0aCA+Pj4gMik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB3b3JkczMyW2ldID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd29yZHMzMltpID4+PiAyXSB8PSAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCA4ICogKDMgLSBpICYgMHgzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JkczMyO1xuICB9XG4gIGZ1bmN0aW9uIHdvcmRzMzJUb1N0cmluZyh3b3JkczMyKSB7XG4gICAgICB2YXIgc3RyID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoICogNDsgaSsrKSB7XG4gICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHdvcmRzMzJbaSA+Pj4gMl0gPj4+IDggKiAoMyAtIGkgJiAweDMpKSAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgfVxuICBmdW5jdGlvbiBmayhpbmRleCwgYiwgYywgZCkge1xuICAgICAgaWYgKGluZGV4IDwgMjApIHtcbiAgICAgICAgICByZXR1cm4gWyhiICYgYykgfCAofmIgJiBkKSwgMHg1YTgyNzk5OV07XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPCA0MCkge1xuICAgICAgICAgIHJldHVybiBbYiBeIGMgXiBkLCAweDZlZDllYmExXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA8IDYwKSB7XG4gICAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCksIDB4OGYxYmJjZGNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtiIF4gYyBeIGQsIDB4Y2E2MmMxZDZdO1xuICB9XG4gIGZ1bmN0aW9uIGFkZDMyKGEsIGIpIHtcbiAgICAgIHZhciBsb3cgPSAoYSAmIDB4ZmZmZikgKyAoYiAmIDB4ZmZmZik7XG4gICAgICB2YXIgaGlnaCA9IChhID4+IDE2KSArIChiID4+IDE2KSArIChsb3cgPj4gMTYpO1xuICAgICAgcmV0dXJuIChoaWdoIDw8IDE2KSB8IChsb3cgJiAweGZmZmYpO1xuICB9XG4gIGZ1bmN0aW9uIHJvbDMyKGEsIGNvdW50KSB7XG4gICAgICByZXR1cm4gKGEgPDwgY291bnQpIHwgKGEgPj4+ICgzMiAtIGNvdW50KSk7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBNZXNzYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIG5vZGVzIG1lc3NhZ2UgQVNUXG4gICAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXJzIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gc3RhdGljIGNvbnRlbnRcbiAgICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlclRvTXNnSWRzIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gdHJhbnNsYXRhYmxlIG1lc3NhZ2UgSURzICh1c2VkIGZvciBJQ1VcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzKVxuICAgICAgICogQHBhcmFtIG1lYW5pbmdcbiAgICAgICAqIEBwYXJhbSBkZXNjcmlwdGlvblxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBNZXNzYWdlKG5vZGVzLCBwbGFjZWhvbGRlcnMsIHBsYWNlaG9sZGVyVG9Nc2dJZHMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gcGxhY2Vob2xkZXJzO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJUb01zZ0lkcyA9IHBsYWNlaG9sZGVyVG9Nc2dJZHM7XG4gICAgICAgICAgdGhpcy5tZWFuaW5nID0gbWVhbmluZztcbiAgICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gTWVzc2FnZTtcbiAgfSgpKTtcbiAgdmFyIFRleHQkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZXh0KHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBUZXh0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICAgIHJldHVybiBUZXh0O1xuICB9KCkpO1xuICB2YXIgQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbnRhaW5lcihjaGlsZHJlbiwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgQ29udGFpbmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGFpbmVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIENvbnRhaW5lcjtcbiAgfSgpKTtcbiAgdmFyIEljdSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJY3UoZXhwcmVzc2lvbiwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBJY3UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRJY3UodGhpcywgY29udGV4dCk7IH07XG4gICAgICByZXR1cm4gSWN1O1xuICB9KCkpO1xuICB2YXIgVGFnUGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGFnUGxhY2Vob2xkZXIodGFnLCBhdHRycywgc3RhcnROYW1lLCBjbG9zZU5hbWUsIGNoaWxkcmVuLCBpc1ZvaWQsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgICAgdGhpcy5zdGFydE5hbWUgPSBzdGFydE5hbWU7XG4gICAgICAgICAgdGhpcy5jbG9zZU5hbWUgPSBjbG9zZU5hbWU7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHRoaXMuaXNWb2lkID0gaXNWb2lkO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBUYWdQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRhZ1BsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIFRhZ1BsYWNlaG9sZGVyO1xuICB9KCkpO1xuICB2YXIgUGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUGxhY2Vob2xkZXIodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAnJzsgfVxuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIFBsYWNlaG9sZGVyO1xuICB9KCkpO1xuICB2YXIgSWN1UGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSWN1UGxhY2Vob2xkZXIodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAnJzsgfVxuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICBJY3VQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEljdVBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgICAgcmV0dXJuIEljdVBsYWNlaG9sZGVyO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIFRBR19UT19QTEFDRUhPTERFUl9OQU1FUyA9IHtcbiAgICAgICdBJzogJ0xJTksnLFxuICAgICAgJ0InOiAnQk9MRF9URVhUJyxcbiAgICAgICdCUic6ICdMSU5FX0JSRUFLJyxcbiAgICAgICdFTSc6ICdFTVBIQVNJU0VEX1RFWFQnLFxuICAgICAgJ0gxJzogJ0hFQURJTkdfTEVWRUwxJyxcbiAgICAgICdIMic6ICdIRUFESU5HX0xFVkVMMicsXG4gICAgICAnSDMnOiAnSEVBRElOR19MRVZFTDMnLFxuICAgICAgJ0g0JzogJ0hFQURJTkdfTEVWRUw0JyxcbiAgICAgICdINSc6ICdIRUFESU5HX0xFVkVMNScsXG4gICAgICAnSDYnOiAnSEVBRElOR19MRVZFTDYnLFxuICAgICAgJ0hSJzogJ0hPUklaT05UQUxfUlVMRScsXG4gICAgICAnSSc6ICdJVEFMSUNfVEVYVCcsXG4gICAgICAnTEknOiAnTElTVF9JVEVNJyxcbiAgICAgICdMSU5LJzogJ01FRElBX0xJTksnLFxuICAgICAgJ09MJzogJ09SREVSRURfTElTVCcsXG4gICAgICAnUCc6ICdQQVJBR1JBUEgnLFxuICAgICAgJ1EnOiAnUVVPVEFUSU9OJyxcbiAgICAgICdTJzogJ1NUUklLRVRIUk9VR0hfVEVYVCcsXG4gICAgICAnU01BTEwnOiAnU01BTExfVEVYVCcsXG4gICAgICAnU1VCJzogJ1NVQlNUUklQVCcsXG4gICAgICAnU1VQJzogJ1NVUEVSU0NSSVBUJyxcbiAgICAgICdUQk9EWSc6ICdUQUJMRV9CT0RZJyxcbiAgICAgICdURCc6ICdUQUJMRV9DRUxMJyxcbiAgICAgICdURk9PVCc6ICdUQUJMRV9GT09URVInLFxuICAgICAgJ1RIJzogJ1RBQkxFX0hFQURFUl9DRUxMJyxcbiAgICAgICdUSEVBRCc6ICdUQUJMRV9IRUFERVInLFxuICAgICAgJ1RSJzogJ1RBQkxFX1JPVycsXG4gICAgICAnVFQnOiAnTU9OT1NQQUNFRF9URVhUJyxcbiAgICAgICdVJzogJ1VOREVSTElORURfVEVYVCcsXG4gICAgICAnVUwnOiAnVU5PUkRFUkVEX0xJU1QnLFxuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyB1bmlxdWUgbmFtZXMgZm9yIHBsYWNlaG9sZGVyIHdpdGggZGlmZmVyZW50IGNvbnRlbnRcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgUGxhY2Vob2xkZXJSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQbGFjZWhvbGRlclJlZ2lzdHJ5KCkge1xuICAgICAgICAgIC8vIENvdW50IHRoZSBvY2N1cnJlbmNlIG9mIHRoZSBiYXNlIG5hbWUgdG9wIGdlbmVyYXRlIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHMgPSB7fTtcbiAgICAgICAgICAvLyBNYXBzIHNpZ25hdHVyZSB0byBwbGFjZWhvbGRlciBuYW1lc1xuICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZSA9IHt9O1xuICAgICAgfVxuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUgPSBmdW5jdGlvbiAodGFnLCBhdHRycywgaXNWb2lkKSB7XG4gICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuX2hhc2hUYWcodGFnLCBhdHRycywgaXNWb2lkKTtcbiAgICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoaXNWb2lkID8gYmFzZU5hbWUgOiBcIlNUQVJUX1wiICsgYmFzZU5hbWUpO1xuICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gbmFtZTtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH07XG4gICAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gdGhpcy5faGFzaENsb3NpbmdUYWcodGFnKTtcbiAgICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoXCJDTE9TRV9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IG5hbWU7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgICB2YXIgdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBcIlBIOiBcIiArIHVwcGVyTmFtZSArIFwiPVwiICsgY29udGVudDtcbiAgICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdW5pcXVlTmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZSh1cHBlck5hbWUpO1xuICAgICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gdW5pcXVlTmFtZTtcbiAgICAgICAgICByZXR1cm4gdW5pcXVlTmFtZTtcbiAgICAgIH07XG4gICAgICAvLyBHZW5lcmF0ZSBhIGhhc2ggZm9yIGEgdGFnIC0gZG9lcyBub3QgdGFrZSBhdHRyaWJ1dGUgb3JkZXIgaW50byBhY2NvdW50XG4gICAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaFRhZyA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBcIjxcIiArIHRhZztcbiAgICAgICAgICB2YXIgc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykuc29ydCgpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gKFwiIFwiICsgbmFtZSArIFwiPVwiICsgYXR0cnNbbmFtZV0pOyB9KS5qb2luKCcnKTtcbiAgICAgICAgICB2YXIgZW5kID0gaXNWb2lkID8gJy8+JyA6IFwiPjwvXCIgKyB0YWcgKyBcIj5cIjtcbiAgICAgICAgICByZXR1cm4gc3RhcnQgKyBzdHJBdHRycyArIGVuZDtcbiAgICAgIH07XG4gICAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaENsb3NpbmdUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0aGlzLl9oYXNoVGFnKFwiL1wiICsgdGFnLCB7fSwgZmFsc2UpOyB9O1xuICAgICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuX2dlbmVyYXRlVW5pcXVlTmFtZSA9IGZ1bmN0aW9uIChiYXNlKSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBiYXNlO1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW25hbWVdO1xuICAgICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgICBuZXh0ID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWUgKz0gXCJfXCIgKyBuZXh0O1xuICAgICAgICAgICAgICBuZXh0Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXSA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBsYWNlaG9sZGVyUmVnaXN0cnk7XG4gIH0oKSk7XG5cbiAgdmFyIF9leHBQYXJzZXIgPSBuZXcgUGFyc2VyKG5ldyBMZXhlcigpKTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiBjb252ZXJ0aW5nIGh0bWwgbm9kZXMgdG8gYW4gaTE4biBNZXNzYWdlIGdpdmVuIGFuIGludGVycG9sYXRpb25Db25maWdcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBfSTE4blZpc2l0b3IoX2V4cFBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbikge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnRvSTE4bk1lc3NhZ2Uobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uKTtcbiAgICAgIH07XG4gIH1cbiAgdmFyIF9JMThuVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfSTE4blZpc2l0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5fZXhwcmVzc2lvblBhcnNlciA9IF9leHByZXNzaW9uUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgIH1cbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudG9JMThuTWVzc2FnZSA9IGZ1bmN0aW9uIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICB0aGlzLl9pc0ljdSA9IG5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGVzWzBdIGluc3RhbmNlb2YgRXhwYW5zaW9uO1xuICAgICAgICAgIHRoaXMuX2ljdURlcHRoID0gMDtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5ID0gbmV3IFBsYWNlaG9sZGVyUmVnaXN0cnkoKTtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudCA9IHt9O1xuICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9JZHMgPSB7fTtcbiAgICAgICAgICB2YXIgaTE4bm9kZXMgPSB2aXNpdEFsbCh0aGlzLCBub2Rlcywge30pO1xuICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShpMThub2RlcywgdGhpcy5fcGxhY2Vob2xkZXJUb0NvbnRlbnQsIHRoaXMuX3BsYWNlaG9sZGVyVG9JZHMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uKTtcbiAgICAgIH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIC8vIERvIG5vdCB2aXNpdCB0aGUgYXR0cmlidXRlcywgdHJhbnNsYXRhYmxlIG9uZXMgYXJlIHRvcC1sZXZlbCBBU1RzXG4gICAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpc1ZvaWQgPSBnZXRIdG1sVGFnRGVmaW5pdGlvbihlbC5uYW1lKS5pc1ZvaWQ7XG4gICAgICAgICAgdmFyIHN0YXJ0UGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lLCBhdHRycywgaXNWb2lkKTtcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtzdGFydFBoTmFtZV0gPSBlbC5zb3VyY2VTcGFuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgdmFyIGNsb3NlUGhOYW1lID0gJyc7XG4gICAgICAgICAgaWYgKCFpc1ZvaWQpIHtcbiAgICAgICAgICAgICAgY2xvc2VQaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldENsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKGVsLm5hbWUpO1xuICAgICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtjbG9zZVBoTmFtZV0gPSBcIjwvXCIgKyBlbC5uYW1lICsgXCI+XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVGFnUGxhY2Vob2xkZXIoZWwubmFtZSwgYXR0cnMsIHN0YXJ0UGhOYW1lLCBjbG9zZVBoTmFtZSwgY2hpbGRyZW4sIGlzVm9pZCwgZWwuc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24oYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgICB9O1xuICAgICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5faWN1RGVwdGgrKztcbiAgICAgICAgICB2YXIgaTE4bkljdUNhc2VzID0ge307XG4gICAgICAgICAgdmFyIGkxOG5JY3UgPSBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGkxOG5JY3VDYXNlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIGljdS5jYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChjYXplKSB7XG4gICAgICAgICAgICAgIGkxOG5JY3VDYXNlc1tjYXplLnZhbHVlXSA9IG5ldyBDb250YWluZXIoY2F6ZS5leHByZXNzaW9uLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcywge30pOyB9KSwgY2F6ZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLl9pY3VEZXB0aC0tO1xuICAgICAgICAgIGlmICh0aGlzLl9pc0ljdSB8fCB0aGlzLl9pY3VEZXB0aCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG1lc3NhZ2UgKHZzIGEgcGFydCBvZiB0aGUgbWVzc2FnZSkgaXMgYW4gSUNVIG1lc3NhZ2UgcmV0dXJucyBpdFxuICAgICAgICAgICAgICByZXR1cm4gaTE4bkljdTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRWxzZSByZXR1cm5zIGEgcGxhY2Vob2xkZXJcbiAgICAgICAgICAvLyBJQ1UgcGxhY2Vob2xkZXJzIHNob3VsZCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0aGVpciBvcmlnaW5hbCBjb250ZW50IGJ1dCB3aXRoIHRoZSB0aGVpclxuICAgICAgICAgIC8vIHRyYW5zbGF0aW9ucy4gV2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgdmlzaXRvciAodGhleSBhcmUgbm90IHJlLWVudHJhbnQpIHRvIGNvbXB1dGUgdGhlXG4gICAgICAgICAgLy8gbWVzc2FnZSBpZC5cbiAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBhZGQgYSBodG1sLk5vZGUgLT4gaTE4bi5NZXNzYWdlIGNhY2hlIHRvIGF2b2lkIGhhdmluZyB0byByZS1jcmVhdGUgdGhlIG1zZ1xuICAgICAgICAgIHZhciBwaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZSgnSUNVJywgaWN1LnNvdXJjZVNwYW4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKHRoaXMuX2V4cHJlc3Npb25QYXJzZXIsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9JZHNbcGhOYW1lXSA9IGRpZ2VzdE1lc3NhZ2UodmlzaXRvci50b0kxOG5NZXNzYWdlKFtpY3VdLCAnJywgJycpKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEljdVBsYWNlaG9sZGVyKGkxOG5JY3UsIHBoTmFtZSwgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uICh0ZXh0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIHNwbGl0SW50ZXJwb2xhdGlvbiA9IHRoaXMuX2V4cHJlc3Npb25QYXJzZXIuc3BsaXRJbnRlcnBvbGF0aW9uKHRleHQsIHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKSwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKCFzcGxpdEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gTm8gZXhwcmVzc2lvbiwgcmV0dXJuIGEgc2luZ2xlIHRleHRcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDEodGV4dCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiBhIGdyb3VwIG9mIHRleHQgKyBleHByZXNzaW9uc1xuICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKG5vZGVzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLCBzRGVsaW1pdGVyID0gX2Euc3RhcnQsIGVEZWxpbWl0ZXIgPSBfYS5lbmQ7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGxpdEludGVycG9sYXRpb24uc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBzcGxpdEludGVycG9sYXRpb24uZXhwcmVzc2lvbnNbaV07XG4gICAgICAgICAgICAgIHZhciBiYXNlTmFtZSA9IF9leHRyYWN0UGxhY2Vob2xkZXJOYW1lKGV4cHJlc3Npb24pIHx8ICdJTlRFUlBPTEFUSU9OJztcbiAgICAgICAgICAgICAgdmFyIHBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0UGxhY2Vob2xkZXJOYW1lKGJhc2VOYW1lLCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2ldLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgUGxhY2Vob2xkZXIoZXhwcmVzc2lvbiwgcGhOYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W3BoTmFtZV0gPSBzRGVsaW1pdGVyICsgZXhwcmVzc2lvbiArIGVEZWxpbWl0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBsYXN0IGluZGV4IGNvbnRhaW5zIG5vIGV4cHJlc3Npb25cbiAgICAgICAgICB2YXIgbGFzdFN0cmluZ0lkeCA9IHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzW2xhc3RTdHJpbmdJZHhdLmxlbmd0aCkge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbbGFzdFN0cmluZ0lkeF0sIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0kxOG5WaXNpdG9yO1xuICB9KCkpO1xuICB2YXIgX0NVU1RPTV9QSF9FWFAgPSAvXFwvXFwvW1xcc1xcU10qaTE4bltcXHNcXFNdKlxcKFtcXHNcXFNdKnBoW1xcc1xcU10qPVtcXHNcXFNdKlwiKFtcXHNcXFNdKj8pXCJbXFxzXFxTXSpcXCkvZztcbiAgZnVuY3Rpb24gX2V4dHJhY3RQbGFjZWhvbGRlck5hbWUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC5zcGxpdChfQ1VTVE9NX1BIX0VYUClbMV07XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLyoqXG4gICAqIEFuIGkxOG4gZXJyb3IuXG4gICAqL1xuICB2YXIgSTE4bkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ2KEkxOG5FcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEkxOG5FcnJvcihzcGFuLCBtc2cpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtc2cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEkxOG5FcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG5cbiAgdmFyIF9JMThOX0FUVFIgPSAnaTE4bic7XG4gIHZhciBfSTE4Tl9BVFRSX1BSRUZJWCA9ICdpMThuLSc7XG4gIHZhciBfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAgPSAvXmkxOG46Py87XG4gIC8qKlxuICAgKiBFeHRyYWN0IHRyYW5zbGF0YWJsZSBtZXNzYWdlcyBmcm9tIGFuIGh0bWwgQVNUXG4gICAqL1xuICBmdW5jdGlvbiBleHRyYWN0TWVzc2FnZXMobm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICAgIHJldHVybiB2aXNpdG9yLmV4dHJhY3Qobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICB9XG4gIGZ1bmN0aW9uIG1lcmdlVHJhbnNsYXRpb25zKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICAgIHJldHVybiB2aXNpdG9yLm1lcmdlKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcpO1xuICB9XG4gIHZhciBFeHRyYWN0aW9uUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4dHJhY3Rpb25SZXN1bHQobWVzc2FnZXMsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBFeHRyYWN0aW9uUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgX1Zpc2l0b3JNb2RlO1xuICAoZnVuY3Rpb24gKF9WaXNpdG9yTW9kZSkge1xuICAgICAgX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZVtcIkV4dHJhY3RcIl0gPSAwXSA9IFwiRXh0cmFjdFwiO1xuICAgICAgX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZVtcIk1lcmdlXCJdID0gMV0gPSBcIk1lcmdlXCI7XG4gIH0pKF9WaXNpdG9yTW9kZSB8fCAoX1Zpc2l0b3JNb2RlID0ge30pKTtcbiAgLyoqXG4gICAqIFRoaXMgVmlzaXRvciBpcyB1c2VkOlxuICAgKiAxLiB0byBleHRyYWN0IGFsbCB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3MgZnJvbSBhbiBodG1sIEFTVCAoc2VlIGBleHRyYWN0KClgKSxcbiAgICogMi4gdG8gcmVwbGFjZSB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3Mgd2l0aCB0aGUgYWN0dWFsIHRyYW5zbGF0aW9ucyAoc2VlIGBtZXJnZSgpYClcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgX1Zpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1Zpc2l0b3IoX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgICB0aGlzLl9pbXBsaWNpdFRhZ3MgPSBfaW1wbGljaXRUYWdzO1xuICAgICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRXh0cmFjdHMgdGhlIG1lc3NhZ2VzIGZyb20gdGhlIHRyZWVcbiAgICAgICAqL1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLkV4dHJhY3QsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMsIG51bGwpOyB9KTtcbiAgICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0sICdVbmNsb3NlZCBibG9jaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEV4dHJhY3Rpb25SZXN1bHQodGhpcy5fbWVzc2FnZXMsIHRoaXMuX2Vycm9ycyk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgdHJlZSB3aGVyZSBhbGwgdHJhbnNsYXRhYmxlIG5vZGVzIGFyZSB0cmFuc2xhdGVkXG4gICAgICAgKi9cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdChfVmlzaXRvck1vZGUuTWVyZ2UsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9ucyA9IHRyYW5zbGF0aW9ucztcbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgZmFrZSByb290IGVsZW1lbnRcbiAgICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBFbGVtZW50KCd3cmFwcGVyJywgW10sIG5vZGVzLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgICB2YXIgdHJhbnNsYXRlZE5vZGUgPSB3cmFwcGVyLnZpc2l0KHRoaXMsIG51bGwpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgJ1VuY2xvc2VkIGJsb2NrJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRyYW5zbGF0ZWROb2RlLmNoaWxkcmVuLCB0aGlzLl9lcnJvcnMpO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICAgIC8vIFBhcnNlIGNhc2VzIGZvciB0cmFuc2xhdGFibGUgaHRtbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKGljdUNhc2UudmFsdWUsIGV4cHJlc3Npb24sIGljdUNhc2Uuc291cmNlU3BhbiwgaWN1Q2FzZS52YWx1ZVNvdXJjZVNwYW4sIGljdUNhc2UuZXhwU291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4oaWN1KTtcbiAgICAgICAgICB2YXIgd2FzSW5JY3UgPSB0aGlzLl9pbkljdTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICAgIC8vIG5lc3RlZCBJQ1UgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBleHRyYWN0ZWQgYnV0IHRvcC1sZXZlbCB0cmFuc2xhdGVkIGFzIGEgd2hvbGVcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKFtpY3VdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9pbkljdSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjYXNlcyA9IHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcywgY29udGV4dCk7XG4gICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgICBpY3UgPSBuZXcgRXhwYW5zaW9uKGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3BhbiwgaWN1LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2luSWN1ID0gd2FzSW5JY3U7XG4gICAgICAgICAgcmV0dXJuIGljdTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgaXNPcGVuaW5nID0gX2lzT3BlbmluZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgaWYgKGlzT3BlbmluZyAmJiB0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnQ291bGQgbm90IHN0YXJ0IGEgYmxvY2sgaW5zaWRlIGEgdHJhbnNsYXRhYmxlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNDbG9zaW5nID0gX2lzQ2xvc2luZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgaWYgKGlzQ2xvc2luZyAmJiAhdGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ1RyeWluZyB0byBjbG9zZSBhbiB1bm9wZW5lZCBibG9jaycpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5faW5JMThuTm9kZSAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzT3BlbmluZykge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0RGVwdGggPSB0aGlzLl9kZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja0NoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYyA9IGNvbW1lbnQudmFsdWUucmVwbGFjZShfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlcHRoID09IHRoaXMuX2Jsb2NrU3RhcnREZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCwgdGhpcy5fYmxvY2tDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fYWRkTWVzc2FnZSh0aGlzLl9ibG9ja0NoaWxkcmVuLCB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgYXR0cmlidXRlcyBpbiBzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGNvbW1lbnQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRBbGwodGhpcywgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0kxOE4gYmxvY2tzIHNob3VsZCBub3QgY3Jvc3MgZWxlbWVudCBib3VuZGFyaWVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbih0ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGVsKTtcbiAgICAgICAgICB0aGlzLl9kZXB0aCsrO1xuICAgICAgICAgIHZhciB3YXNJbkkxOG5Ob2RlID0gdGhpcy5faW5JMThuTm9kZTtcbiAgICAgICAgICB2YXIgd2FzSW5JbXBsaWNpdE5vZGUgPSB0aGlzLl9pbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlcztcbiAgICAgICAgICAvLyBFeHRyYWN0IG9ubHkgdG9wIGxldmVsIG5vZGVzIHdpdGggdGhlIChpbXBsaWNpdCkgXCJpMThuXCIgYXR0cmlidXRlIGlmIG5vdCBpbiBhIGJsb2NrIG9yIGFuIElDVVxuICAgICAgICAgIC8vIG1lc3NhZ2VcbiAgICAgICAgICB2YXIgaTE4bkF0dHIgPSBfZ2V0STE4bkF0dHIoZWwpO1xuICAgICAgICAgIHZhciBpc0ltcGxpY2l0ID0gdGhpcy5faW1wbGljaXRUYWdzLnNvbWUoZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gZWwubmFtZSA9PT0gdGFnOyB9KSAmJlxuICAgICAgICAgICAgICAhdGhpcy5faW5JY3UgJiYgIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uO1xuICAgICAgICAgIHZhciBpc1RvcExldmVsSW1wbGljaXQgPSAhd2FzSW5JbXBsaWNpdE5vZGUgJiYgaXNJbXBsaWNpdDtcbiAgICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IHRoaXMuX2luSW1wbGljaXROb2RlIHx8IGlzSW1wbGljaXQ7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbiAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgICAgaWYgKGkxOG5BdHRyKSB7XG4gICAgICAgICAgICAgICAgICAvLyBleHBsaWNpdCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UoZWwuY2hpbGRyZW4sIGkxOG5BdHRyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGVsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGltcGxpY2l0IHRyYW5zbGF0aW9uXG4gICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fYWRkTWVzc2FnZShlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShlbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1RyYW5zbGF0YWJsZSA9IGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdDtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKGVsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbihlbCwgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UgJiYgIWkxOG5BdHRyICYmICFpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBjaGlsZC52aXNpdChfdGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIV90aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBjbG9zZSAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCAnQ291bGQgbm90IG1hcmsgYW4gZWxlbWVudCBhcyB0cmFuc2xhdGFibGUgaW5zaWRlIGEgdHJhbnNsYXRhYmxlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PSBfVmlzaXRvck1vZGUuRXh0cmFjdCkge1xuICAgICAgICAgICAgICAgICAgLy8gRGVzY2VuZCBpbnRvIGNoaWxkIG5vZGVzIGZvciBleHRyYWN0aW9uXG4gICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUcmFuc2xhdGUgYXR0cmlidXRlcyBpbiBJQ1UgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2l0ZWQgPSBjaGlsZC52aXNpdChfdGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIV90aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBjbG9zZSAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fdmlzaXRBdHRyaWJ1dGVzT2YoZWwpO1xuICAgICAgICAgIHRoaXMuX2RlcHRoLS07XG4gICAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHdhc0luSTE4bk5vZGU7XG4gICAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBjaGlsZE5vZGVzIGluIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAtIHRob3NlIG5vZGVzIHdpbGwgYmUgcmVwbGFjZSBhbnl3YXlcbiAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZWRBdHRycyA9IHRoaXMuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMoZWwpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWwubmFtZSwgdHJhbnNsYXRlZEF0dHJzLCBjaGlsZE5vZGVzLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG1vZGUsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9kZXB0aCA9IDA7XG4gICAgICAgICAgdGhpcy5faW5JY3UgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZSA9IGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgIH07XG4gICAgICAvLyBsb29rcyBmb3IgdHJhbnNsYXRhYmxlIGF0dHJpYnV0ZXNcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRBdHRyaWJ1dGVzT2YgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZSA9IHt9O1xuICAgICAgICAgIHZhciBpbXBsaWNpdEF0dHJOYW1lcyA9IHRoaXMuX2ltcGxpY2l0QXR0cnNbZWwubmFtZV0gfHwgW107XG4gICAgICAgICAgZWwuYXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCk7IH0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgICBhdHRyLnZhbHVlOyB9KTtcbiAgICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgaW4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRNZXNzYWdlKFthdHRyXSwgZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaW1wbGljaXRBdHRyTmFtZXMuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYXR0ci5uYW1lID09PSBuYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8vIGFkZCBhIHRyYW5zbGF0YWJsZSBtZXNzYWdlXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX2FkZE1lc3NhZ2UgPSBmdW5jdGlvbiAoYXN0LCBtZWFuaW5nQW5kRGVzYykge1xuICAgICAgICAgIGlmIChhc3QubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgICAgYXN0Lmxlbmd0aCA9PSAxICYmIGFzdFswXSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSQxICYmICFhc3RbMF0udmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IGNyZWF0ZSBlbXB0eSBtZXNzYWdlc1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfYSA9IF9zcGxpdE1lYW5pbmdBbmREZXNjKG1lYW5pbmdBbmREZXNjKSwgbWVhbmluZyA9IF9hWzBdLCBkZXNjcmlwdGlvbiA9IF9hWzFdO1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoYXN0LCBtZWFuaW5nLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH07XG4gICAgICAvLyBUcmFuc2xhdGVzIHRoZSBnaXZlbiBtZXNzYWdlIGdpdmVuIHRoZSBgVHJhbnNsYXRpb25CdW5kbGVgXG4gICAgICAvLyBuby1vcCB3aGVuIGNhbGxlZCBpbiBleHRyYWN0aW9uIG1vZGUgKHJldHVybnMgW10pXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3RyYW5zbGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAobWVzc2FnZSAmJiB0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gZGlnZXN0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5fdHJhbnNsYXRpb25zLmdldChpZCk7XG4gICAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCBcIlRyYW5zbGF0aW9uIHVuYXZhaWxhYmxlIGZvciBtZXNzYWdlIGlkPVxcXCJcIiArIGlkICsgXCJcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICB9O1xuICAgICAgLy8gdHJhbnNsYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIGFuIGVsZW1lbnQgYW5kIHJlbW92ZSBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fdHJhbnNsYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBlbC5hdHRycztcbiAgICAgICAgICB2YXIgaTE4bkF0dHJpYnV0ZU1lYW5pbmdzID0ge307XG4gICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAgIGkxOG5BdHRyaWJ1dGVNZWFuaW5nc1thdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgICAgICAgICAgIF9zcGxpdE1lYW5pbmdBbmREZXNjKGF0dHIudmFsdWUpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IF9JMThOX0FUVFIgfHwgYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzdHJpcCBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYXR0ci52YWx1ZSAmJiBhdHRyLnZhbHVlICE9ICcnICYmIGkxOG5BdHRyaWJ1dGVNZWFuaW5ncy5oYXNPd25Qcm9wZXJ0eShhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbWVhbmluZyA9IGkxOG5BdHRyaWJ1dGVNZWFuaW5nc1thdHRyLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBfdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoW2F0dHJdLCBtZWFuaW5nLCAnJyk7XG4gICAgICAgICAgICAgICAgICB2YXIgaWQgPSBkaWdlc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gX3RoaXMuX3RyYW5zbGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzWzBdIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2Rlc1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlJDEoYXR0ci5uYW1lLCB2YWx1ZSwgYXR0ci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0cmFuc2xhdGlvbiBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgaWQgKyBcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgaWQgKyBcIlxcXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkQXR0cmlidXRlcztcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEFkZCB0aGUgbm9kZSBhcyBhIGNoaWxkIG9mIHRoZSBibG9jayB3aGVuOlxuICAgICAgICogLSB3ZSBhcmUgaW4gYSBibG9jayxcbiAgICAgICAqIC0gd2UgYXJlIG5vdCBpbnNpZGUgYSBJQ1UgbWVzc2FnZSAodGhvc2UgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSksXG4gICAgICAgKiAtIHRoZSBub2RlIGlzIGEgXCJkaXJlY3QgY2hpbGRcIiBvZiB0aGUgYmxvY2tcbiAgICAgICAqL1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jayAmJiAhdGhpcy5faW5JY3UgJiYgdGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Jsb2NrQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBNYXJrcyB0aGUgc3RhcnQgb2YgYSBzZWN0aW9uLCBzZWUgYF9lbmRTZWN0aW9uYFxuICAgICAgICovXG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBzdGFydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9WaXNpdG9yLnByb3RvdHlwZSwgXCJfaXNJblRyYW5zbGF0YWJsZVNlY3Rpb25cIiwge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgdHJhbnNsYXRhYmxlIHNlY3Rpb24gY291bGQgYmU6XG4gICAgICAgICAgICogLSBhIHRyYW5zbGF0YWJsZSBlbGVtZW50LFxuICAgICAgICAgICAqIC0gbm9kZXMgYmV0d2VlbiBgPCEtLSBpMThuIC0tPmAgYW5kIGA8IS0tIC9pMThuIC0tPmAgY29tbWVudHNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgIT09IHZvaWQgMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogVGVybWluYXRlcyBhIHNlY3Rpb24uXG4gICAgICAgKlxuICAgICAgICogSWYgYSBzZWN0aW9uIGhhcyBvbmx5IG9uZSBzaWduaWZpY2FudCBjaGlsZHJlbiAoY29tbWVudHMgbm90IHNpZ25pZmljYW50KSB0aGVuIHdlIHNob3VsZCBub3RcbiAgICAgICAqIGtlZXAgdGhlIG1lc3NhZ2UgZnJvbSB0aGlzIGNoaWxkcmVuOlxuICAgICAgICpcbiAgICAgICAqIGA8cCBpMThuPVwibWVhbmluZ3xkZXNjcmlwdGlvblwiPntJQ1UgbWVzc2FnZX08L3A+YCB3b3VsZCBwcm9kdWNlIHR3byBtZXNzYWdlczpcbiAgICAgICAqIC0gb25lIGZvciB0aGUgPHA+IGNvbnRlbnQgd2l0aCBtZWFuaW5nIGFuZCBkZXNjcmlwdGlvbixcbiAgICAgICAqIC0gYW5vdGhlciBvbmUgZm9yIHRoZSBJQ1UgbWVzc2FnZS5cbiAgICAgICAqXG4gICAgICAgKiBJbiB0aGlzIGNhc2UgdGhlIGxhc3QgbWVzc2FnZSBpcyBkaXNjYXJkZWQgYXMgaXQgY29udGFpbnMgbGVzcyBpbmZvcm1hdGlvbiAodGhlIEFTVCBpc1xuICAgICAgICogb3RoZXJ3aXNlIGlkZW50aWNhbCkuXG4gICAgICAgKlxuICAgICAgICogTm90ZSB0aGF0IHdlIHNob3VsZCBzdGlsbCBrZWVwIG1lc3NhZ2VzIGV4dHJhY3RlZCBmcm9tIGF0dHJpYnV0ZXMgaW5zaWRlIHRoZSBzZWN0aW9uIChpZSBpbiB0aGVcbiAgICAgICAqIElDVSBtZXNzYWdlIGhlcmUpXG4gICAgICAgKi9cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUsIGRpcmVjdENoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2RlLCAnVW5leHBlY3RlZCBzZWN0aW9uIGVuZCcpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydDtcbiAgICAgICAgICB2YXIgc2lnbmlmaWNhbnRDaGlsZHJlbiA9IGRpcmVjdENoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIG5vZGUpIHsgcmV0dXJuIGNvdW50ICsgKG5vZGUgaW5zdGFuY2VvZiBDb21tZW50ID8gMCA6IDEpOyB9LCAwKTtcbiAgICAgICAgICBpZiAoc2lnbmlmaWNhbnRDaGlsZHJlbiA9PSAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IHN0YXJ0SW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGFzdCA9IHRoaXMuX21lc3NhZ2VzW2ldLm5vZGVzO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoYXN0Lmxlbmd0aCA9PSAxICYmIGFzdFswXSBpbnN0YW5jZW9mIFRleHQkMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1zZykge1xuICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX1Zpc2l0b3I7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9pc09wZW5pbmdDb21tZW50KG4pIHtcbiAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUuc3RhcnRzV2l0aCgnaTE4bicpO1xuICB9XG4gIGZ1bmN0aW9uIF9pc0Nsb3NpbmdDb21tZW50KG4pIHtcbiAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUgPT09ICcvaTE4bic7XG4gIH1cbiAgZnVuY3Rpb24gX2dldEkxOG5BdHRyKHApIHtcbiAgICAgIHJldHVybiBwLmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gX0kxOE5fQVRUUjsgfSkgfHwgbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBfc3BsaXRNZWFuaW5nQW5kRGVzYyhpMThuKSB7XG4gICAgICBpZiAoIWkxOG4pXG4gICAgICAgICAgcmV0dXJuIFsnJywgJyddO1xuICAgICAgdmFyIHBpcGVJbmRleCA9IGkxOG4uaW5kZXhPZignfCcpO1xuICAgICAgcmV0dXJuIHBpcGVJbmRleCA9PSAtMSA/IFsnJywgaTE4bl0gOiBbaTE4bi5zbGljZSgwLCBwaXBlSW5kZXgpLCBpMThuLnNsaWNlKHBpcGVJbmRleCArIDEpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGNvbnRhaW5lciBmb3IgbWVzc2FnZSBleHRyYWN0ZWQgZnJvbSB0aGUgdGVtcGxhdGVzLlxuICAgKi9cbiAgdmFyIE1lc3NhZ2VCdW5kbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTWVzc2FnZUJ1bmRsZShfaHRtbFBhcnNlciwgX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5faW1wbGljaXRUYWdzID0gX2ltcGxpY2l0VGFncztcbiAgICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZU1hcCA9IHt9O1xuICAgICAgfVxuICAgICAgTWVzc2FnZUJ1bmRsZS5wcm90b3R5cGUudXBkYXRlRnJvbVRlbXBsYXRlID0gZnVuY3Rpb24gKGh0bWwsIHVybCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGh0bWxQYXJzZXJSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKGh0bWwsIHVybCwgdHJ1ZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gaHRtbFBhcnNlclJlc3VsdC5lcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpMThuUGFyc2VyUmVzdWx0ID0gZXh0cmFjdE1lc3NhZ2VzKGh0bWxQYXJzZXJSZXN1bHQucm9vdE5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCB0aGlzLl9pbXBsaWNpdFRhZ3MsIHRoaXMuX2ltcGxpY2l0QXR0cnMpO1xuICAgICAgICAgIGlmIChpMThuUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGkxOG5QYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpMThuUGFyc2VyUmVzdWx0Lm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHsgX3RoaXMuX21lc3NhZ2VNYXBbZGlnZXN0TWVzc2FnZShtZXNzYWdlKV0gPSBtZXNzYWdlOyB9KTtcbiAgICAgIH07XG4gICAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS5nZXRNZXNzYWdlTWFwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZU1hcDsgfTtcbiAgICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHNlcmlhbGl6ZXIpIHsgcmV0dXJuIHNlcmlhbGl6ZXIud3JpdGUodGhpcy5fbWVzc2FnZU1hcCk7IH07XG4gICAgICByZXR1cm4gTWVzc2FnZUJ1bmRsZTtcbiAgfSgpKTtcblxuICB2YXIgWG1sVGFnRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBYbWxUYWdEZWZpbml0aW9uKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gVGFnQ29udGVudFR5cGUuUEFSU0FCTEVfREFUQTtcbiAgICAgICAgICB0aGlzLmlzVm9pZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaWdub3JlRmlyc3RMZiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY2FuU2VsZkNsb3NlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLnJlcXVpcmVFeHRyYVBhcmVudCA9IGZ1bmN0aW9uIChjdXJyZW50UGFyZW50KSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgIFhtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLmlzQ2xvc2VkQnlDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgIHJldHVybiBYbWxUYWdEZWZpbml0aW9uO1xuICB9KCkpO1xuICB2YXIgX1RBR19ERUZJTklUSU9OID0gbmV3IFhtbFRhZ0RlZmluaXRpb24oKTtcbiAgZnVuY3Rpb24gZ2V0WG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gX1RBR19ERUZJTklUSU9OO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBYbWxQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDcoWG1sUGFyc2VyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gWG1sUGFyc2VyKCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGdldFhtbFRhZ0RlZmluaXRpb24pO1xuICAgICAgfVxuICAgICAgWG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3Jtcykge1xuICAgICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgbnVsbCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFhtbFBhcnNlcjtcbiAgfShQYXJzZXIkMSkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgLy8gR2VuZXJhdGUgYSBtYXAgb2YgcGxhY2Vob2xkZXIgdG8gY29udGVudCBpbmRleGVkIGJ5IG1lc3NhZ2UgaWRzXG4gIGZ1bmN0aW9uIGV4dHJhY3RQbGFjZWhvbGRlcnMobWVzc2FnZUJ1bmRsZSkge1xuICAgICAgdmFyIG1lc3NhZ2VNYXAgPSBtZXNzYWdlQnVuZGxlLmdldE1lc3NhZ2VNYXAoKTtcbiAgICAgIHZhciBwbGFjZWhvbGRlcnMgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VNYXApLmZvckVhY2goZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgcGxhY2Vob2xkZXJzW21zZ0lkXSA9IG1lc3NhZ2VNYXBbbXNnSWRdLnBsYWNlaG9sZGVycztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVycztcbiAgfVxuICAvLyBHZW5lcmF0ZSBhIG1hcCBvZiBwbGFjZWhvbGRlciB0byBtZXNzYWdlIGlkcyBpbmRleGVkIGJ5IG1lc3NhZ2UgaWRzXG4gIGZ1bmN0aW9uIGV4dHJhY3RQbGFjZWhvbGRlclRvSWRzKG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgIHZhciBtZXNzYWdlTWFwID0gbWVzc2FnZUJ1bmRsZS5nZXRNZXNzYWdlTWFwKCk7XG4gICAgICB2YXIgcGxhY2Vob2xkZXJUb0lkcyA9IHt9O1xuICAgICAgT2JqZWN0LmtleXMobWVzc2FnZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAobXNnSWQpIHtcbiAgICAgICAgICBwbGFjZWhvbGRlclRvSWRzW21zZ0lkXSA9IG1lc3NhZ2VNYXBbbXNnSWRdLnBsYWNlaG9sZGVyVG9Nc2dJZHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlclRvSWRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDggPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBfVmlzaXRvciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9WaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0ckF0dHJzID0gdGhpcy5fc2VyaWFsaXplQXR0cmlidXRlcyh0YWcuYXR0cnMpO1xuICAgICAgICAgIGlmICh0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnLm5hbWUgKyBzdHJBdHRycyArIFwiLz5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0ckNoaWxkcmVuID0gdGFnLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICAgIHJldHVybiBcIjxcIiArIHRhZy5uYW1lICsgc3RyQXR0cnMgKyBcIj5cIiArIHN0ckNoaWxkcmVuLmpvaW4oJycpICsgXCI8L1wiICsgdGFnLm5hbWUgKyBcIj5cIjtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIHRleHQudmFsdWU7IH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsKSB7XG4gICAgICAgICAgcmV0dXJuIFwiPD94bWxcIiArIHRoaXMuX3NlcmlhbGl6ZUF0dHJpYnV0ZXMoZGVjbC5hdHRycykgKyBcIiA/PlwiO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgICAgICAgIHZhciBzdHJBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIChuYW1lICsgXCI9XFxcIlwiICsgYXR0cnNbbmFtZV0gKyBcIlxcXCJcIik7IH0pLmpvaW4oJyAnKTtcbiAgICAgICAgICByZXR1cm4gc3RyQXR0cnMubGVuZ3RoID4gMCA/ICcgJyArIHN0ckF0dHJzIDogJyc7XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RG9jdHlwZSA9IGZ1bmN0aW9uIChkb2N0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIFwiPCFET0NUWVBFIFwiICsgZG9jdHlwZS5yb290VGFnICsgXCIgW1xcblwiICsgZG9jdHlwZS5kdGQgKyBcIlxcbl0+XCI7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9WaXNpdG9yO1xuICB9KCkpO1xuICB2YXIgX3Zpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMSgpO1xuICBmdW5jdGlvbiBzZXJpYWxpemUobm9kZXMpIHtcbiAgICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3Zpc2l0b3IpOyB9KS5qb2luKCcnKTtcbiAgfVxuICB2YXIgRGVjbGFyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGVjbGFyYXRpb24odW5lc2NhcGVkQXR0cnMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyh1bmVzY2FwZWRBdHRycykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICBfdGhpcy5hdHRyc1trXSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgRGVjbGFyYXRpb24ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJhdGlvbih0aGlzKTsgfTtcbiAgICAgIHJldHVybiBEZWNsYXJhdGlvbjtcbiAgfSgpKTtcbiAgdmFyIERvY3R5cGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRG9jdHlwZShyb290VGFnLCBkdGQpIHtcbiAgICAgICAgICB0aGlzLnJvb3RUYWcgPSByb290VGFnO1xuICAgICAgICAgIHRoaXMuZHRkID0gZHRkO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgRG9jdHlwZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdERvY3R5cGUodGhpcyk7IH07XG4gICAgICByZXR1cm4gRG9jdHlwZTtcbiAgfSgpKTtcbiAgdmFyIFRhZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUYWcobmFtZSwgdW5lc2NhcGVkQXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAodW5lc2NhcGVkQXR0cnMgPT09IHZvaWQgMCkgeyB1bmVzY2FwZWRBdHRycyA9IHt9OyB9XG4gICAgICAgICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHsgY2hpbGRyZW4gPSBbXTsgfVxuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgICBPYmplY3Qua2V5cyh1bmVzY2FwZWRBdHRycykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICBfdGhpcy5hdHRyc1trXSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgVGFnLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGFnKHRoaXMpOyB9O1xuICAgICAgcmV0dXJuIFRhZztcbiAgfSgpKTtcbiAgdmFyIFRleHQkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZXh0KHVuZXNjYXBlZFZhbHVlKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkVmFsdWUpO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgVGV4dC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcyk7IH07XG4gICAgICByZXR1cm4gVGV4dDtcbiAgfSgpKTtcbiAgdmFyIENSID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ4KENSLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQ1Iod3MpIHtcbiAgICAgICAgICBpZiAod3MgPT09IHZvaWQgMCkgeyB3cyA9IDA7IH1cbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIlxcblwiICsgbmV3IEFycmF5KHdzICsgMSkuam9pbignICcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDUjtcbiAgfShUZXh0JDIpKTtcbiAgdmFyIF9FU0NBUEVEX0NIQVJTID0gW1xuICAgICAgWy8mL2csICcmYW1wOyddLFxuICAgICAgWy9cIi9nLCAnJnF1b3Q7J10sXG4gICAgICBbLycvZywgJyZhcG9zOyddLFxuICAgICAgWy88L2csICcmbHQ7J10sXG4gICAgICBbLz4vZywgJyZndDsnXSxcbiAgXTtcbiAgZnVuY3Rpb24gX2VzY2FwZVhtbCh0ZXh0KSB7XG4gICAgICByZXR1cm4gX0VTQ0FQRURfQ0hBUlMucmVkdWNlKGZ1bmN0aW9uICh0ZXh0LCBlbnRyeSkgeyByZXR1cm4gdGV4dC5yZXBsYWNlKGVudHJ5WzBdLCBlbnRyeVsxXSk7IH0sIHRleHQpO1xuICB9XG5cbiAgdmFyIF9WRVJTSU9OID0gJzEuMic7XG4gIHZhciBfWE1MTlMgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjEuMic7XG4gIC8vIFRPRE8odmljYik6IG1ha2UgdGhpcyBhIHBhcmFtIChzL18vLS8pXG4gIHZhciBfU09VUkNFX0xBTkcgPSAnZW4nO1xuICB2YXIgX1BMQUNFSE9MREVSX1RBRyA9ICd4JztcbiAgdmFyIF9TT1VSQ0VfVEFHID0gJ3NvdXJjZSc7XG4gIHZhciBfVEFSR0VUX1RBRyA9ICd0YXJnZXQnO1xuICB2YXIgX1VOSVRfVEFHID0gJ3RyYW5zLXVuaXQnO1xuICAvLyBodHRwOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi92MS4yL29zL3hsaWZmLWNvcmUuaHRtbFxuICAvLyBodHRwOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi92MS4yL3hsaWZmLXByb2ZpbGUtaHRtbC94bGlmZi1wcm9maWxlLWh0bWwtMS4yLmh0bWxcbiAgdmFyIFhsaWZmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFhsaWZmKF9odG1sUGFyc2VyLCBfaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnID0gX2ludGVycG9sYXRpb25Db25maWc7XG4gICAgICB9XG4gICAgICBYbGlmZi5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobWVzc2FnZU1hcCkge1xuICAgICAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9Xcml0ZVZpc2l0b3IoKTtcbiAgICAgICAgICB2YXIgdHJhbnNVbml0cyA9IFtdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VNYXApLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZU1hcFtpZF07XG4gICAgICAgICAgICAgIHZhciB0cmFuc1VuaXQgPSBuZXcgVGFnKF9VTklUX1RBRywgeyBpZDogaWQsIGRhdGF0eXBlOiAnaHRtbCcgfSk7XG4gICAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZyhfU09VUkNFX1RBRywge30sIHZpc2l0b3Iuc2VyaWFsaXplKG1lc3NhZ2Uubm9kZXMpKSwgbmV3IENSKDgpLCBuZXcgVGFnKF9UQVJHRVRfVEFHKSk7XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdkZXNjcmlwdGlvbicgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5kZXNjcmlwdGlvbildKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWVhbmluZykge1xuICAgICAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBwcmlvcml0eTogJzEnLCBmcm9tOiAnbWVhbmluZycgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5tZWFuaW5nKV0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoNikpO1xuICAgICAgICAgICAgICB0cmFuc1VuaXRzLnB1c2gobmV3IENSKDYpLCB0cmFuc1VuaXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBib2R5ID0gbmV3IFRhZygnYm9keScsIHt9LCB0cmFuc1VuaXRzLmNvbmNhdChbbmV3IENSKDQpXSkpO1xuICAgICAgICAgIHZhciBmaWxlID0gbmV3IFRhZygnZmlsZScsIHsgJ3NvdXJjZS1sYW5ndWFnZSc6IF9TT1VSQ0VfTEFORywgZGF0YXR5cGU6ICdwbGFpbnRleHQnLCBvcmlnaW5hbDogJ25nMi50ZW1wbGF0ZScgfSwgW25ldyBDUig0KSwgYm9keSwgbmV3IENSKDIpXSk7XG4gICAgICAgICAgdmFyIHhsaWZmID0gbmV3IFRhZygneGxpZmYnLCB7IHZlcnNpb246IF9WRVJTSU9OLCB4bWxuczogX1hNTE5TIH0sIFtuZXcgQ1IoMiksIGZpbGUsIG5ldyBDUigpXSk7XG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSwgbmV3IENSKCksIHhsaWZmLCBuZXcgQ1IoKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIFhsaWZmLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCwgbWVzc2FnZUJ1bmRsZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgLy8gUGFyc2UgdGhlIHh0YiBmaWxlIGludG8geG1sIG5vZGVzXG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShjb250ZW50LCB1cmwpO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgcmVzdWx0LmVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHBsYWNlaG9sZGVycywgbWVzc2FnZXMgYXJlIG5vdyBzdHJpbmdcbiAgICAgICAgICB2YXIgX2EgPSBuZXcgX0xvYWRWaXNpdG9yKCkucGFyc2UocmVzdWx0LnJvb3ROb2RlcywgbWVzc2FnZUJ1bmRsZSksIG1lc3NhZ2VzID0gX2EubWVzc2FnZXMsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIG1lc3NhZ2VzIHRvIGh0bWwgYXN0XG4gICAgICAgICAgLy8gVE9ETyh2aWNiKTogbWFwIGVycm9yIG1lc3NhZ2UgYmFjayB0byB0aGUgb3JpZ2luYWwgbWVzc2FnZSBpbiB4dGJcbiAgICAgICAgICB2YXIgbWVzc2FnZU1hcCA9IHt9O1xuICAgICAgICAgIHZhciBwYXJzZUVycm9ycyA9IFtdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICB2YXIgcmVzID0gX3RoaXMuX2h0bWxQYXJzZXIucGFyc2UobWVzc2FnZXNbaWRdLCB1cmwsIHRydWUsIF90aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgcGFyc2VFcnJvcnMucHVzaC5hcHBseShwYXJzZUVycm9ycywgcmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgIG1lc3NhZ2VNYXBbaWRdID0gcmVzLnJvb3ROb2RlcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocGFyc2VFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBwYXJzZUVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlTWFwO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBYbGlmZjtcbiAgfSgpKTtcbiAgdmFyIF9Xcml0ZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1dyaXRlVmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiBbbmV3IFRleHQkMih0ZXh0LnZhbHVlKV07IH07XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBub2RlLnZpc2l0KF90aGlzKSk7IH0pO1xuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgIH07XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5faXNJbkljdSkge1xuICAgICAgICAgICAgICAvLyBuZXN0ZWQgSUNVIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4bGlmZiBkb2VzIG5vdCBzdXBwb3J0IG5lc3RlZCBJQ1UgbWVzc2FnZXMnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faXNJbkljdSA9IHRydWU7XG4gICAgICAgICAgLy8gVE9ETyh2aWNiKTogc3VwcG9ydCBJQ1UgbWVzc2FnZXNcbiAgICAgICAgICAvLyBodHRwczovL2xpc3RzLm9hc2lzLW9wZW4ub3JnL2FyY2hpdmVzL3hsaWZmLzIwMTIwMS9tc2cwMDAyOC5odG1sXG4gICAgICAgICAgLy8gaHR0cDovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYvdjEuMi94bGlmZi1wcm9maWxlLXBvL3hsaWZmLXByb2ZpbGUtcG8tMS4yLWNkMDIuaHRtbFxuICAgICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2lzSW5JY3UgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBjdHlwZSA9IGdldEN0eXBlRm9yVGFnKHBoLnRhZyk7XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLnN0YXJ0TmFtZSwgY3R5cGU6IGN0eXBlIH0pO1xuICAgICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2xvc2VUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBpZDogcGguY2xvc2VOYW1lLCBjdHlwZTogY3R5cGUgfSk7XG4gICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXS5jb25jYXQodGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBbY2xvc2VUYWdQaF0pO1xuICAgICAgfTtcbiAgICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRywgeyBpZDogcGgubmFtZSB9KV07XG4gICAgICB9O1xuICAgICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5uYW1lIH0pXTtcbiAgICAgIH07XG4gICAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX2lzSW5JY3UgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXIuZmxhdHRlbihub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9Xcml0ZVZpc2l0b3I7XG4gIH0oKSk7XG4gIC8vIFRPRE8odmljYik6IGFkZCBlcnJvciBtYW5hZ2VtZW50IChzdHJ1Y3R1cmUpXG4gIC8vIFRPRE8odmljYik6IGZhY3Rvcml6ZSAoeHRiKSA/XG4gIHZhciBfTG9hZFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0xvYWRWaXNpdG9yKCkge1xuICAgICAgfVxuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChub2RlcywgbWVzc2FnZUJ1bmRsZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzID0gW107XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRlZE1lc3NhZ2VzID0ge307XG4gICAgICAgICAgdGhpcy5fbXNnSWQgPSAnJztcbiAgICAgICAgICB0aGlzLl90YXJnZXQgPSBbXTtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAvLyBGaW5kIGFsbCBtZXNzYWdlc1xuICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIG5vZGVzLCBudWxsKTtcbiAgICAgICAgICB2YXIgbWVzc2FnZU1hcCA9IG1lc3NhZ2VCdW5kbGUuZ2V0TWVzc2FnZU1hcCgpO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlcnMgPSBleHRyYWN0UGxhY2Vob2xkZXJzKG1lc3NhZ2VCdW5kbGUpO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlclRvSWRzID0gZXh0cmFjdFBsYWNlaG9sZGVyVG9JZHMobWVzc2FnZUJ1bmRsZSk7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBtZXNzYWdlcyB0aGF0IGlzIG5vdCBwcmVzZW50IGluIHRoZSBzb3VyY2UgbWVzc2FnZSBidW5kbGUuXG4gICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlTWFwLmhhc093blByb3BlcnR5KG1lc3NhZ2VbMF0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlcmUgY291bGQgYmUgbm8gSUNVIHBsYWNlaG9sZGVycyBpbnNpZGUgYW4gSUNVIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIC8vIHdlIGRvIG5vdCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSBgcGxhY2Vob2xkZXJUb01zZ0lkc2Agb2YgdGhlIHJlZmVyZW5jZWRcbiAgICAgICAgICAgICAgLy8gbWVzc2FnZXMsIHRob3NlIHdvdWxkIGFsd2F5cyBiZSBlbXB0eVxuICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBvdmVya2lsbCAtIGNyZWF0ZSAyIGJ1Y2tldHMgYW5kIFsuLi53b0RlcHMsIC4uLndEZXBzXS5wcm9jZXNzKClcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc3NhZ2VNYXBbYVswXV0ucGxhY2Vob2xkZXJUb01zZ0lkcykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobWVzc2FnZU1hcFtiWzBdXS5wbGFjZWhvbGRlclRvTXNnSWRzKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gbWVzc2FnZVswXTtcbiAgICAgICAgICAgICAgX3RoaXMuX3BsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVyc1tpZF0gfHwge307XG4gICAgICAgICAgICAgIF90aGlzLl9wbGFjZWhvbGRlclRvSWRzID0gcGxhY2Vob2xkZXJUb0lkc1tpZF0gfHwge307XG4gICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IG1ha2Ugc3VyZSB0aGVyZSBpcyBubyBgX1RSQU5TTEFUSU9OU19UQUdgIG5vciBgX1RSQU5TTEFUSU9OX1RBR2BcbiAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlc1tpZF0gPSB2aXNpdEFsbChfdGhpcywgbWVzc2FnZVsxXSkuam9pbignJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZXM6IHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcywgZXJyb3JzOiB0aGlzLl9lcnJvcnMgfTtcbiAgICAgIH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBfVU5JVF9UQUc6XG4gICAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgdmFyIG1zZ0lkID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFtc2dJZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1VOSVRfVEFHICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tc2dJZCA9IG1zZ0lkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlTm9kZXMucHVzaChbdGhpcy5fbXNnSWQsIHRoaXMuX3RhcmdldF0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUc6XG4gICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgc291cmNlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHOlxuICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9UQUc6XG4gICAgICAgICAgICAgICAgICB2YXIgaWRBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9QTEFDRUhPTERFUl9UQUcgKyBcIj4gbWlzc2VzIHRoZSBcXFwiaWRcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXJzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYWNlaG9sZGVyVG9JZHMuaGFzT3duUHJvcGVydHkoaWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLl9wbGFjZWhvbGRlclRvSWRzW2lkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlc1t0aGlzLl9wbGFjZWhvbGRlclRvSWRzW2lkXV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IGJldHRlciBlcnJvciBtZXNzYWdlIGZvciB3aGVuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gIXRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLl9wbGFjZWhvbGRlclRvSWRzW2lkXSlcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIlRoZSBwbGFjZWhvbGRlciBcXFwiXCIgKyBpZCArIFwiXFxcIiBkb2VzIG5vdCBleGlzdHMgaW4gdGhlIHNvdXJjZSBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgICAgX0xvYWRWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gJyc7IH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUgY29kZScpO1xuICAgICAgfTtcbiAgICAgIF9Mb2FkVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfTG9hZFZpc2l0b3IucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0xvYWRWaXNpdG9yO1xuICB9KCkpO1xuICBmdW5jdGlvbiBnZXRDdHlwZUZvclRhZyh0YWcpIHtcbiAgICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICAgIHJldHVybiAnbGInO1xuICAgICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBcIngtXCIgKyB0YWc7XG4gICAgICB9XG4gIH1cblxuICB2YXIgX01FU1NBR0VTX1RBRyA9ICdtZXNzYWdlYnVuZGxlJztcbiAgdmFyIF9NRVNTQUdFX1RBRyA9ICdtc2cnO1xuICB2YXIgX1BMQUNFSE9MREVSX1RBRyQxID0gJ3BoJztcbiAgdmFyIF9FWEVNUExFX1RBRyA9ICdleCc7XG4gIHZhciBfRE9DVFlQRSA9IFwiPCFFTEVNRU5UIG1lc3NhZ2VidW5kbGUgKG1zZykqPlxcbjwhQVRUTElTVCBtZXNzYWdlYnVuZGxlIGNsYXNzIENEQVRBICNJTVBMSUVEPlxcblxcbjwhRUxFTUVOVCBtc2cgKCNQQ0RBVEF8cGh8c291cmNlKSo+XFxuPCFBVFRMSVNUIG1zZyBpZCBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIHNlcSBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG5hbWUgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBkZXNjIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgbWVhbmluZyBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG9ic29sZXRlIChvYnNvbGV0ZSkgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyB4bWw6c3BhY2UgKGRlZmF1bHR8cHJlc2VydmUpIFxcXCJkZWZhdWx0XFxcIj5cXG48IUFUVExJU1QgbXNnIGlzX2hpZGRlbiBDREFUQSAjSU1QTElFRD5cXG5cXG48IUVMRU1FTlQgc291cmNlICgjUENEQVRBKT5cXG5cXG48IUVMRU1FTlQgcGggKCNQQ0RBVEF8ZXgpKj5cXG48IUFUVExJU1QgcGggbmFtZSBDREFUQSAjUkVRVUlSRUQ+XFxuXFxuPCFFTEVNRU5UIGV4ICgjUENEQVRBKT5cIjtcbiAgdmFyIFhtYiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBYbWIoKSB7XG4gICAgICB9XG4gICAgICBYbWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VNYXApIHtcbiAgICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBfVmlzaXRvciQyKCk7XG4gICAgICAgICAgdmFyIHJvb3ROb2RlID0gbmV3IFRhZyhfTUVTU0FHRVNfVEFHKTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtZXNzYWdlTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG1lc3NhZ2VNYXBbaWRdO1xuICAgICAgICAgICAgICB2YXIgYXR0cnMgPSB7IGlkOiBpZCB9O1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgYXR0cnNbJ2Rlc2MnXSA9IG1lc3NhZ2UuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWVhbmluZykge1xuICAgICAgICAgICAgICAgICAgYXR0cnNbJ21lYW5pbmcnXSA9IG1lc3NhZ2UubWVhbmluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigyKSwgbmV3IFRhZyhfTUVTU0FHRV9UQUcsIGF0dHJzLCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuLnB1c2gobmV3IENSKCkpO1xuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksXG4gICAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgICBuZXcgRG9jdHlwZShfTUVTU0FHRVNfVEFHLCBfRE9DVFlQRSksXG4gICAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgICByb290Tm9kZSxcbiAgICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgWG1iLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCwgbWVzc2FnZUJ1bmRsZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gWG1iO1xuICB9KCkpO1xuICB2YXIgX1Zpc2l0b3IkMiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfVmlzaXRvcigpIHtcbiAgICAgIH1cbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gW25ldyBUZXh0JDIodGV4dC52YWx1ZSldOyB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVzLnB1c2guYXBwbHkobm9kZXMsIG5vZGUudmlzaXQoX3RoaXMpKTsgfSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBub2RlcyA9IFtuZXcgVGV4dCQyKFwie1wiICsgaWN1LmV4cHJlc3Npb24gKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIildO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBbbmV3IFRleHQkMihjICsgXCIge1wiKV0uY29uY2F0KGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQyKFwifVwiKSk7XG4gICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIHN0YXJ0RXggPSBuZXcgVGFnKF9FWEVNUExFX1RBRywge30sIFtuZXcgVGV4dCQyKFwiPFwiICsgcGgudGFnICsgXCI+XCIpXSk7XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwgeyBuYW1lOiBwaC5zdGFydE5hbWUgfSwgW3N0YXJ0RXhdKTtcbiAgICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAgIC8vIHZvaWQgdGFncyBoYXZlIG5vIGNoaWxkcmVuIG5vciBjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNsb3NlRXggPSBuZXcgVGFnKF9FWEVNUExFX1RBRywge30sIFtuZXcgVGV4dCQyKFwiPC9cIiArIHBoLnRhZyArIFwiPlwiKV0pO1xuICAgICAgICAgIHZhciBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGguY2xvc2VOYW1lIH0sIFtjbG9zZUV4XSk7XG4gICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXS5jb25jYXQodGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBbY2xvc2VUYWdQaF0pO1xuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwgeyBuYW1lOiBwaC5uYW1lIH0pXTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGgubmFtZSB9KV07XG4gICAgICB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmZsYXR0ZW4obm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVmlzaXRvcjtcbiAgfSgpKTtcblxuICB2YXIgX1RSQU5TTEFUSU9OU19UQUcgPSAndHJhbnNsYXRpb25idW5kbGUnO1xuICB2YXIgX1RSQU5TTEFUSU9OX1RBRyA9ICd0cmFuc2xhdGlvbic7XG4gIHZhciBfUExBQ0VIT0xERVJfVEFHJDIgPSAncGgnO1xuICB2YXIgWHRiID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFh0YihfaHRtbFBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgfVxuICAgICAgWHRiLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlTWFwKSB7IHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTsgfTtcbiAgICAgIFh0Yi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIC8vIFBhcnNlIHRoZSB4dGIgZmlsZSBpbnRvIHhtbCBub2Rlc1xuICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoY29udGVudCwgdXJsKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIHJlc3VsdC5lcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBwbGFjZWhvbGRlcnMsIG1lc3NhZ2VzIGFyZSBub3cgc3RyaW5nXG4gICAgICAgICAgdmFyIF9hID0gbmV3IF9WaXNpdG9yJDMoKS5wYXJzZShyZXN1bHQucm9vdE5vZGVzLCBtZXNzYWdlQnVuZGxlKSwgbWVzc2FnZXMgPSBfYS5tZXNzYWdlcywgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInh0YiBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvcnMuam9pbignXFxuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgbWVzc2FnZXMgdG8gaHRtbCBhc3RcbiAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBtYXAgZXJyb3IgbWVzc2FnZSBiYWNrIHRvIHRoZSBvcmlnaW5hbCBtZXNzYWdlIGluIHh0YlxuICAgICAgICAgIHZhciBtZXNzYWdlTWFwID0ge307XG4gICAgICAgICAgdmFyIHBhcnNlRXJyb3JzID0gW107XG4gICAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHZhciByZXMgPSBfdGhpcy5faHRtbFBhcnNlci5wYXJzZShtZXNzYWdlc1tpZF0sIHVybCwgdHJ1ZSwgX3RoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgICBwYXJzZUVycm9ycy5wdXNoLmFwcGx5KHBhcnNlRXJyb3JzLCByZXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgbWVzc2FnZU1hcFtpZF0gPSByZXMucm9vdE5vZGVzO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChwYXJzZUVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIHBhcnNlRXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2VNYXA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFh0YjtcbiAgfSgpKTtcbiAgdmFyIF9WaXNpdG9yJDMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1Zpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAobm9kZXMsIG1lc3NhZ2VCdW5kbGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuX21lc3NhZ2VOb2RlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcyA9IHt9O1xuICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoID0gMDtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbkRlcHRoID0gMDtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAvLyBGaW5kIGFsbCBtZXNzYWdlc1xuICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIG5vZGVzLCBudWxsKTtcbiAgICAgICAgICB2YXIgbWVzc2FnZU1hcCA9IG1lc3NhZ2VCdW5kbGUuZ2V0TWVzc2FnZU1hcCgpO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlcnMgPSBleHRyYWN0UGxhY2Vob2xkZXJzKG1lc3NhZ2VCdW5kbGUpO1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlclRvSWRzID0gZXh0cmFjdFBsYWNlaG9sZGVyVG9JZHMobWVzc2FnZUJ1bmRsZSk7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBtZXNzYWdlcyB0aGF0IGlzIG5vdCBwcmVzZW50IGluIHRoZSBzb3VyY2UgbWVzc2FnZSBidW5kbGUuXG4gICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlTWFwLmhhc093blByb3BlcnR5KG1lc3NhZ2VbMF0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlcmUgY291bGQgYmUgbm8gSUNVIHBsYWNlaG9sZGVycyBpbnNpZGUgYW4gSUNVIG1lc3NhZ2UsXG4gICAgICAgICAgICAgIC8vIHdlIGRvIG5vdCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSBgcGxhY2Vob2xkZXJUb01zZ0lkc2Agb2YgdGhlIHJlZmVyZW5jZWRcbiAgICAgICAgICAgICAgLy8gbWVzc2FnZXMsIHRob3NlIHdvdWxkIGFsd2F5cyBiZSBlbXB0eVxuICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBvdmVya2lsbCAtIGNyZWF0ZSAyIGJ1Y2tldHMgYW5kIFsuLi53b0RlcHMsIC4uLndEZXBzXS5wcm9jZXNzKClcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc3NhZ2VNYXBbYVswXV0ucGxhY2Vob2xkZXJUb01zZ0lkcykubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobWVzc2FnZU1hcFtiWzBdXS5wbGFjZWhvbGRlclRvTXNnSWRzKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gbWVzc2FnZVswXTtcbiAgICAgICAgICAgICAgX3RoaXMuX3BsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVyc1tpZF0gfHwge307XG4gICAgICAgICAgICAgIF90aGlzLl9wbGFjZWhvbGRlclRvSWRzID0gcGxhY2Vob2xkZXJUb0lkc1tpZF0gfHwge307XG4gICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IG1ha2Ugc3VyZSB0aGVyZSBpcyBubyBgX1RSQU5TTEFUSU9OU19UQUdgIG5vciBgX1RSQU5TTEFUSU9OX1RBR2BcbiAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlc1tpZF0gPSB2aXNpdEFsbChfdGhpcywgbWVzc2FnZVsxXSkuam9pbignJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZXM6IHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlcywgZXJyb3JzOiB0aGlzLl9lcnJvcnMgfTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTlNfVEFHOlxuICAgICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgrKztcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9idW5kbGVEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTlNfVEFHICsgXCI+IGVsZW1lbnRzIGNhbiBub3QgYmUgbmVzdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9idW5kbGVEZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1RSQU5TTEFUSU9OX1RBRzpcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uRGVwdGgrKztcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2xhdGlvbkRlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1RSQU5TTEFUSU9OX1RBRyArIFwiPiBlbGVtZW50cyBjYW4gbm90IGJlIG5lc3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBpZEF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2lkJzsgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiPFwiICsgX1RSQU5TTEFUSU9OX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSUNVIHBsYWNlaG9sZGVycyBhcmUgcmVmZXJlbmNlIHRvIG90aGVyIG1lc3NhZ2VzLlxuICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWZlcmVuY2VkIG1lc3NhZ2UgbWlnaHQgbm90IGhhdmUgYmVlbiBkZWNvZGVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGhhdmUgYWxsIG1lc3NhZ2VzIGF2YWlsYWJsZSB0byBtYWtlIHN1cmUgZGVwcyBhcmUgZGVjb2RlZCBmaXJzdC5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiByZXBvcnQgYW4gZXJyb3Igb24gZHVwbGljYXRlIGlkXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZU5vZGVzLnB1c2goW2lkQXR0ci52YWx1ZSwgZWxlbWVudC5jaGlsZHJlbl0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25EZXB0aC0tO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgX1BMQUNFSE9MREVSX1RBRyQyOlxuICAgICAgICAgICAgICAgICAgdmFyIG5hbWVBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICduYW1lJzsgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAoIW5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfUExBQ0VIT0xERVJfVEFHJDIgKyBcIj4gbWlzc2VzIHRoZSBcXFwibmFtZVxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkobmFtZV8xKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXJzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlclRvSWRzLmhhc093blByb3BlcnR5KG5hbWVfMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRlZE1lc3NhZ2VzLmhhc093blByb3BlcnR5KHRoaXMuX3BsYWNlaG9sZGVyVG9JZHNbbmFtZV8xXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zbGF0ZWRNZXNzYWdlc1t0aGlzLl9wbGFjZWhvbGRlclRvSWRzW25hbWVfMV1dO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBiZXR0ZXIgZXJyb3IgbWVzc2FnZSBmb3Igd2hlblxuICAgICAgICAgICAgICAgICAgICAgIC8vICF0aGlzLl90cmFuc2xhdGVkTWVzc2FnZXMuaGFzT3duUHJvcGVydHkodGhpcy5fcGxhY2Vob2xkZXJUb0lkc1tuYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIlRoZSBwbGFjZWhvbGRlciBcXFwiXCIgKyBuYW1lXzEgKyBcIlxcXCIgZG9lcyBub3QgZXhpc3RzIGluIHRoZSBzb3VyY2UgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgJ1VuZXhwZWN0ZWQgdGFnJyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIHRleHQudmFsdWU7IH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuICcnOyB9O1xuICAgICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHN0ckNhc2VzID0gZXhwYW5zaW9uLmNhc2VzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy52aXNpdChfdGhpcywgbnVsbCk7IH0pO1xuICAgICAgICAgIHJldHVybiBcIntcIiArIGV4cGFuc2lvbi5zd2l0Y2hWYWx1ZSArIFwiLCBcIiArIGV4cGFuc2lvbi50eXBlICsgXCIsIHN0ckNhc2VzLmpvaW4oJyAnKX1cIjtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gZXhwYW5zaW9uQ2FzZS52YWx1ZSArIFwiIHtcIiArIHZpc2l0QWxsKHRoaXMsIGV4cGFuc2lvbkNhc2UuZXhwcmVzc2lvbiwgbnVsbCkgKyBcIn1cIjtcbiAgICAgIH07XG4gICAgICBfVmlzaXRvci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfVmlzaXRvcjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8qKlxuICAgKiBBIGNvbnRhaW5lciBmb3IgdHJhbnNsYXRlZCBtZXNzYWdlc1xuICAgKi9cbiAgdmFyIFRyYW5zbGF0aW9uQnVuZGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRyYW5zbGF0aW9uQnVuZGxlKF9tZXNzYWdlTWFwKSB7XG4gICAgICAgICAgaWYgKF9tZXNzYWdlTWFwID09PSB2b2lkIDApIHsgX21lc3NhZ2VNYXAgPSB7fTsgfVxuICAgICAgICAgIHRoaXMuX21lc3NhZ2VNYXAgPSBfbWVzc2FnZU1hcDtcbiAgICAgIH1cbiAgICAgIFRyYW5zbGF0aW9uQnVuZGxlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsLCBtZXNzYWdlQnVuZGxlLCBzZXJpYWxpemVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2xhdGlvbkJ1bmRsZShzZXJpYWxpemVyLmxvYWQoY29udGVudCwgdXJsLCBtZXNzYWdlQnVuZGxlKSk7XG4gICAgICB9O1xuICAgICAgVHJhbnNsYXRpb25CdW5kbGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZU1hcFtpZF07IH07XG4gICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZCBpbiB0aGlzLl9tZXNzYWdlTWFwOyB9O1xuICAgICAgcmV0dXJuIFRyYW5zbGF0aW9uQnVuZGxlO1xuICB9KCkpO1xuXG4gIHZhciBJMThOSHRtbFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUT0RPKHZpY2IpOiB0cmFuc0IubG9hZCgpIHNob3VsZCBub3QgbmVlZCBhIG1zZ0IgJiBhZGQgdHJhbnNCLnJlc29sdmUobXNnQixcbiAgICAgIC8vIGludGVycG9sYXRpb25Db25maWcpXG4gICAgICAvLyBUT0RPKHZpY2IpOiByZW1vdmUgdGhlIGludGVycG9sYXRpb25Db25maWcgZnJvbSB0aGUgWHRiIHNlcmlhbGl6ZXJcbiAgICAgIGZ1bmN0aW9uIEkxOE5IdG1sUGFyc2VyKF9odG1sUGFyc2VyLCBfdHJhbnNsYXRpb25zLCBfdHJhbnNsYXRpb25zRm9ybWF0KSB7XG4gICAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9ucyA9IF90cmFuc2xhdGlvbnM7XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25zRm9ybWF0ID0gX3RyYW5zbGF0aW9uc0Zvcm1hdDtcbiAgICAgIH1cbiAgICAgIEkxOE5IdG1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICAgIHZhciBwYXJzZVJlc3VsdCA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2Uoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNsYXRpb25zIHx8IHRoaXMuX3RyYW5zbGF0aW9ucyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgLy8gRG8gbm90IGVuYWJsZSBpMThuIHdoZW4gbm8gdHJhbnNsYXRpb24gYnVuZGxlIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVE9ETyh2aWNiKTogYWRkIHN1cHBvcnQgZm9yIGltcGxpY2l0IHRhZ3MgLyBhdHRyaWJ1dGVzXG4gICAgICAgICAgdmFyIG1lc3NhZ2VCdW5kbGUgPSBuZXcgTWVzc2FnZUJ1bmRsZSh0aGlzLl9odG1sUGFyc2VyLCBbXSwge30pO1xuICAgICAgICAgIHZhciBlcnJvcnMgPSBtZXNzYWdlQnVuZGxlLnVwZGF0ZUZyb21UZW1wbGF0ZShzb3VyY2UsIHVybCwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKGVycm9ycyAmJiBlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgcGFyc2VSZXN1bHQuZXJyb3JzLmNvbmNhdChlcnJvcnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSB0aGlzLl9jcmVhdGVTZXJpYWxpemVyKGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgIHZhciB0cmFuc2xhdGlvbkJ1bmRsZSA9IFRyYW5zbGF0aW9uQnVuZGxlLmxvYWQodGhpcy5fdHJhbnNsYXRpb25zLCB1cmwsIG1lc3NhZ2VCdW5kbGUsIHNlcmlhbGl6ZXIpO1xuICAgICAgICAgIHJldHVybiBtZXJnZVRyYW5zbGF0aW9ucyhwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHRyYW5zbGF0aW9uQnVuZGxlLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBbXSwge30pO1xuICAgICAgfTtcbiAgICAgIEkxOE5IdG1sUGFyc2VyLnByb3RvdHlwZS5fY3JlYXRlU2VyaWFsaXplciA9IGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgdmFyIGZvcm1hdCA9ICh0aGlzLl90cmFuc2xhdGlvbnNGb3JtYXQgfHwgJ3hsZicpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgY2FzZSAneG1iJzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWG1iKCk7XG4gICAgICAgICAgICAgIGNhc2UgJ3h0Yic6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFh0Yih0aGlzLl9odG1sUGFyc2VyLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgICAgY2FzZSAneGxpZmYnOlxuICAgICAgICAgICAgICBjYXNlICd4bGYnOlxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBYbGlmZih0aGlzLl9odG1sUGFyc2VyLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEkxOE5IdG1sUGFyc2VyO1xuICB9KCkpO1xuXG4gIHZhciBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5pc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTtcbiAgdmFyIENoYW5nZURldGVjdG9yU3RhdHVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkNoYW5nZURldGVjdG9yU3RhdHVzO1xuICB2YXIgTGlmZWN5Y2xlSG9va3MgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uTGlmZWN5Y2xlSG9va3M7XG4gIHZhciBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkxJRkVDWUNMRV9IT09LU19WQUxVRVM7XG4gIHZhciBSZWZsZWN0b3JSZWFkZXIgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uUmVmbGVjdG9yUmVhZGVyO1xuICB2YXIgQXBwRWxlbWVudCA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BcHBFbGVtZW50O1xuICB2YXIgQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICB2YXIgQXBwVmlldyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BcHBWaWV3O1xuICB2YXIgRGVidWdBcHBWaWV3ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkRlYnVnQXBwVmlldztcbiAgdmFyIE5nTW9kdWxlSW5qZWN0b3IgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uTmdNb2R1bGVJbmplY3RvcjtcbiAgdmFyIHJlZ2lzdGVyTW9kdWxlRmFjdG9yeSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5yZWdpc3Rlck1vZHVsZUZhY3Rvcnk7XG4gIHZhciBWaWV3VHlwZSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5WaWV3VHlwZTtcbiAgdmFyIE1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5NQVhfSU5URVJQT0xBVElPTl9WQUxVRVM7XG4gIHZhciBjaGVja0JpbmRpbmcgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uY2hlY2tCaW5kaW5nO1xuICB2YXIgZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5mbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzO1xuICB2YXIgaW50ZXJwb2xhdGUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uaW50ZXJwb2xhdGU7XG4gIHZhciBWaWV3VXRpbHMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uVmlld1V0aWxzO1xuICB2YXIgRGVidWdDb250ZXh0ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkRlYnVnQ29udGV4dDtcbiAgdmFyIFN0YXRpY05vZGVEZWJ1Z0luZm8gPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uU3RhdGljTm9kZURlYnVnSW5mbztcbiAgdmFyIGRldk1vZGVFcXVhbCA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5kZXZNb2RlRXF1YWw7XG4gIHZhciBVTklOSVRJQUxJWkVEID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlVOSU5JVElBTElaRUQ7XG4gIHZhciBWYWx1ZVVud3JhcHBlciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5WYWx1ZVVud3JhcHBlcjtcbiAgdmFyIFRlbXBsYXRlUmVmXyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5UZW1wbGF0ZVJlZl87XG4gIHZhciBFTVBUWV9BUlJBWSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5FTVBUWV9BUlJBWTtcbiAgdmFyIEVNUFRZX01BUCA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5FTVBUWV9NQVA7XG4gIHZhciBwdXJlUHJveHkxID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTE7XG4gIHZhciBwdXJlUHJveHkyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTI7XG4gIHZhciBwdXJlUHJveHkzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTM7XG4gIHZhciBwdXJlUHJveHk0ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTQ7XG4gIHZhciBwdXJlUHJveHk1ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTU7XG4gIHZhciBwdXJlUHJveHk2ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTY7XG4gIHZhciBwdXJlUHJveHk3ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTc7XG4gIHZhciBwdXJlUHJveHk4ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTg7XG4gIHZhciBwdXJlUHJveHk5ID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnB1cmVQcm94eTk7XG4gIHZhciBwdXJlUHJveHkxMCA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5wdXJlUHJveHkxMDtcbiAgdmFyIGNhc3RCeVZhbHVlID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmNhc3RCeVZhbHVlO1xuICB2YXIgQ29uc29sZSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5Db25zb2xlO1xuICB2YXIgcmVmbGVjdG9yID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLnJlZmxlY3RvcjtcbiAgdmFyIFJlZmxlY3RvciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5SZWZsZWN0b3I7XG4gIHZhciBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLlJlZmxlY3Rpb25DYXBhYmlsaXRpZXM7XG4gIHZhciBOb09wQW5pbWF0aW9uUGxheWVyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLk5vT3BBbmltYXRpb25QbGF5ZXI7XG4gIHZhciBBbmltYXRpb25TZXF1ZW5jZVBsYXllciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5BbmltYXRpb25TZXF1ZW5jZVBsYXllcjtcbiAgdmFyIEFuaW1hdGlvbkdyb3VwUGxheWVyID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkFuaW1hdGlvbkdyb3VwUGxheWVyO1xuICB2YXIgQW5pbWF0aW9uS2V5ZnJhbWUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQW5pbWF0aW9uS2V5ZnJhbWU7XG4gIHZhciBBbmltYXRpb25TdHlsZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uQW5pbWF0aW9uU3R5bGVzO1xuICB2YXIgQU5ZX1NUQVRFID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLkFOWV9TVEFURTtcbiAgdmFyIERFRkFVTFRfU1RBVEUgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uREVGQVVMVF9TVEFURTtcbiAgdmFyIEVNUFRZX0FOSU1BVElPTl9TVEFURSA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5FTVBUWV9TVEFURTtcbiAgdmFyIEZJTExfU1RZTEVfRkxBRyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5GSUxMX1NUWUxFX0ZMQUc7XG4gIHZhciBwcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18ucHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzO1xuICB2YXIgYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5iYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzO1xuICB2YXIgY2xlYXJTdHlsZXMgPSBfYW5ndWxhcl9jb3JlLl9fY29yZV9wcml2YXRlX18uY2xlYXJTdHlsZXM7XG4gIHZhciBjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5jb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcztcbiAgdmFyIHJlbmRlclN0eWxlcyA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5yZW5kZXJTdHlsZXM7XG4gIHZhciBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5Db21wb25lbnRTdGlsbExvYWRpbmdFcnJvcjtcblxuICB2YXIgQVBQX1ZJRVdfTU9EVUxFX1VSTCA9IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci92aWV3Jyk7XG4gIHZhciBWSUVXX1VUSUxTX01PRFVMRV9VUkwgPSBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdmlld191dGlscycpO1xuICB2YXIgQ0RfTU9EVUxFX1VSTCA9IGFzc2V0VXJsKCdjb3JlJywgJ2NoYW5nZV9kZXRlY3Rpb24vY2hhbmdlX2RldGVjdGlvbicpO1xuICB2YXIgQU5JTUFUSU9OX1NUWUxFX1VUSUxfQVNTRVRfVVJMID0gYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl9zdHlsZV91dGlsJyk7XG4gIHZhciBJZGVudGlmaWVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBJZGVudGlmaWVycygpIHtcbiAgICAgIH1cbiAgICAgIElkZW50aWZpZXJzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgPSB7XG4gICAgICAgICAgbmFtZTogJ0FOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbWV0YWRhdGEvZGknKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WaWV3VXRpbHMgPSB7XG4gICAgICAgICAgbmFtZTogJ1ZpZXdVdGlscycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdmlld191dGlscycpLFxuICAgICAgICAgIHJ1bnRpbWU6IFZpZXdVdGlsc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFwcFZpZXcgPSB7IG5hbWU6ICdBcHBWaWV3JywgbW9kdWxlVXJsOiBBUFBfVklFV19NT0RVTEVfVVJMLCBydW50aW1lOiBBcHBWaWV3IH07XG4gICAgICBJZGVudGlmaWVycy5EZWJ1Z0FwcFZpZXcgPSB7XG4gICAgICAgICAgbmFtZTogJ0RlYnVnQXBwVmlldycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBUFBfVklFV19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IERlYnVnQXBwVmlld1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFwcEVsZW1lbnQgPSB7XG4gICAgICAgICAgbmFtZTogJ0FwcEVsZW1lbnQnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL2VsZW1lbnQnKSxcbiAgICAgICAgICBydW50aW1lOiBBcHBFbGVtZW50XG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuRWxlbWVudFJlZiA9IHtcbiAgICAgICAgICBuYW1lOiAnRWxlbWVudFJlZicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvZWxlbWVudF9yZWYnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmID0ge1xuICAgICAgICAgIG5hbWU6ICdWaWV3Q29udGFpbmVyUmVmJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci92aWV3X2NvbnRhaW5lcl9yZWYnKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWZcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3RvclJlZiA9IHtcbiAgICAgICAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0b3JSZWYnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnY2hhbmdlX2RldGVjdGlvbi9jaGFuZ2VfZGV0ZWN0b3JfcmVmJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZlxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlJlbmRlckNvbXBvbmVudFR5cGUgPSB7XG4gICAgICAgICAgbmFtZTogJ1JlbmRlckNvbXBvbmVudFR5cGUnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAncmVuZGVyL2FwaScpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyQ29tcG9uZW50VHlwZVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlF1ZXJ5TGlzdCA9IHtcbiAgICAgICAgICBuYW1lOiAnUXVlcnlMaXN0JyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9xdWVyeV9saXN0JyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3RcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5UZW1wbGF0ZVJlZiA9IHtcbiAgICAgICAgICBuYW1lOiAnVGVtcGxhdGVSZWYnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3RlbXBsYXRlX3JlZicpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWZcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5UZW1wbGF0ZVJlZl8gPSB7XG4gICAgICAgICAgbmFtZTogJ1RlbXBsYXRlUmVmXycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvdGVtcGxhdGVfcmVmJyksXG4gICAgICAgICAgcnVudGltZTogVGVtcGxhdGVSZWZfXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IHtcbiAgICAgICAgICBuYW1lOiAnQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvY29tcG9uZW50X2ZhY3RvcnlfcmVzb2x2ZXInKSxcbiAgICAgICAgICBydW50aW1lOiBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgICAgICAgIG5hbWU6ICdDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXInLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL2NvbXBvbmVudF9mYWN0b3J5X3Jlc29sdmVyJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5ID0ge1xuICAgICAgICAgIG5hbWU6ICdDb21wb25lbnRGYWN0b3J5JyxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudEZhY3RvcnksXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdsaW5rZXIvY29tcG9uZW50X2ZhY3RvcnknKVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLk5nTW9kdWxlRmFjdG9yeSA9IHtcbiAgICAgICAgICBuYW1lOiAnTmdNb2R1bGVGYWN0b3J5JyxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlRmFjdG9yeSxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9uZ19tb2R1bGVfZmFjdG9yeScpXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuTmdNb2R1bGVJbmplY3RvciA9IHtcbiAgICAgICAgICBuYW1lOiAnTmdNb2R1bGVJbmplY3RvcicsXG4gICAgICAgICAgcnVudGltZTogTmdNb2R1bGVJbmplY3RvcixcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2xpbmtlci9uZ19tb2R1bGVfZmFjdG9yeScpXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuUmVnaXN0ZXJNb2R1bGVGYWN0b3J5Rm4gPSB7XG4gICAgICAgICAgbmFtZTogJ3JlZ2lzdGVyTW9kdWxlRmFjdG9yeScsXG4gICAgICAgICAgcnVudGltZTogcmVnaXN0ZXJNb2R1bGVGYWN0b3J5LFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL25nX21vZHVsZV9mYWN0b3J5X2xvYWRlcicpXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuVmFsdWVVbndyYXBwZXIgPSB7IG5hbWU6ICdWYWx1ZVVud3JhcHBlcicsIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCwgcnVudGltZTogVmFsdWVVbndyYXBwZXIgfTtcbiAgICAgIElkZW50aWZpZXJzLkluamVjdG9yID0ge1xuICAgICAgICAgIG5hbWU6ICdJbmplY3RvcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdkaS9pbmplY3RvcicpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0b3JcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WaWV3RW5jYXBzdWxhdGlvbiA9IHtcbiAgICAgICAgICBuYW1lOiAnVmlld0VuY2Fwc3VsYXRpb24nLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbWV0YWRhdGEvdmlldycpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb25cbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5WaWV3VHlwZSA9IHtcbiAgICAgICAgICBuYW1lOiAnVmlld1R5cGUnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL3ZpZXdfdHlwZScpLFxuICAgICAgICAgIHJ1bnRpbWU6IFZpZXdUeXBlXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7XG4gICAgICAgICAgbmFtZTogJ0NoYW5nZURldGVjdGlvblN0cmF0ZWd5JyxcbiAgICAgICAgICBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLlN0YXRpY05vZGVEZWJ1Z0luZm8gPSB7XG4gICAgICAgICAgbmFtZTogJ1N0YXRpY05vZGVEZWJ1Z0luZm8nLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL2RlYnVnX2NvbnRleHQnKSxcbiAgICAgICAgICBydW50aW1lOiBTdGF0aWNOb2RlRGVidWdJbmZvXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuRGVidWdDb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6ICdEZWJ1Z0NvbnRleHQnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnbGlua2VyL2RlYnVnX2NvbnRleHQnKSxcbiAgICAgICAgICBydW50aW1lOiBEZWJ1Z0NvbnRleHRcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5SZW5kZXJlciA9IHtcbiAgICAgICAgICBuYW1lOiAnUmVuZGVyZXInLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAncmVuZGVyL2FwaScpLFxuICAgICAgICAgIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5TaW1wbGVDaGFuZ2UgPSB7IG5hbWU6ICdTaW1wbGVDaGFuZ2UnLCBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsIHJ1bnRpbWU6IF9hbmd1bGFyX2NvcmUuU2ltcGxlQ2hhbmdlIH07XG4gICAgICBJZGVudGlmaWVycy5VTklOSVRJQUxJWkVEID0geyBuYW1lOiAnVU5JTklUSUFMSVpFRCcsIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCwgcnVudGltZTogVU5JTklUSUFMSVpFRCB9O1xuICAgICAgSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JTdGF0dXMgPSB7XG4gICAgICAgICAgbmFtZTogJ0NoYW5nZURldGVjdG9yU3RhdHVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IENEX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogQ2hhbmdlRGV0ZWN0b3JTdGF0dXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5jaGVja0JpbmRpbmcgPSB7XG4gICAgICAgICAgbmFtZTogJ2NoZWNrQmluZGluZycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogY2hlY2tCaW5kaW5nXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlcyA9IHtcbiAgICAgICAgICBuYW1lOiAnZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2RlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2Rlc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmRldk1vZGVFcXVhbCA9IHsgbmFtZTogJ2Rldk1vZGVFcXVhbCcsIG1vZHVsZVVybDogQ0RfTU9EVUxFX1VSTCwgcnVudGltZTogZGV2TW9kZUVxdWFsIH07XG4gICAgICBJZGVudGlmaWVycy5pbnRlcnBvbGF0ZSA9IHtcbiAgICAgICAgICBuYW1lOiAnaW50ZXJwb2xhdGUnLFxuICAgICAgICAgIG1vZHVsZVVybDogVklFV19VVElMU19NT0RVTEVfVVJMLFxuICAgICAgICAgIHJ1bnRpbWU6IGludGVycG9sYXRlXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuY2FzdEJ5VmFsdWUgPSB7XG4gICAgICAgICAgbmFtZTogJ2Nhc3RCeVZhbHVlJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCxcbiAgICAgICAgICBydW50aW1lOiBjYXN0QnlWYWx1ZVxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkVNUFRZX0FSUkFZID0ge1xuICAgICAgICAgIG5hbWU6ICdFTVBUWV9BUlJBWScsXG4gICAgICAgICAgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsXG4gICAgICAgICAgcnVudGltZTogRU1QVFlfQVJSQVlcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5FTVBUWV9NQVAgPSB7IG5hbWU6ICdFTVBUWV9NQVAnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogRU1QVFlfTUFQIH07XG4gICAgICBJZGVudGlmaWVycy5wdXJlUHJveGllcyA9IFtcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTEnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogcHVyZVByb3h5MSB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTInLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogcHVyZVByb3h5MiB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTMnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogcHVyZVByb3h5MyB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTQnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogcHVyZVByb3h5NCB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTUnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogcHVyZVByb3h5NSB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTYnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogcHVyZVByb3h5NiB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTcnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogcHVyZVByb3h5NyB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTgnLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogcHVyZVByb3h5OCB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTknLCBtb2R1bGVVcmw6IFZJRVdfVVRJTFNfTU9EVUxFX1VSTCwgcnVudGltZTogcHVyZVByb3h5OSB9LFxuICAgICAgICAgIHsgbmFtZTogJ3B1cmVQcm94eTEwJywgbW9kdWxlVXJsOiBWSUVXX1VUSUxTX01PRFVMRV9VUkwsIHJ1bnRpbWU6IHB1cmVQcm94eTEwIH0sXG4gICAgICBdO1xuICAgICAgSWRlbnRpZmllcnMuU2VjdXJpdHlDb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6ICdTZWN1cml0eUNvbnRleHQnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnc2VjdXJpdHknKSxcbiAgICAgICAgICBydW50aW1lOiBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dCxcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5BbmltYXRpb25LZXlmcmFtZSA9IHtcbiAgICAgICAgICBuYW1lOiAnQW5pbWF0aW9uS2V5ZnJhbWUnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl9rZXlmcmFtZScpLFxuICAgICAgICAgIHJ1bnRpbWU6IEFuaW1hdGlvbktleWZyYW1lXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQW5pbWF0aW9uU3R5bGVzID0ge1xuICAgICAgICAgIG5hbWU6ICdBbmltYXRpb25TdHlsZXMnLFxuICAgICAgICAgIG1vZHVsZVVybDogYXNzZXRVcmwoJ2NvcmUnLCAnYW5pbWF0aW9uL2FuaW1hdGlvbl9zdHlsZXMnKSxcbiAgICAgICAgICBydW50aW1lOiBBbmltYXRpb25TdHlsZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5Ob09wQW5pbWF0aW9uUGxheWVyID0ge1xuICAgICAgICAgIG5hbWU6ICdOb09wQW5pbWF0aW9uUGxheWVyJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2FuaW1hdGlvbi9hbmltYXRpb25fcGxheWVyJyksXG4gICAgICAgICAgcnVudGltZTogTm9PcEFuaW1hdGlvblBsYXllclxuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkFuaW1hdGlvbkdyb3VwUGxheWVyID0ge1xuICAgICAgICAgIG5hbWU6ICdBbmltYXRpb25Hcm91cFBsYXllcicsXG4gICAgICAgICAgbW9kdWxlVXJsOiBhc3NldFVybCgnY29yZScsICdhbmltYXRpb24vYW5pbWF0aW9uX2dyb3VwX3BsYXllcicpLFxuICAgICAgICAgIHJ1bnRpbWU6IEFuaW1hdGlvbkdyb3VwUGxheWVyXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIgPSB7XG4gICAgICAgICAgbmFtZTogJ0FuaW1hdGlvblNlcXVlbmNlUGxheWVyJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2FuaW1hdGlvbi9hbmltYXRpb25fc2VxdWVuY2VfcGxheWVyJyksXG4gICAgICAgICAgcnVudGltZTogQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXJcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5wcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ3ByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwsXG4gICAgICAgICAgcnVudGltZTogcHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcyA9IHtcbiAgICAgICAgICBuYW1lOiAnYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwsXG4gICAgICAgICAgcnVudGltZTogYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLmNsZWFyU3R5bGVzID0ge1xuICAgICAgICAgIG5hbWU6ICdjbGVhclN0eWxlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwsXG4gICAgICAgICAgcnVudGltZTogY2xlYXJTdHlsZXNcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5yZW5kZXJTdHlsZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ3JlbmRlclN0eWxlcycsXG4gICAgICAgICAgbW9kdWxlVXJsOiBBTklNQVRJT05fU1RZTEVfVVRJTF9BU1NFVF9VUkwsXG4gICAgICAgICAgcnVudGltZTogcmVuZGVyU3R5bGVzXG4gICAgICB9O1xuICAgICAgSWRlbnRpZmllcnMuY29sbGVjdEFuZFJlc29sdmVTdHlsZXMgPSB7XG4gICAgICAgICAgbmFtZTogJ2NvbGxlY3RBbmRSZXNvbHZlU3R5bGVzJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IEFOSU1BVElPTl9TVFlMRV9VVElMX0FTU0VUX1VSTCxcbiAgICAgICAgICBydW50aW1lOiBjb2xsZWN0QW5kUmVzb2x2ZVN0eWxlc1xuICAgICAgfTtcbiAgICAgIElkZW50aWZpZXJzLkxPQ0FMRV9JRCA9IHtcbiAgICAgICAgICBuYW1lOiAnTE9DQUxFX0lEJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2kxOG4vdG9rZW5zJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5MT0NBTEVfSURcbiAgICAgIH07XG4gICAgICBJZGVudGlmaWVycy5UUkFOU0xBVElPTlNfRk9STUFUID0ge1xuICAgICAgICAgIG5hbWU6ICdUUkFOU0xBVElPTlNfRk9STUFUJyxcbiAgICAgICAgICBtb2R1bGVVcmw6IGFzc2V0VXJsKCdjb3JlJywgJ2kxOG4vdG9rZW5zJyksXG4gICAgICAgICAgcnVudGltZTogX2FuZ3VsYXJfY29yZS5UUkFOU0xBVElPTlNfRk9STUFUXG4gICAgICB9O1xuICAgICAgcmV0dXJuIElkZW50aWZpZXJzO1xuICB9KCkpO1xuICBmdW5jdGlvbiByZXNvbHZlSWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoe1xuICAgICAgICAgIG5hbWU6IGlkZW50aWZpZXIubmFtZSxcbiAgICAgICAgICBtb2R1bGVVcmw6IGlkZW50aWZpZXIubW9kdWxlVXJsLFxuICAgICAgICAgIHJlZmVyZW5jZTogcmVmbGVjdG9yLnJlc29sdmVJZGVudGlmaWVyKGlkZW50aWZpZXIubmFtZSwgaWRlbnRpZmllci5tb2R1bGVVcmwsIGlkZW50aWZpZXIucnVudGltZSlcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGlkZW50aWZpZXJUb2tlbihpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgaWRlbnRpZmllcjogaWRlbnRpZmllciB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlSWRlbnRpZmllclRva2VuKGlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiBpZGVudGlmaWVyVG9rZW4ocmVzb2x2ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVFbnVtSWRlbnRpZmllcihlbnVtVHlwZSwgbmFtZSkge1xuICAgICAgdmFyIHJlc29sdmVkRW51bSA9IHJlZmxlY3Rvci5yZXNvbHZlRW51bShlbnVtVHlwZS5yZWZlcmVuY2UsIG5hbWUpO1xuICAgICAgcmV0dXJuIG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogZW51bVR5cGUubmFtZSArIFwiLlwiICsgbmFtZSwgbW9kdWxlVXJsOiBlbnVtVHlwZS5tb2R1bGVVcmwsIHJlZmVyZW5jZTogcmVzb2x2ZWRFbnVtIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBIdG1sUGFyc2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQ5KEh0bWxQYXJzZXIsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBIdG1sUGFyc2VyKCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGdldEh0bWxUYWdEZWZpbml0aW9uKTtcbiAgICAgIH1cbiAgICAgIEh0bWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgaWYgKHBhcnNlRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyBwYXJzZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICB9O1xuICAgICAgSHRtbFBhcnNlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBIdG1sUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICByZXR1cm4gSHRtbFBhcnNlcjtcbiAgfShQYXJzZXIkMSkpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxMCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgLy8gaHR0cDovL2NsZHIudW5pY29kZS5vcmcvaW5kZXgvY2xkci1zcGVjL3BsdXJhbC1ydWxlc1xuICB2YXIgUExVUkFMX0NBU0VTID0gWyd6ZXJvJywgJ29uZScsICd0d28nLCAnZmV3JywgJ21hbnknLCAnb3RoZXInXTtcbiAgLyoqXG4gICAqIEV4cGFuZHMgc3BlY2lhbCBmb3JtcyBpbnRvIGVsZW1lbnRzLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSxcbiAgICpcbiAgICogYGBgXG4gICAqIHsgbWVzc2FnZXMubGVuZ3RoLCBwbHVyYWwsXG4gICAqICAgPTAge3plcm99XG4gICAqICAgPTEge29uZX1cbiAgICogICBvdGhlciB7bW9yZSB0aGFuIG9uZX1cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogd2lsbCBiZSBleHBhbmRlZCBpbnRvXG4gICAqXG4gICAqIGBgYFxuICAgKiA8bmctY29udGFpbmVyIFtuZ1BsdXJhbF09XCJtZXNzYWdlcy5sZW5ndGhcIj5cbiAgICogICA8dGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiPTBcIj56ZXJvPC9uZy1jb250YWluZXI+XG4gICAqICAgPHRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIj0xXCI+b25lPC9uZy1jb250YWluZXI+XG4gICAqICAgPHRlbXBsYXRlIG5nUGx1cmFsQ2FzZT1cIm90aGVyXCI+bW9yZSB0aGFuIG9uZTwvbmctY29udGFpbmVyPlxuICAgKiA8L25nLWNvbnRhaW5lcj5cbiAgICogYGBgXG4gICAqL1xuICBmdW5jdGlvbiBleHBhbmROb2Rlcyhub2Rlcykge1xuICAgICAgdmFyIGV4cGFuZGVyID0gbmV3IF9FeHBhbmRlcigpO1xuICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25SZXN1bHQodmlzaXRBbGwoZXhwYW5kZXIsIG5vZGVzKSwgZXhwYW5kZXIuaXNFeHBhbmRlZCwgZXhwYW5kZXIuZXJyb3JzKTtcbiAgfVxuICB2YXIgRXhwYW5zaW9uUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEV4cGFuc2lvblJlc3VsdChub2RlcywgZXhwYW5kZWQsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gZXhwYW5kZWQ7XG4gICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gRXhwYW5zaW9uUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgRXhwYW5zaW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEwKEV4cGFuc2lvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gRXhwYW5zaW9uRXJyb3Ioc3BhbiwgZXJyb3JNc2cpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBlcnJvck1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gRXhwYW5zaW9uRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICAvKipcbiAgICogRXhwYW5kIGV4cGFuc2lvbiBmb3JtcyAocGx1cmFsLCBzZWxlY3QpIHRvIGRpcmVjdGl2ZXNcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgX0V4cGFuZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9FeHBhbmRlcigpIHtcbiAgICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgfVxuICAgICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChlbGVtZW50Lm5hbWUsIGVsZW1lbnQuYXR0cnMsIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IHJldHVybiBhdHRyaWJ1dGU7IH07XG4gICAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0OyB9O1xuICAgICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gY29tbWVudDsgfTtcbiAgICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gaWN1LnR5cGUgPT0gJ3BsdXJhbCcgPyBfZXhwYW5kUGx1cmFsRm9ybShpY3UsIHRoaXMuZXJyb3JzKSA6XG4gICAgICAgICAgICAgIF9leHBhbmREZWZhdWx0Rm9ybShpY3UsIHRoaXMuZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGJlIHJlYWNoZWQnKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0V4cGFuZGVyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfZXhwYW5kUGx1cmFsRm9ybShhc3QsIGVycm9ycykge1xuICAgICAgdmFyIGNoaWxkcmVuID0gYXN0LmNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmIChQTFVSQUxfQ0FTRVMuaW5kZXhPZihjLnZhbHVlKSA9PSAtMSAmJiAhYy52YWx1ZS5tYXRjaCgvXj1cXGQrJC8pKSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBFeHBhbnNpb25FcnJvcihjLnZhbHVlU291cmNlU3BhbiwgXCJQbHVyYWwgY2FzZXMgc2hvdWxkIGJlIFxcXCI9PG51bWJlcj5cXFwiIG9yIG9uZSBvZiBcIiArIFBMVVJBTF9DQVNFUy5qb2luKFwiLCBcIikpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGV4cGFuc2lvblJlc3VsdCA9IGV4cGFuZE5vZGVzKGMuZXhwcmVzc2lvbik7XG4gICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBleHBhbnNpb25SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoXCJ0ZW1wbGF0ZVwiLCBbbmV3IEF0dHJpYnV0ZSQxKCduZ1BsdXJhbENhc2UnLCBcIlwiICsgYy52YWx1ZSwgYy52YWx1ZVNvdXJjZVNwYW4pXSwgZXhwYW5zaW9uUmVzdWx0Lm5vZGVzLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHN3aXRjaEF0dHIgPSBuZXcgQXR0cmlidXRlJDEoJ1tuZ1BsdXJhbF0nLCBhc3Quc3dpdGNoVmFsdWUsIGFzdC5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KCduZy1jb250YWluZXInLCBbc3dpdGNoQXR0cl0sIGNoaWxkcmVuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuKTtcbiAgfVxuICBmdW5jdGlvbiBfZXhwYW5kRGVmYXVsdEZvcm0oYXN0LCBlcnJvcnMpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGFzdC5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICB2YXIgZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuc2lvblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChcInRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlJDEoJ25nU3dpdGNoQ2FzZScsIFwiXCIgKyBjLnZhbHVlLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUkMSgnW25nU3dpdGNoXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgICByZXR1cm4gbmV3IEVsZW1lbnQoJ25nLWNvbnRhaW5lcicsIFtzd2l0Y2hBdHRyXSwgY2hpbGRyZW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDExID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTEoUHJvdmlkZXJFcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFByb3ZpZGVyRXJyb3IobWVzc2FnZSwgc3Bhbikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb3ZpZGVyRXJyb3I7XG4gIH0oUGFyc2VFcnJvcikpO1xuICB2YXIgUHJvdmlkZXJWaWV3Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQcm92aWRlclZpZXdDb250ZXh0KGNvbXBvbmVudCwgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KTtcbiAgICAgICAgICB0aGlzLnZpZXdQcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVycyhjb21wb25lbnQudmlld1Byb3ZpZGVycywgc291cmNlU3BhbiwgdGhpcy5lcnJvcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKF90aGlzLnZpZXdQcm92aWRlcnMuZ2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy52aWV3UHJvdmlkZXJzLnNldChwcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvdmlkZXJWaWV3Q29udGV4dDtcbiAgfSgpKTtcbiAgdmFyIFByb3ZpZGVyRWxlbWVudENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUHJvdmlkZXJFbGVtZW50Q29udGV4dCh2aWV3Q29udGV4dCwgX3BhcmVudCwgX2lzVmlld1Jvb3QsIF9kaXJlY3RpdmVBc3RzLCBhdHRycywgcmVmcywgX3NvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMudmlld0NvbnRleHQgPSB2aWV3Q29udGV4dDtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICAgIHRoaXMuX2lzVmlld1Jvb3QgPSBfaXNWaWV3Um9vdDtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVBc3RzID0gX2RpcmVjdGl2ZUFzdHM7XG4gICAgICAgICAgdGhpcy5fc291cmNlU3BhbiA9IF9zb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5faGFzVmlld0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2F0dHJzID0ge307XG4gICAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0ckFzdCkgeyByZXR1cm4gX3RoaXMuX2F0dHJzW2F0dHJBc3QubmFtZV0gPSBhdHRyQXN0LnZhbHVlOyB9KTtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlc01ldGEgPSBfZGlyZWN0aXZlQXN0cy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkgeyByZXR1cm4gZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZTsgfSk7XG4gICAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID1cbiAgICAgICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnNGcm9tRGlyZWN0aXZlcyhkaXJlY3RpdmVzTWV0YSwgX3NvdXJjZVNwYW4sIHZpZXdDb250ZXh0LmVycm9ycyk7XG4gICAgICAgICAgdGhpcy5fY29udGVudFF1ZXJpZXMgPSBfZ2V0Q29udGVudFF1ZXJpZXMoZGlyZWN0aXZlc01ldGEpO1xuICAgICAgICAgIHZhciBxdWVyaWVkVG9rZW5zID0gbmV3IE1hcCgpO1xuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FsbFByb3ZpZGVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2FkZFF1ZXJ5UmVhZHNUbyhwcm92aWRlci50b2tlbiwgcXVlcmllZFRva2Vucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZBc3QpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2FkZFF1ZXJ5UmVhZHNUbyhuZXcgQ29tcGlsZVRva2VuTWV0YWRhdGEoeyB2YWx1ZTogcmVmQXN0Lm5hbWUgfSksIHF1ZXJpZWRUb2tlbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcmllZFRva2Vucy5nZXQocmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKS5yZWZlcmVuY2UpKSkge1xuICAgICAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY3JlYXRlIHRoZSBwcm92aWRlcnMgdGhhdCB3ZSBrbm93IGFyZSBlYWdlciBmaXJzdFxuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FsbFByb3ZpZGVycykuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGVhZ2VyID0gcHJvdmlkZXIuZWFnZXIgfHwgaXNQcmVzZW50KHF1ZXJpZWRUb2tlbnMuZ2V0KHByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgICBpZiAoZWFnZXIpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLmFmdGVyRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIC8vIGNvbGxlY3QgbGF6eSBwcm92aWRlcnNcbiAgICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl9hbGxQcm92aWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIucHJvdmlkZXJUeXBlLCBwcm92aWRlci50b2tlbiwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1Qcm92aWRlcnNcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFwV3JhcHBlci52YWx1ZXModGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZSwgXCJ0cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHNcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgc29ydGVkUHJvdmlkZXJUeXBlcyA9IHRoaXMudHJhbnNmb3JtUHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXI7IH0pO1xuICAgICAgICAgICAgICB2YXIgc29ydGVkRGlyZWN0aXZlcyA9IExpc3RXcmFwcGVyLmNsb25lKHRoaXMuX2RpcmVjdGl2ZUFzdHMpO1xuICAgICAgICAgICAgICBMaXN0V3JhcHBlci5zb3J0KHNvcnRlZERpcmVjdGl2ZXMsIGZ1bmN0aW9uIChkaXIxLCBkaXIyKSB7IHJldHVybiBzb3J0ZWRQcm92aWRlclR5cGVzLmluZGV4T2YoZGlyMS5kaXJlY3RpdmUudHlwZSkgLVxuICAgICAgICAgICAgICAgICAgc29ydGVkUHJvdmlkZXJUeXBlcy5pbmRleE9mKGRpcjIuZGlyZWN0aXZlLnR5cGUpOyB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHNvcnRlZERpcmVjdGl2ZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1ZpZXdDb250YWluZXI7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2FkZFF1ZXJ5UmVhZHNUbyA9IGZ1bmN0aW9uICh0b2tlbiwgcXVlcnlSZWFkVG9rZW5zKSB7XG4gICAgICAgICAgdGhpcy5fZ2V0UXVlcmllc0Zvcih0b2tlbikuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXJ5UmVhZFRva2VuID0gaXNQcmVzZW50KHF1ZXJ5LnJlYWQpID8gcXVlcnkucmVhZCA6IHRva2VuO1xuICAgICAgICAgICAgICBpZiAoaXNCbGFuayhxdWVyeVJlYWRUb2tlbnMuZ2V0KHF1ZXJ5UmVhZFRva2VuLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgICAgICBxdWVyeVJlYWRUb2tlbnMuc2V0KHF1ZXJ5UmVhZFRva2VuLnJlZmVyZW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0UXVlcmllc0ZvciA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICB2YXIgY3VycmVudEVsID0gdGhpcztcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgIHZhciBxdWVyaWVzO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50RWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcXVlcmllcyA9IGN1cnJlbnRFbC5fY29udGVudFF1ZXJpZXMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcmllcykpIHtcbiAgICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbChyZXN1bHQsIHF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkuZGVzY2VuZGFudHMgfHwgZGlzdGFuY2UgPD0gMTsgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50RWwuX2RpcmVjdGl2ZUFzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgZGlzdGFuY2UrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50RWwgPSBjdXJyZW50RWwuX3BhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVlcmllcyA9IHRoaXMudmlld0NvbnRleHQudmlld1F1ZXJpZXMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChxdWVyaWVzKSkge1xuICAgICAgICAgICAgICBMaXN0V3JhcHBlci5hZGRBbGwocmVzdWx0LCBxdWVyaWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIHRva2VuLCBlYWdlcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXIgPSB0aGlzLl9hbGxQcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyIHx8ICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UpICYmXG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSkgfHxcbiAgICAgICAgICAgICAgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSB8fFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5CdWlsdGluKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPSB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NlZW5Qcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSkpKSB7XG4gICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khIFwiICsgdG9rZW4ubmFtZSwgdGhpcy5fc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2VlblByb3ZpZGVycy5zZXQodG9rZW4ucmVmZXJlbmNlLCB0cnVlKTtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQcm92aWRlcnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gcHJvdmlkZXIudXNlRXhpc3Rpbmc7XG4gICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZERlcHM7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdEaURlcCA9IF90aGlzLl9nZXREZXBlbmRlbmN5KHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJUeXBlLCBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0pLCBlYWdlcik7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4aXN0aW5nRGlEZXAudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gZXhpc3RpbmdEaURlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkZXBzID0gaXNQcmVzZW50KHByb3ZpZGVyLmRlcHMpID8gcHJvdmlkZXIuZGVwcyA6IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcik7IH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkZXBzID0gaXNQcmVzZW50KHByb3ZpZGVyLmRlcHMpID8gcHJvdmlkZXIuZGVwcyA6IHByb3ZpZGVyLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogdHJhbnNmb3JtZWRVc2VFeGlzdGluZyxcbiAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0cmFuc2Zvcm1lZFVzZVZhbHVlLFxuICAgICAgICAgICAgICAgICAgZGVwczogdHJhbnNmb3JtZWREZXBzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPVxuICAgICAgICAgICAgICBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocmVzb2x2ZWRQcm92aWRlciwgeyBlYWdlcjogZWFnZXIsIHByb3ZpZGVyczogdHJhbnNmb3JtZWRQcm92aWRlcnMgfSk7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuc2V0KHRva2VuLnJlZmVyZW5jZSwgdHJhbnNmb3JtZWRQcm92aWRlckFzdCk7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgICB9O1xuICAgICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldExvY2FsRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgICAgaWYgKGVhZ2VyID09PSB2b2lkIDApIHsgZWFnZXIgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKGRlcC5pc0F0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gdGhpcy5fYXR0cnNbZGVwLnRva2VuLnZhbHVlXTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbm9ybWFsaXplQmxhbmsoYXR0clZhbHVlKSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChkZXAucXVlcnkpIHx8IGlzUHJlc2VudChkZXAudmlld1F1ZXJ5KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlcC50b2tlbikpIHtcbiAgICAgICAgICAgICAgLy8gYWNjZXNzIGJ1aWx0aW50c1xuICAgICAgICAgICAgICBpZiAoKHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGRlcC50b2tlbi5yZWZlcmVuY2UgPT09IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuUmVuZGVyZXIpLnJlZmVyZW5jZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGRlcC50b2tlbi5yZWZlcmVuY2UgPT09IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuRWxlbWVudFJlZikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3RvclJlZikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkZXAudG9rZW4ucmVmZXJlbmNlID09PVxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZikucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzVmlld0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYWNjZXNzIHRoZSBpbmplY3RvclxuICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5JbmplY3RvcikucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGFjY2VzcyBwcm92aWRlcnNcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLnRva2VuLCBlYWdlcikpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGVwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKHJlcXVlc3RpbmdQcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpIHtcbiAgICAgICAgICBpZiAoZWFnZXIgPT09IHZvaWQgMCkgeyBlYWdlciA9IG51bGw7IH1cbiAgICAgICAgICB2YXIgY3VyckVsZW1lbnQgPSB0aGlzO1xuICAgICAgICAgIHZhciBjdXJyRWFnZXIgPSBlYWdlcjtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldExvY2FsRGVwZW5kZW5jeShyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlcC5pc1NlbGYpIHtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQgJiYgZGVwLmlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgcGFyZW50IGVsZW1lbnRzXG4gICAgICAgICAgICAgIHdoaWxlICghcmVzdWx0ICYmIGlzUHJlc2VudChjdXJyRWxlbWVudC5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHByZXZFbGVtZW50ID0gY3VyckVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICBjdXJyRWxlbWVudCA9IGN1cnJFbGVtZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZiAocHJldkVsZW1lbnQuX2lzVmlld1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyRWFnZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJFbGVtZW50Ll9nZXRMb2NhbERlcGVuZGVuY3koZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZGVwLCBjdXJyRWFnZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGNoZWNrIEBIb3N0IHJlc3RyaWN0aW9uXG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWRlcC5pc0hvc3QgfHwgdGhpcy52aWV3Q29udGV4dC5jb21wb25lbnQudHlwZS5pc0hvc3QgfHxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSA9PT0gZGVwLnRva2VuLnJlZmVyZW5jZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGlzUHJlc2VudCh0aGlzLnZpZXdDb250ZXh0LnZpZXdQcm92aWRlcnMuZ2V0KGRlcC50b2tlbi5yZWZlcmVuY2UpKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlcC5pc09wdGlvbmFsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBudWxsIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiTm8gcHJvdmlkZXIgZm9yIFwiICsgZGVwLnRva2VuLm5hbWUsIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUHJvdmlkZXJFbGVtZW50Q29udGV4dDtcbiAgfSgpKTtcbiAgdmFyIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIobmdNb2R1bGUsIGV4dHJhUHJvdmlkZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2FsbFByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB2YXIgbmdNb2R1bGVUeXBlcyA9IG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1vZHVsZU1ldGEpIHsgcmV0dXJuIG1vZHVsZU1ldGEudHlwZTsgfSk7XG4gICAgICAgICAgbmdNb2R1bGVUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIG5nTW9kdWxlUHJvdmlkZXIgPSBuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoeyB0b2tlbjogbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgaWRlbnRpZmllcjogbmdNb2R1bGVUeXBlIH0pLCB1c2VDbGFzczogbmdNb2R1bGVUeXBlIH0pO1xuICAgICAgICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhbbmdNb2R1bGVQcm92aWRlcl0sIGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIHRydWUsIHNvdXJjZVNwYW4sIF90aGlzLl9lcnJvcnMsIF90aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKF9ub3JtYWxpemVQcm92aWRlcnMobmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5wcm92aWRlcnMuY29uY2F0KGV4dHJhUHJvdmlkZXJzKSwgc291cmNlU3BhbiwgdGhpcy5fZXJyb3JzKSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRoaXMuX2Vycm9ycywgdGhpcy5fYWxsUHJvdmlkZXJzKTtcbiAgICAgIH1cbiAgICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl9hbGxQcm92aWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLmVhZ2VyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGhpcy5fZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gdGhpcy5fZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aWRlciBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycyk7XG4gICAgICB9O1xuICAgICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHRva2VuLCBlYWdlcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXIgPSB0aGlzLl9hbGxQcm92aWRlcnMuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9IHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQodHJhbnNmb3JtZWRQcm92aWRlckFzdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW4ucmVmZXJlbmNlKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khIFwiICsgdG9rZW4ubmFtZSwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzLnNldCh0b2tlbi5yZWZlcmVuY2UsIHRydWUpO1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZFByb3ZpZGVycyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBwcm92aWRlci51c2VWYWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBwcm92aWRlci51c2VFeGlzdGluZztcbiAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkRGVwcztcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VFeGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0RpRGVwID0gX3RoaXMuX2dldERlcGVuZGVuY3kobmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KSwgZWFnZXIsIHJlc29sdmVkUHJvdmlkZXIuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4aXN0aW5nRGlEZXAudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IGV4aXN0aW5nRGlEZXAudG9rZW47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gZXhpc3RpbmdEaURlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkZXBzID0gaXNQcmVzZW50KHByb3ZpZGVyLmRlcHMpID8gcHJvdmlkZXIuZGVwcyA6IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXAsIGVhZ2VyLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pOyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IGlzUHJlc2VudChwcm92aWRlci5kZXBzKSA/IHByb3ZpZGVyLmRlcHMgOiBwcm92aWRlci51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KGRlcCwgZWFnZXIsIHJlc29sdmVkUHJvdmlkZXIuc291cmNlU3Bhbik7IH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nLFxuICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRyYW5zZm9ybWVkVXNlVmFsdWUsXG4gICAgICAgICAgICAgICAgICBkZXBzOiB0cmFuc2Zvcm1lZERlcHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9XG4gICAgICAgICAgICAgIF90cmFuc2Zvcm1Qcm92aWRlckFzdChyZXNvbHZlZFByb3ZpZGVyLCB7IGVhZ2VyOiBlYWdlciwgcHJvdmlkZXJzOiB0cmFuc2Zvcm1lZFByb3ZpZGVycyB9KTtcbiAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5zZXQodG9rZW4ucmVmZXJlbmNlLCB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KTtcbiAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgIH07XG4gICAgICBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGRlcCwgZWFnZXIsIHJlcXVlc3RvclNvdXJjZVNwYW4pIHtcbiAgICAgICAgICBpZiAoZWFnZXIgPT09IHZvaWQgMCkgeyBlYWdlciA9IG51bGw7IH1cbiAgICAgICAgICB2YXIgZm91bmRMb2NhbCA9IGZhbHNlO1xuICAgICAgICAgIGlmICghZGVwLmlzU2tpcFNlbGYgJiYgaXNQcmVzZW50KGRlcC50b2tlbikpIHtcbiAgICAgICAgICAgICAgLy8gYWNjZXNzIHRoZSBpbmplY3RvclxuICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5JbmplY3RvcikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICBkZXAudG9rZW4ucmVmZXJlbmNlID09PVxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kTG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIoZGVwLnRva2VuLCBlYWdlcikpKSB7XG4gICAgICAgICAgICAgICAgICBmb3VuZExvY2FsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZGVwO1xuICAgICAgICAgIGlmIChkZXAuaXNTZWxmICYmICFmb3VuZExvY2FsKSB7XG4gICAgICAgICAgICAgIGlmIChkZXAuaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IFByb3ZpZGVyRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyBkZXAudG9rZW4ubmFtZSwgcmVxdWVzdG9yU291cmNlU3BhbikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCBfYSkge1xuICAgICAgdmFyIHVzZUV4aXN0aW5nID0gX2EudXNlRXhpc3RpbmcsIHVzZVZhbHVlID0gX2EudXNlVmFsdWUsIGRlcHMgPSBfYS5kZXBzO1xuICAgICAgcmV0dXJuIG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7XG4gICAgICAgICAgdG9rZW46IHByb3ZpZGVyLnRva2VuLFxuICAgICAgICAgIHVzZUNsYXNzOiBwcm92aWRlci51c2VDbGFzcyxcbiAgICAgICAgICB1c2VFeGlzdGluZzogdXNlRXhpc3RpbmcsXG4gICAgICAgICAgdXNlRmFjdG9yeTogcHJvdmlkZXIudXNlRmFjdG9yeSxcbiAgICAgICAgICB1c2VWYWx1ZTogdXNlVmFsdWUsXG4gICAgICAgICAgZGVwczogZGVwcyxcbiAgICAgICAgICBtdWx0aTogcHJvdmlkZXIubXVsdGlcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIF90cmFuc2Zvcm1Qcm92aWRlckFzdChwcm92aWRlciwgX2EpIHtcbiAgICAgIHZhciBlYWdlciA9IF9hLmVhZ2VyLCBwcm92aWRlcnMgPSBfYS5wcm92aWRlcnM7XG4gICAgICByZXR1cm4gbmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci5tdWx0aVByb3ZpZGVyLCBwcm92aWRlci5lYWdlciB8fCBlYWdlciwgcHJvdmlkZXJzLCBwcm92aWRlci5wcm92aWRlclR5cGUsIHByb3ZpZGVyLmxpZmVjeWNsZUhvb2tzLCBwcm92aWRlci5zb3VyY2VTcGFuKTtcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVycywgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCB0YXJnZXRQcm92aWRlcnMpIHtcbiAgICAgIGlmICh0YXJnZXRQcm92aWRlcnMgPT09IHZvaWQgMCkgeyB0YXJnZXRQcm92aWRlcnMgPSBudWxsOyB9XG4gICAgICBpZiAoIXRhcmdldFByb3ZpZGVycykge1xuICAgICAgICAgIHRhcmdldFByb3ZpZGVycyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJlc2VudChwcm92aWRlcnMpKSB7XG4gICAgICAgICAgcHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FycmF5KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVycyhwcm92aWRlciwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCB0YXJnZXRQcm92aWRlcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZVByb3ZpZGVyID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyIGluc3RhbmNlb2YgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIgaW5zdGFuY2VvZiBDb21waWxlVHlwZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplUHJvdmlkZXIgPSBuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoeyB0b2tlbjogbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgaWRlbnRpZmllcjogcHJvdmlkZXIgfSksIHVzZUNsYXNzOiBwcm92aWRlciB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiVW5rbm93biBwcm92aWRlciB0eXBlIFwiICsgcHJvdmlkZXIsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobm9ybWFsaXplUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJvdmlkZXJzLnB1c2gobm9ybWFsaXplUHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0UHJvdmlkZXJzO1xuICB9XG4gIGZ1bmN0aW9uIF9yZXNvbHZlUHJvdmlkZXJzRnJvbURpcmVjdGl2ZXMoZGlyZWN0aXZlcywgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzKSB7XG4gICAgICB2YXIgcHJvdmlkZXJzQnlUb2tlbiA9IG5ldyBNYXAoKTtcbiAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgdmFyIGRpclByb3ZpZGVyID0gbmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHsgdG9rZW46IG5ldyBDb21waWxlVG9rZW5NZXRhZGF0YSh7IGlkZW50aWZpZXI6IGRpcmVjdGl2ZS50eXBlIH0pLCB1c2VDbGFzczogZGlyZWN0aXZlLnR5cGUgfSk7XG4gICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoW2RpclByb3ZpZGVyXSwgZGlyZWN0aXZlLmlzQ29tcG9uZW50ID8gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuQ29tcG9uZW50IDogZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlLCB0cnVlLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHByb3ZpZGVyc0J5VG9rZW4pO1xuICAgICAgfSk7XG4gICAgICAvLyBOb3RlOiBkaXJlY3RpdmVzIG5lZWQgdG8gYmUgYWJsZSB0byBvdmVyd3JpdGUgcHJvdmlkZXJzIG9mIGEgY29tcG9uZW50IVxuICAgICAgdmFyIGRpcmVjdGl2ZXNXaXRoQ29tcG9uZW50Rmlyc3QgPSBkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBkaXIuaXNDb21wb25lbnQ7IH0pLmNvbmNhdChkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAhZGlyLmlzQ29tcG9uZW50OyB9KSk7XG4gICAgICBkaXJlY3RpdmVzV2l0aENvbXBvbmVudEZpcnN0LmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKF9ub3JtYWxpemVQcm92aWRlcnMoZGlyZWN0aXZlLnByb3ZpZGVycywgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzKSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSwgZmFsc2UsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgcHJvdmlkZXJzQnlUb2tlbik7XG4gICAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoX25vcm1hbGl6ZVByb3ZpZGVycyhkaXJlY3RpdmUudmlld1Byb3ZpZGVycywgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzKSwgZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UsIGZhbHNlLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHByb3ZpZGVyc0J5VG9rZW4pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvdmlkZXJzQnlUb2tlbjtcbiAgfVxuICBmdW5jdGlvbiBfcmVzb2x2ZVByb3ZpZGVycyhwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgZWFnZXIsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycywgdGFyZ2V0UHJvdmlkZXJzQnlUb2tlbikge1xuICAgICAgcHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXIgPSB0YXJnZXRQcm92aWRlcnNCeVRva2VuLmdldChwcm92aWRlci50b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocmVzb2x2ZWRQcm92aWRlcikgJiYgcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyICE9PSBwcm92aWRlci5tdWx0aSkge1xuICAgICAgICAgICAgICB0YXJnZXRFcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIk1peGluZyBtdWx0aSBhbmQgbm9uIG11bHRpIHByb3ZpZGVyIGlzIG5vdCBwb3NzaWJsZSBmb3IgdG9rZW4gXCIgKyByZXNvbHZlZFByb3ZpZGVyLnRva2VuLm5hbWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIHZhciBsaWZlY3ljbGVIb29rcyA9IHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIgJiYgcHJvdmlkZXIudG9rZW4uaWRlbnRpZmllciBpbnN0YW5jZW9mIENvbXBpbGVUeXBlTWV0YWRhdGEgP1xuICAgICAgICAgICAgICAgICAgcHJvdmlkZXIudG9rZW4uaWRlbnRpZmllci5saWZlY3ljbGVIb29rcyA6XG4gICAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IG5ldyBQcm92aWRlckFzdChwcm92aWRlci50b2tlbiwgcHJvdmlkZXIubXVsdGksIGVhZ2VyIHx8IGxpZmVjeWNsZUhvb2tzLmxlbmd0aCA+IDAsIFtwcm92aWRlcl0sIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0YXJnZXRQcm92aWRlcnNCeVRva2VuLnNldChwcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIHJlc29sdmVkUHJvdmlkZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFwcm92aWRlci5tdWx0aSkge1xuICAgICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIuY2xlYXIocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRWaWV3UXVlcmllcyhjb21wb25lbnQpIHtcbiAgICAgIHZhciB2aWV3UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgIGlmIChpc1ByZXNlbnQoY29tcG9uZW50LnZpZXdRdWVyaWVzKSkge1xuICAgICAgICAgIGNvbXBvbmVudC52aWV3UXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgcXVlcnkpOyB9KTtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudC50eXBlLmRpRGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlcC52aWV3UXVlcnkpKSB7XG4gICAgICAgICAgICAgIF9hZGRRdWVyeVRvVG9rZW5NYXAodmlld1F1ZXJpZXMsIGRlcC52aWV3UXVlcnkpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHZpZXdRdWVyaWVzO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXRDb250ZW50UXVlcmllcyhkaXJlY3RpdmVzKSB7XG4gICAgICB2YXIgY29udGVudFF1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGlyZWN0aXZlLnF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZS5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBfYWRkUXVlcnlUb1Rva2VuTWFwKGNvbnRlbnRRdWVyaWVzLCBxdWVyeSk7IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXJlY3RpdmUudHlwZS5kaURlcHMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVwLnF1ZXJ5KSkge1xuICAgICAgICAgICAgICAgICAgX2FkZFF1ZXJ5VG9Ub2tlbk1hcChjb250ZW50UXVlcmllcywgZGVwLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29udGVudFF1ZXJpZXM7XG4gIH1cbiAgZnVuY3Rpb24gX2FkZFF1ZXJ5VG9Ub2tlbk1hcChtYXAsIHF1ZXJ5KSB7XG4gICAgICBxdWVyeS5zZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KHRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICAgICAgICBlbnRyeSA9IFtdO1xuICAgICAgICAgICAgICBtYXAuc2V0KHRva2VuLnJlZmVyZW5jZSwgZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbnRyeS5wdXNoKHF1ZXJ5KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFbGVtZW50U2NoZW1hUmVnaXN0cnk7XG4gIH0oKSk7XG5cbiAgdmFyIFN0eWxlV2l0aEltcG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3R5bGVXaXRoSW1wb3J0cyhzdHlsZSwgc3R5bGVVcmxzKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICAgIHRoaXMuc3R5bGVVcmxzID0gc3R5bGVVcmxzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0eWxlV2l0aEltcG9ydHM7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkge1xuICAgICAgaWYgKGlzQmxhbmsodXJsKSB8fCB1cmwubGVuZ3RoID09PSAwIHx8IHVybFswXSA9PSAnLycpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHNjaGVtZU1hdGNoID0gdXJsLm1hdGNoKF91cmxXaXRoU2NoZW1hUmUpO1xuICAgICAgcmV0dXJuIHNjaGVtZU1hdGNoID09PSBudWxsIHx8IHNjaGVtZU1hdGNoWzFdID09ICdwYWNrYWdlJyB8fCBzY2hlbWVNYXRjaFsxXSA9PSAnYXNzZXQnO1xuICB9XG4gIC8qKlxuICAgKiBSZXdyaXRlcyBzdHlsZXNoZWV0cyBieSByZXNvbHZpbmcgYW5kIHJlbW92aW5nIHRoZSBAaW1wb3J0IHVybHMgdGhhdFxuICAgKiBhcmUgZWl0aGVyIHJlbGF0aXZlIG9yIGRvbid0IGhhdmUgYSBgcGFja2FnZTpgIHNjaGVtZVxuICAgKi9cbiAgZnVuY3Rpb24gZXh0cmFjdFN0eWxlVXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCkge1xuICAgICAgdmFyIGZvdW5kVXJscyA9IFtdO1xuICAgICAgdmFyIG1vZGlmaWVkQ3NzVGV4dCA9IFN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChjc3NUZXh0LCBfY3NzSW1wb3J0UmUsIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgdmFyIHVybCA9IGlzUHJlc2VudChtWzFdKSA/IG1bMV0gOiBtWzJdO1xuICAgICAgICAgIGlmICghaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSkge1xuICAgICAgICAgICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byByZXNvbHZlIG5vbi1wYWNrYWdlIGFic29sdXRlIFVSTHMgd2l0aCBVUkkgc2NoZW1lXG4gICAgICAgICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3VuZFVybHMucHVzaChyZXNvbHZlci5yZXNvbHZlKGJhc2VVcmwsIHVybCkpO1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBTdHlsZVdpdGhJbXBvcnRzKG1vZGlmaWVkQ3NzVGV4dCwgZm91bmRVcmxzKTtcbiAgfVxuICB2YXIgX2Nzc0ltcG9ydFJlID0gL0BpbXBvcnRcXHMrKD86dXJsXFwoKT9cXHMqKD86KD86WydcIl0oW14nXCJdKikpfChbXjtcXClcXHNdKikpW147XSo7Py9nO1xuICB2YXIgX3VybFdpdGhTY2hlbWFSZSA9IC9eKFteOi8/I10rKTovO1xuXG4gIHZhciBOR19DT05URU5UX1NFTEVDVF9BVFRSID0gJ3NlbGVjdCc7XG4gIHZhciBOR19DT05URU5UX0VMRU1FTlQgPSAnbmctY29udGVudCc7XG4gIHZhciBMSU5LX0VMRU1FTlQgPSAnbGluayc7XG4gIHZhciBMSU5LX1NUWUxFX1JFTF9BVFRSID0gJ3JlbCc7XG4gIHZhciBMSU5LX1NUWUxFX0hSRUZfQVRUUiA9ICdocmVmJztcbiAgdmFyIExJTktfU1RZTEVfUkVMX1ZBTFVFID0gJ3N0eWxlc2hlZXQnO1xuICB2YXIgU1RZTEVfRUxFTUVOVCA9ICdzdHlsZSc7XG4gIHZhciBTQ1JJUFRfRUxFTUVOVCA9ICdzY3JpcHQnO1xuICB2YXIgTkdfTk9OX0JJTkRBQkxFX0FUVFIgPSAnbmdOb25CaW5kYWJsZSc7XG4gIHZhciBOR19QUk9KRUNUX0FTID0gJ25nUHJvamVjdEFzJztcbiAgZnVuY3Rpb24gcHJlcGFyc2VFbGVtZW50KGFzdCkge1xuICAgICAgdmFyIHNlbGVjdEF0dHIgPSBudWxsO1xuICAgICAgdmFyIGhyZWZBdHRyID0gbnVsbDtcbiAgICAgIHZhciByZWxBdHRyID0gbnVsbDtcbiAgICAgIHZhciBub25CaW5kYWJsZSA9IGZhbHNlO1xuICAgICAgdmFyIHByb2plY3RBcyA9IG51bGw7XG4gICAgICBhc3QuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHZhciBsY0F0dHJOYW1lID0gYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGxjQXR0ck5hbWUgPT0gTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUikge1xuICAgICAgICAgICAgICBzZWxlY3RBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobGNBdHRyTmFtZSA9PSBMSU5LX1NUWUxFX0hSRUZfQVRUUikge1xuICAgICAgICAgICAgICBocmVmQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGxjQXR0ck5hbWUgPT0gTElOS19TVFlMRV9SRUxfQVRUUikge1xuICAgICAgICAgICAgICByZWxBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lID09IE5HX05PTl9CSU5EQUJMRV9BVFRSKSB7XG4gICAgICAgICAgICAgIG5vbkJpbmRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lID09IE5HX1BST0pFQ1RfQVMpIHtcbiAgICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgcHJvamVjdEFzID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2VsZWN0QXR0ciA9IG5vcm1hbGl6ZU5nQ29udGVudFNlbGVjdChzZWxlY3RBdHRyKTtcbiAgICAgIHZhciBub2RlTmFtZSA9IGFzdC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk9USEVSO1xuICAgICAgaWYgKHNwbGl0TnNOYW1lKG5vZGVOYW1lKVsxXSA9PSBOR19DT05URU5UX0VMRU1FTlQpIHtcbiAgICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNUWUxFX0VMRU1FTlQpIHtcbiAgICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTQ1JJUFRfRUxFTUVOVCkge1xuICAgICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBMSU5LX0VMRU1FTlQgJiYgcmVsQXR0ciA9PSBMSU5LX1NUWUxFX1JFTF9WQUxVRSkge1xuICAgICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKTtcbiAgfVxuICB2YXIgUHJlcGFyc2VkRWxlbWVudFR5cGU7XG4gIChmdW5jdGlvbiAoUHJlcGFyc2VkRWxlbWVudFR5cGUpIHtcbiAgICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiTkdfQ09OVEVOVFwiXSA9IDBdID0gXCJOR19DT05URU5UXCI7XG4gICAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIlNUWUxFXCJdID0gMV0gPSBcIlNUWUxFXCI7XG4gICAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIlNUWUxFU0hFRVRcIl0gPSAyXSA9IFwiU1RZTEVTSEVFVFwiO1xuICAgICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTQ1JJUFRcIl0gPSAzXSA9IFwiU0NSSVBUXCI7XG4gICAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIk9USEVSXCJdID0gNF0gPSBcIk9USEVSXCI7XG4gIH0pKFByZXBhcnNlZEVsZW1lbnRUeXBlIHx8IChQcmVwYXJzZWRFbGVtZW50VHlwZSA9IHt9KSk7XG4gIHZhciBQcmVwYXJzZWRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFByZXBhcnNlZEVsZW1lbnQodHlwZSwgc2VsZWN0QXR0ciwgaHJlZkF0dHIsIG5vbkJpbmRhYmxlLCBwcm9qZWN0QXMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgIHRoaXMuc2VsZWN0QXR0ciA9IHNlbGVjdEF0dHI7XG4gICAgICAgICAgdGhpcy5ocmVmQXR0ciA9IGhyZWZBdHRyO1xuICAgICAgICAgIHRoaXMubm9uQmluZGFibGUgPSBub25CaW5kYWJsZTtcbiAgICAgICAgICB0aGlzLnByb2plY3RBcyA9IHByb2plY3RBcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcmVwYXJzZWRFbGVtZW50O1xuICB9KCkpO1xuICBmdW5jdGlvbiBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cikge1xuICAgICAgaWYgKHNlbGVjdEF0dHIgPT09IG51bGwgfHwgc2VsZWN0QXR0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gJyonO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdEF0dHI7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIC8vIEdyb3VwIDEgPSBcImJpbmQtXCJcbiAgLy8gR3JvdXAgMiA9IFwibGV0LVwiXG4gIC8vIEdyb3VwIDMgPSBcInJlZi0vI1wiXG4gIC8vIEdyb3VwIDQgPSBcIm9uLVwiXG4gIC8vIEdyb3VwIDUgPSBcImJpbmRvbi1cIlxuICAvLyBHcm91cCA2ID0gXCJAXCJcbiAgLy8gR3JvdXAgNyA9IHRoZSBpZGVudGlmaWVyIGFmdGVyIFwiYmluZC1cIiwgXCJsZXQtXCIsIFwicmVmLS8jXCIsIFwib24tXCIsIFwiYmluZG9uLVwiIG9yIFwiQFwiXG4gIC8vIEdyb3VwIDggPSBpZGVudGlmaWVyIGluc2lkZSBbKCldXG4gIC8vIEdyb3VwIDkgPSBpZGVudGlmaWVyIGluc2lkZSBbXVxuICAvLyBHcm91cCAxMCA9IGlkZW50aWZpZXIgaW5zaWRlICgpXG4gIHZhciBCSU5EX05BTUVfUkVHRVhQID0gL14oPzooPzooPzooYmluZC0pfChsZXQtKXwocmVmLXwjKXwob24tKXwoYmluZG9uLSl8KEApKSguKykpfFxcW1xcKChbXlxcKV0rKVxcKVxcXXxcXFsoW15cXF1dKylcXF18XFwoKFteXFwpXSspXFwpKSQvO1xuICB2YXIgS1dfQklORF9JRFggPSAxO1xuICB2YXIgS1dfTEVUX0lEWCA9IDI7XG4gIHZhciBLV19SRUZfSURYID0gMztcbiAgdmFyIEtXX09OX0lEWCA9IDQ7XG4gIHZhciBLV19CSU5ET05fSURYID0gNTtcbiAgdmFyIEtXX0FUX0lEWCA9IDY7XG4gIHZhciBJREVOVF9LV19JRFggPSA3O1xuICB2YXIgSURFTlRfQkFOQU5BX0JPWF9JRFggPSA4O1xuICB2YXIgSURFTlRfUFJPUEVSVFlfSURYID0gOTtcbiAgdmFyIElERU5UX0VWRU5UX0lEWCA9IDEwO1xuICB2YXIgQU5JTUFURV9QUk9QX1BSRUZJWCA9ICdhbmltYXRlLSc7XG4gIHZhciBURU1QTEFURV9FTEVNRU5UID0gJ3RlbXBsYXRlJztcbiAgdmFyIFRFTVBMQVRFX0FUVFIgPSAndGVtcGxhdGUnO1xuICB2YXIgVEVNUExBVEVfQVRUUl9QUkVGSVggPSAnKic7XG4gIHZhciBDTEFTU19BVFRSID0gJ2NsYXNzJztcbiAgdmFyIFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUiA9ICcuJztcbiAgdmFyIEFUVFJJQlVURV9QUkVGSVggPSAnYXR0cic7XG4gIHZhciBDTEFTU19QUkVGSVggPSAnY2xhc3MnO1xuICB2YXIgU1RZTEVfUFJFRklYID0gJ3N0eWxlJztcbiAgdmFyIFRFWFRfQ1NTX1NFTEVDVE9SID0gQ3NzU2VsZWN0b3IucGFyc2UoJyonKVswXTtcbiAgLyoqXG4gICAqIFByb3ZpZGVzIGFuIGFycmF5IG9mIHtAbGluayBUZW1wbGF0ZUFzdFZpc2l0b3J9cyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gdHJhbnNmb3JtXG4gICAqIHBhcnNlZCB0ZW1wbGF0ZXMgYmVmb3JlIGNvbXBpbGF0aW9uIGlzIGludm9rZWQsIGFsbG93aW5nIGN1c3RvbSBleHByZXNzaW9uIHN5bnRheFxuICAgKiBhbmQgb3RoZXIgYWR2YW5jZWQgdHJhbnNmb3JtYXRpb25zLlxuICAgKlxuICAgKiBUaGlzIGlzIGN1cnJlbnRseSBhbiBpbnRlcm5hbC1vbmx5IGZlYXR1cmUgYW5kIG5vdCBtZWFudCBmb3IgZ2VuZXJhbCB1c2UuXG4gICAqL1xuICB2YXIgVEVNUExBVEVfVFJBTlNGT1JNUyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdUZW1wbGF0ZVRyYW5zZm9ybXMnKTtcbiAgdmFyIFRlbXBsYXRlUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMoVGVtcGxhdGVQYXJzZUVycm9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZUVycm9yKG1lc3NhZ2UsIHNwYW4sIGxldmVsKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgbWVzc2FnZSwgbGV2ZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VFcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBUZW1wbGF0ZVBhcnNlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VSZXN1bHQodGVtcGxhdGVBc3QsIGVycm9ycykge1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVBc3QgPSB0ZW1wbGF0ZUFzdDtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgVGVtcGxhdGVQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZXIoX2V4cHJQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2h0bWxQYXJzZXIsIF9jb25zb2xlLCB0cmFuc2Zvcm1zKSB7XG4gICAgICAgICAgdGhpcy5fZXhwclBhcnNlciA9IF9leHByUGFyc2VyO1xuICAgICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gdHJhbnNmb3JtcztcbiAgICAgIH1cbiAgICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50cnlQYXJzZShjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpO1xuICAgICAgICAgIHZhciB3YXJuaW5ncyA9IHJlc3VsdC5lcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IFBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HOyB9KTtcbiAgICAgICAgICB2YXIgZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5sZXZlbCA9PT0gUGFyc2VFcnJvckxldmVsLkZBVEFMOyB9KTtcbiAgICAgICAgICBpZiAod2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLndhcm4oXCJUZW1wbGF0ZSBwYXJzZSB3YXJuaW5nczpcXG5cIiArIHdhcm5pbmdzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IGVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcGxhdGUgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnRlbXBsYXRlQXN0O1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIHRlbXBsYXRlLCBkaXJlY3RpdmVzLCBwaXBlcywgc2NoZW1hcywgdGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgICBpZiAoY29tcG9uZW50LnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIGludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBodG1sQXN0V2l0aEVycm9ycyA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2UodGVtcGxhdGUsIHRlbXBsYXRlVXJsLCB0cnVlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICB2YXIgZXJyb3JzID0gaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzO1xuICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gSUNVIG1lc3NhZ2VzIHRvIGFuZ3VsYXIgZGlyZWN0aXZlc1xuICAgICAgICAgICAgICB2YXIgZXhwYW5kZWRIdG1sQXN0ID0gZXhwYW5kTm9kZXMoaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzKTtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBleHBhbmRlZEh0bWxBc3QuZXJyb3JzKTtcbiAgICAgICAgICAgICAgaHRtbEFzdFdpdGhFcnJvcnMgPSBuZXcgUGFyc2VUcmVlUmVzdWx0KGV4cGFuZGVkSHRtbEFzdC5ub2RlcywgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciB1bmlxRGlyZWN0aXZlcyA9IHJlbW92ZUlkZW50aWZpZXJEdXBsaWNhdGVzKGRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgICB2YXIgdW5pcVBpcGVzID0gcmVtb3ZlSWRlbnRpZmllckR1cGxpY2F0ZXMocGlwZXMpO1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJWaWV3Q29udGV4dCA9IG5ldyBQcm92aWRlclZpZXdDb250ZXh0KGNvbXBvbmVudCwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzWzBdLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB2YXIgcGFyc2VWaXNpdG9yID0gbmV3IFRlbXBsYXRlUGFyc2VWaXNpdG9yKHByb3ZpZGVyVmlld0NvbnRleHQsIHVuaXFEaXJlY3RpdmVzLCB1bmlxUGlwZXMsIHNjaGVtYXMsIHRoaXMuX2V4cHJQYXJzZXIsIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmlzaXRBbGwocGFyc2VWaXNpdG9yLCBodG1sQXN0V2l0aEVycm9ycy5yb290Tm9kZXMsIEVNUFRZX0VMRU1FTlRfQ09OVEVYVCk7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgcGFyc2VWaXNpdG9yLmVycm9ycy5jb25jYXQocHJvdmlkZXJWaWV3Q29udGV4dC5lcnJvcnMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9hc3NlcnROb1JlZmVyZW5jZUR1cGxpY2F0aW9uT25UZW1wbGF0ZShyZXN1bHQsIGVycm9ycyk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJzZVJlc3VsdChyZXN1bHQsIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy50cmFuc2Zvcm1zKSkge1xuICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNmb3JtKSB7IHJlc3VsdCA9IHRlbXBsYXRlVmlzaXRBbGwodHJhbnNmb3JtLCByZXN1bHQpOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVBhcnNlUmVzdWx0KHJlc3VsdCwgZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICAvKiogQGludGVybmFsICovXG4gICAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUuX2Fzc2VydE5vUmVmZXJlbmNlRHVwbGljYXRpb25PblRlbXBsYXRlID0gZnVuY3Rpb24gKHJlc3VsdCwgZXJyb3JzKSB7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nUmVmZXJlbmNlcyA9IFtdO1xuICAgICAgICAgIHJlc3VsdC5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuICEhZWxlbWVudC5yZWZlcmVuY2VzOyB9KVxuICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudC5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IHJlZmVyZW5jZS5uYW1lO1xuICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdSZWZlcmVuY2VzLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBleGlzdGluZ1JlZmVyZW5jZXMucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBUZW1wbGF0ZVBhcnNlRXJyb3IoXCJSZWZlcmVuY2UgXFxcIiNcIiArIG5hbWUgKyBcIlxcXCIgaXMgZGVmaW5lZCBzZXZlcmFsIHRpbWVzXCIsIHJlZmVyZW5jZS5zb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRkFUQUwpO1xuICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7IH0pO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFRlbXBsYXRlUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogUGFyc2VyLCB9LFxuICAgICAgICAgIHsgdHlwZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB9LFxuICAgICAgICAgIHsgdHlwZTogSTE4Tkh0bWxQYXJzZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBDb25zb2xlLCB9LFxuICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW1RFTVBMQVRFX1RSQU5TRk9STVMsXSB9LF0gfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gVGVtcGxhdGVQYXJzZXI7XG4gIH0oKSk7XG4gIHZhciBUZW1wbGF0ZVBhcnNlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlVmlzaXRvcihwcm92aWRlclZpZXdDb250ZXh0LCBkaXJlY3RpdmVzLCBwaXBlcywgX3NjaGVtYXMsIF9leHByUGFyc2VyLCBfc2NoZW1hUmVnaXN0cnkpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCA9IHByb3ZpZGVyVmlld0NvbnRleHQ7XG4gICAgICAgICAgdGhpcy5fc2NoZW1hcyA9IF9zY2hlbWFzO1xuICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgICB0aGlzLnNlbGVjdG9yTWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMubmdDb250ZW50Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMucGlwZXNCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdmFyIHRlbXBNZXRhID0gcHJvdmlkZXJWaWV3Q29udGV4dC5jb21wb25lbnQudGVtcGxhdGU7XG4gICAgICAgICAgaWYgKHRlbXBNZXRhICYmIHRlbXBNZXRhLmludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0ZW1wTWV0YS5pbnRlcnBvbGF0aW9uWzBdLFxuICAgICAgICAgICAgICAgICAgZW5kOiB0ZW1wTWV0YS5pbnRlcnBvbGF0aW9uWzFdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlLCBpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBDc3NTZWxlY3Rvci5wYXJzZShkaXJlY3RpdmUuc2VsZWN0b3IpO1xuICAgICAgICAgICAgICBfdGhpcy5zZWxlY3Rvck1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoc2VsZWN0b3IsIGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICAgIF90aGlzLmRpcmVjdGl2ZXNJbmRleC5zZXQoZGlyZWN0aXZlLCBpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMucGlwZXNCeU5hbWUuc2V0KHBpcGUubmFtZSwgcGlwZSk7IH0pO1xuICAgICAgfVxuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzb3VyY2VTcGFuLCBsZXZlbCkge1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkZBVEFMOyB9XG4gICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgVGVtcGxhdGVQYXJzZUVycm9yKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9yZXBvcnRQYXJzZXJFcnJvcnMgPSBmdW5jdGlvbiAoZXJyb3JzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBlcnJvcnNfMSA9IGVycm9yczsgX2kgPCBlcnJvcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gZXJyb3JzXzFbX2ldO1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlcnJvci5tZXNzYWdlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHNvdXJjZUluZm8sIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgICBpZiAoYXN0KVxuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0UGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0KSAmJlxuICAgICAgICAgICAgICAgICAgYXN0LmFzdC5leHByZXNzaW9ucy5sZW5ndGggPiBNQVhfSU5URVJQT0xBVElPTl9WQUxVRVMpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgc3VwcG9ydCBhdCBtb3N0IFwiICsgTUFYX0lOVEVSUE9MQVRJT05fVkFMVUVTICsgXCIgaW50ZXJwb2xhdGlvbiB2YWx1ZXMhXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VBY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUFjdGlvbih2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICAgIGlmIChhc3QpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydFBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWFzdCB8fCBhc3QuYXN0IGluc3RhbmNlb2YgRW1wdHlFeHByKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkVtcHR5IGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZFwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUJpbmRpbmcodmFsdWUsIHNvdXJjZUluZm8sIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgICBpZiAoYXN0KVxuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0UGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgYmluZGluZ3NSZXN1bHQgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyh2YWx1ZSwgc291cmNlSW5mbyk7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydFBhcnNlckVycm9ycyhiaW5kaW5nc1Jlc3VsdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICBiaW5kaW5nc1Jlc3VsdC50ZW1wbGF0ZUJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYmluZGluZy5leHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jaGVja1BpcGVzKGJpbmRpbmcuZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBiaW5kaW5nc1Jlc3VsdC53YXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uICh3YXJuaW5nKSB7IF90aGlzLl9yZXBvcnRFcnJvcih3YXJuaW5nLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7IH0pO1xuICAgICAgICAgICAgICByZXR1cm4gYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcIiArIGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY2hlY2tQaXBlcyA9IGZ1bmN0aW9uIChhc3QsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0KSkge1xuICAgICAgICAgICAgICB2YXIgY29sbGVjdG9yID0gbmV3IFBpcGVDb2xsZWN0b3IoKTtcbiAgICAgICAgICAgICAgYXN0LnZpc2l0KGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgIGNvbGxlY3Rvci5waXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5waXBlc0J5TmFtZS5oYXMocGlwZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVGhlIHBpcGUgJ1wiICsgcGlwZU5hbWUgKyBcIicgY291bGQgbm90IGJlIGZvdW5kXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChURVhUX0NTU19TRUxFQ1RPUik7XG4gICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLl9wYXJzZUludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRUZXh0QXN0KGV4cHIsIG5nQ29udGVudEluZGV4LCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXN0KHRleHQudmFsdWUsIG5nQ29udGVudEluZGV4LCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyQXN0KGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5uYW1lO1xuICAgICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFKSB7XG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgICAvLyBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCAmJlxuICAgICAgICAgICAgICBpc1N0eWxlVXJsUmVzb2x2YWJsZShwcmVwYXJzZWRFbGVtZW50LmhyZWZBdHRyKSkge1xuICAgICAgICAgICAgICAvLyBTa2lwcGluZyBzdHlsZXNoZWV0cyB3aXRoIGVpdGhlciByZWxhdGl2ZSB1cmxzIG9yIHBhY2thZ2Ugc2NoZW1lIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgIC8vIHRoZW0gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtYXRjaGFibGVBdHRycyA9IFtdO1xuICAgICAgICAgIHZhciBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xuICAgICAgICAgIHZhciBlbGVtZW50T3JEaXJlY3RpdmVSZWZzID0gW107XG4gICAgICAgICAgdmFyIGVsZW1lbnRWYXJzID0gW107XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblByb3BzID0gW107XG4gICAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XG4gICAgICAgICAgdmFyIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMgPSBbXTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVFbGVtZW50VmFycyA9IFtdO1xuICAgICAgICAgIHZhciBoYXNJbmxpbmVUZW1wbGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYXR0cnMgPSBbXTtcbiAgICAgICAgICB2YXIgbGNFbE5hbWUgPSBzcGxpdE5zTmFtZShub2RlTmFtZS50b0xvd2VyQ2FzZSgpKVsxXTtcbiAgICAgICAgICB2YXIgaXNUZW1wbGF0ZUVsZW1lbnQgPSBsY0VsTmFtZSA9PSBURU1QTEFURV9FTEVNRU5UO1xuICAgICAgICAgIGVsZW1lbnQuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICB2YXIgaGFzQmluZGluZyA9IF90aGlzLl9wYXJzZUF0dHIoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHIsIG1hdGNoYWJsZUF0dHJzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgYW5pbWF0aW9uUHJvcHMsIGV2ZW50cywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgICB2YXIgaGFzVGVtcGxhdGVCaW5kaW5nID0gX3RoaXMuX3BhcnNlSW5saW5lVGVtcGxhdGVCaW5kaW5nKGF0dHIsIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlRWxlbWVudFZhcnMpO1xuICAgICAgICAgICAgICBpZiAoaGFzVGVtcGxhdGVCaW5kaW5nICYmIGhhc0lubGluZVRlbXBsYXRlcykge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiQ2FuJ3QgaGF2ZSBtdWx0aXBsZSB0ZW1wbGF0ZSBiaW5kaW5ncyBvbiBvbmUgZWxlbWVudC4gVXNlIG9ubHkgb25lIGF0dHJpYnV0ZSBuYW1lZCAndGVtcGxhdGUnIG9yIHByZWZpeGVkIHdpdGggKlwiLCBhdHRyLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgICAgYXR0cnMucHVzaChfdGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICBtYXRjaGFibGVBdHRycy5wdXNoKFthdHRyLm5hbWUsIGF0dHIudmFsdWVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICBoYXNJbmxpbmVUZW1wbGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGVsZW1lbnRDc3NTZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3Rvcihub2RlTmFtZSwgbWF0Y2hhYmxlQXR0cnMpO1xuICAgICAgICAgIHZhciBfYSA9IHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgZWxlbWVudENzc1NlbGVjdG9yKSwgZGlyZWN0aXZlTWV0YXMgPSBfYS5kaXJlY3RpdmVzLCBtYXRjaEVsZW1lbnQgPSBfYS5tYXRjaEVsZW1lbnQ7XG4gICAgICAgICAgdmFyIHJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlQXN0cyA9IHRoaXMuX2NyZWF0ZURpcmVjdGl2ZUFzdHMoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnQubmFtZSwgZGlyZWN0aXZlTWV0YXMsIGVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50LnNvdXJjZVNwYW4sIHJlZmVyZW5jZXMpO1xuICAgICAgICAgIHZhciBlbGVtZW50UHJvcHMgPSB0aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzKGVsZW1lbnQubmFtZSwgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGRpcmVjdGl2ZUFzdHMpXG4gICAgICAgICAgICAgIC5jb25jYXQoYW5pbWF0aW9uUHJvcHMpO1xuICAgICAgICAgIHZhciBpc1ZpZXdSb290ID0gcGFyZW50LmlzVGVtcGxhdGVFbGVtZW50IHx8IGhhc0lubGluZVRlbXBsYXRlcztcbiAgICAgICAgICB2YXIgcHJvdmlkZXJDb250ZXh0ID0gbmV3IFByb3ZpZGVyRWxlbWVudENvbnRleHQodGhpcy5wcm92aWRlclZpZXdDb250ZXh0LCBwYXJlbnQucHJvdmlkZXJDb250ZXh0LCBpc1ZpZXdSb290LCBkaXJlY3RpdmVBc3RzLCBhdHRycywgcmVmZXJlbmNlcywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEFsbChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlID8gTk9OX0JJTkRBQkxFX1ZJU0lUT1IgOiB0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBFbGVtZW50Q29udGV4dC5jcmVhdGUoaXNUZW1wbGF0ZUVsZW1lbnQsIGRpcmVjdGl2ZUFzdHMsIGlzVGVtcGxhdGVFbGVtZW50ID8gcGFyZW50LnByb3ZpZGVyQ29udGV4dCA6IHByb3ZpZGVyQ29udGV4dCkpO1xuICAgICAgICAgIHByb3ZpZGVyQ29udGV4dC5hZnRlckVsZW1lbnQoKTtcbiAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgYWN0dWFsIHNlbGVjdG9yIHdoZW4gdGhlIGBuZ1Byb2plY3RBc2AgYXR0cmlidXRlIGlzIHByb3ZpZGVkXG4gICAgICAgICAgdmFyIHByb2plY3Rpb25TZWxlY3RvciA9IGlzUHJlc2VudChwcmVwYXJzZWRFbGVtZW50LnByb2plY3RBcykgP1xuICAgICAgICAgICAgICBDc3NTZWxlY3Rvci5wYXJzZShwcmVwYXJzZWRFbGVtZW50LnByb2plY3RBcylbMF0gOlxuICAgICAgICAgICAgICBlbGVtZW50Q3NzU2VsZWN0b3I7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChwcm9qZWN0aW9uU2VsZWN0b3IpO1xuICAgICAgICAgIHZhciBwYXJzZWRFbGVtZW50O1xuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQpIHtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChlbGVtZW50LmNoaWxkcmVuKSAmJiBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiPG5nLWNvbnRlbnQ+IGVsZW1lbnQgY2Fubm90IGhhdmUgY29udGVudC4gPG5nLWNvbnRlbnQ+IG11c3QgYmUgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgPC9uZy1jb250ZW50PlwiLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgTmdDb250ZW50QXN0KHRoaXMubmdDb250ZW50Q291bnQrKywgaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IG5nQ29udGVudEluZGV4LCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICB0aGlzLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMoZGlyZWN0aXZlQXN0cywgZXZlbnRzKTtcbiAgICAgICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZShkaXJlY3RpdmVBc3RzLCBlbGVtZW50UHJvcHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgRW1iZWRkZWRUZW1wbGF0ZUFzdChhdHRycywgZXZlbnRzLCByZWZlcmVuY2VzLCBlbGVtZW50VmFycywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0cywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybVByb3ZpZGVycywgcHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lciwgY2hpbGRyZW4sIGhhc0lubGluZVRlbXBsYXRlcyA/IG51bGwgOiBuZ0NvbnRlbnRJbmRleCwgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2Fzc2VydEVsZW1lbnRFeGlzdHMobWF0Y2hFbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgdGhpcy5fYXNzZXJ0T25seU9uZUNvbXBvbmVudChkaXJlY3RpdmVBc3RzLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB2YXIgbmdDb250ZW50SW5kZXhfMSA9IGhhc0lubGluZVRlbXBsYXRlcyA/IG51bGwgOiBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KHByb2plY3Rpb25TZWxlY3Rvcik7XG4gICAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgRWxlbWVudEFzdChub2RlTmFtZSwgYXR0cnMsIGVsZW1lbnRQcm9wcywgZXZlbnRzLCByZWZlcmVuY2VzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBjaGlsZHJlbiwgaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IG5nQ29udGVudEluZGV4XzEsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgIHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzKGRpcmVjdGl2ZUFzdHMpXG4gICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50RGlyZWN0aXZlQXN0KSB7IHJldHVybiBfdGhpcy5fdmFsaWRhdGVFbGVtZW50QW5pbWF0aW9uSW5wdXRPdXRwdXRzKGNvbXBvbmVudERpcmVjdGl2ZUFzdC5ob3N0UHJvcGVydGllcywgY29tcG9uZW50RGlyZWN0aXZlQXN0Lmhvc3RFdmVudHMsIGNvbXBvbmVudERpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudGVtcGxhdGUpOyB9KTtcbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFRlbXBsYXRlID0gcHJvdmlkZXJDb250ZXh0LnZpZXdDb250ZXh0LmNvbXBvbmVudC50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVFbGVtZW50QW5pbWF0aW9uSW5wdXRPdXRwdXRzKGVsZW1lbnRQcm9wcywgZXZlbnRzLCBjb21wb25lbnRUZW1wbGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNJbmxpbmVUZW1wbGF0ZXMpIHtcbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlQ3NzU2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoVEVNUExBVEVfRUxFTUVOVCwgdGVtcGxhdGVNYXRjaGFibGVBdHRycyk7XG4gICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZURpcmVjdGl2ZU1ldGFzID0gdGhpcy5fcGFyc2VEaXJlY3RpdmVzKHRoaXMuc2VsZWN0b3JNYXRjaGVyLCB0ZW1wbGF0ZUNzc1NlbGVjdG9yKS5kaXJlY3RpdmVzO1xuICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVEaXJlY3RpdmVBc3RzID0gdGhpcy5fY3JlYXRlRGlyZWN0aXZlQXN0cyh0cnVlLCBlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRGlyZWN0aXZlTWV0YXMsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIFtdLCBlbGVtZW50LnNvdXJjZVNwYW4sIFtdKTtcbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlRWxlbWVudFByb3BzID0gdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyhlbGVtZW50Lm5hbWUsIHRlbXBsYXRlRWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIHRlbXBsYXRlRGlyZWN0aXZlQXN0cyk7XG4gICAgICAgICAgICAgIHRoaXMuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUodGVtcGxhdGVEaXJlY3RpdmVBc3RzLCB0ZW1wbGF0ZUVsZW1lbnRQcm9wcywgZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0ID0gbmV3IFByb3ZpZGVyRWxlbWVudENvbnRleHQodGhpcy5wcm92aWRlclZpZXdDb250ZXh0LCBwYXJlbnQucHJvdmlkZXJDb250ZXh0LCBwYXJlbnQuaXNUZW1wbGF0ZUVsZW1lbnQsIHRlbXBsYXRlRGlyZWN0aXZlQXN0cywgW10sIFtdLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC5hZnRlckVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbWJlZGRlZFRlbXBsYXRlQXN0KFtdLCBbXSwgW10sIHRlbXBsYXRlRWxlbWVudFZhcnMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0cywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIFtwYXJzZWRFbGVtZW50XSwgbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXJzZWRFbGVtZW50O1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVFbGVtZW50QW5pbWF0aW9uSW5wdXRPdXRwdXRzID0gZnVuY3Rpb24gKGlucHV0cywgb3V0cHV0cywgdGVtcGxhdGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciB0cmlnZ2VyTG9va3VwID0gbmV3IFNldCgpO1xuICAgICAgICAgIHRlbXBsYXRlLmFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgdHJpZ2dlckxvb2t1cC5hZGQoZW50cnkubmFtZSk7IH0pO1xuICAgICAgICAgIHZhciBhbmltYXRpb25JbnB1dHMgPSBpbnB1dHMuZmlsdGVyKGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gaW5wdXQuaXNBbmltYXRpb247IH0pO1xuICAgICAgICAgIGFuaW1hdGlvbklucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IGlucHV0Lm5hbWU7XG4gICAgICAgICAgICAgIGlmICghdHJpZ2dlckxvb2t1cC5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIkNvdWxkbid0IGZpbmQgYW4gYW5pbWF0aW9uIGVudHJ5IGZvciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIsIGlucHV0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgaWYgKG91dHB1dC5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gYW5pbWF0aW9uSW5wdXRzLmZpbmQoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5uYW1lID09IG91dHB1dC5uYW1lOyB9KTtcbiAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJVbmFibGUgdG8gbGlzdGVuIG9uIChAXCIgKyBvdXRwdXQubmFtZSArIFwiLlwiICsgb3V0cHV0LnBoYXNlICsgXCIpIGJlY2F1c2UgdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFtAXCIgKyBvdXRwdXQubmFtZSArIFwiXSBpc24ndCBiZWluZyB1c2VkIG9uIHRoZSBzYW1lIGVsZW1lbnRcIiwgb3V0cHV0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uIChhdHRyLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldFZhcnMpIHtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IG51bGw7XG4gICAgICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ci5uYW1lKSA9PSBURU1QTEFURV9BVFRSKSB7XG4gICAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChURU1QTEFURV9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IGF0dHIubmFtZS5zdWJzdHJpbmcoVEVNUExBVEVfQVRUUl9QUkVGSVgubGVuZ3RoKTsgLy8gcmVtb3ZlIHRoZSBzdGFyXG4gICAgICAgICAgICAgIHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgPSAoYXR0ci52YWx1ZS5sZW5ndGggPT0gMCkgPyBrZXkgOiBrZXkgKyAnICcgKyBhdHRyLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRlbXBsYXRlQmluZGluZ3NTb3VyY2UpKSB7XG4gICAgICAgICAgICAgIHZhciBiaW5kaW5ncyA9IHRoaXMuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyh0ZW1wbGF0ZUJpbmRpbmdzU291cmNlLCBhdHRyLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcua2V5SXNWYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IFZhcmlhYmxlQXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLm5hbWUsIGF0dHIuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KGJpbmRpbmcuZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLmV4cHJlc3Npb24sIGF0dHIuc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW2JpbmRpbmcua2V5LCAnJ10pO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlTGl0ZXJhbEF0dHIoYmluZGluZy5rZXksIG51bGwsIGF0dHIuc291cmNlU3BhbiwgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUF0dHIgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHIsIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0QW5pbWF0aW9uUHJvcHMsIHRhcmdldEV2ZW50cywgdGFyZ2V0UmVmcywgdGFyZ2V0VmFycykge1xuICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5fbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyLm5hbWUpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgdmFyIHNyY1NwYW4gPSBhdHRyLnNvdXJjZVNwYW47XG4gICAgICAgICAgdmFyIGJpbmRQYXJ0cyA9IG5hbWUubWF0Y2goQklORF9OQU1FX1JFR0VYUCk7XG4gICAgICAgICAgdmFyIGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoYmluZFBhcnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGJpbmRQYXJ0c1tLV19CSU5EX0lEWF0pKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5T3JBbmltYXRpb24oYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldEFuaW1hdGlvblByb3BzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfTEVUX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VWYXJpYWJsZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0VmFycyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCJsZXQtXFxcIiBpcyBvbmx5IHN1cHBvcnRlZCBvbiB0ZW1wbGF0ZSBlbGVtZW50cy5cIiwgc3JjU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX1JFRl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VSZWZlcmVuY2UoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldFJlZnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19PTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV2ZW50T3JBbmltYXRpb25FdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19CSU5ET05fSURYXSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eU9yQW5pbWF0aW9uKGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRBbmltYXRpb25Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19BVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX2lzQW5pbWF0aW9uTGFiZWwobmFtZSkgJiYgaXNQcmVzZW50KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJBc3NpZ25pbmcgYW5pbWF0aW9uIHRyaWdnZXJzIHZpYSBAcHJvcD1cXFwiZXhwXFxcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgVXNlIHByb3BlcnR5IGJpbmRpbmdzIChlLmcuIFtAcHJvcF09XFxcImV4cFxcXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLlwiLCBzcmNTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRkFUQUwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24oYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0QW5pbWF0aW9uUHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9CQU5BTkFfQk9YX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlPckFuaW1hdGlvbihiaW5kUGFydHNbSURFTlRfQkFOQU5BX0JPWF9JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRBbmltYXRpb25Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbSURFTlRfQkFOQU5BX0JPWF9JRFhdLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX1BST1BFUlRZX0lEWF0pIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlPckFuaW1hdGlvbihiaW5kUGFydHNbSURFTlRfUFJPUEVSVFlfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0QW5pbWF0aW9uUHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tJREVOVF9FVkVOVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUV2ZW50T3JBbmltYXRpb25FdmVudChiaW5kUGFydHNbSURFTlRfRVZFTlRfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBoYXNCaW5kaW5nID1cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWhhc0JpbmRpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VMaXRlcmFsQXR0cihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGFzQmluZGluZztcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gL15kYXRhLS9pLnRlc3QoYXR0ck5hbWUpID8gYXR0ck5hbWUuc3Vic3RyaW5nKDUpIDogYXR0ck5hbWU7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVZhcmlhYmxlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRWYXJzKSB7XG4gICAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gdmFyaWFibGUgbmFtZXNcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldFZhcnMucHVzaChuZXcgVmFyaWFibGVBc3QoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlUmVmZXJlbmNlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRSZWZzKSB7XG4gICAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJcXFwiLVxcXCIgaXMgbm90IGFsbG93ZWQgaW4gcmVmZXJlbmNlIG5hbWVzXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXRSZWZzLnB1c2gobmV3IEVsZW1lbnRPckRpcmVjdGl2ZVJlZihpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3BhbikpO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eU9yQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0QW5pbWF0aW9uUHJvcHMpIHtcbiAgICAgICAgICB2YXIgYW5pbWF0ZVByb3BMZW5ndGggPSBBTklNQVRFX1BST1BfUFJFRklYLmxlbmd0aDtcbiAgICAgICAgICB2YXIgaXNBbmltYXRpb25Qcm9wID0gX2lzQW5pbWF0aW9uTGFiZWwobmFtZSk7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblByZWZpeExlbmd0aCA9IDE7XG4gICAgICAgICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIGFuaW1hdGVQcm9wTGVuZ3RoKSA9PSBBTklNQVRFX1BST1BfUFJFRklYKSB7XG4gICAgICAgICAgICAgIGlzQW5pbWF0aW9uUHJvcCA9IHRydWU7XG4gICAgICAgICAgICAgIGFuaW1hdGlvblByZWZpeExlbmd0aCA9IGFuaW1hdGVQcm9wTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBbmltYXRpb25Qcm9wKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uKG5hbWUuc3Vic3RyKGFuaW1hdGlvblByZWZpeExlbmd0aCksIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRBbmltYXRpb25Qcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBzb3VyY2VTcGFuKSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0QW5pbWF0aW9uUHJvcHMpIHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgb2NjdXIgd2hlbiBhIEB0cmlnZ2VyIGlzIG5vdCBwYWlyZWQgd2l0aCBhbiBleHByZXNzaW9uLlxuICAgICAgICAgIC8vIEZvciBhbmltYXRpb25zIGl0IGlzIHZhbGlkIHRvIG5vdCBoYXZlIGFuIGV4cHJlc3Npb24gc2luY2UgKi92b2lkXG4gICAgICAgICAgLy8gc3RhdGVzIHdpbGwgYmUgYXBwbGllZCBieSBhbmd1bGFyIHdoZW4gdGhlIGVsZW1lbnQgaXMgYXR0YWNoZWQvZGV0YWNoZWRcbiAgICAgICAgICBpZiAoIWlzUHJlc2VudChleHByZXNzaW9uKSB8fCBleHByZXNzaW9uLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb24gPSAnbnVsbCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICAgIHRhcmdldEFuaW1hdGlvblByb3BzLnB1c2gobmV3IEJvdW5kRWxlbWVudFByb3BlcnR5QXN0KG5hbWUsIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb24sIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkUsIGFzdCwgbnVsbCwgc291cmNlU3BhbikpO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICAgIHZhciBleHByID0gdGhpcy5fcGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgZXhwciwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlUHJvcGVydHlBc3QgPSBmdW5jdGlvbiAobmFtZSwgYXN0LCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eShuYW1lLCBhc3QsIGZhbHNlLCBzb3VyY2VTcGFuKSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUFzc2lnbm1lbnRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VFdmVudE9yQW5pbWF0aW9uRXZlbnQobmFtZSArIFwiQ2hhbmdlXCIsIGV4cHJlc3Npb24gKyBcIj0kZXZlbnRcIiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUV2ZW50T3JBbmltYXRpb25FdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgICAgaWYgKF9pc0FuaW1hdGlvbkxhYmVsKG5hbWUpKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb25FdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VFdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUFuaW1hdGlvbkV2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldEV2ZW50cykge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gc3BsaXRBdFBlcmlvZChuYW1lLCBbbmFtZSwgJyddKTtcbiAgICAgICAgICB2YXIgZXZlbnROYW1lID0gbWF0Y2hlc1swXTtcbiAgICAgICAgICB2YXIgcGhhc2UgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKHBoYXNlKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGhhc2UpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAgICAgICAgICAgICAgIHZhciBhc3QgPSB0aGlzLl9wYXJzZUFjdGlvbihleHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFdmVudHMucHVzaChuZXcgQm91bmRFdmVudEFzdChldmVudE5hbWUsIG51bGwsIHBoYXNlLCBhc3QsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGUgcHJvdmlkZWQgYW5pbWF0aW9uIG91dHB1dCBwaGFzZSB2YWx1ZSBcXFwiXCIgKyBwaGFzZSArIFwiXFxcIiBmb3IgXFxcIkBcIiArIGV2ZW50TmFtZSArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkICh1c2Ugc3RhcnQgb3IgZG9uZSlcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiVGhlIGFuaW1hdGlvbiB0cmlnZ2VyIG91dHB1dCBldmVudCAoQFwiICsgZXZlbnROYW1lICsgXCIpIGlzIG1pc3NpbmcgaXRzIHBoYXNlIHZhbHVlIG5hbWUgKHN0YXJ0IG9yIGRvbmUgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQpXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICAgIC8vIGxvbmcgZm9ybWF0OiAndGFyZ2V0OiBldmVudE5hbWUnXG4gICAgICAgICAgdmFyIF9hID0gc3BsaXRBdENvbG9uKG5hbWUsIFtudWxsLCBuYW1lXSksIHRhcmdldCA9IF9hWzBdLCBldmVudE5hbWUgPSBfYVsxXTtcbiAgICAgICAgICB2YXIgYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBCb3VuZEV2ZW50QXN0KGV2ZW50TmFtZSwgdGFyZ2V0LCBudWxsLCBhc3QsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAvLyBEb24ndCBkZXRlY3QgZGlyZWN0aXZlcyBmb3IgZXZlbnQgbmFtZXMgZm9yIG5vdyxcbiAgICAgICAgICAvLyBzbyBkb24ndCBhZGQgdGhlIGV2ZW50IG5hbWUgdG8gdGhlIG1hdGNoYWJsZUF0dHJzXG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUxpdGVyYWxBdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRQcm9wcykge1xuICAgICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kRWxlbWVudE9yRGlyZWN0aXZlUHJvcGVydHkobmFtZSwgdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSh2YWx1ZSwgJycpLCB0cnVlLCBzb3VyY2VTcGFuKSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoc2VsZWN0b3JNYXRjaGVyLCBlbGVtZW50Q3NzU2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIC8vIE5lZWQgdG8gc29ydCB0aGUgZGlyZWN0aXZlcyBzbyB0aGF0IHdlIGdldCBjb25zaXN0ZW50IHJlc3VsdHMgdGhyb3VnaG91dCxcbiAgICAgICAgICAvLyBhcyBzZWxlY3Rvck1hdGNoZXIgdXNlcyBNYXBzIGluc2lkZS5cbiAgICAgICAgICAvLyBBbHNvIGRlZHVwbGljYXRlIGRpcmVjdGl2ZXMgYXMgdGhleSBtaWdodCBtYXRjaCBtb3JlIHRoYW4gb25lIHRpbWUhXG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBuZXcgQXJyYXkodGhpcy5kaXJlY3RpdmVzSW5kZXguc2l6ZSk7XG4gICAgICAgICAgLy8gV2hldGhlciBhbnkgZGlyZWN0aXZlIHNlbGVjdG9yIG1hdGNoZXMgb24gdGhlIGVsZW1lbnQgbmFtZVxuICAgICAgICAgIHZhciBtYXRjaEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICBzZWxlY3Rvck1hdGNoZXIubWF0Y2goZWxlbWVudENzc1NlbGVjdG9yLCBmdW5jdGlvbiAoc2VsZWN0b3IsIGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICBkaXJlY3RpdmVzW190aGlzLmRpcmVjdGl2ZXNJbmRleC5nZXQoZGlyZWN0aXZlKV0gPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICAgIG1hdGNoRWxlbWVudCA9IG1hdGNoRWxlbWVudCB8fCBzZWxlY3Rvci5oYXNFbGVtZW50U2VsZWN0b3IoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAhIWRpcjsgfSksXG4gICAgICAgICAgICAgIG1hdGNoRWxlbWVudDogbWF0Y2hFbGVtZW50LFxuICAgICAgICAgIH07XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVBc3RzID0gZnVuY3Rpb24gKGlzVGVtcGxhdGVFbGVtZW50LCBlbGVtZW50TmFtZSwgZGlyZWN0aXZlcywgcHJvcHMsIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMsIGVsZW1lbnRTb3VyY2VTcGFuLCB0YXJnZXRSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbWF0Y2hlZFJlZmVyZW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZUFzdHMgPSBkaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIHZhciBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihlbGVtZW50U291cmNlU3Bhbi5zdGFydCwgZWxlbWVudFNvdXJjZVNwYW4uZW5kLCBcIkRpcmVjdGl2ZSBcIiArIGRpcmVjdGl2ZS50eXBlLm5hbWUpO1xuICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBkaXJlY3RpdmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGhvc3RQcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgICAgIHZhciBob3N0RXZlbnRzID0gW107XG4gICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVQcm9wZXJ0aWVzID0gW107XG4gICAgICAgICAgICAgIF90aGlzLl9jcmVhdGVEaXJlY3RpdmVIb3N0UHJvcGVydHlBc3RzKGVsZW1lbnROYW1lLCBkaXJlY3RpdmUuaG9zdFByb3BlcnRpZXMsIHNvdXJjZVNwYW4sIGhvc3RQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlLmhvc3RMaXN0ZW5lcnMsIHNvdXJjZVNwYW4sIGhvc3RFdmVudHMpO1xuICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlRGlyZWN0aXZlUHJvcGVydHlBc3RzKGRpcmVjdGl2ZS5pbnB1dHMsIHByb3BzLCBkaXJlY3RpdmVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgZWxlbWVudE9yRGlyZWN0aXZlUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChlbE9yRGlyUmVmKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKGVsT3JEaXJSZWYudmFsdWUubGVuZ3RoID09PSAwICYmIGRpcmVjdGl2ZS5pc0NvbXBvbmVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoZGlyZWN0aXZlLmV4cG9ydEFzID09IGVsT3JEaXJSZWYudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVmZXJlbmNlcy5wdXNoKG5ldyBSZWZlcmVuY2VBc3QoZWxPckRpclJlZi5uYW1lLCBpZGVudGlmaWVyVG9rZW4oZGlyZWN0aXZlLnR5cGUpLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkUmVmZXJlbmNlcy5hZGQoZWxPckRpclJlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgRGlyZWN0aXZlQXN0KGRpcmVjdGl2ZSwgZGlyZWN0aXZlUHJvcGVydGllcywgaG9zdFByb3BlcnRpZXMsIGhvc3RFdmVudHMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZWxPckRpclJlZikge1xuICAgICAgICAgICAgICBpZiAoZWxPckRpclJlZi52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRSZWZlcmVuY2VzLmhhcyhlbE9yRGlyUmVmLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVGhlcmUgaXMgbm8gZGlyZWN0aXZlIHdpdGggXFxcImV4cG9ydEFzXFxcIiBzZXQgdG8gXFxcIlwiICsgZWxPckRpclJlZi52YWx1ZSArIFwiXFxcIlwiLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZWZUb2tlbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZWZUb2tlbiA9IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVmZXJlbmNlcy5wdXNoKG5ldyBSZWZlcmVuY2VBc3QoZWxPckRpclJlZi5uYW1lLCByZWZUb2tlbiwgZWxPckRpclJlZi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTsgLy8gZml4IHN5bnRheCBoaWdobGlnaHRpbmcgaXNzdWU6IGBcbiAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlQXN0cztcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUhvc3RQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIGhvc3RQcm9wcywgc291cmNlU3BhbiwgdGFyZ2V0UHJvcGVydHlBc3RzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoaG9zdFByb3BzKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGhvc3RQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gaG9zdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhleHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBleHByQXN0ID0gX3RoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcm9wZXJ0eUFzdHMucHVzaChfdGhpcy5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0KGVsZW1lbnROYW1lLCBwcm9wTmFtZSwgZXhwckFzdCwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVmFsdWUgb2YgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZyBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBuZWVkcyB0byBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gZXhwcmVzc2lvbiBidXQgZ290IFxcXCJcIiArIGV4cHJlc3Npb24gKyBcIlxcXCIgKFwiICsgdHlwZW9mIGV4cHJlc3Npb24gKyBcIilcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMgPSBmdW5jdGlvbiAoaG9zdExpc3RlbmVycywgc291cmNlU3BhbiwgdGFyZ2V0RXZlbnRBc3RzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAoaG9zdExpc3RlbmVycykge1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhob3N0TGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBob3N0TGlzdGVuZXJzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhleHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wYXJzZUV2ZW50T3JBbmltYXRpb25FdmVudChwcm9wTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgW10sIHRhcmdldEV2ZW50QXN0cyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJWYWx1ZSBvZiB0aGUgaG9zdCBsaXN0ZW5lciBcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBuZWVkcyB0byBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gZXhwcmVzc2lvbiBidXQgZ290IFxcXCJcIiArIGV4cHJlc3Npb24gKyBcIlxcXCIgKFwiICsgdHlwZW9mIGV4cHJlc3Npb24gKyBcIilcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZVByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVQcm9wZXJ0aWVzLCBib3VuZFByb3BzLCB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzKSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgdmFyIGJvdW5kUHJvcHNCeU5hbWVfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgYm91bmRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBib3VuZFByb3BzQnlOYW1lXzEuZ2V0KGJvdW5kUHJvcC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgIGlmICghcHJldlZhbHVlIHx8IHByZXZWYWx1ZS5pc0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIFthXT1cImJcIiBhIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gYT1cImJcIiBvbiB0aGUgc2FtZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRQcm9wc0J5TmFtZV8xLnNldChib3VuZFByb3AubmFtZSwgYm91bmRQcm9wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZVByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKGRpclByb3ApIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlbFByb3AgPSBkaXJlY3RpdmVQcm9wZXJ0aWVzW2RpclByb3BdO1xuICAgICAgICAgICAgICAgICAgdmFyIGJvdW5kUHJvcCA9IGJvdW5kUHJvcHNCeU5hbWVfMS5nZXQoZWxQcm9wKTtcbiAgICAgICAgICAgICAgICAgIC8vIEJpbmRpbmdzIGFyZSBvcHRpb25hbCwgc28gdGhpcyBiaW5kaW5nIG9ubHkgbmVlZHMgdG8gYmUgc2V0IHVwIGlmIGFuIGV4cHJlc3Npb24gaXMgZ2l2ZW4uXG4gICAgICAgICAgICAgICAgICBpZiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcy5wdXNoKG5ldyBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0KGRpclByb3AsIGJvdW5kUHJvcC5uYW1lLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgYm91bmRQcm9wLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgcHJvcHMsIGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBib3VuZEVsZW1lbnRQcm9wcyA9IFtdO1xuICAgICAgICAgIHZhciBib3VuZERpcmVjdGl2ZVByb3BzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgZGlyZWN0aXZlLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICBib3VuZERpcmVjdGl2ZVByb3BzSW5kZXguc2V0KHByb3AudGVtcGxhdGVOYW1lLCBwcm9wKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICBpZiAoIXByb3AuaXNMaXRlcmFsICYmICFib3VuZERpcmVjdGl2ZVByb3BzSW5kZXguZ2V0KHByb3AubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kRWxlbWVudFByb3BzLnB1c2goX3RoaXMuX2NyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdChlbGVtZW50TmFtZSwgcHJvcC5uYW1lLCBwcm9wLmV4cHJlc3Npb24sIHByb3Auc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGJvdW5kRWxlbWVudFByb3BzO1xuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudFByb3BlcnR5QXN0ID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBuYW1lLCBhc3QsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgdW5pdCA9IG51bGw7XG4gICAgICAgICAgdmFyIGJpbmRpbmdUeXBlO1xuICAgICAgICAgIHZhciBib3VuZFByb3BlcnR5TmFtZTtcbiAgICAgICAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUik7XG4gICAgICAgICAgdmFyIHNlY3VyaXR5Q29udGV4dDtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0VmFsdWUgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgaWYgKF9pc0FuaW1hdGlvbkxhYmVsKHBhcnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydFZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dCA9IF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LmdldE1hcHBlZFByb3BOYW1lKHBhcnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHQgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5zZWN1cml0eUNvbnRleHQoZWxlbWVudE5hbWUsIGJvdW5kUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgc291cmNlU3BhbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zY2hlbWFSZWdpc3RyeS5oYXNQcm9wZXJ0eShlbGVtZW50TmFtZSwgYm91bmRQcm9wZXJ0eU5hbWUsIHRoaXMuX3NjaGVtYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTXNnID0gXCJDYW4ndCBiaW5kIHRvICdcIiArIGJvdW5kUHJvcGVydHlOYW1lICsgXCInIHNpbmNlIGl0IGlzbid0IGEga25vd24gcHJvcGVydHkgb2YgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnROYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJcXG4xLiBJZiAnXCIgKyBlbGVtZW50TmFtZSArIFwiJyBpcyBhbiBBbmd1bGFyIGNvbXBvbmVudCBhbmQgaXQgaGFzICdcIiArIGJvdW5kUHJvcGVydHlOYW1lICsgXCInIGlucHV0LCB0aGVuIHZlcmlmeSB0aGF0IGl0IGlzIHBhcnQgb2YgdGhpcyBtb2R1bGUuXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJcXG4yLiBJZiAnXCIgKyBlbGVtZW50TmFtZSArIFwiJyBpcyBhIFdlYiBDb21wb25lbnQgdGhlbiBhZGQgXFxcIkNVU1RPTV9FTEVNRU5UU19TQ0hFTUFcXFwiIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50IHRvIHN1cHByZXNzIHRoaXMgbWVzc2FnZS5cXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVycm9yTXNnLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09IEFUVFJJQlVURV9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lKGJvdW5kUHJvcGVydHlOYW1lLCBzb3VyY2VTcGFuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIC8vIE5COiBGb3Igc2VjdXJpdHkgcHVycG9zZXMsIHVzZSB0aGUgbWFwcGVkIHByb3BlcnR5IG5hbWUsIG5vdCB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAgICAgICAgICAgICAgICB2YXIgbWFwUHJvcE5hbWUgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShib3VuZFByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHQgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5zZWN1cml0eUNvbnRleHQoZWxlbWVudE5hbWUsIG1hcFByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgIHZhciBuc1NlcGFyYXRvcklkeCA9IGJvdW5kUHJvcGVydHlOYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICAgIGlmIChuc1NlcGFyYXRvcklkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5zID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKDAsIG5zU2VwYXJhdG9ySWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKG5zU2VwYXJhdG9ySWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBtZXJnZU5zQW5kTmFtZShucywgbmFtZV8xKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzcztcbiAgICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dCA9IF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAocGFydHNbMF0gPT0gU1RZTEVfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgICB1bml0ID0gcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzJdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nVHlwZS5TdHlsZTtcbiAgICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dCA9IF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlNUWUxFO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJJbnZhbGlkIHByb3BlcnR5IG5hbWUgJ1wiICsgbmFtZSArIFwiJ1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChib3VuZFByb3BlcnR5TmFtZSwgYmluZGluZ1R5cGUsIHNlY3VyaXR5Q29udGV4dCwgYXN0LCB1bml0LCBzb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSBwcm9wTmFtZSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgLyBhdHRyaWJ1dGVcbiAgICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuXG4gICAgICAgKiBAcGFyYW0gaXNBdHRyIHRydWUgd2hlbiBiaW5kaW5nIHRvIGFuIGF0dHJpYnV0ZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzb3VyY2VTcGFuLCBpc0F0dHIpIHtcbiAgICAgICAgICB2YXIgcmVwb3J0ID0gaXNBdHRyID8gdGhpcy5fc2NoZW1hUmVnaXN0cnkudmFsaWRhdGVBdHRyaWJ1dGUocHJvcE5hbWUpIDpcbiAgICAgICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkudmFsaWRhdGVQcm9wZXJ0eShwcm9wTmFtZSk7XG4gICAgICAgICAgaWYgKHJlcG9ydC5lcnJvcikge1xuICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihyZXBvcnQubXNnLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRkFUQUwpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlcyhkaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5kaXJlY3RpdmUudHlwZS5uYW1lOyB9KTtcbiAgICAgIH07XG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgc291cmNlU3Bhbikge1xuICAgICAgICAgIHZhciBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiTW9yZSB0aGFuIG9uZSBjb21wb25lbnQ6IFwiICsgY29tcG9uZW50VHlwZU5hbWVzLmpvaW4oJywnKSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogTWFrZSBzdXJlIHRoYXQgbm9uLWFuZ3VsYXIgdGFncyBjb25mb3JtIHRvIHRoZSBzY2hlbWFzLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IEFuIGVsZW1lbnQgaXMgY29uc2lkZXJlZCBhbiBhbmd1bGFyIHRhZyB3aGVuIGF0IGxlYXN0IG9uZSBkaXJlY3RpdmUgc2VsZWN0b3IgbWF0Y2hlcyB0aGVcbiAgICAgICAqIHRhZyBuYW1lLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSBtYXRjaEVsZW1lbnQgV2hldGhlciBhbnkgZGlyZWN0aXZlIGhhcyBtYXRjaGVkIG9uIHRoZSB0YWcgbmFtZVxuICAgICAgICogQHBhcmFtIGVsZW1lbnQgdGhlIGh0bWwgZWxlbWVudFxuICAgICAgICovXG4gICAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydEVsZW1lbnRFeGlzdHMgPSBmdW5jdGlvbiAobWF0Y2hFbGVtZW50LCBlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGVsTmFtZSA9IGVsZW1lbnQubmFtZS5yZXBsYWNlKC9eOnhodG1sOi8sICcnKTtcbiAgICAgICAgICBpZiAoIW1hdGNoRWxlbWVudCAmJiAhdGhpcy5fc2NoZW1hUmVnaXN0cnkuaGFzRWxlbWVudChlbE5hbWUsIHRoaXMuX3NjaGVtYXMpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvck1zZyA9IChcIidcIiArIGVsTmFtZSArIFwiJyBpcyBub3QgYSBrbm93biBlbGVtZW50OlxcblwiKSArXG4gICAgICAgICAgICAgICAgICAoXCIxLiBJZiAnXCIgKyBlbE5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBjb21wb25lbnQsIHRoZW4gdmVyaWZ5IHRoYXQgaXQgaXMgcGFydCBvZiB0aGlzIG1vZHVsZS5cXG5cIikgK1xuICAgICAgICAgICAgICAgICAgKFwiMi4gSWYgJ1wiICsgZWxOYW1lICsgXCInIGlzIGEgV2ViIENvbXBvbmVudCB0aGVuIGFkZCBcXFwiQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQVxcXCIgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQgdG8gc3VwcHJlc3MgdGhpcyBtZXNzYWdlLlwiKTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3JNc2csIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBlbGVtZW50UHJvcHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiQ29tcG9uZW50cyBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZTogXCIgKyBjb21wb25lbnRUeXBlTmFtZXMuam9pbignLCcpLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudFByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiUHJvcGVydHkgYmluZGluZyBcIiArIHByb3AubmFtZSArIFwiIG5vdCB1c2VkIGJ5IGFueSBkaXJlY3RpdmUgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGUuIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm9wZXJ0eSBuYW1lIGlzIHNwZWxsZWQgY29ycmVjdGx5IGFuZCBhbGwgZGlyZWN0aXZlcyBhcmUgbGlzdGVkIGluIHRoZSBcXFwiZGlyZWN0aXZlc1xcXCIgc2VjdGlvbi5cIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgZXZlbnRzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgYWxsRGlyZWN0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZS5kaXJlY3RpdmUub3V0cHV0cykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGRpcmVjdGl2ZS5kaXJlY3RpdmUub3V0cHV0c1trXTtcbiAgICAgICAgICAgICAgICAgIGFsbERpcmVjdGl2ZUV2ZW50cy5hZGQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQudGFyZ2V0KSB8fCAhYWxsRGlyZWN0aXZlRXZlbnRzLmhhcyhldmVudC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiRXZlbnQgYmluZGluZyBcIiArIGV2ZW50LmZ1bGxOYW1lICsgXCIgbm90IGVtaXR0ZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIGV2ZW50IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJkaXJlY3RpdmVzXFxcIiBzZWN0aW9uLlwiLCBldmVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlVmlzaXRvcjtcbiAgfSgpKTtcbiAgdmFyIE5vbkJpbmRhYmxlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOb25CaW5kYWJsZVZpc2l0b3IoKSB7XG4gICAgICB9XG4gICAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUIHx8XG4gICAgICAgICAgICAgIHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUgfHxcbiAgICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYW5kIHN0eWxlc2hlZXRzIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZW1cbiAgICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdHRyTmFtZUFuZFZhbHVlcyA9IGFzdC5hdHRycy5tYXAoZnVuY3Rpb24gKGF0dHJBc3QpIHsgcmV0dXJuIFthdHRyQXN0Lm5hbWUsIGF0dHJBc3QudmFsdWVdOyB9KTtcbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoYXN0Lm5hbWUsIGF0dHJOYW1lQW5kVmFsdWVzKTtcbiAgICAgICAgICB2YXIgbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KHNlbGVjdG9yKTtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB2aXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIEVNUFRZX0VMRU1FTlRfQ09OVEVYVCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50QXN0KGFzdC5uYW1lLCB2aXNpdEFsbCh0aGlzLCBhc3QuYXR0cnMpLCBbXSwgW10sIFtdLCBbXSwgW10sIGZhbHNlLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIGFzdC5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJBc3QoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4pO1xuICAgICAgfTtcbiAgICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoVEVYVF9DU1NfU0VMRUNUT1IpO1xuICAgICAgICAgIHJldHVybiBuZXcgVGV4dEFzdCh0ZXh0LnZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICAgIH07XG4gICAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uOyB9O1xuICAgICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyByZXR1cm4gZXhwYW5zaW9uQ2FzZTsgfTtcbiAgICAgIHJldHVybiBOb25CaW5kYWJsZVZpc2l0b3I7XG4gIH0oKSk7XG4gIHZhciBCb3VuZEVsZW1lbnRPckRpcmVjdGl2ZVByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEJvdW5kRWxlbWVudE9yRGlyZWN0aXZlUHJvcGVydHkobmFtZSwgZXhwcmVzc2lvbiwgaXNMaXRlcmFsLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuaXNMaXRlcmFsID0gaXNMaXRlcmFsO1xuICAgICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICB9XG4gICAgICByZXR1cm4gQm91bmRFbGVtZW50T3JEaXJlY3RpdmVQcm9wZXJ0eTtcbiAgfSgpKTtcbiAgdmFyIEVsZW1lbnRPckRpcmVjdGl2ZVJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbGVtZW50T3JEaXJlY3RpdmVSZWYobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEVsZW1lbnRPckRpcmVjdGl2ZVJlZjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gc3BsaXRDbGFzc2VzKGNsYXNzQXR0clZhbHVlKSB7XG4gICAgICByZXR1cm4gY2xhc3NBdHRyVmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xuICB9XG4gIHZhciBFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFbGVtZW50Q29udGV4dChpc1RlbXBsYXRlRWxlbWVudCwgX25nQ29udGVudEluZGV4TWF0Y2hlciwgX3dpbGRjYXJkTmdDb250ZW50SW5kZXgsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICAgIHRoaXMuaXNUZW1wbGF0ZUVsZW1lbnQgPSBpc1RlbXBsYXRlRWxlbWVudDtcbiAgICAgICAgICB0aGlzLl9uZ0NvbnRlbnRJbmRleE1hdGNoZXIgPSBfbmdDb250ZW50SW5kZXhNYXRjaGVyO1xuICAgICAgICAgIHRoaXMuX3dpbGRjYXJkTmdDb250ZW50SW5kZXggPSBfd2lsZGNhcmROZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgICB0aGlzLnByb3ZpZGVyQ29udGV4dCA9IHByb3ZpZGVyQ29udGV4dDtcbiAgICAgIH1cbiAgICAgIEVsZW1lbnRDb250ZXh0LmNyZWF0ZSA9IGZ1bmN0aW9uIChpc1RlbXBsYXRlRWxlbWVudCwgZGlyZWN0aXZlcywgcHJvdmlkZXJDb250ZXh0KSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgICAgdmFyIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBudWxsO1xuICAgICAgICAgIHZhciBjb21wb25lbnQgPSBkaXJlY3RpdmVzLmZpbmQoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICB2YXIgbmdDb250ZW50U2VsZWN0b3JzID0gY29tcG9uZW50LmRpcmVjdGl2ZS50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnM7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmdDb250ZW50U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBuZ0NvbnRlbnRTZWxlY3RvcnNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgIHdpbGRjYXJkTmdDb250ZW50SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhDc3NTZWxlY3Rvci5wYXJzZShuZ0NvbnRlbnRTZWxlY3RvcnNbaV0pLCBpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRDb250ZXh0KGlzVGVtcGxhdGVFbGVtZW50LCBtYXRjaGVyLCB3aWxkY2FyZE5nQ29udGVudEluZGV4LCBwcm92aWRlckNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIEVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5maW5kTmdDb250ZW50SW5kZXggPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgbmdDb250ZW50SW5kaWNlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX25nQ29udGVudEluZGV4TWF0Y2hlci5tYXRjaChzZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBuZ0NvbnRlbnRJbmRleCkgeyBuZ0NvbnRlbnRJbmRpY2VzLnB1c2gobmdDb250ZW50SW5kZXgpOyB9KTtcbiAgICAgICAgICBuZ0NvbnRlbnRJbmRpY2VzLnNvcnQoKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3dpbGRjYXJkTmdDb250ZW50SW5kZXgpKSB7XG4gICAgICAgICAgICAgIG5nQ29udGVudEluZGljZXMucHVzaCh0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5nQ29udGVudEluZGljZXMubGVuZ3RoID4gMCA/IG5nQ29udGVudEluZGljZXNbMF0gOiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBFbGVtZW50Q29udGV4dDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yKGVsZW1lbnROYW1lLCBtYXRjaGFibGVBdHRycykge1xuICAgICAgdmFyIGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgICB2YXIgZWxOYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKVsxXTtcbiAgICAgIGNzc1NlbGVjdG9yLnNldEVsZW1lbnQoZWxOYW1lTm9Ocyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoYWJsZUF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGF0dHJOYW1lID0gbWF0Y2hhYmxlQXR0cnNbaV1bMF07XG4gICAgICAgICAgdmFyIGF0dHJOYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGF0dHJOYW1lKVsxXTtcbiAgICAgICAgICB2YXIgYXR0clZhbHVlID0gbWF0Y2hhYmxlQXR0cnNbaV1bMV07XG4gICAgICAgICAgY3NzU2VsZWN0b3IuYWRkQXR0cmlidXRlKGF0dHJOYW1lTm9OcywgYXR0clZhbHVlKTtcbiAgICAgICAgICBpZiAoYXR0ck5hbWUudG9Mb3dlckNhc2UoKSA9PSBDTEFTU19BVFRSKSB7XG4gICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gc3BsaXRDbGFzc2VzKGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiBjc3NTZWxlY3Rvci5hZGRDbGFzc05hbWUoY2xhc3NOYW1lKTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNzc1NlbGVjdG9yO1xuICB9XG4gIHZhciBFTVBUWV9FTEVNRU5UX0NPTlRFWFQgPSBuZXcgRWxlbWVudENvbnRleHQodHJ1ZSwgbmV3IFNlbGVjdG9yTWF0Y2hlcigpLCBudWxsLCBudWxsKTtcbiAgdmFyIE5PTl9CSU5EQUJMRV9WSVNJVE9SID0gbmV3IE5vbkJpbmRhYmxlVmlzaXRvcigpO1xuICB2YXIgUGlwZUNvbGxlY3RvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMoUGlwZUNvbGxlY3RvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIFBpcGVDb2xsZWN0b3IoKSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgdGhpcy5waXBlcyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIFBpcGVDb2xsZWN0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB0aGlzLnBpcGVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgICAgYXN0LmV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gUGlwZUNvbGxlY3RvcjtcbiAgfShSZWN1cnNpdmVBc3RWaXNpdG9yKSk7XG4gIGZ1bmN0aW9uIF9pc0FuaW1hdGlvbkxhYmVsKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lWzBdID09ICdAJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQkMSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCcpO1xuICB9XG4gIHZhciBDb21waWxlckNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlckNvbmZpZyhfYSkge1xuICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnJlbmRlclR5cGVzLCByZW5kZXJUeXBlcyA9IF9jID09PSB2b2lkIDAgPyBuZXcgRGVmYXVsdFJlbmRlclR5cGVzKCkgOiBfYywgX2QgPSBfYi5kZWZhdWx0RW5jYXBzdWxhdGlvbiwgZGVmYXVsdEVuY2Fwc3VsYXRpb24gPSBfZCA9PT0gdm9pZCAwID8gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCA6IF9kLCBnZW5EZWJ1Z0luZm8gPSBfYi5nZW5EZWJ1Z0luZm8sIGxvZ0JpbmRpbmdVcGRhdGUgPSBfYi5sb2dCaW5kaW5nVXBkYXRlLCBfZSA9IF9iLnVzZUppdCwgdXNlSml0ID0gX2UgPT09IHZvaWQgMCA/IHRydWUgOiBfZTtcbiAgICAgICAgICB0aGlzLnJlbmRlclR5cGVzID0gcmVuZGVyVHlwZXM7XG4gICAgICAgICAgdGhpcy5kZWZhdWx0RW5jYXBzdWxhdGlvbiA9IGRlZmF1bHRFbmNhcHN1bGF0aW9uO1xuICAgICAgICAgIHRoaXMuX2dlbkRlYnVnSW5mbyA9IGdlbkRlYnVnSW5mbztcbiAgICAgICAgICB0aGlzLl9sb2dCaW5kaW5nVXBkYXRlID0gbG9nQmluZGluZ1VwZGF0ZTtcbiAgICAgICAgICB0aGlzLnVzZUppdCA9IHVzZUppdDtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlckNvbmZpZy5wcm90b3R5cGUsIFwiZ2VuRGVidWdJbmZvXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dlbkRlYnVnSW5mbyA9PT0gdm9pZCAwID8gX2FuZ3VsYXJfY29yZS5pc0Rldk1vZGUoKSA6IHRoaXMuX2dlbkRlYnVnSW5mbztcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21waWxlckNvbmZpZy5wcm90b3R5cGUsIFwibG9nQmluZGluZ1VwZGF0ZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dCaW5kaW5nVXBkYXRlID09PSB2b2lkIDAgPyBfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpIDogdGhpcy5fbG9nQmluZGluZ1VwZGF0ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDb21waWxlckNvbmZpZztcbiAgfSgpKTtcbiAgLyoqXG4gICAqIFR5cGVzIHVzZWQgZm9yIHRoZSByZW5kZXJlci5cbiAgICogQ2FuIGJlIHJlcGxhY2VkIHRvIHNwZWNpYWxpemUgdGhlIGdlbmVyYXRlZCBvdXRwdXQgdG8gYSBzcGVjaWZpYyByZW5kZXJlclxuICAgKiB0byBoZWxwIHRyZWUgc2hha2luZy5cbiAgICovXG4gIHZhciBSZW5kZXJUeXBlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZW5kZXJUeXBlcygpIHtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCQxKCk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlclR5cGVzLnByb3RvdHlwZSwgXCJyZW5kZXJUZXh0XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyRWxlbWVudFwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkJDEoKTsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyVHlwZXMucHJvdG90eXBlLCBcInJlbmRlckNvbW1lbnRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCQxKCk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlclR5cGVzLnByb3RvdHlwZSwgXCJyZW5kZXJOb2RlXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQkMSgpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyRXZlbnRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCQxKCk7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFJlbmRlclR5cGVzO1xuICB9KCkpO1xuICB2YXIgRGVmYXVsdFJlbmRlclR5cGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERlZmF1bHRSZW5kZXJUeXBlcygpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlclRleHQgPSBudWxsO1xuICAgICAgICAgIHRoaXMucmVuZGVyRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5yZW5kZXJDb21tZW50ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnJlbmRlck5vZGUgPSBudWxsO1xuICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmF1bHRSZW5kZXJUeXBlcy5wcm90b3R5cGUsIFwicmVuZGVyZXJcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuUmVuZGVyZXIpOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIDtcbiAgICAgIHJldHVybiBEZWZhdWx0UmVuZGVyVHlwZXM7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDEyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgQW5pbWF0aW9uQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkFzdCgpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgICAgdGhpcy5wbGF5VGltZSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gQW5pbWF0aW9uQXN0O1xuICB9KCkpO1xuICB2YXIgQW5pbWF0aW9uU3RhdGVBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEFuaW1hdGlvblN0YXRlQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVBc3QoKSB7XG4gICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQW5pbWF0aW9uU3RhdGVBc3Q7XG4gIH0oQW5pbWF0aW9uQXN0KSk7XG4gIHZhciBBbmltYXRpb25FbnRyeUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQW5pbWF0aW9uRW50cnlBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25FbnRyeUFzdChuYW1lLCBzdGF0ZURlY2xhcmF0aW9ucywgc3RhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5zdGF0ZURlY2xhcmF0aW9ucyA9IHN0YXRlRGVjbGFyYXRpb25zO1xuICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9ucyA9IHN0YXRlVHJhbnNpdGlvbnM7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25FbnRyeUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uRW50cnkodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvbkVudHJ5QXN0O1xuICB9KEFuaW1hdGlvbkFzdCkpO1xuICB2YXIgQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbkFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbkFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3Qoc3RhdGVOYW1lLCBzdHlsZXMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0YXRlTmFtZSA9IHN0YXRlTmFtZTtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb24odGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25Bc3Q7XG4gIH0oQW5pbWF0aW9uU3RhdGVBc3QpKTtcbiAgdmFyIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uRXhwcmVzc2lvbihmcm9tU3RhdGUsIHRvU3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmZyb21TdGF0ZSA9IGZyb21TdGF0ZTtcbiAgICAgICAgICB0aGlzLnRvU3RhdGUgPSB0b1N0YXRlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkV4cHJlc3Npb247XG4gIH0oKSk7XG4gIHZhciBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25Bc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkFzdChzdGF0ZUNoYW5nZXMsIGFuaW1hdGlvbikge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VzID0gc3RhdGVDaGFuZ2VzO1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRpb25TdGF0ZVRyYW5zaXRpb24odGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkFzdDtcbiAgfShBbmltYXRpb25TdGF0ZUFzdCkpO1xuICB2YXIgQW5pbWF0aW9uU3RlcEFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQW5pbWF0aW9uU3RlcEFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0ZXBBc3Qoc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0aW5nU3R5bGVzID0gc3RhcnRpbmdTdHlsZXM7XG4gICAgICAgICAgdGhpcy5rZXlmcmFtZXMgPSBrZXlmcmFtZXM7XG4gICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgICB0aGlzLmVhc2luZyA9IGVhc2luZztcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblN0ZXBBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvblN0ZXAodGhpcywgY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIEFuaW1hdGlvblN0ZXBBc3Q7XG4gIH0oQW5pbWF0aW9uQXN0KSk7XG4gIHZhciBBbmltYXRpb25TdHlsZXNBc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgX19leHRlbmRzJDEyKEFuaW1hdGlvblN0eWxlc0FzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0eWxlc0FzdChzdHlsZXMpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblN0eWxlc0FzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0aW9uU3R5bGVzKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25TdHlsZXNBc3Q7XG4gIH0oQW5pbWF0aW9uQXN0KSk7XG4gIHZhciBBbmltYXRpb25LZXlmcmFtZUFzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQW5pbWF0aW9uS2V5ZnJhbWVBc3QsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBBbmltYXRpb25LZXlmcmFtZUFzdChvZmZzZXQsIHN0eWxlcykge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uS2V5ZnJhbWVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvbktleWZyYW1lKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25LZXlmcmFtZUFzdDtcbiAgfShBbmltYXRpb25Bc3QpKTtcbiAgdmFyIEFuaW1hdGlvbldpdGhTdGVwc0FzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTIoQW5pbWF0aW9uV2l0aFN0ZXBzQXN0LCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uV2l0aFN0ZXBzQXN0KHN0ZXBzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFuaW1hdGlvbldpdGhTdGVwc0FzdDtcbiAgfShBbmltYXRpb25Bc3QpKTtcbiAgdmFyIEFuaW1hdGlvbkdyb3VwQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihBbmltYXRpb25Hcm91cEFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkdyb3VwQXN0KHN0ZXBzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uR3JvdXBBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvbkdyb3VwKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25Hcm91cEFzdDtcbiAgfShBbmltYXRpb25XaXRoU3RlcHNBc3QpKTtcbiAgdmFyIEFuaW1hdGlvblNlcXVlbmNlQXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxMihBbmltYXRpb25TZXF1ZW5jZUFzdCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblNlcXVlbmNlQXN0KHN0ZXBzKSB7XG4gICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uU2VxdWVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGlvblNlcXVlbmNlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25TZXF1ZW5jZUFzdDtcbiAgfShBbmltYXRpb25XaXRoU3RlcHNBc3QpKTtcblxuICB2YXIgQW5pbWF0aW9uRW50cnlDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVudHJ5Q29tcGlsZVJlc3VsdChuYW1lLCBzdGF0ZW1lbnRzLCBmbkV4cCkge1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgICB0aGlzLmZuRXhwID0gZm5FeHA7XG4gICAgICB9XG4gICAgICByZXR1cm4gQW5pbWF0aW9uRW50cnlDb21waWxlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgQW5pbWF0aW9uQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uQ29tcGlsZXIoKSB7XG4gICAgICB9XG4gICAgICBBbmltYXRpb25Db21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChmYWN0b3J5TmFtZVByZWZpeCwgcGFyc2VkQW5pbWF0aW9ucykge1xuICAgICAgICAgIHJldHVybiBwYXJzZWRBbmltYXRpb25zLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgdmFyIGZhY3RvcnlOYW1lID0gZmFjdG9yeU5hbWVQcmVmaXggKyBcIl9cIiArIGVudHJ5Lm5hbWU7XG4gICAgICAgICAgICAgIHZhciB2aXNpdG9yID0gbmV3IF9BbmltYXRpb25CdWlsZGVyKGVudHJ5Lm5hbWUsIGZhY3RvcnlOYW1lKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IuYnVpbGQoZW50cnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBbmltYXRpb25Db21waWxlcjtcbiAgfSgpKTtcbiAgdmFyIF9BTklNQVRJT05fRkFDVE9SWV9FTEVNRU5UX1ZBUiA9IHZhcmlhYmxlKCdlbGVtZW50Jyk7XG4gIHZhciBfQU5JTUFUSU9OX0RFRkFVTFRfU1RBVEVfVkFSID0gdmFyaWFibGUoJ2RlZmF1bHRTdGF0ZVN0eWxlcycpO1xuICB2YXIgX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfVkFSID0gdmFyaWFibGUoJ3ZpZXcnKTtcbiAgdmFyIF9BTklNQVRJT05fRkFDVE9SWV9SRU5ERVJFUl9WQVIgPSBfQU5JTUFUSU9OX0ZBQ1RPUllfVklFV19WQVIucHJvcCgncmVuZGVyZXInKTtcbiAgdmFyIF9BTklNQVRJT05fQ1VSUkVOVF9TVEFURV9WQVIgPSB2YXJpYWJsZSgnY3VycmVudFN0YXRlJyk7XG4gIHZhciBfQU5JTUFUSU9OX05FWFRfU1RBVEVfVkFSID0gdmFyaWFibGUoJ25leHRTdGF0ZScpO1xuICB2YXIgX0FOSU1BVElPTl9QTEFZRVJfVkFSID0gdmFyaWFibGUoJ3BsYXllcicpO1xuICB2YXIgX0FOSU1BVElPTl9USU1FX1ZBUiA9IHZhcmlhYmxlKCd0b3RhbFRpbWUnKTtcbiAgdmFyIF9BTklNQVRJT05fU1RBUlRfU1RBVEVfU1RZTEVTX1ZBUiA9IHZhcmlhYmxlKCdzdGFydFN0YXRlU3R5bGVzJyk7XG4gIHZhciBfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSID0gdmFyaWFibGUoJ2VuZFN0YXRlU3R5bGVzJyk7XG4gIHZhciBfQU5JTUFUSU9OX0NPTExFQ1RFRF9TVFlMRVMgPSB2YXJpYWJsZSgnY29sbGVjdGVkU3R5bGVzJyk7XG4gIHZhciBFTVBUWV9NQVAkMSA9IGxpdGVyYWxNYXAoW10pO1xuICB2YXIgX0FuaW1hdGlvbkJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0FuaW1hdGlvbkJ1aWxkZXIoYW5pbWF0aW9uTmFtZSwgZmFjdG9yeU5hbWUpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25OYW1lO1xuICAgICAgICAgIHRoaXMuX2ZuVmFyTmFtZSA9IGZhY3RvcnlOYW1lICsgJ19mYWN0b3J5JztcbiAgICAgICAgICB0aGlzLl9zdGF0ZXNNYXBWYXJOYW1lID0gZmFjdG9yeU5hbWUgKyAnX3N0YXRlcyc7XG4gICAgICAgICAgdGhpcy5fc3RhdGVzTWFwVmFyID0gdmFyaWFibGUodGhpcy5fc3RhdGVzTWFwVmFyTmFtZSk7XG4gICAgICB9XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlci5wcm90b3R5cGUudmlzaXRBbmltYXRpb25TdHlsZXMgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIHN0eWxlc0FyciA9IFtdO1xuICAgICAgICAgIGlmIChjb250ZXh0LmlzRXhwZWN0aW5nRmlyc3RTdHlsZVN0ZXApIHtcbiAgICAgICAgICAgICAgc3R5bGVzQXJyLnB1c2goX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSKTtcbiAgICAgICAgICAgICAgY29udGV4dC5pc0V4cGVjdGluZ0ZpcnN0U3R5bGVTdGVwID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzdC5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgc3R5bGVzQXJyLnB1c2gobGl0ZXJhbE1hcChPYmplY3Qua2V5cyhlbnRyeSkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIGxpdGVyYWwoZW50cnlba2V5XSldOyB9KSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFuaW1hdGlvblN0eWxlcykpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5jb2xsZWN0QW5kUmVzb2x2ZVN0eWxlcykpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICBfQU5JTUFUSU9OX0NPTExFQ1RFRF9TVFlMRVMsIGxpdGVyYWxBcnIoc3R5bGVzQXJyKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvbktleWZyYW1lID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFuaW1hdGlvbktleWZyYW1lKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5vZmZzZXQpLCBhc3Quc3R5bGVzLnZpc2l0KHRoaXMsIGNvbnRleHQpXG4gICAgICAgICAgXSk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uU3RlcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChjb250ZXh0LmVuZFN0YXRlQW5pbWF0ZVN0ZXAgPT09IGFzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRFbmRTdGF0ZUFuaW1hdGlvbihhc3QsIGNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RhcnRpbmdTdHlsZXNFeHByID0gYXN0LnN0YXJ0aW5nU3R5bGVzLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHZhciBrZXlmcmFtZUV4cHJlc3Npb25zID0gYXN0LmtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGtleWZyYW1lRW50cnkpIHsgcmV0dXJuIGtleWZyYW1lRW50cnkudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEFuaW1hdGVNZXRob2QoYXN0LCBzdGFydGluZ1N0eWxlc0V4cHIsIGxpdGVyYWxBcnIoa2V5ZnJhbWVFeHByZXNzaW9ucyksIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRFbmRTdGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzdGFydGluZ1N0eWxlc0V4cHIgPSBhc3Quc3RhcnRpbmdTdHlsZXMudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgdmFyIGtleWZyYW1lRXhwcmVzc2lvbnMgPSBhc3Qua2V5ZnJhbWVzLm1hcChmdW5jdGlvbiAoa2V5ZnJhbWUpIHsgcmV0dXJuIGtleWZyYW1lLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgdmFyIGtleWZyYW1lc0V4cHIgPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmJhbGFuY2VBbmltYXRpb25LZXlmcmFtZXMpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICBfQU5JTUFUSU9OX0NPTExFQ1RFRF9TVFlMRVMsIF9BTklNQVRJT05fRU5EX1NUQVRFX1NUWUxFU19WQVIsXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIoa2V5ZnJhbWVFeHByZXNzaW9ucylcbiAgICAgICAgICBdKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEFuaW1hdGVNZXRob2QoYXN0LCBzdGFydGluZ1N0eWxlc0V4cHIsIGtleWZyYW1lc0V4cHIsIGNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5fY2FsbEFuaW1hdGVNZXRob2QgPSBmdW5jdGlvbiAoYXN0LCBzdGFydGluZ1N0eWxlc0V4cHIsIGtleWZyYW1lc0V4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0LnRvdGFsVHJhbnNpdGlvblRpbWUgKz0gYXN0LmR1cmF0aW9uICsgYXN0LmRlbGF5O1xuICAgICAgICAgIHJldHVybiBfQU5JTUFUSU9OX0ZBQ1RPUllfUkVOREVSRVJfVkFSLmNhbGxNZXRob2QoJ2FuaW1hdGUnLCBbXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fRkFDVE9SWV9FTEVNRU5UX1ZBUiwgc3RhcnRpbmdTdHlsZXNFeHByLCBrZXlmcmFtZXNFeHByLCBsaXRlcmFsKGFzdC5kdXJhdGlvbiksXG4gICAgICAgICAgICAgIGxpdGVyYWwoYXN0LmRlbGF5KSwgbGl0ZXJhbChhc3QuZWFzaW5nKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvblNlcXVlbmNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHBsYXllckV4cHJzID0gYXN0LnN0ZXBzLm1hcChmdW5jdGlvbiAoc3RlcCkgeyByZXR1cm4gc3RlcC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFuaW1hdGlvblNlcXVlbmNlUGxheWVyKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsQXJyKHBsYXllckV4cHJzKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvbkdyb3VwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHBsYXllckV4cHJzID0gYXN0LnN0ZXBzLm1hcChmdW5jdGlvbiAoc3RlcCkgeyByZXR1cm4gc3RlcC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFuaW1hdGlvbkdyb3VwUGxheWVyKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsQXJyKHBsYXllckV4cHJzKVxuICAgICAgICAgIF0pO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS52aXNpdEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIGZsYXRTdHlsZXMgPSB7fTtcbiAgICAgICAgICBfZ2V0U3R5bGVzQXJyYXkoYXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGZsYXRTdHlsZXNba2V5XSA9IGVudHJ5W2tleV07IH0pOyB9KTtcbiAgICAgICAgICBjb250ZXh0LnN0YXRlTWFwLnJlZ2lzdGVyU3RhdGUoYXN0LnN0YXRlTmFtZSwgZmxhdFN0eWxlcyk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAgIHZhciBzdGVwcyA9IGFzdC5hbmltYXRpb24uc3RlcHM7XG4gICAgICAgICAgdmFyIGxhc3RTdGVwID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKF9pc0VuZFN0YXRlQW5pbWF0ZVN0ZXAobGFzdFN0ZXApKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuZW5kU3RhdGVBbmltYXRlU3RlcCA9IGxhc3RTdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250ZXh0LnRvdGFsVHJhbnNpdGlvblRpbWUgPSAwO1xuICAgICAgICAgIGNvbnRleHQuaXNFeHBlY3RpbmdGaXJzdFN0eWxlU3RlcCA9IHRydWU7XG4gICAgICAgICAgdmFyIHN0YXRlQ2hhbmdlUHJlY29uZGl0aW9ucyA9IFtdO1xuICAgICAgICAgIGFzdC5zdGF0ZUNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgc3RhdGVDaGFuZ2VQcmVjb25kaXRpb25zLnB1c2goX2NvbXBhcmVUb0FuaW1hdGlvblN0YXRlRXhwcihfQU5JTUFUSU9OX0NVUlJFTlRfU1RBVEVfVkFSLCBzdGF0ZUNoYW5nZS5mcm9tU3RhdGUpXG4gICAgICAgICAgICAgICAgICAuYW5kKF9jb21wYXJlVG9BbmltYXRpb25TdGF0ZUV4cHIoX0FOSU1BVElPTl9ORVhUX1NUQVRFX1ZBUiwgc3RhdGVDaGFuZ2UudG9TdGF0ZSkpKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlQ2hhbmdlLmZyb21TdGF0ZSAhPSBBTllfU1RBVEUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RhdGVNYXAucmVnaXN0ZXJTdGF0ZShzdGF0ZUNoYW5nZS5mcm9tU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzdGF0ZUNoYW5nZS50b1N0YXRlICE9IEFOWV9TVEFURSkge1xuICAgICAgICAgICAgICAgICAgY29udGV4dC5zdGF0ZU1hcC5yZWdpc3RlclN0YXRlKHN0YXRlQ2hhbmdlLnRvU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblBsYXllckV4cHIgPSBhc3QuYW5pbWF0aW9uLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIHZhciByZWR1Y2VkU3RhdGVDaGFuZ2VzUHJlY29uZGl0aW9uID0gc3RhdGVDaGFuZ2VQcmVjb25kaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5vcihiKTsgfSk7XG4gICAgICAgICAgdmFyIHByZWNvbmRpdGlvbiA9IF9BTklNQVRJT05fUExBWUVSX1ZBUi5lcXVhbHMoTlVMTF9FWFBSKS5hbmQocmVkdWNlZFN0YXRlQ2hhbmdlc1ByZWNvbmRpdGlvbik7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblN0bXQgPSBfQU5JTUFUSU9OX1BMQVlFUl9WQVIuc2V0KGFuaW1hdGlvblBsYXllckV4cHIpLnRvU3RtdCgpO1xuICAgICAgICAgIHZhciB0b3RhbFRpbWVTdG10ID0gX0FOSU1BVElPTl9USU1FX1ZBUi5zZXQobGl0ZXJhbChjb250ZXh0LnRvdGFsVHJhbnNpdGlvblRpbWUpKS50b1N0bXQoKTtcbiAgICAgICAgICByZXR1cm4gbmV3IElmU3RtdChwcmVjb25kaXRpb24sIFthbmltYXRpb25TdG10LCB0b3RhbFRpbWVTdG10XSk7XG4gICAgICB9O1xuICAgICAgX0FuaW1hdGlvbkJ1aWxkZXIucHJvdG90eXBlLnZpc2l0QW5pbWF0aW9uRW50cnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAvLyB2aXNpdCBlYWNoIG9mIHRoZSBkZWNsYXJhdGlvbnMgZmlyc3QgdG8gYnVpbGQgdGhlIGNvbnRleHQgc3RhdGUgbWFwXG4gICAgICAgICAgYXN0LnN0YXRlRGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gZGVmLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgICAgLy8gdGhpcyBzaG91bGQgYWx3YXlzIGJlIGRlZmluZWQgZXZlbiBpZiB0aGUgdXNlciBvdmVycmlkZXMgaXRcbiAgICAgICAgICBjb250ZXh0LnN0YXRlTWFwLnJlZ2lzdGVyU3RhdGUoREVGQVVMVF9TVEFURSwge30pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fRkFDVE9SWV9WSUVXX1ZBUlxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnY2FuY2VsQWN0aXZlQW5pbWF0aW9uJywgW1xuICAgICAgICAgICAgICBfQU5JTUFUSU9OX0ZBQ1RPUllfRUxFTUVOVF9WQVIsIGxpdGVyYWwodGhpcy5hbmltYXRpb25OYW1lKSxcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9ORVhUX1NUQVRFX1ZBUi5lcXVhbHMobGl0ZXJhbChFTVBUWV9BTklNQVRJT05fU1RBVEUpKVxuICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fQ09MTEVDVEVEX1NUWUxFUy5zZXQoRU1QVFlfTUFQJDEpLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgc3RhdGVtZW50cy5wdXNoKF9BTklNQVRJT05fUExBWUVSX1ZBUi5zZXQoTlVMTF9FWFBSKS50b0RlY2xTdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX1RJTUVfVkFSLnNldChsaXRlcmFsKDApKS50b0RlY2xTdG10KCkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX0RFRkFVTFRfU1RBVEVfVkFSLnNldCh0aGlzLl9zdGF0ZXNNYXBWYXIua2V5KGxpdGVyYWwoREVGQVVMVF9TVEFURSkpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSLnNldCh0aGlzLl9zdGF0ZXNNYXBWYXIua2V5KF9BTklNQVRJT05fQ1VSUkVOVF9TVEFURV9WQVIpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IElmU3RtdChfQU5JTUFUSU9OX1NUQVJUX1NUQVRFX1NUWUxFU19WQVIuZXF1YWxzKE5VTExfRVhQUiksIFtfQU5JTUFUSU9OX1NUQVJUX1NUQVRFX1NUWUxFU19WQVIuc2V0KF9BTklNQVRJT05fREVGQVVMVF9TVEFURV9WQVIpLnRvU3RtdCgpXSkpO1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSLnNldCh0aGlzLl9zdGF0ZXNNYXBWYXIua2V5KF9BTklNQVRJT05fTkVYVF9TVEFURV9WQVIpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IElmU3RtdChfQU5JTUFUSU9OX0VORF9TVEFURV9TVFlMRVNfVkFSLmVxdWFscyhOVUxMX0VYUFIpLCBbX0FOSU1BVElPTl9FTkRfU1RBVEVfU1RZTEVTX1ZBUi5zZXQoX0FOSU1BVElPTl9ERUZBVUxUX1NUQVRFX1ZBUikudG9TdG10KCldKSk7XG4gICAgICAgICAgdmFyIFJFTkRFUl9TVFlMRVNfRk4gPSBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLnJlbmRlclN0eWxlcykpO1xuICAgICAgICAgIC8vIGJlZm9yZSB3ZSBzdGFydCBhbnkgYW5pbWF0aW9uIHdlIHdhbnQgdG8gY2xlYXIgb3V0IHRoZSBzdGFydGluZ1xuICAgICAgICAgIC8vIHN0eWxlcyBmcm9tIHRoZSBlbGVtZW50J3Mgc3R5bGUgcHJvcGVydHkgKHNpbmNlIHRoZXkgd2VyZSBwbGFjZWRcbiAgICAgICAgICAvLyB0aGVyZSBhdCB0aGUgZW5kIG9mIHRoZSBsYXN0IGFuaW1hdGlvblxuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChSRU5ERVJfU1RZTEVTX0ZOXG4gICAgICAgICAgICAgIC5jYWxsRm4oW1xuICAgICAgICAgICAgICBfQU5JTUFUSU9OX0ZBQ1RPUllfRUxFTUVOVF9WQVIsIF9BTklNQVRJT05fRkFDVE9SWV9SRU5ERVJFUl9WQVIsXG4gICAgICAgICAgICAgIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY2xlYXJTdHlsZXMpKVxuICAgICAgICAgICAgICAgICAgLmNhbGxGbihbX0FOSU1BVElPTl9TVEFSVF9TVEFURV9TVFlMRVNfVkFSXSlcbiAgICAgICAgICBdKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIGFzdC5zdGF0ZVRyYW5zaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zQXN0KSB7IHJldHVybiBzdGF0ZW1lbnRzLnB1c2godHJhbnNBc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpKTsgfSk7XG4gICAgICAgICAgLy8gdGhpcyBjaGVjayBlbnN1cmVzIHRoYXQgdGhlIGFuaW1hdGlvbiBmYWN0b3J5IGFsd2F5cyByZXR1cm5zIGEgcGxheWVyXG4gICAgICAgICAgLy8gc28gdGhhdCB0aGUgb25Eb25lIGNhbGxiYWNrIGNhbiBiZSB1c2VkIGZvciB0cmFja2luZ1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgSWZTdG10KF9BTklNQVRJT05fUExBWUVSX1ZBUi5lcXVhbHMoTlVMTF9FWFBSKSwgW19BTklNQVRJT05fUExBWUVSX1ZBUlxuICAgICAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLk5vT3BBbmltYXRpb25QbGF5ZXIpKS5pbnN0YW50aWF0ZShbXSkpXG4gICAgICAgICAgICAgICAgICAudG9TdG10KCldKSk7XG4gICAgICAgICAgLy8gb25jZSBjb21wbGV0ZSB3ZSB3YW50IHRvIGFwcGx5IHRoZSBzdHlsZXMgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAvLyBzaW5jZSB0aGUgZGVzdGluYXRpb24gc3RhdGUncyB2YWx1ZXMgc2hvdWxkIHBlcnNpc3Qgb25jZVxuICAgICAgICAgIC8vIHRoZSBhbmltYXRpb24gc2VxdWVuY2UgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9QTEFZRVJfVkFSXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdvbkRvbmUnLCBbZm4oW10sIFtSRU5ERVJfU1RZTEVTX0ZOXG4gICAgICAgICAgICAgICAgICAgICAgLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgICAgX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSLCBfQU5JTUFUSU9OX0ZBQ1RPUllfUkVOREVSRVJfVkFSLFxuICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9BTklNQVRJT05fU1RBUlRfU1RBVEVfU1RZTEVTX1ZBUiwgX0FOSU1BVElPTl9FTkRfU1RBVEVfU1RZTEVTX1ZBUlxuICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKV0pXSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfVkFSXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdxdWV1ZUFuaW1hdGlvbicsIFtcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9GQUNUT1JZX0VMRU1FTlRfVkFSLCBsaXRlcmFsKHRoaXMuYW5pbWF0aW9uTmFtZSksXG4gICAgICAgICAgICAgIF9BTklNQVRJT05fUExBWUVSX1ZBUiwgX0FOSU1BVElPTl9USU1FX1ZBUixcbiAgICAgICAgICAgICAgX0FOSU1BVElPTl9DVVJSRU5UX1NUQVRFX1ZBUiwgX0FOSU1BVElPTl9ORVhUX1NUQVRFX1ZBUlxuICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgcmV0dXJuIGZuKFtcbiAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oX0FOSU1BVElPTl9GQUNUT1JZX1ZJRVdfVkFSLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtEWU5BTUlDX1RZUEVdKSksXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKF9BTklNQVRJT05fRkFDVE9SWV9FTEVNRU5UX1ZBUi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgICAgICBuZXcgRm5QYXJhbShfQU5JTUFUSU9OX0NVUlJFTlRfU1RBVEVfVkFSLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKF9BTklNQVRJT05fTkVYVF9TVEFURV9WQVIubmFtZSwgRFlOQU1JQ19UWVBFKVxuICAgICAgICAgIF0sIHN0YXRlbWVudHMpO1xuICAgICAgfTtcbiAgICAgIF9BbmltYXRpb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBfQW5pbWF0aW9uQnVpbGRlckNvbnRleHQoKTtcbiAgICAgICAgICB2YXIgZm5TdGF0ZW1lbnQgPSBhc3QudmlzaXQodGhpcywgY29udGV4dCkudG9EZWNsU3RtdCh0aGlzLl9mblZhck5hbWUpO1xuICAgICAgICAgIHZhciBmblZhcmlhYmxlID0gdmFyaWFibGUodGhpcy5fZm5WYXJOYW1lKTtcbiAgICAgICAgICB2YXIgbG9va3VwTWFwID0gW107XG4gICAgICAgICAgT2JqZWN0LmtleXMoY29udGV4dC5zdGF0ZU1hcC5zdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250ZXh0LnN0YXRlTWFwLnN0YXRlc1tzdGF0ZU5hbWVdO1xuICAgICAgICAgICAgICB2YXIgdmFyaWFibGVWYWx1ZSA9IEVNUFRZX01BUCQxO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlTWFwXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgc3R5bGVNYXBfMS5wdXNoKFtrZXksIGxpdGVyYWwodmFsdWVba2V5XSldKTsgfSk7XG4gICAgICAgICAgICAgICAgICB2YXJpYWJsZVZhbHVlID0gbGl0ZXJhbE1hcChzdHlsZU1hcF8xKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsb29rdXBNYXAucHVzaChbc3RhdGVOYW1lLCB2YXJpYWJsZVZhbHVlXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkU3RhdGVzTWFwU3RtdCA9IHRoaXMuX3N0YXRlc01hcFZhci5zZXQobGl0ZXJhbE1hcChsb29rdXBNYXApKS50b0RlY2xTdG10KCk7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbY29tcGlsZWRTdGF0ZXNNYXBTdG10LCBmblN0YXRlbWVudF07XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25FbnRyeUNvbXBpbGVSZXN1bHQodGhpcy5hbmltYXRpb25OYW1lLCBzdGF0ZW1lbnRzLCBmblZhcmlhYmxlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0FuaW1hdGlvbkJ1aWxkZXI7XG4gIH0oKSk7XG4gIHZhciBfQW5pbWF0aW9uQnVpbGRlckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0FuaW1hdGlvbkJ1aWxkZXJDb250ZXh0KCkge1xuICAgICAgICAgIHRoaXMuc3RhdGVNYXAgPSBuZXcgX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcCgpO1xuICAgICAgICAgIHRoaXMuZW5kU3RhdGVBbmltYXRlU3RlcCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5pc0V4cGVjdGluZ0ZpcnN0U3R5bGVTdGVwID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50b3RhbFRyYW5zaXRpb25UaW1lID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfQW5pbWF0aW9uQnVpbGRlckNvbnRleHQ7XG4gIH0oKSk7XG4gIHZhciBfQW5pbWF0aW9uQnVpbGRlclN0YXRlTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9BbmltYXRpb25CdWlsZGVyU3RhdGVNYXAoKSB7XG4gICAgICAgICAgdGhpcy5fc3RhdGVzID0ge307XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcC5wcm90b3R5cGUsIFwic3RhdGVzXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXRlczsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBfQW5pbWF0aW9uQnVpbGRlclN0YXRlTWFwLnByb3RvdHlwZS5yZWdpc3RlclN0YXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBudWxsOyB9XG4gICAgICAgICAgdmFyIGV4aXN0aW5nRW50cnkgPSB0aGlzLl9zdGF0ZXNbbmFtZV07XG4gICAgICAgICAgaWYgKCFleGlzdGluZ0VudHJ5KSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0YXRlc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX0FuaW1hdGlvbkJ1aWxkZXJTdGF0ZU1hcDtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gX2NvbXBhcmVUb0FuaW1hdGlvblN0YXRlRXhwcih2YWx1ZSwgYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgIHZhciBlbXB0eVN0YXRlTGl0ZXJhbCA9IGxpdGVyYWwoRU1QVFlfQU5JTUFUSU9OX1NUQVRFKTtcbiAgICAgIHN3aXRjaCAoYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgICBjYXNlIEVNUFRZX0FOSU1BVElPTl9TVEFURTpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmVxdWFscyhlbXB0eVN0YXRlTGl0ZXJhbCk7XG4gICAgICAgICAgY2FzZSBBTllfU1RBVEU6XG4gICAgICAgICAgICAgIHJldHVybiBsaXRlcmFsKHRydWUpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5lcXVhbHMobGl0ZXJhbChhbmltYXRpb25TdGF0ZSkpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9pc0VuZFN0YXRlQW5pbWF0ZVN0ZXAoc3RlcCkge1xuICAgICAgLy8gdGhlIGZpbmFsIGFuaW1hdGlvbiBzdGVwIGlzIGNoYXJhY3Rlcml6ZWQgYnkgaGF2aW5nIG9ubHkgVFdPXG4gICAgICAvLyBrZXlmcmFtZSB2YWx1ZXMgYW5kIGl0IG11c3QgaGF2ZSB6ZXJvIHN0eWxlcyBmb3IgYm90aCBrZXlmcmFtZXNcbiAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgQW5pbWF0aW9uU3RlcEFzdCAmJiBzdGVwLmR1cmF0aW9uID4gMCAmJiBzdGVwLmtleWZyYW1lcy5sZW5ndGggPT0gMikge1xuICAgICAgICAgIHZhciBzdHlsZXMxID0gX2dldFN0eWxlc0FycmF5KHN0ZXAua2V5ZnJhbWVzWzBdKVswXTtcbiAgICAgICAgICB2YXIgc3R5bGVzMiA9IF9nZXRTdHlsZXNBcnJheShzdGVwLmtleWZyYW1lc1sxXSlbMF07XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlczEpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhzdHlsZXMyKS5sZW5ndGggPT09IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gX2dldFN0eWxlc0FycmF5KG9iaikge1xuICAgICAgcmV0dXJuIG9iai5zdHlsZXMuc3R5bGVzO1xuICB9XG5cbiAgdmFyIE1hdGgkMSA9IGdsb2JhbCQxLk1hdGg7XG5cbiAgdmFyIFN0eWxlc0NvbGxlY3Rpb25FbnRyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZXNDb2xsZWN0aW9uRW50cnkodGltZSwgdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIFN0eWxlc0NvbGxlY3Rpb25FbnRyeS5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uICh0aW1lLCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0aW1lID09IHRoaXMudGltZSAmJiB2YWx1ZSA9PSB0aGlzLnZhbHVlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTdHlsZXNDb2xsZWN0aW9uRW50cnk7XG4gIH0oKSk7XG4gIHZhciBTdHlsZXNDb2xsZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0eWxlc0NvbGxlY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIFN0eWxlc0NvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydEF0VGltZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdGltZSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgdHVwbGUgPSBuZXcgU3R5bGVzQ29sbGVjdGlvbkVudHJ5KHRpbWUsIHZhbHVlKTtcbiAgICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuc3R5bGVzW3Byb3BlcnR5XTtcbiAgICAgICAgICBpZiAoIWlzUHJlc2VudChlbnRyaWVzKSkge1xuICAgICAgICAgICAgICBlbnRyaWVzID0gdGhpcy5zdHlsZXNbcHJvcGVydHldID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGluc2VydCB0aGlzIGF0IHRoZSByaWdodCBzdG9wIGluIHRoZSBhcnJheVxuICAgICAgICAgIC8vIHRoaXMgd2F5IHdlIGNhbiBrZWVwIGl0IHNvcnRlZFxuICAgICAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgaWYgKGVudHJpZXNbaV0udGltZSA8PSB0aW1lKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnRpb25JbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0KGVudHJpZXMsIGluc2VydGlvbkluZGV4LCB0dXBsZSk7XG4gICAgICB9O1xuICAgICAgU3R5bGVzQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QnlJbmRleCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLnN0eWxlc1twcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChpdGVtcykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49IGl0ZW1zLmxlbmd0aCA/IG51bGwgOiBpdGVtc1tpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFN0eWxlc0NvbGxlY3Rpb24ucHJvdG90eXBlLmluZGV4T2ZBdE9yQmVmb3JlVGltZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdGltZSkge1xuICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5zdHlsZXNbcHJvcGVydHldO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZW50cmllcykpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzW2ldLnRpbWUgPD0gdGltZSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU3R5bGVzQ29sbGVjdGlvbjtcbiAgfSgpKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBfSU5JVElBTF9LRVlGUkFNRSA9IDA7XG4gIHZhciBfVEVSTUlOQUxfS0VZRlJBTUUgPSAxO1xuICB2YXIgX09ORV9TRUNPTkQgPSAxMDAwO1xuICB2YXIgQW5pbWF0aW9uUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblBhcnNlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgQW5pbWF0aW9uUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlwiICsgdGhpcy5tc2c7IH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uUGFyc2VFcnJvcjtcbiAgfShQYXJzZUVycm9yKSk7XG4gIHZhciBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkVudHJ5UGFyc2VSZXN1bHQoYXN0LCBlcnJvcnMpIHtcbiAgICAgICAgICB0aGlzLmFzdCA9IGFzdDtcbiAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgIH1cbiAgICAgIHJldHVybiBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0O1xuICB9KCkpO1xuICB2YXIgQW5pbWF0aW9uUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblBhcnNlcigpIHtcbiAgICAgIH1cbiAgICAgIEFuaW1hdGlvblBhcnNlci5wcm90b3R5cGUucGFyc2VDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQudHlwZS5uYW1lO1xuICAgICAgICAgIHZhciBhbmltYXRpb25UcmlnZ2VyTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdmFyIGFzdHMgPSBjb21wb25lbnQudGVtcGxhdGUuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5wYXJzZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgdmFyIGFzdCA9IHJlc3VsdC5hc3Q7XG4gICAgICAgICAgICAgIHZhciB0cmlnZ2VyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uVHJpZ2dlck5hbWVzLmhhcyh0cmlnZ2VyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIlRoZSBhbmltYXRpb24gdHJpZ2dlciBcXFwiXCIgKyB0cmlnZ2VyTmFtZSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoZSBcIiArIGNvbXBvbmVudE5hbWUgKyBcIiBjb21wb25lbnRcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uVHJpZ2dlck5hbWVzLmFkZCh0cmlnZ2VyTmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZV8xID0gXCItIFVuYWJsZSB0byBwYXJzZSB0aGUgYW5pbWF0aW9uIHNlcXVlbmNlIGZvciBcXFwiXCIgKyB0cmlnZ2VyTmFtZSArIFwiXFxcIiBvbiB0aGUgXCIgKyBjb21wb25lbnROYW1lICsgXCIgY29tcG9uZW50IGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczpcIjtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHsgZXJyb3JNZXNzYWdlXzEgKz0gJ1xcbi0tICcgKyBlcnJvci5tc2c7IH0pO1xuICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3JNZXNzYWdlXzEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvclN0cmluZyA9IGVycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW5pbWF0aW9uIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFzdHM7XG4gICAgICB9O1xuICAgICAgQW5pbWF0aW9uUGFyc2VyLnByb3RvdHlwZS5wYXJzZUVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgIHZhciBzdGF0ZVN0eWxlcyA9IHt9O1xuICAgICAgICAgIHZhciB0cmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICAgIHZhciBzdGF0ZURlY2xhcmF0aW9uQXN0cyA9IFtdO1xuICAgICAgICAgIGVudHJ5LmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgICBpZiAoZGVmIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgX3BhcnNlQW5pbWF0aW9uRGVjbGFyYXRpb25TdGF0ZXMoZGVmLCBlcnJvcnMpLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlRGVjbGFyYXRpb25Bc3RzLnB1c2goYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZVN0eWxlc1thc3Quc3RhdGVOYW1lXSA9IGFzdC5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGF0ZVRyYW5zaXRpb25Bc3RzID0gdHJhbnNpdGlvbnMubWFwKGZ1bmN0aW9uICh0cmFuc0RlZikgeyByZXR1cm4gX3BhcnNlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uKHRyYW5zRGVmLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTsgfSk7XG4gICAgICAgICAgdmFyIGFzdCA9IG5ldyBBbmltYXRpb25FbnRyeUFzdChlbnRyeS5uYW1lLCBzdGF0ZURlY2xhcmF0aW9uQXN0cywgc3RhdGVUcmFuc2l0aW9uQXN0cyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25FbnRyeVBhcnNlUmVzdWx0KGFzdCwgZXJyb3JzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQW5pbWF0aW9uUGFyc2VyO1xuICB9KCkpO1xuICBmdW5jdGlvbiBfcGFyc2VBbmltYXRpb25EZWNsYXJhdGlvblN0YXRlcyhzdGF0ZU1ldGFkYXRhLCBlcnJvcnMpIHtcbiAgICAgIHZhciBzdHlsZVZhbHVlcyA9IFtdO1xuICAgICAgc3RhdGVNZXRhZGF0YS5zdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlc0VudHJ5KSB7XG4gICAgICAgICAgLy8gVE9ETyAobWF0c2tvKTogY2hhbmdlIHRoaXMgd2hlbiB3ZSBnZXQgQ1NTIGNsYXNzIGludGVncmF0aW9uIHN1cHBvcnRcbiAgICAgICAgICBpZiAoaXNTdHJpbmdNYXAoc3R5bGVzRW50cnkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlVmFsdWVzLnB1c2goc3R5bGVzRW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJTdGF0ZSBiYXNlZCBhbmltYXRpb25zIGNhbm5vdCBjb250YWluIHJlZmVyZW5jZXMgdG8gb3RoZXIgc3RhdGVzXCIpKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBkZWZTdHlsZXMgPSBuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KHN0eWxlVmFsdWVzKTtcbiAgICAgIHZhciBzdGF0ZXMgPSBzdGF0ZU1ldGFkYXRhLnN0YXRlTmFtZUV4cHIuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgcmV0dXJuIHN0YXRlcy5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBuZXcgQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbkFzdChzdGF0ZSwgZGVmU3R5bGVzKTsgfSk7XG4gIH1cbiAgZnVuY3Rpb24gX3BhcnNlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uKHRyYW5zaXRpb25TdGF0ZU1ldGFkYXRhLCBzdGF0ZVN0eWxlcywgZXJyb3JzKSB7XG4gICAgICB2YXIgc3R5bGVzID0gbmV3IFN0eWxlc0NvbGxlY3Rpb24oKTtcbiAgICAgIHZhciB0cmFuc2l0aW9uRXhwcnMgPSBbXTtcbiAgICAgIHZhciB0cmFuc2l0aW9uU3RhdGVzID0gdHJhbnNpdGlvblN0YXRlTWV0YWRhdGEuc3RhdGVDaGFuZ2VFeHByLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgIHRyYW5zaXRpb25TdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcikge1xuICAgICAgICAgIF9wYXJzZUFuaW1hdGlvblRyYW5zaXRpb25FeHByKGV4cHIsIGVycm9ycykuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNFeHByKSB7XG4gICAgICAgICAgICAgIHRyYW5zaXRpb25FeHBycy5wdXNoKHRyYW5zRXhwcik7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBlbnRyeSA9IF9ub3JtYWxpemVBbmltYXRpb25FbnRyeSh0cmFuc2l0aW9uU3RhdGVNZXRhZGF0YS5zdGVwcyk7XG4gICAgICB2YXIgYW5pbWF0aW9uID0gX25vcm1hbGl6ZVN0eWxlU3RlcHMoZW50cnksIHN0YXRlU3R5bGVzLCBlcnJvcnMpO1xuICAgICAgdmFyIGFuaW1hdGlvbkFzdCA9IF9wYXJzZVRyYW5zaXRpb25BbmltYXRpb24oYW5pbWF0aW9uLCAwLCBzdHlsZXMsIHN0YXRlU3R5bGVzLCBlcnJvcnMpO1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIF9maWxsQW5pbWF0aW9uQXN0U3RhcnRpbmdLZXlmcmFtZXMoYW5pbWF0aW9uQXN0LCBzdHlsZXMsIGVycm9ycyk7XG4gICAgICB9XG4gICAgICB2YXIgc3RlcHNBc3QgPSAoYW5pbWF0aW9uQXN0IGluc3RhbmNlb2YgQW5pbWF0aW9uV2l0aFN0ZXBzQXN0KSA/XG4gICAgICAgICAgYW5pbWF0aW9uQXN0IDpcbiAgICAgICAgICBuZXcgQW5pbWF0aW9uU2VxdWVuY2VBc3QoW2FuaW1hdGlvbkFzdF0pO1xuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25Bc3QodHJhbnNpdGlvbkV4cHJzLCBzdGVwc0FzdCk7XG4gIH1cbiAgZnVuY3Rpb24gX3BhcnNlQW5pbWF0aW9uVHJhbnNpdGlvbkV4cHIoZXZlbnRTdHIsIGVycm9ycykge1xuICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICB2YXIgbWF0Y2ggPSBldmVudFN0ci5tYXRjaCgvXihcXCp8Wy1cXHddKylcXHMqKDw/Wz0tXT4pXFxzKihcXCp8Wy1cXHddKykkLyk7XG4gICAgICBpZiAoIWlzUHJlc2VudChtYXRjaCkgfHwgbWF0Y2gubGVuZ3RoIDwgNCkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwidGhlIHByb3ZpZGVkIFwiICsgZXZlbnRTdHIgKyBcIiBpcyBub3Qgb2YgYSBzdXBwb3J0ZWQgZm9ybWF0XCIpKTtcbiAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG4gICAgICB9XG4gICAgICB2YXIgZnJvbVN0YXRlID0gbWF0Y2hbMV07XG4gICAgICB2YXIgc2VwYXJhdG9yID0gbWF0Y2hbMl07XG4gICAgICB2YXIgdG9TdGF0ZSA9IG1hdGNoWzNdO1xuICAgICAgZXhwcmVzc2lvbnMucHVzaChuZXcgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uRXhwcmVzc2lvbihmcm9tU3RhdGUsIHRvU3RhdGUpKTtcbiAgICAgIHZhciBpc0Z1bGxBbnlTdGF0ZUV4cHIgPSBmcm9tU3RhdGUgPT0gQU5ZX1NUQVRFICYmIHRvU3RhdGUgPT0gQU5ZX1NUQVRFO1xuICAgICAgaWYgKHNlcGFyYXRvclswXSA9PSAnPCcgJiYgIWlzRnVsbEFueVN0YXRlRXhwcikge1xuICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gobmV3IEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbkV4cHJlc3Npb24odG9TdGF0ZSwgZnJvbVN0YXRlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG4gIH1cbiAgZnVuY3Rpb24gX25vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KGVudHJ5KSB7XG4gICAgICByZXR1cm4gaXNBcnJheShlbnRyeSkgPyBuZXcgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoZW50cnkpIDpcbiAgICAgICAgICBlbnRyeTtcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplU3R5bGVNZXRhZGF0YShlbnRyeSwgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIG5vcm1hbGl6ZWRTdHlsZXMgPSBbXTtcbiAgICAgIGVudHJ5LnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZUVudHJ5KSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHN0eWxlRW50cnkpKSB7XG4gICAgICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbChub3JtYWxpemVkU3R5bGVzLCBfcmVzb2x2ZVN0eWxlc0Zyb21TdGF0ZShzdHlsZUVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBub3JtYWxpemVkU3R5bGVzLnB1c2goc3R5bGVFbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplZFN0eWxlcztcbiAgfVxuICBmdW5jdGlvbiBfbm9ybWFsaXplU3R5bGVTdGVwcyhlbnRyeSwgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHN0ZXBzID0gX25vcm1hbGl6ZVN0eWxlU3RlcEVudHJ5KGVudHJ5LCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgIHJldHVybiAoZW50cnkgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSkgP1xuICAgICAgICAgIG5ldyBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShzdGVwcykgOlxuICAgICAgICAgIG5ldyBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShzdGVwcyk7XG4gIH1cbiAgZnVuY3Rpb24gX21lcmdlQW5pbWF0aW9uU3R5bGVzKHN0eWxlc0xpc3QsIG5ld0l0ZW0pIHtcbiAgICAgIGlmIChpc1N0cmluZ01hcChuZXdJdGVtKSAmJiBzdHlsZXNMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gc3R5bGVzTGlzdC5sZW5ndGggLSAxO1xuICAgICAgICAgIHZhciBsYXN0SXRlbSA9IHN0eWxlc0xpc3RbbGFzdEluZGV4XTtcbiAgICAgICAgICBpZiAoaXNTdHJpbmdNYXAobGFzdEl0ZW0pKSB7XG4gICAgICAgICAgICAgIHN0eWxlc0xpc3RbbGFzdEluZGV4XSA9IFN0cmluZ01hcFdyYXBwZXIubWVyZ2UobGFzdEl0ZW0sIG5ld0l0ZW0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3R5bGVzTGlzdC5wdXNoKG5ld0l0ZW0pO1xuICB9XG4gIGZ1bmN0aW9uIF9ub3JtYWxpemVTdHlsZVN0ZXBFbnRyeShlbnRyeSwgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHN0ZXBzO1xuICAgICAgaWYgKGVudHJ5IGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSB7XG4gICAgICAgICAgc3RlcHMgPSBlbnRyeS5zdGVwcztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbZW50cnldO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1N0ZXBzID0gW107XG4gICAgICB2YXIgY29tYmluZWRTdHlsZXM7XG4gICAgICBzdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgaWYgKHN0ZXAgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAvLyB0aGlzIG9jY3VycyB3aGVuIGEgc3R5bGUgc3RlcCBpcyBmb2xsb3dlZCBieSBhIHByZXZpb3VzIHN0eWxlIHN0ZXBcbiAgICAgICAgICAgICAgLy8gb3Igd2hlbiB0aGUgZmlyc3Qgc3R5bGUgc3RlcCBpcyBydW4uIFdlIHdhbnQgdG8gY29uY2F0ZW5hdGUgYWxsIHN1YnNlcXVlbnRcbiAgICAgICAgICAgICAgLy8gc3R5bGUgc3RlcHMgdG9nZXRoZXIgaW50byBhIHNpbmdsZSBzdHlsZSBzdGVwIHN1Y2ggdGhhdCB3ZSBoYXZlIHRoZSBjb3JyZWN0XG4gICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIGtleWZyYW1lIGRhdGEgdG8gcGFzcyBpbnRvIHRoZSBhbmltYXRpb24gcGxheWVyLlxuICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudChjb21iaW5lZFN0eWxlcykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbWJpbmVkU3R5bGVzID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX25vcm1hbGl6ZVN0eWxlTWV0YWRhdGEoc3RlcCwgc3RhdGVTdHlsZXMsIGVycm9ycylcbiAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyBfbWVyZ2VBbmltYXRpb25TdHlsZXMoY29tYmluZWRTdHlsZXMsIGVudHJ5KTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpdCBpcyBpbXBvcnRhbnQgdGhhdCB3ZSBjcmVhdGUgYSBtZXRhZGF0YSBlbnRyeSBvZiB0aGUgY29tYmluZWQgc3R5bGVzXG4gICAgICAgICAgICAgIC8vIGJlZm9yZSB3ZSBnbyBvbiBhbiBwcm9jZXNzIHRoZSBhbmltYXRlLCBzZXF1ZW5jZSBvciBncm91cCBtZXRhZGF0YSBzdGVwcy5cbiAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBBU1Qgd2lsbCBoYXZlIHRoZSBwcmV2aW91cyBzdHlsZXMgcGFpbnRlZCBvblxuICAgICAgICAgICAgICAvLyBzY3JlZW4gYmVmb3JlIGFueSBmdXJ0aGVyIGFuaW1hdGlvbnMgdGhhdCB1c2UgdGhlIHN0eWxlcyB0YWtlIHBsYWNlLlxuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbWJpbmVkU3R5bGVzKSkge1xuICAgICAgICAgICAgICAgICAgbmV3U3RlcHMucHVzaChuZXcgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEoMCwgY29tYmluZWRTdHlsZXMpKTtcbiAgICAgICAgICAgICAgICAgIGNvbWJpbmVkU3R5bGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc3RlcCBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGRvIG5vdCByZWN1cnNlIGludG8gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSBzaW5jZVxuICAgICAgICAgICAgICAgICAgLy8gdGhvc2Ugc3R5bGUgc3RlcHMgYXJlIG5vdCBnb2luZyB0byBiZSBzcXVhc2hlZFxuICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGVTdHlsZVZhbHVlID0gc3RlcC5zdHlsZXM7XG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0ZVN0eWxlVmFsdWUgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVTdHlsZVZhbHVlLnN0eWxlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9ub3JtYWxpemVTdHlsZU1ldGFkYXRhKGFuaW1hdGVTdHlsZVZhbHVlLCBzdGF0ZVN0eWxlcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFuaW1hdGVTdHlsZVZhbHVlIGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlU3R5bGVWYWx1ZS5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwKSB7IHN0ZXAuc3R5bGVzID0gX25vcm1hbGl6ZVN0eWxlTWV0YWRhdGEoc3RlcCwgc3RhdGVTdHlsZXMsIGVycm9ycyk7IH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHN0ZXAgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpbm5lclN0ZXBzID0gX25vcm1hbGl6ZVN0eWxlU3RlcEVudHJ5KHN0ZXAsIHN0YXRlU3R5bGVzLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgc3RlcCA9IHN0ZXAgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSA/XG4gICAgICAgICAgICAgICAgICAgICAgbmV3IENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhKGlubmVyU3RlcHMpIDpcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEoaW5uZXJTdGVwcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV3U3RlcHMucHVzaChzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIHRoaXMgaGFwcGVucyB3aGVuIG9ubHkgc3R5bGVzIHdlcmUgYW5pbWF0ZWQgd2l0aGluIHRoZSBzZXF1ZW5jZVxuICAgICAgaWYgKGlzUHJlc2VudChjb21iaW5lZFN0eWxlcykpIHtcbiAgICAgICAgICBuZXdTdGVwcy5wdXNoKG5ldyBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSgwLCBjb21iaW5lZFN0eWxlcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1N0ZXBzO1xuICB9XG4gIGZ1bmN0aW9uIF9yZXNvbHZlU3R5bGVzRnJvbVN0YXRlKHN0YXRlTmFtZSwgc3RhdGVTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgaWYgKHN0YXRlTmFtZVswXSAhPSAnOicpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIkFuaW1hdGlvbiBzdGF0ZXMgdmlhIHN0eWxlcyBtdXN0IGJlIHByZWZpeGVkIHdpdGggYSBcXFwiOlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZWRTdGF0ZU5hbWUgPSBzdGF0ZU5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHN0YXRlU3R5bGVzW25vcm1hbGl6ZWRTdGF0ZU5hbWVdO1xuICAgICAgICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIlVuYWJsZSB0byBhcHBseSBzdHlsZXMgZHVlIHRvIG1pc3NpbmcgYSBzdGF0ZTogXFxcIlwiICsgbm9ybWFsaXplZFN0YXRlTmFtZSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZS5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZ01hcChzdHlsZXNFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChzdHlsZXNFbnRyeSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gIH1cbiAgdmFyIF9BbmltYXRpb25UaW1pbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF9BbmltYXRpb25UaW1pbmdzKGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgICB0aGlzLmVhc2luZyA9IGVhc2luZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBfQW5pbWF0aW9uVGltaW5ncztcbiAgfSgpKTtcbiAgZnVuY3Rpb24gX3BhcnNlQW5pbWF0aW9uS2V5ZnJhbWVzKGtleWZyYW1lU2VxdWVuY2UsIGN1cnJlbnRUaW1lLCBjb2xsZWN0ZWRTdHlsZXMsIHN0YXRlU3R5bGVzLCBlcnJvcnMpIHtcbiAgICAgIHZhciB0b3RhbEVudHJpZXMgPSBrZXlmcmFtZVNlcXVlbmNlLnN0ZXBzLmxlbmd0aDtcbiAgICAgIHZhciB0b3RhbE9mZnNldHMgPSAwO1xuICAgICAga2V5ZnJhbWVTZXF1ZW5jZS5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwKSB7IHJldHVybiB0b3RhbE9mZnNldHMgKz0gKGlzUHJlc2VudChzdGVwLm9mZnNldCkgPyAxIDogMCk7IH0pO1xuICAgICAgaWYgKHRvdGFsT2Zmc2V0cyA+IDAgJiYgdG90YWxPZmZzZXRzIDwgdG90YWxFbnRyaWVzKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IEFuaW1hdGlvblBhcnNlRXJyb3IoXCJOb3QgYWxsIHN0eWxlKCkgZW50cmllcyBjb250YWluIGFuIG9mZnNldCBmb3IgdGhlIHByb3ZpZGVkIGtleWZyYW1lKClcIikpO1xuICAgICAgICAgIHRvdGFsT2Zmc2V0cyA9IHRvdGFsRW50cmllcztcbiAgICAgIH1cbiAgICAgIHZhciBsaW1pdCA9IHRvdGFsRW50cmllcyAtIDE7XG4gICAgICB2YXIgbWFyZ2luID0gdG90YWxPZmZzZXRzID09IDAgPyAoMSAvIGxpbWl0KSA6IDA7XG4gICAgICB2YXIgcmF3S2V5ZnJhbWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIGRvU29ydEtleWZyYW1lcyA9IGZhbHNlO1xuICAgICAgdmFyIGxhc3RPZmZzZXQgPSAwO1xuICAgICAga2V5ZnJhbWVTZXF1ZW5jZS5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHN0eWxlTWV0YWRhdGEub2Zmc2V0O1xuICAgICAgICAgIHZhciBrZXlmcmFtZVN0eWxlcyA9IHt9O1xuICAgICAgICAgIHN0eWxlTWV0YWRhdGEuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvcCAhPSAnb2Zmc2V0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGtleWZyYW1lU3R5bGVzW3Byb3BdID0gZW50cnlbcHJvcF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQob2Zmc2V0KSkge1xuICAgICAgICAgICAgICBkb1NvcnRLZXlmcmFtZXMgPSBkb1NvcnRLZXlmcmFtZXMgfHwgKG9mZnNldCA8IGxhc3RPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gaW5kZXggPT0gbGltaXQgPyBfVEVSTUlOQUxfS0VZRlJBTUUgOiAobWFyZ2luICogaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByYXdLZXlmcmFtZXMucHVzaChbb2Zmc2V0LCBrZXlmcmFtZVN0eWxlc10pO1xuICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgIH0pO1xuICAgICAgaWYgKGRvU29ydEtleWZyYW1lcykge1xuICAgICAgICAgIExpc3RXcmFwcGVyLnNvcnQocmF3S2V5ZnJhbWVzLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSA8PSBiWzBdID8gLTEgOiAxOyB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGZpcnN0S2V5ZnJhbWUgPSByYXdLZXlmcmFtZXNbMF07XG4gICAgICBpZiAoZmlyc3RLZXlmcmFtZVswXSAhPSBfSU5JVElBTF9LRVlGUkFNRSkge1xuICAgICAgICAgIExpc3RXcmFwcGVyLmluc2VydChyYXdLZXlmcmFtZXMsIDAsIGZpcnN0S2V5ZnJhbWUgPSBbX0lOSVRJQUxfS0VZRlJBTUUsIHt9XSk7XG4gICAgICB9XG4gICAgICB2YXIgZmlyc3RLZXlmcmFtZVN0eWxlcyA9IGZpcnN0S2V5ZnJhbWVbMV07XG4gICAgICBsaW1pdCA9IHJhd0tleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3RLZXlmcmFtZSA9IHJhd0tleWZyYW1lc1tsaW1pdF07XG4gICAgICBpZiAobGFzdEtleWZyYW1lWzBdICE9IF9URVJNSU5BTF9LRVlGUkFNRSkge1xuICAgICAgICAgIHJhd0tleWZyYW1lcy5wdXNoKGxhc3RLZXlmcmFtZSA9IFtfVEVSTUlOQUxfS0VZRlJBTUUsIHt9XSk7XG4gICAgICAgICAgbGltaXQrKztcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0S2V5ZnJhbWVTdHlsZXMgPSBsYXN0S2V5ZnJhbWVbMV07XG4gICAgICBmb3IgKGkgPSAxOyBpIDw9IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSByYXdLZXlmcmFtZXNbaV07XG4gICAgICAgICAgdmFyIHN0eWxlcyA9IGVudHJ5WzFdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudChmaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgZmlyc3RLZXlmcmFtZVN0eWxlc1twcm9wXSA9IEZJTExfU1RZTEVfRkxBRztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSByYXdLZXlmcmFtZXNbaV07XG4gICAgICAgICAgdmFyIHN0eWxlcyA9IGVudHJ5WzFdO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudChsYXN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICBsYXN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSBzdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBmb3IgKGkgPSBsaW1pdCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgX2xvb3BfMSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhd0tleWZyYW1lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBuZXcgQW5pbWF0aW9uS2V5ZnJhbWVBc3QoZW50cnlbMF0sIG5ldyBBbmltYXRpb25TdHlsZXNBc3QoW2VudHJ5WzFdXSkpOyB9KTtcbiAgfVxuICBmdW5jdGlvbiBfcGFyc2VUcmFuc2l0aW9uQW5pbWF0aW9uKGVudHJ5LCBjdXJyZW50VGltZSwgY29sbGVjdGVkU3R5bGVzLCBzdGF0ZVN0eWxlcywgZXJyb3JzKSB7XG4gICAgICB2YXIgYXN0O1xuICAgICAgdmFyIHBsYXlUaW1lID0gMDtcbiAgICAgIHZhciBzdGFydGluZ1RpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkge1xuICAgICAgICAgIHZhciBtYXhEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgdmFyIHN0ZXBzID0gW107XG4gICAgICAgICAgdmFyIGlzR3JvdXAgPSBlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICAgICAgICAgIHZhciBwcmV2aW91c1N0eWxlcztcbiAgICAgICAgICBlbnRyeS5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICAvLyB0aGVzZSB3aWxsIGdldCBwaWNrZWQgdXAgYnkgdGhlIG5leHQgc3RlcC4uLlxuICAgICAgICAgICAgICB2YXIgdGltZSA9IGlzR3JvdXAgPyBzdGFydGluZ1RpbWUgOiBjdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5IGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGVudHJ5LnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZXNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHRoaXMgcG9pbnQgd2Uga25vdyB0aGF0IHdlIG9ubHkgaGF2ZSBzdHJpbmdtYXAgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IHN0eWxlc0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyBjb2xsZWN0ZWRTdHlsZXMuaW5zZXJ0QXRUaW1lKHByb3AsIHRpbWUsIG1hcFtwcm9wXSk7IH0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBwcmV2aW91c1N0eWxlcyA9IGVudHJ5LnN0eWxlcztcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaW5uZXJBc3QgPSBfcGFyc2VUcmFuc2l0aW9uQW5pbWF0aW9uKGVudHJ5LCB0aW1lLCBjb2xsZWN0ZWRTdHlsZXMsIHN0YXRlU3R5bGVzLCBlcnJvcnMpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByZXZpb3VzU3R5bGVzKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5IGluc3RhbmNlb2YgQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0aW5nU3R5bGVzID0gbmV3IEFuaW1hdGlvblN0eWxlc0FzdChwcmV2aW91c1N0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcHMucHVzaChuZXcgQW5pbWF0aW9uU3RlcEFzdChzdGFydGluZ1N0eWxlcywgW10sIDAsIDAsICcnKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJTdGVwID0gaW5uZXJBc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsKGlubmVyU3RlcC5zdGFydGluZ1N0eWxlcy5zdHlsZXMsIHByZXZpb3VzU3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHByZXZpb3VzU3R5bGVzID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgYXN0RHVyYXRpb24gPSBpbm5lckFzdC5wbGF5VGltZTtcbiAgICAgICAgICAgICAgY3VycmVudFRpbWUgKz0gYXN0RHVyYXRpb247XG4gICAgICAgICAgICAgIHBsYXlUaW1lICs9IGFzdER1cmF0aW9uO1xuICAgICAgICAgICAgICBtYXhEdXJhdGlvbiA9IE1hdGgkMS5tYXgoYXN0RHVyYXRpb24sIG1heER1cmF0aW9uKTtcbiAgICAgICAgICAgICAgc3RlcHMucHVzaChpbm5lckFzdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChwcmV2aW91c1N0eWxlcykpIHtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0aW5nU3R5bGVzID0gbmV3IEFuaW1hdGlvblN0eWxlc0FzdChwcmV2aW91c1N0eWxlcyk7XG4gICAgICAgICAgICAgIHN0ZXBzLnB1c2gobmV3IEFuaW1hdGlvblN0ZXBBc3Qoc3RhcnRpbmdTdHlsZXMsIFtdLCAwLCAwLCAnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgICBhc3QgPSBuZXcgQW5pbWF0aW9uR3JvdXBBc3Qoc3RlcHMpO1xuICAgICAgICAgICAgICBwbGF5VGltZSA9IG1heER1cmF0aW9uO1xuICAgICAgICAgICAgICBjdXJyZW50VGltZSA9IHN0YXJ0aW5nVGltZSArIHBsYXlUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYXN0ID0gbmV3IEFuaW1hdGlvblNlcXVlbmNlQXN0KHN0ZXBzKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbnRyeSBpbnN0YW5jZW9mIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICB2YXIgdGltaW5ncyA9IF9wYXJzZVRpbWVFeHByZXNzaW9uKGVudHJ5LnRpbWluZ3MsIGVycm9ycyk7XG4gICAgICAgICAgdmFyIHN0eWxlcyA9IGVudHJ5LnN0eWxlcztcbiAgICAgICAgICB2YXIga2V5ZnJhbWVzO1xuICAgICAgICAgIGlmIChzdHlsZXMgaW5zdGFuY2VvZiBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSkge1xuICAgICAgICAgICAgICBrZXlmcmFtZXMgPVxuICAgICAgICAgICAgICAgICAgX3BhcnNlQW5pbWF0aW9uS2V5ZnJhbWVzKHN0eWxlcywgY3VycmVudFRpbWUsIGNvbGxlY3RlZFN0eWxlcywgc3RhdGVTdHlsZXMsIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc3R5bGVEYXRhID0gc3R5bGVzO1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX1RFUk1JTkFMX0tFWUZSQU1FO1xuICAgICAgICAgICAgICB2YXIgc3R5bGVBc3QgPSBuZXcgQW5pbWF0aW9uU3R5bGVzQXN0KHN0eWxlRGF0YS5zdHlsZXMpO1xuICAgICAgICAgICAgICB2YXIga2V5ZnJhbWUgPSBuZXcgQW5pbWF0aW9uS2V5ZnJhbWVBc3Qob2Zmc2V0LCBzdHlsZUFzdCk7XG4gICAgICAgICAgICAgIGtleWZyYW1lcyA9IFtrZXlmcmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzdCA9IG5ldyBBbmltYXRpb25TdGVwQXN0KG5ldyBBbmltYXRpb25TdHlsZXNBc3QoW10pLCBrZXlmcmFtZXMsIHRpbWluZ3MuZHVyYXRpb24sIHRpbWluZ3MuZGVsYXksIHRpbWluZ3MuZWFzaW5nKTtcbiAgICAgICAgICBwbGF5VGltZSA9IHRpbWluZ3MuZHVyYXRpb24gKyB0aW1pbmdzLmRlbGF5O1xuICAgICAgICAgIGN1cnJlbnRUaW1lICs9IHBsYXlUaW1lO1xuICAgICAgICAgIGtleWZyYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlmcmFtZSAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4ga2V5ZnJhbWUuc3R5bGVzLnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gT2JqZWN0LmtleXMoZW50cnkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgY29sbGVjdGVkU3R5bGVzLmluc2VydEF0VGltZShwcm9wLCBjdXJyZW50VGltZSwgZW50cnlbcHJvcF0pOyB9KTsgfSk7IH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGNvZGUgcmVhY2hlcyB0aGlzIHN0YWdlIHRoZW4gYW4gZXJyb3JcbiAgICAgICAgICAvLyBoYXMgYWxyZWFkeSBiZWVuIHBvcHVsYXRlZCB3aXRoaW4gdGhlIF9ub3JtYWxpemVTdHlsZVN0ZXBzKClcbiAgICAgICAgICAvLyBvcGVyYXRpb24uLi5cbiAgICAgICAgICBhc3QgPSBuZXcgQW5pbWF0aW9uU3RlcEFzdChudWxsLCBbXSwgMCwgMCwgJycpO1xuICAgICAgfVxuICAgICAgYXN0LnBsYXlUaW1lID0gcGxheVRpbWU7XG4gICAgICBhc3Quc3RhcnRUaW1lID0gc3RhcnRpbmdUaW1lO1xuICAgICAgcmV0dXJuIGFzdDtcbiAgfVxuICBmdW5jdGlvbiBfZmlsbEFuaW1hdGlvbkFzdFN0YXJ0aW5nS2V5ZnJhbWVzKGFzdCwgY29sbGVjdGVkU3R5bGVzLCBlcnJvcnMpIHtcbiAgICAgIC8vIHN0ZXBzIHRoYXQgb25seSBjb250YWluIHN0eWxlIHdpbGwgbm90IGJlIGZpbGxlZFxuICAgICAgaWYgKChhc3QgaW5zdGFuY2VvZiBBbmltYXRpb25TdGVwQXN0KSAmJiBhc3Qua2V5ZnJhbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIga2V5ZnJhbWVzID0gYXN0LmtleWZyYW1lcztcbiAgICAgICAgICBpZiAoa2V5ZnJhbWVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgIHZhciBlbmRLZXlmcmFtZSA9IGtleWZyYW1lc1swXTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0S2V5ZnJhbWUgPSBfY3JlYXRlU3RhcnRLZXlmcmFtZUZyb21FbmRLZXlmcmFtZShlbmRLZXlmcmFtZSwgYXN0LnN0YXJ0VGltZSwgYXN0LnBsYXlUaW1lLCBjb2xsZWN0ZWRTdHlsZXMsIGVycm9ycyk7XG4gICAgICAgICAgICAgIGFzdC5rZXlmcmFtZXMgPSBbc3RhcnRLZXlmcmFtZSwgZW5kS2V5ZnJhbWVdO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIEFuaW1hdGlvbldpdGhTdGVwc0FzdCkge1xuICAgICAgICAgIGFzdC5zdGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gX2ZpbGxBbmltYXRpb25Bc3RTdGFydGluZ0tleWZyYW1lcyhlbnRyeSwgY29sbGVjdGVkU3R5bGVzLCBlcnJvcnMpOyB9KTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfcGFyc2VUaW1lRXhwcmVzc2lvbihleHAsIGVycm9ycykge1xuICAgICAgdmFyIHJlZ2V4ID0gL14oW1xcLlxcZF0rKShtP3MpKD86XFxzKyhbXFwuXFxkXSspKG0/cykpPyg/OlxccysoWy1hLXpdKyg/OlxcKC4rP1xcKSk/KSk/L2k7XG4gICAgICB2YXIgZHVyYXRpb247XG4gICAgICB2YXIgZGVsYXkgPSAwO1xuICAgICAgdmFyIGVhc2luZyA9IG51bGw7XG4gICAgICBpZiAoaXNTdHJpbmcoZXhwKSkge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gZXhwLm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgQW5pbWF0aW9uUGFyc2VFcnJvcihcIlRoZSBwcm92aWRlZCB0aW1pbmcgdmFsdWUgXFxcIlwiICsgZXhwICsgXCJcXFwiIGlzIGludmFsaWQuXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQW5pbWF0aW9uVGltaW5ncygwLCAwLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGR1cmF0aW9uTWF0Y2ggPSBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pO1xuICAgICAgICAgIHZhciBkdXJhdGlvblVuaXQgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgIGlmIChkdXJhdGlvblVuaXQgPT0gJ3MnKSB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uTWF0Y2ggKj0gX09ORV9TRUNPTkQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGR1cmF0aW9uID0gTWF0aCQxLmZsb29yKGR1cmF0aW9uTWF0Y2gpO1xuICAgICAgICAgIHZhciBkZWxheU1hdGNoID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICB2YXIgZGVsYXlVbml0ID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlbGF5TWF0Y2gpKSB7XG4gICAgICAgICAgICAgIHZhciBkZWxheVZhbCA9IHBhcnNlRmxvYXQoZGVsYXlNYXRjaCk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVsYXlVbml0KSAmJiBkZWxheVVuaXQgPT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICBkZWxheVZhbCAqPSBfT05FX1NFQ09ORDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWxheSA9IE1hdGgkMS5mbG9vcihkZWxheVZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlYXNpbmdWYWwgPSBtYXRjaGVzWzVdO1xuICAgICAgICAgIGlmICghaXNCbGFuayhlYXNpbmdWYWwpKSB7XG4gICAgICAgICAgICAgIGVhc2luZyA9IGVhc2luZ1ZhbDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBkdXJhdGlvbiA9IGV4cDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgX0FuaW1hdGlvblRpbWluZ3MoZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpO1xuICB9XG4gIGZ1bmN0aW9uIF9jcmVhdGVTdGFydEtleWZyYW1lRnJvbUVuZEtleWZyYW1lKGVuZEtleWZyYW1lLCBzdGFydFRpbWUsIGR1cmF0aW9uLCBjb2xsZWN0ZWRTdHlsZXMsIGVycm9ycykge1xuICAgICAgdmFyIHZhbHVlcyA9IHt9O1xuICAgICAgdmFyIGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICAgIGVuZEtleWZyYW1lLnN0eWxlcy5zdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVEYXRhKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwgPSBzdHlsZURhdGFbcHJvcF07XG4gICAgICAgICAgICAgIGlmIChwcm9wID09ICdvZmZzZXQnKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0SW5kZXggPSBjb2xsZWN0ZWRTdHlsZXMuaW5kZXhPZkF0T3JCZWZvcmVUaW1lKHByb3AsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgIHZhciByZXN1bHRFbnRyeSAvKiogVE9ETyAjOTEwMCAqLywgbmV4dEVudHJ5IC8qKiBUT0RPICM5MTAwICovLCB2YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyZXN1bHRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdEVudHJ5ID0gY29sbGVjdGVkU3R5bGVzLmdldEJ5SW5kZXgocHJvcCwgcmVzdWx0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHRFbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgIG5leHRFbnRyeSA9IGNvbGxlY3RlZFN0eWxlcy5nZXRCeUluZGV4KHByb3AsIHJlc3VsdEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGEgZmxhZyB0aGF0IHRoZSBydW50aW1lIGNvZGUgdXNlcyB0byBwYXNzXG4gICAgICAgICAgICAgICAgICAvLyBpbiBhIHZhbHVlIGVpdGhlciBmcm9tIHRoZSBzdGF0ZSBkZWNsYXJhdGlvbiBzdHlsZXNcbiAgICAgICAgICAgICAgICAgIC8vIG9yIHVzaW5nIHRoZSBBVVRPX1NUWUxFIHZhbHVlIChlLmcuIGdldENvbXB1dGVkU3R5bGUpXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IEZJTExfU1RZTEVfRkxBRztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KG5leHRFbnRyeSkgJiYgIW5leHRFbnRyeS5tYXRjaGVzKGVuZFRpbWUsIHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBBbmltYXRpb25QYXJzZUVycm9yKFwiVGhlIGFuaW1hdGVkIENTUyBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wICsgXCJcXFwiIHVuZXhwZWN0ZWRseSBjaGFuZ2VzIGJldHdlZW4gc3RlcHMgXFxcIlwiICsgcmVzdWx0RW50cnkudGltZSArIFwibXNcXFwiIGFuZCBcXFwiXCIgKyBlbmRUaW1lICsgXCJtc1xcXCIgYXQgXFxcIlwiICsgbmV4dEVudHJ5LnRpbWUgKyBcIm1zXFxcIlwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWVzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uS2V5ZnJhbWVBc3QoX0lOSVRJQUxfS0VZRlJBTUUsIG5ldyBBbmltYXRpb25TdHlsZXNBc3QoW3ZhbHVlc10pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KHZhbHVlLCB0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgbmV3IF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyKCksIHR5cGUpO1xuICB9XG4gIHZhciBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcigpIHtcbiAgICAgIH1cbiAgICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEFycmF5ID0gZnVuY3Rpb24gKGFyciwgdHlwZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoYXJyLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZpc2l0VmFsdWUodmFsdWUsIF90aGlzLCBudWxsKTsgfSksIHR5cGUpO1xuICAgICAgfTtcbiAgICAgIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIHR5cGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZW50cmllcy5wdXNoKFtrZXksIHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBudWxsKV0pOyB9KTtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbE1hcChlbnRyaWVzLCB0eXBlKTtcbiAgICAgIH07XG4gICAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQcmltaXRpdmUgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHsgcmV0dXJuIGxpdGVyYWwodmFsdWUsIHR5cGUpOyB9O1xuICAgICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IERvbid0IG5vdyBob3cgdG8gY29tcGlsZSB2YWx1ZSBcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyO1xuICB9KCkpO1xuXG4gIHZhciBfRGVidWdTdGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfRGVidWdTdGF0ZShub2RlSW5kZXgsIHNvdXJjZUFzdCkge1xuICAgICAgICAgIHRoaXMubm9kZUluZGV4ID0gbm9kZUluZGV4O1xuICAgICAgICAgIHRoaXMuc291cmNlQXN0ID0gc291cmNlQXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9EZWJ1Z1N0YXRlO1xuICB9KCkpO1xuICB2YXIgTlVMTF9ERUJVR19TVEFURSA9IG5ldyBfRGVidWdTdGF0ZShudWxsLCBudWxsKTtcbiAgdmFyIENvbXBpbGVNZXRob2QgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZU1ldGhvZChfdmlldykge1xuICAgICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcbiAgICAgICAgICB0aGlzLl9uZXdTdGF0ZSA9IE5VTExfREVCVUdfU1RBVEU7XG4gICAgICAgICAgdGhpcy5fY3VyclN0YXRlID0gTlVMTF9ERUJVR19TVEFURTtcbiAgICAgICAgICB0aGlzLl9ib2R5U3RhdGVtZW50cyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2RlYnVnRW5hYmxlZCA9IHRoaXMuX3ZpZXcuZ2VuQ29uZmlnLmdlbkRlYnVnSW5mbztcbiAgICAgIH1cbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLl91cGRhdGVEZWJ1Z0NvbnRleHRJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbmV3U3RhdGUubm9kZUluZGV4ICE9PSB0aGlzLl9jdXJyU3RhdGUubm9kZUluZGV4IHx8XG4gICAgICAgICAgICAgIHRoaXMuX25ld1N0YXRlLnNvdXJjZUFzdCAhPT0gdGhpcy5fY3VyclN0YXRlLnNvdXJjZUFzdCkge1xuICAgICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMuX3VwZGF0ZURlYnVnQ29udGV4dCh0aGlzLl9uZXdTdGF0ZSk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXhwcikpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2JvZHlTdGF0ZW1lbnRzLnB1c2goZXhwci50b1N0bXQoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuX3VwZGF0ZURlYnVnQ29udGV4dCA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJTdGF0ZSA9IHRoaXMuX25ld1N0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgaWYgKHRoaXMuX2RlYnVnRW5hYmxlZCkge1xuICAgICAgICAgICAgICB2YXIgc291cmNlTG9jYXRpb24gPSBpc1ByZXNlbnQobmV3U3RhdGUuc291cmNlQXN0KSA/IG5ld1N0YXRlLnNvdXJjZUFzdC5zb3VyY2VTcGFuLnN0YXJ0IDogbnVsbDtcbiAgICAgICAgICAgICAgcmV0dXJuIFRISVNfRVhQUi5jYWxsTWV0aG9kKCdkZWJ1ZycsIFtcbiAgICAgICAgICAgICAgICAgIGxpdGVyYWwobmV3U3RhdGUubm9kZUluZGV4KSxcbiAgICAgICAgICAgICAgICAgIGlzUHJlc2VudChzb3VyY2VMb2NhdGlvbikgPyBsaXRlcmFsKHNvdXJjZUxvY2F0aW9uLmxpbmUpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgICAgaXNQcmVzZW50KHNvdXJjZUxvY2F0aW9uKSA/IGxpdGVyYWwoc291cmNlTG9jYXRpb24uY29sKSA6IE5VTExfRVhQUlxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5yZXNldERlYnVnSW5mb0V4cHIgPSBmdW5jdGlvbiAobm9kZUluZGV4LCB0ZW1wbGF0ZUFzdCkge1xuICAgICAgICAgIHZhciByZXMgPSB0aGlzLl91cGRhdGVEZWJ1Z0NvbnRleHQobmV3IF9EZWJ1Z1N0YXRlKG5vZGVJbmRleCwgdGVtcGxhdGVBc3QpKTtcbiAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHJlcykgPyByZXMgOiBOVUxMX0VYUFI7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUucmVzZXREZWJ1Z0luZm8gPSBmdW5jdGlvbiAobm9kZUluZGV4LCB0ZW1wbGF0ZUFzdCkge1xuICAgICAgICAgIHRoaXMuX25ld1N0YXRlID0gbmV3IF9EZWJ1Z1N0YXRlKG5vZGVJbmRleCwgdGVtcGxhdGVBc3QpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRob2QucHJvdG90eXBlLmFkZFN0bXQgPSBmdW5jdGlvbiAoc3RtdCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZURlYnVnQ29udGV4dElmTmVlZGVkKCk7XG4gICAgICAgICAgdGhpcy5fYm9keVN0YXRlbWVudHMucHVzaChzdG10KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5hZGRTdG10cyA9IGZ1bmN0aW9uIChzdG10cykge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZURlYnVnQ29udGV4dElmTmVlZGVkKCk7XG4gICAgICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsKHRoaXMuX2JvZHlTdGF0ZW1lbnRzLCBzdG10cyk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGhvZC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYm9keVN0YXRlbWVudHM7IH07XG4gICAgICBDb21waWxlTWV0aG9kLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYm9keVN0YXRlbWVudHMubGVuZ3RoID09PSAwOyB9O1xuICAgICAgcmV0dXJuIENvbXBpbGVNZXRob2Q7XG4gIH0oKSk7XG5cbiAgZnVuY3Rpb24gZ2V0UHJvcGVydHlJblZpZXcocHJvcGVydHksIGNhbGxpbmdWaWV3LCBkZWZpbmVkVmlldykge1xuICAgICAgaWYgKGNhbGxpbmdWaWV3ID09PSBkZWZpbmVkVmlldykge1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciB2aWV3UHJvcCA9IFRISVNfRVhQUjtcbiAgICAgICAgICB2YXIgY3VyclZpZXcgPSBjYWxsaW5nVmlldztcbiAgICAgICAgICB3aGlsZSAoY3VyclZpZXcgIT09IGRlZmluZWRWaWV3ICYmIGlzUHJlc2VudChjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldykpIHtcbiAgICAgICAgICAgICAgY3VyclZpZXcgPSBjdXJyVmlldy5kZWNsYXJhdGlvbkVsZW1lbnQudmlldztcbiAgICAgICAgICAgICAgdmlld1Byb3AgPSB2aWV3UHJvcC5wcm9wKCdwYXJlbnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJWaWV3ICE9PSBkZWZpbmVkVmlldykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBlcnJvcjogQ291bGQgbm90IGNhbGN1bGF0ZSBhIHByb3BlcnR5IGluIGEgcGFyZW50IHZpZXc6IFwiICsgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcGVydHkgaW5zdGFuY2VvZiBSZWFkUHJvcEV4cHIpIHtcbiAgICAgICAgICAgICAgdmFyIHJlYWRQcm9wRXhwcl8xID0gcHJvcGVydHk7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IERvbid0IGNhc3QgZm9yIG1lbWJlcnMgb2YgdGhlIEFwcFZpZXcgYmFzZSBjbGFzcy4uLlxuICAgICAgICAgICAgICBpZiAoZGVmaW5lZFZpZXcuZmllbGRzLnNvbWUoZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBmaWVsZC5uYW1lID09IHJlYWRQcm9wRXhwcl8xLm5hbWU7IH0pIHx8XG4gICAgICAgICAgICAgICAgICBkZWZpbmVkVmlldy5nZXR0ZXJzLnNvbWUoZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBmaWVsZC5uYW1lID09IHJlYWRQcm9wRXhwcl8xLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgICB2aWV3UHJvcCA9IHZpZXdQcm9wLmNhc3QoZGVmaW5lZFZpZXcuY2xhc3NUeXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVwbGFjZVZhckluRXhwcmVzc2lvbihUSElTX0VYUFIubmFtZSwgdmlld1Byb3AsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbmplY3RGcm9tVmlld1BhcmVudEluamVjdG9yKHRva2VuLCBvcHRpb25hbCkge1xuICAgICAgdmFyIGFyZ3MgPSBbY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pXTtcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgIGFyZ3MucHVzaChOVUxMX0VYUFIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRISVNfRVhQUi5wcm9wKCdwYXJlbnRJbmplY3RvcicpLmNhbGxNZXRob2QoJ2dldCcsIGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFZpZXdGYWN0b3J5TmFtZShjb21wb25lbnQsIGVtYmVkZGVkVGVtcGxhdGVJbmRleCkge1xuICAgICAgcmV0dXJuIFwidmlld0ZhY3RvcnlfXCIgKyBjb21wb25lbnQudHlwZS5uYW1lICsgZW1iZWRkZWRUZW1wbGF0ZUluZGV4O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZsYXRBcnJheShleHByZXNzaW9ucykge1xuICAgICAgdmFyIGxhc3ROb25BcnJheUV4cHJlc3Npb25zID0gW107XG4gICAgICB2YXIgcmVzdWx0ID0gbGl0ZXJhbEFycihbXSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGV4cHIgPSBleHByZXNzaW9uc1tpXTtcbiAgICAgICAgICBpZiAoZXhwci50eXBlIGluc3RhbmNlb2YgQXJyYXlUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0Tm9uQXJyYXlFeHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXksIFtsaXRlcmFsQXJyKGxhc3ROb25BcnJheUV4cHJlc3Npb25zKV0pO1xuICAgICAgICAgICAgICAgICAgbGFzdE5vbkFycmF5RXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY2FsbE1ldGhvZChCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5LCBbZXhwcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdE5vbkFycmF5RXhwcmVzc2lvbnMucHVzaChleHByKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdE5vbkFycmF5RXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgIHJlc3VsdC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXksIFtsaXRlcmFsQXJyKGxhc3ROb25BcnJheUV4cHJlc3Npb25zKV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVQdXJlUHJveHkoZm4sIGFyZ0NvdW50LCBwdXJlUHJveHlQcm9wLCB2aWV3KSB7XG4gICAgICB2aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKHB1cmVQcm94eVByb3AubmFtZSwgbnVsbCkpO1xuICAgICAgdmFyIHB1cmVQcm94eUlkID0gYXJnQ291bnQgPCBJZGVudGlmaWVycy5wdXJlUHJveGllcy5sZW5ndGggPyBJZGVudGlmaWVycy5wdXJlUHJveGllc1thcmdDb3VudF0gOiBudWxsO1xuICAgICAgaWYgKCFwdXJlUHJveHlJZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG51bWJlciBvZiBhcmd1bWVudCBmb3IgcHVyZSBmdW5jdGlvbnM6IFwiICsgYXJnQ291bnQpO1xuICAgICAgfVxuICAgICAgdmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIucHJvcChwdXJlUHJveHlQcm9wLm5hbWUpXG4gICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKHB1cmVQcm94eUlkKSkuY2FsbEZuKFtmbl0pKVxuICAgICAgICAgIC50b1N0bXQoKSk7XG4gIH1cblxuICB2YXIgVmlld1F1ZXJ5VmFsdWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdRdWVyeVZhbHVlcyh2aWV3LCB2YWx1ZXMpIHtcbiAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFZpZXdRdWVyeVZhbHVlcztcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVRdWVyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlUXVlcnkobWV0YSwgcXVlcnlMaXN0LCBvd25lckRpcmVjdGl2ZUV4cHJlc3Npb24sIHZpZXcpIHtcbiAgICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgICAgICAgIHRoaXMucXVlcnlMaXN0ID0gcXVlcnlMaXN0O1xuICAgICAgICAgIHRoaXMub3duZXJEaXJlY3RpdmVFeHByZXNzaW9uID0gb3duZXJEaXJlY3RpdmVFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgdGhpcy5fdmFsdWVzID0gbmV3IFZpZXdRdWVyeVZhbHVlcyh2aWV3LCBbXSk7XG4gICAgICB9XG4gICAgICBDb21waWxlUXVlcnkucHJvdG90eXBlLmFkZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCB2aWV3KSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRWaWV3ID0gdmlldztcbiAgICAgICAgICB2YXIgZWxQYXRoID0gW107XG4gICAgICAgICAgd2hpbGUgKGlzUHJlc2VudChjdXJyZW50VmlldykgJiYgY3VycmVudFZpZXcgIT09IHRoaXMudmlldykge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50RWwgPSBjdXJyZW50Vmlldy5kZWNsYXJhdGlvbkVsZW1lbnQ7XG4gICAgICAgICAgICAgIGVsUGF0aC51bnNoaWZ0KHBhcmVudEVsKTtcbiAgICAgICAgICAgICAgY3VycmVudFZpZXcgPSBwYXJlbnRFbC52aWV3O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcXVlcnlMaXN0Rm9yRGlydHlFeHByID0gZ2V0UHJvcGVydHlJblZpZXcodGhpcy5xdWVyeUxpc3QsIHZpZXcsIHRoaXMudmlldyk7XG4gICAgICAgICAgdmFyIHZpZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgICAgZWxQYXRoLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgIHZhciBsYXN0ID0gdmlld1ZhbHVlcy52YWx1ZXMubGVuZ3RoID4gMCA/IHZpZXdWYWx1ZXMudmFsdWVzW3ZpZXdWYWx1ZXMudmFsdWVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBWaWV3UXVlcnlWYWx1ZXMgJiYgbGFzdC52aWV3ID09PSBlbC5lbWJlZGRlZFZpZXcpIHtcbiAgICAgICAgICAgICAgICAgIHZpZXdWYWx1ZXMgPSBsYXN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZpZXdWYWx1ZXMgPSBuZXcgVmlld1F1ZXJ5VmFsdWVzKGVsLmVtYmVkZGVkVmlldywgW10pO1xuICAgICAgICAgICAgICAgICAgdmlld1ZhbHVlcy52YWx1ZXMucHVzaChuZXdWaWV3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgIHZpZXdWYWx1ZXMgPSBuZXdWaWV3VmFsdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmlld1ZhbHVlcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGVsUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZpZXcuZGlydHlQYXJlbnRRdWVyaWVzTWV0aG9kLmFkZFN0bXQocXVlcnlMaXN0Rm9yRGlydHlFeHByLmNhbGxNZXRob2QoJ3NldERpcnR5JywgW10pLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZVF1ZXJ5LnByb3RvdHlwZS5faXNTdGF0aWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuICF0aGlzLl92YWx1ZXMudmFsdWVzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFZpZXdRdWVyeVZhbHVlczsgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZVF1ZXJ5LnByb3RvdHlwZS5hZnRlckNoaWxkcmVuID0gZnVuY3Rpb24gKHRhcmdldFN0YXRpY01ldGhvZCAvKiogVE9ETyAjOTEwMCAqLywgdGFyZ2V0RHluYW1pY01ldGhvZCkge1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBjcmVhdGVRdWVyeVZhbHVlcyh0aGlzLl92YWx1ZXMpO1xuICAgICAgICAgIHZhciB1cGRhdGVTdG10cyA9IFt0aGlzLnF1ZXJ5TGlzdC5jYWxsTWV0aG9kKCdyZXNldCcsIFtsaXRlcmFsQXJyKHZhbHVlcyldKS50b1N0bXQoKV07XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlRXhwciA9IHRoaXMubWV0YS5maXJzdCA/IHRoaXMucXVlcnlMaXN0LnByb3AoJ2ZpcnN0JykgOiB0aGlzLnF1ZXJ5TGlzdDtcbiAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaCh0aGlzLm93bmVyRGlyZWN0aXZlRXhwcmVzc2lvbi5wcm9wKHRoaXMubWV0YS5wcm9wZXJ0eU5hbWUpLnNldCh2YWx1ZUV4cHIpLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLm1ldGEuZmlyc3QpIHtcbiAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaCh0aGlzLnF1ZXJ5TGlzdC5jYWxsTWV0aG9kKCdub3RpZnlPbkNoYW5nZXMnLCBbXSkudG9TdG10KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5tZXRhLmZpcnN0ICYmIHRoaXMuX2lzU3RhdGljKCkpIHtcbiAgICAgICAgICAgICAgLy8gZm9yIHF1ZXJpZXMgdGhhdCBkb24ndCBjaGFuZ2UgYW5kIHRoZSB1c2VyIGFza2VkIGZvciBhIHNpbmdsZSBlbGVtZW50LFxuICAgICAgICAgICAgICAvLyBzZXQgaXQgaW1tZWRpYXRlbHkuIFRoYXQgaXMgZS5nLiBuZWVkZWQgZm9yIHF1ZXJ5aW5nIGZvciBWaWV3Q29udGFpbmVyUmVmcywgLi4uXG4gICAgICAgICAgICAgIC8vIHdlIGRvbid0IGRvIHRoaXMgZm9yIFF1ZXJ5TGlzdHMgZm9yIG5vdyBhcyB0aGlzIHdvdWxkIGJyZWFrIHRoZSB0aW1pbmcgd2hlblxuICAgICAgICAgICAgICAvLyB3ZSBjYWxsIFF1ZXJ5TGlzdCBsaXN0ZW5lcnMuLi5cbiAgICAgICAgICAgICAgdGFyZ2V0U3RhdGljTWV0aG9kLmFkZFN0bXRzKHVwZGF0ZVN0bXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldER5bmFtaWNNZXRob2QuYWRkU3RtdChuZXcgSWZTdG10KHRoaXMucXVlcnlMaXN0LnByb3AoJ2RpcnR5JyksIHVwZGF0ZVN0bXRzKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBDb21waWxlUXVlcnk7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5VmFsdWVzKHZpZXdWYWx1ZXMpIHtcbiAgICAgIHJldHVybiBMaXN0V3JhcHBlci5mbGF0dGVuKHZpZXdWYWx1ZXMudmFsdWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICBpZiAoZW50cnkgaW5zdGFuY2VvZiBWaWV3UXVlcnlWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcE5lc3RlZFZpZXdzKGVudHJ5LnZpZXcuZGVjbGFyYXRpb25FbGVtZW50LmFwcEVsZW1lbnQsIGVudHJ5LnZpZXcsIGNyZWF0ZVF1ZXJ5VmFsdWVzKGVudHJ5KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIG1hcE5lc3RlZFZpZXdzKGRlY2xhcmF0aW9uQXBwRWxlbWVudCwgdmlldywgZXhwcmVzc2lvbnMpIHtcbiAgICAgIHZhciBhZGp1c3RlZEV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChleHByKSB7IHJldHVybiByZXBsYWNlVmFySW5FeHByZXNzaW9uKFRISVNfRVhQUi5uYW1lLCB2YXJpYWJsZSgnbmVzdGVkVmlldycpLCBleHByKTsgfSk7XG4gICAgICByZXR1cm4gZGVjbGFyYXRpb25BcHBFbGVtZW50LmNhbGxNZXRob2QoJ21hcE5lc3RlZFZpZXdzJywgW1xuICAgICAgICAgIHZhcmlhYmxlKHZpZXcuY2xhc3NOYW1lKSxcbiAgICAgICAgICBmbihbbmV3IEZuUGFyYW0oJ25lc3RlZFZpZXcnLCB2aWV3LmNsYXNzVHlwZSldLCBbbmV3IFJldHVyblN0YXRlbWVudChsaXRlcmFsQXJyKGFkanVzdGVkRXhwcmVzc2lvbnMpKV0sIERZTkFNSUNfVFlQRSlcbiAgICAgIF0pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVF1ZXJ5TGlzdChxdWVyeSwgZGlyZWN0aXZlSW5zdGFuY2UsIHByb3BlcnR5TmFtZSwgY29tcGlsZVZpZXcpIHtcbiAgICAgIGNvbXBpbGVWaWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKHByb3BlcnR5TmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5RdWVyeUxpc3QpLCBbRFlOQU1JQ19UWVBFXSkpKTtcbiAgICAgIHZhciBleHByID0gVEhJU19FWFBSLnByb3AocHJvcGVydHlOYW1lKTtcbiAgICAgIGNvbXBpbGVWaWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuUXVlcnlMaXN0KSwgW0RZTkFNSUNfVFlQRV0pXG4gICAgICAgICAgLmluc3RhbnRpYXRlKFtdKSlcbiAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgZnVuY3Rpb24gYWRkUXVlcnlUb1Rva2VuTWFwKG1hcCwgcXVlcnkpIHtcbiAgICAgIHF1ZXJ5Lm1ldGEuc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gbWFwLmdldChzZWxlY3Rvci5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgICAgZW50cnkgPSBbXTtcbiAgICAgICAgICAgICAgbWFwLnNldChzZWxlY3Rvci5yZWZlcmVuY2UsIGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW50cnkucHVzaChxdWVyeSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnVtRXhwcmVzc2lvbihjbGFzc0lkZW50aWZpZXIsIG5hbWUpIHtcbiAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVFbnVtSWRlbnRpZmllcihjbGFzc0lkZW50aWZpZXIsIG5hbWUpKTtcbiAgfVxuICB2YXIgVmlld1R5cGVFbnVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdUeXBlRW51bSgpIHtcbiAgICAgIH1cbiAgICAgIFZpZXdUeXBlRW51bS5mcm9tVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgdmlld1R5cGUgPSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3VHlwZSk7XG4gICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFZpZXdUeXBlLkhPU1Q6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKHZpZXdUeXBlLCAnSE9TVCcpO1xuICAgICAgICAgICAgICBjYXNlIFZpZXdUeXBlLkNPTVBPTkVOVDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZW51bUV4cHJlc3Npb24odmlld1R5cGUsICdDT01QT05FTlQnKTtcbiAgICAgICAgICAgICAgY2FzZSBWaWV3VHlwZS5FTUJFRERFRDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfZW51bUV4cHJlc3Npb24odmlld1R5cGUsICdFTUJFRERFRCcpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbmF2bGlkIFZpZXdUeXBlIHZhbHVlOiBcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIFZpZXdUeXBlRW51bTtcbiAgfSgpKTtcbiAgdmFyIFZpZXdFbmNhcHN1bGF0aW9uRW51bSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3RW5jYXBzdWxhdGlvbkVudW0oKSB7XG4gICAgICB9XG4gICAgICBWaWV3RW5jYXBzdWxhdGlvbkVudW0uZnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHZpZXdFbmNhcHN1bGF0aW9uID0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVmlld0VuY2Fwc3VsYXRpb24pO1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbih2aWV3RW5jYXBzdWxhdGlvbiwgJ0VtdWxhdGVkJyk7XG4gICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5OYXRpdmU6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKHZpZXdFbmNhcHN1bGF0aW9uLCAnTmF0aXZlJyk7XG4gICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbih2aWV3RW5jYXBzdWxhdGlvbiwgJ05vbmUnKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW5hdmxpZCBWaWV3RW5jYXBzdWxhdGlvbiB2YWx1ZTogXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBWaWV3RW5jYXBzdWxhdGlvbkVudW07XG4gIH0oKSk7XG4gIHZhciBDaGFuZ2VEZXRlY3RvclN0YXR1c0VudW0gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtKCkge1xuICAgICAgfVxuICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtLmZyb21WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBjaGFuZ2VEZXRlY3RvclN0YXR1cyA9IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yU3RhdHVzKTtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tPbmNlOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbihjaGFuZ2VEZXRlY3RvclN0YXR1cywgJ0NoZWNrT25jZScpO1xuICAgICAgICAgICAgICBjYXNlIENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKGNoYW5nZURldGVjdG9yU3RhdHVzLCAnQ2hlY2tlZCcpO1xuICAgICAgICAgICAgICBjYXNlIENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrQWx3YXlzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbihjaGFuZ2VEZXRlY3RvclN0YXR1cywgJ0NoZWNrQWx3YXlzJyk7XG4gICAgICAgICAgICAgIGNhc2UgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGV0YWNoZWQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKGNoYW5nZURldGVjdG9yU3RhdHVzLCAnRGV0YWNoZWQnKTtcbiAgICAgICAgICAgICAgY2FzZSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5FcnJvcmVkOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbnVtRXhwcmVzc2lvbihjaGFuZ2VEZXRlY3RvclN0YXR1cywgJ0Vycm9yZWQnKTtcbiAgICAgICAgICAgICAgY2FzZSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2VudW1FeHByZXNzaW9uKGNoYW5nZURldGVjdG9yU3RhdHVzLCAnRGVzdHJveWVkJyk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkluYXZsaWQgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMgdmFsdWU6IFwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JTdGF0dXNFbnVtO1xuICB9KCkpO1xuICB2YXIgVmlld0NvbnN0cnVjdG9yVmFycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3Q29uc3RydWN0b3JWYXJzKCkge1xuICAgICAgfVxuICAgICAgVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMgPSB2YXJpYWJsZSgndmlld1V0aWxzJyk7XG4gICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLnBhcmVudEluamVjdG9yID0gdmFyaWFibGUoJ3BhcmVudEluamVjdG9yJyk7XG4gICAgICBWaWV3Q29uc3RydWN0b3JWYXJzLmRlY2xhcmF0aW9uRWwgPSB2YXJpYWJsZSgnZGVjbGFyYXRpb25FbCcpO1xuICAgICAgcmV0dXJuIFZpZXdDb25zdHJ1Y3RvclZhcnM7XG4gIH0oKSk7XG4gIHZhciBWaWV3UHJvcGVydGllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3UHJvcGVydGllcygpIHtcbiAgICAgIH1cbiAgICAgIFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyID0gVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJyk7XG4gICAgICBWaWV3UHJvcGVydGllcy5wcm9qZWN0YWJsZU5vZGVzID0gVEhJU19FWFBSLnByb3AoJ3Byb2plY3RhYmxlTm9kZXMnKTtcbiAgICAgIFZpZXdQcm9wZXJ0aWVzLnZpZXdVdGlscyA9IFRISVNfRVhQUi5wcm9wKCd2aWV3VXRpbHMnKTtcbiAgICAgIHJldHVybiBWaWV3UHJvcGVydGllcztcbiAgfSgpKTtcbiAgdmFyIEV2ZW50SGFuZGxlclZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRXZlbnRIYW5kbGVyVmFycygpIHtcbiAgICAgIH1cbiAgICAgIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQgPSB2YXJpYWJsZSgnJGV2ZW50Jyk7XG4gICAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycztcbiAgfSgpKTtcbiAgdmFyIEluamVjdE1ldGhvZFZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0TWV0aG9kVmFycygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdE1ldGhvZFZhcnMudG9rZW4gPSB2YXJpYWJsZSgndG9rZW4nKTtcbiAgICAgIEluamVjdE1ldGhvZFZhcnMucmVxdWVzdE5vZGVJbmRleCA9IHZhcmlhYmxlKCdyZXF1ZXN0Tm9kZUluZGV4Jyk7XG4gICAgICBJbmplY3RNZXRob2RWYXJzLm5vdEZvdW5kUmVzdWx0ID0gdmFyaWFibGUoJ25vdEZvdW5kUmVzdWx0Jyk7XG4gICAgICByZXR1cm4gSW5qZWN0TWV0aG9kVmFycztcbiAgfSgpKTtcbiAgdmFyIERldGVjdENoYW5nZXNWYXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIERldGVjdENoYW5nZXNWYXJzKCkge1xuICAgICAgfVxuICAgICAgRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSA9IHZhcmlhYmxlKFwidGhyb3dPbkNoYW5nZVwiKTtcbiAgICAgIERldGVjdENoYW5nZXNWYXJzLmNoYW5nZXMgPSB2YXJpYWJsZShcImNoYW5nZXNcIik7XG4gICAgICBEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkID0gdmFyaWFibGUoXCJjaGFuZ2VkXCIpO1xuICAgICAgRGV0ZWN0Q2hhbmdlc1ZhcnMudmFsVW53cmFwcGVyID0gdmFyaWFibGUoXCJ2YWxVbndyYXBwZXJcIik7XG4gICAgICByZXR1cm4gRGV0ZWN0Q2hhbmdlc1ZhcnM7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDE0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgQ29tcGlsZU5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZU5vZGUocGFyZW50LCB2aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIHNvdXJjZUFzdCkge1xuICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgdGhpcy5ub2RlSW5kZXggPSBub2RlSW5kZXg7XG4gICAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gcmVuZGVyTm9kZTtcbiAgICAgICAgICB0aGlzLnNvdXJjZUFzdCA9IHNvdXJjZUFzdDtcbiAgICAgIH1cbiAgICAgIENvbXBpbGVOb2RlLnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5yZW5kZXJOb2RlOyB9O1xuICAgICAgQ29tcGlsZU5vZGUucHJvdG90eXBlLmlzUm9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZpZXcgIT0gdGhpcy5wYXJlbnQudmlldzsgfTtcbiAgICAgIHJldHVybiBDb21waWxlTm9kZTtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVFbGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxNChDb21waWxlRWxlbWVudCwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVFbGVtZW50KHBhcmVudCwgdmlldywgbm9kZUluZGV4LCByZW5kZXJOb2RlLCBzb3VyY2VBc3QsIGNvbXBvbmVudCwgX2RpcmVjdGl2ZXMsIF9yZXNvbHZlZFByb3ZpZGVyc0FycmF5LCBoYXNWaWV3Q29udGFpbmVyLCBoYXNFbWJlZGRlZFZpZXcsIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHBhcmVudCwgdmlldywgbm9kZUluZGV4LCByZW5kZXJOb2RlLCBzb3VyY2VBc3QpO1xuICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZXMgPSBfZGlyZWN0aXZlcztcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlZFByb3ZpZGVyc0FycmF5ID0gX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXk7XG4gICAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLmhhc0VtYmVkZGVkVmlldyA9IGhhc0VtYmVkZGVkVmlldztcbiAgICAgICAgICB0aGlzLl9jb21wVmlld0V4cHIgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3F1ZXJ5Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMuX3F1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0cyA9IFtdO1xuICAgICAgICAgIHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2VUb2tlbnMgPSB7fTtcbiAgICAgICAgICByZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gX3RoaXMucmVmZXJlbmNlVG9rZW5zW3JlZi5uYW1lXSA9IHJlZi52YWx1ZTsgfSk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50UmVmID1cbiAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5FbGVtZW50UmVmKSkuaW5zdGFudGlhdGUoW3RoaXMucmVuZGVyTm9kZV0pO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChyZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkVsZW1lbnRSZWYpLnJlZmVyZW5jZSwgdGhpcy5lbGVtZW50UmVmKTtcbiAgICAgICAgICB0aGlzLmluamVjdG9yID0gVEhJU19FWFBSLmNhbGxNZXRob2QoJ2luamVjdG9yJywgW2xpdGVyYWwodGhpcy5ub2RlSW5kZXgpXSk7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuSW5qZWN0b3IpLnJlZmVyZW5jZSwgdGhpcy5pbmplY3Rvcik7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuUmVuZGVyZXIpLnJlZmVyZW5jZSwgVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJykpO1xuICAgICAgICAgIGlmICh0aGlzLmhhc1ZpZXdDb250YWluZXIgfHwgdGhpcy5oYXNFbWJlZGRlZFZpZXcgfHwgaXNQcmVzZW50KHRoaXMuY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVBcHBFbGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ29tcGlsZUVsZW1lbnQuY3JlYXRlTnVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVFbGVtZW50KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIFtdLCBbXSwgZmFsc2UsIGZhbHNlLCBbXSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLl9jcmVhdGVBcHBFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBcIl9hcHBFbF9cIiArIHRoaXMubm9kZUluZGV4O1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlSW5kZXggPSB0aGlzLmlzUm9vdEVsZW1lbnQoKSA/IG51bGwgOiB0aGlzLnBhcmVudC5ub2RlSW5kZXg7XG4gICAgICAgICAgLy8gcHJpdmF0ZSBpcyBmaW5lIGhlcmUgYXMgbm8gY2hpbGQgdmlldyB3aWxsIHJlZmVyZW5jZSBhbiBBcHBFbGVtZW50XG4gICAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkTmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5BcHBFbGVtZW50KSksIFtTdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICAgICAgICB2YXIgc3RhdGVtZW50ID0gVEhJU19FWFBSLnByb3AoZmllbGROYW1lKVxuICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwRWxlbWVudCkpLmluc3RhbnRpYXRlKFtcbiAgICAgICAgICAgICAgbGl0ZXJhbCh0aGlzLm5vZGVJbmRleCksIGxpdGVyYWwocGFyZW50Tm9kZUluZGV4KSwgVEhJU19FWFBSLCB0aGlzLnJlbmRlck5vZGVcbiAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChzdGF0ZW1lbnQpO1xuICAgICAgICAgIHRoaXMuYXBwRWxlbWVudCA9IFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSk7XG4gICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuQXBwRWxlbWVudCkucmVmZXJlbmNlLCB0aGlzLmFwcEVsZW1lbnQpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBmdW5jdGlvbiAoZW50cnlDb21wb25lbnRzKSB7XG4gICAgICAgICAgaWYgKCFlbnRyeUNvbXBvbmVudHMgfHwgZW50cnlDb21wb25lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjcmVhdGVDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJFeHByID0gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSkuaW5zdGFudGlhdGUoW1xuICAgICAgICAgICAgICBsaXRlcmFsQXJyKGVudHJ5Q29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50KSB7IHJldHVybiBpbXBvcnRFeHByKGVudHJ5Q29tcG9uZW50KTsgfSkpLFxuICAgICAgICAgICAgICBpbmplY3RGcm9tVmlld1BhcmVudEluamVjdG9yKHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSwgZmFsc2UpXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgdG9rZW46IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSxcbiAgICAgICAgICAgICAgdXNlVmFsdWU6IGNyZWF0ZUNvbXBvbmVudEZhY3RvcnlSZXNvbHZlckV4cHJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBBZGQgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIGFzIGZpcnN0IHByb3ZpZGVyIGFzIGl0IGRvZXMgbm90IGhhdmUgZGVwcyBvbiBvdGhlciBwcm92aWRlcnNcbiAgICAgICAgICAvLyBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UgYXMgb25seSB0aGUgY29tcG9uZW50IGFuZCBpdHMgdmlldyBjYW4gc2VlIGl0LFxuICAgICAgICAgIC8vIGJ1dCBub2JvZHkgZWxzZVxuICAgICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXkudW5zaGlmdChuZXcgUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sIGZhbHNlLCB0cnVlLCBbcHJvdmlkZXJdLCBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwgW10sIHRoaXMuc291cmNlQXN0LnNvdXJjZVNwYW4pKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuc2V0Q29tcG9uZW50VmlldyA9IGZ1bmN0aW9uIChjb21wVmlld0V4cHIpIHtcbiAgICAgICAgICB0aGlzLl9jb21wVmlld0V4cHIgPSBjb21wVmlld0V4cHI7XG4gICAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4ID1cbiAgICAgICAgICAgICAgbmV3IEFycmF5KHRoaXMuY29tcG9uZW50LnRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGgpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleFtpXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuc2V0RW1iZWRkZWRWaWV3ID0gZnVuY3Rpb24gKGVtYmVkZGVkVmlldykge1xuICAgICAgICAgIHRoaXMuZW1iZWRkZWRWaWV3ID0gZW1iZWRkZWRWaWV3O1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZW1iZWRkZWRWaWV3KSkge1xuICAgICAgICAgICAgICB2YXIgY3JlYXRlVGVtcGxhdGVSZWZFeHByID0gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZl8pKS5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgICAgICB0aGlzLmFwcEVsZW1lbnQsIHRoaXMuZW1iZWRkZWRWaWV3LnZpZXdGYWN0b3J5XG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgdG9rZW46IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpLFxuICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IGNyZWF0ZVRlbXBsYXRlUmVmRXhwclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gQWRkIFRlbXBsYXRlUmVmIGFzIGZpcnN0IHByb3ZpZGVyIGFzIGl0IGRvZXMgbm90IGhhdmUgZGVwcyBvbiBvdGhlciBwcm92aWRlcnNcbiAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnNBcnJheS51bnNoaWZ0KG5ldyBQcm92aWRlckFzdChwcm92aWRlci50b2tlbiwgZmFsc2UsIHRydWUsIFtwcm92aWRlcl0sIGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLkJ1aWx0aW4sIFtdLCB0aGlzLnNvdXJjZUFzdC5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5iZWZvcmVDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICh0aGlzLmhhc1ZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZikucmVmZXJlbmNlLCB0aGlzLmFwcEVsZW1lbnQucHJvcCgndmNSZWYnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIF90aGlzLl9yZXNvbHZlZFByb3ZpZGVycy5zZXQocHJvdmlkZXIudG9rZW4ucmVmZXJlbmNlLCBwcm92aWRlcik7IH0pO1xuICAgICAgICAgIC8vIGNyZWF0ZSBhbGwgdGhlIHByb3ZpZGVyIGluc3RhbmNlcywgc29tZSBpbiB0aGUgdmlldyBjb25zdHJ1Y3RvcixcbiAgICAgICAgICAvLyBzb21lIGFzIGdldHRlcnMuIFdlIHJlbHkgb24gdGhlIGZhY3QgdGhhdCB0aGV5IGFyZSBhbHJlYWR5IHNvcnRlZCB0b3BvbG9naWNhbGx5LlxuICAgICAgICAgIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IGlzUHJlc2VudChwcm92aWRlci5kZXBzKSA/IHByb3ZpZGVyLmRlcHMgOiBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwc0V4cHIgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocHJvdmlkZXIudXNlRmFjdG9yeSkuY2FsbEZuKGRlcHNFeHByKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwcyA9IGlzUHJlc2VudChwcm92aWRlci5kZXBzKSA/IHByb3ZpZGVyLmRlcHMgOiBwcm92aWRlci51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHNFeHByID0gZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHByb3ZpZGVyLnVzZUNsYXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoZGVwc0V4cHIsIGltcG9ydFR5cGUocHJvdmlkZXIudXNlQ2xhc3MpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChwcm92aWRlci51c2VWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBcIl9cIiArIHJlc29sdmVkUHJvdmlkZXIudG9rZW4ubmFtZSArIFwiX1wiICsgX3RoaXMubm9kZUluZGV4ICsgXCJfXCIgKyBfdGhpcy5pbnN0YW5jZXMuc2l6ZTtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlUHJvdmlkZXJQcm9wZXJ0eShwcm9wTmFtZSwgcmVzb2x2ZWRQcm92aWRlciwgcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zLCByZXNvbHZlZFByb3ZpZGVyLm11bHRpUHJvdmlkZXIsIHJlc29sdmVkUHJvdmlkZXIuZWFnZXIsIF90aGlzKTtcbiAgICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2VzLnNldChyZXNvbHZlZFByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlID0gdGhpcy5fZGlyZWN0aXZlc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGlkZW50aWZpZXJUb2tlbihkaXJlY3RpdmUudHlwZSkucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgZGlyZWN0aXZlLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlNZXRhKSB7IF90aGlzLl9hZGRRdWVyeShxdWVyeU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlKTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBxdWVyaWVzV2l0aFJlYWRzID0gW107XG4gICAgICAgICAgTWFwV3JhcHBlci52YWx1ZXModGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXJpZXNGb3JQcm92aWRlciA9IF90aGlzLl9nZXRRdWVyaWVzRm9yKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgICAgICBMaXN0V3JhcHBlci5hZGRBbGwocXVlcmllc1dpdGhSZWFkcywgcXVlcmllc0ZvclByb3ZpZGVyLm1hcChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIG5ldyBfUXVlcnlXaXRoUmVhZChxdWVyeSwgcmVzb2x2ZWRQcm92aWRlci50b2tlbik7IH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnJlZmVyZW5jZVRva2VucykuZm9yRWFjaChmdW5jdGlvbiAodmFyTmFtZSkge1xuICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBfdGhpcy5yZWZlcmVuY2VUb2tlbnNbdmFyTmFtZV07XG4gICAgICAgICAgICAgIHZhciB2YXJWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgIHZhclZhbHVlID0gX3RoaXMuaW5zdGFuY2VzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFyVmFsdWUgPSBfdGhpcy5yZW5kZXJOb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLnZpZXcubG9jYWxzLnNldCh2YXJOYW1lLCB2YXJWYWx1ZSk7XG4gICAgICAgICAgICAgIHZhciB2YXJUb2tlbiA9IG5ldyBDb21waWxlVG9rZW5NZXRhZGF0YSh7IHZhbHVlOiB2YXJOYW1lIH0pO1xuICAgICAgICAgICAgICBMaXN0V3JhcHBlci5hZGRBbGwocXVlcmllc1dpdGhSZWFkcywgX3RoaXMuX2dldFF1ZXJpZXNGb3IodmFyVG9rZW4pLm1hcChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIG5ldyBfUXVlcnlXaXRoUmVhZChxdWVyeSwgdmFyVG9rZW4pOyB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcXVlcmllc1dpdGhSZWFkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeVdpdGhSZWFkKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChxdWVyeVdpdGhSZWFkLnJlYWQuaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHF1ZXJ5IGZvciBhbiBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmluc3RhbmNlcy5nZXQocXVlcnlXaXRoUmVhZC5yZWFkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBxdWVyeSBmb3IgYSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IF90aGlzLnJlZmVyZW5jZVRva2Vuc1txdWVyeVdpdGhSZWFkLnJlYWQudmFsdWVdO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmluc3RhbmNlcy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMuZWxlbWVudFJlZjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgcXVlcnlXaXRoUmVhZC5xdWVyeS5hZGRWYWx1ZSh2YWx1ZSwgX3RoaXMudmlldyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0ID0gaXNQcmVzZW50KHRoaXMuY29tcG9uZW50KSA/XG4gICAgICAgICAgICAgICAgICBsaXRlcmFsQXJyKHRoaXMuX2NvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJ5TGlzdHMpIDpcbiAgICAgICAgICAgICAgICAgIE5VTExfRVhQUjtcbiAgICAgICAgICAgICAgdmFyIGNvbXBFeHByID0gaXNQcmVzZW50KHRoaXMuZ2V0Q29tcG9uZW50KCkpID8gdGhpcy5nZXRDb21wb25lbnQoKSA6IE5VTExfRVhQUjtcbiAgICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KHRoaXMuYXBwRWxlbWVudFxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ2luaXRDb21wb25lbnQnLCBbY29tcEV4cHIsIGNvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJ5TGlzdCwgdGhpcy5fY29tcFZpZXdFeHByXSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5hZnRlckNoaWxkcmVuID0gZnVuY3Rpb24gKGNoaWxkTm9kZUNvdW50KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl9yZXNvbHZlZFByb3ZpZGVycykuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRQcm92aWRlcikge1xuICAgICAgICAgICAgICAvLyBOb3RlOiBhZnRlckNoaWxkcmVuIGlzIGNhbGxlZCBhZnRlciByZWN1cnNpbmcgaW50byBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBnb29kIHNvIHRoYXQgYW4gaW5qZWN0b3IgbWF0Y2ggaW4gYW4gZWxlbWVudCB0aGF0IGlzIGNsb3NlciB0byBhIHJlcXVlc3RpbmcgZWxlbWVudFxuICAgICAgICAgICAgICAvLyBtYXRjaGVzIGZpcnN0LlxuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJFeHByID0gX3RoaXMuaW5zdGFuY2VzLmdldChyZXNvbHZlZFByb3ZpZGVyLnRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IHZpZXcgcHJvdmlkZXJzIGFyZSBvbmx5IHZpc2libGUgb24gdGhlIGluamVjdG9yIG9mIHRoYXQgZWxlbWVudC5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBub3QgZnVsbHkgY29ycmVjdCBhcyB0aGUgcnVsZXMgZHVyaW5nIGNvZGVnZW4gZG9uJ3QgYWxsb3cgYSBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGhvbGQgb2YgYSB2aWV3IHByb3ZkaWVyIG9uIHRoZSBzYW1lIGVsZW1lbnQuIFdlIHN0aWxsIGRvIHRoaXMgc2VtYW50aWNcbiAgICAgICAgICAgICAgLy8gYXMgaXQgc2ltcGxpZmllcyBvdXIgbW9kZWwgdG8gaGF2aW5nIG9ubHkgb25lIHJ1bnRpbWUgaW5qZWN0b3IgcGVyIGVsZW1lbnQuXG4gICAgICAgICAgICAgIHZhciBwcm92aWRlckNoaWxkTm9kZUNvdW50ID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUgPT09IGV4cG9ydHMuUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlID8gMCA6IGNoaWxkTm9kZUNvdW50O1xuICAgICAgICAgICAgICBfdGhpcy52aWV3LmluamVjdG9yR2V0TWV0aG9kLmFkZFN0bXQoY3JlYXRlSW5qZWN0SW50ZXJuYWxDb25kaXRpb24oX3RoaXMubm9kZUluZGV4LCBwcm92aWRlckNoaWxkTm9kZUNvdW50LCByZXNvbHZlZFByb3ZpZGVyLCBwcm92aWRlckV4cHIpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyh0aGlzLl9xdWVyaWVzKVxuICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocXVlcmllcykgeyByZXR1cm4gcXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkuYWZ0ZXJDaGlsZHJlbihfdGhpcy52aWV3LmNyZWF0ZU1ldGhvZCwgX3RoaXMudmlldy51cGRhdGVDb250ZW50UXVlcmllc01ldGhvZCk7IH0pOyB9KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuYWRkQ29udGVudE5vZGUgPSBmdW5jdGlvbiAobmdDb250ZW50SW5kZXgsIG5vZGVFeHByKSB7XG4gICAgICAgICAgdGhpcy5jb250ZW50Tm9kZXNCeU5nQ29udGVudEluZGV4W25nQ29udGVudEluZGV4XS5wdXNoKG5vZGVFeHByKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb21wb25lbnQpID9cbiAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuZ2V0KGlkZW50aWZpZXJUb2tlbih0aGlzLmNvbXBvbmVudC50eXBlKS5yZWZlcmVuY2UpIDpcbiAgICAgICAgICAgICAgbnVsbDtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuZ2V0UHJvdmlkZXJUb2tlbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX3Jlc29sdmVkUHJvdmlkZXJzKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChyZXNvbHZlZFByb3ZpZGVyKSB7IHJldHVybiBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbihyZXNvbHZlZFByb3ZpZGVyLnRva2VuKTsgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLl9nZXRRdWVyaWVzRm9yID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHZhciBjdXJyZW50RWwgPSB0aGlzO1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XG4gICAgICAgICAgdmFyIHF1ZXJpZXM7XG4gICAgICAgICAgd2hpbGUgKCFjdXJyZW50RWwuaXNOdWxsKCkpIHtcbiAgICAgICAgICAgICAgcXVlcmllcyA9IGN1cnJlbnRFbC5fcXVlcmllcy5nZXQodG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChxdWVyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsKHJlc3VsdCwgcXVlcmllcy5maWx0ZXIoZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBxdWVyeS5tZXRhLmRlc2NlbmRhbnRzIHx8IGRpc3RhbmNlIDw9IDE7IH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY3VycmVudEVsLl9kaXJlY3RpdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VycmVudEVsID0gY3VycmVudEVsLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVlcmllcyA9IHRoaXMudmlldy5jb21wb25lbnRWaWV3LnZpZXdRdWVyaWVzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQocXVlcmllcykpIHtcbiAgICAgICAgICAgICAgTGlzdFdyYXBwZXIuYWRkQWxsKHJlc3VsdCwgcXVlcmllcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUVsZW1lbnQucHJvdG90eXBlLl9hZGRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gXCJfcXVlcnlfXCIgKyBxdWVyeU1ldGEuc2VsZWN0b3JzWzBdLm5hbWUgKyBcIl9cIiArIHRoaXMubm9kZUluZGV4ICsgXCJfXCIgKyB0aGlzLl9xdWVyeUNvdW50Kys7XG4gICAgICAgICAgdmFyIHF1ZXJ5TGlzdCA9IGNyZWF0ZVF1ZXJ5TGlzdChxdWVyeU1ldGEsIGRpcmVjdGl2ZUluc3RhbmNlLCBwcm9wTmFtZSwgdGhpcy52aWV3KTtcbiAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgQ29tcGlsZVF1ZXJ5KHF1ZXJ5TWV0YSwgcXVlcnlMaXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgdGhpcy52aWV3KTtcbiAgICAgICAgICBhZGRRdWVyeVRvVG9rZW5NYXAodGhpcy5fcXVlcmllcywgcXVlcnkpO1xuICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRWxlbWVudC5wcm90b3R5cGUuX2dldExvY2FsRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXApIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAvLyBjb25zdHJ1Y3RvciBjb250ZW50IHF1ZXJ5XG4gICAgICAgICAgaWYgKCFyZXN1bHQgJiYgaXNQcmVzZW50KGRlcC5xdWVyeSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fYWRkUXVlcnkoZGVwLnF1ZXJ5LCBudWxsKS5xdWVyeUxpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbnN0cnVjdG9yIHZpZXcgcXVlcnlcbiAgICAgICAgICBpZiAoIXJlc3VsdCAmJiBpc1ByZXNlbnQoZGVwLnZpZXdRdWVyeSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3JlYXRlUXVlcnlMaXN0KGRlcC52aWV3UXVlcnksIG51bGwsIFwiX3ZpZXdRdWVyeV9cIiArIGRlcC52aWV3UXVlcnkuc2VsZWN0b3JzWzBdLm5hbWUgKyBcIl9cIiArIHRoaXMubm9kZUluZGV4ICsgXCJfXCIgKyB0aGlzLl9jb21wb25lbnRDb25zdHJ1Y3RvclZpZXdRdWVyeUxpc3RzLmxlbmd0aCwgdGhpcy52aWV3KTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcnlMaXN0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVwLnRva2VuKSkge1xuICAgICAgICAgICAgICAvLyBhY2Nlc3MgYnVpbHRpbnMgd2l0aCBzcGVjaWFsIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChkZXAudG9rZW4ucmVmZXJlbmNlID09PVxuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JSZWYpLnJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBWaWV3RXhwci5wcm9wKCdyZWYnKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUluVmlldyhUSElTX0VYUFIucHJvcCgncmVmJyksIHRoaXMudmlldywgdGhpcy52aWV3LmNvbXBvbmVudFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBhY2Nlc3MgcmVndWxhciBwcm92aWRlcnMgb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fcmVzb2x2ZWRQcm92aWRlcnMuZ2V0KGRlcC50b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWxsb3cgZGlyZWN0aXZlcyAvIHB1YmxpYyBzZXJ2aWNlcyB0byBhY2Nlc3MgcHJpdmF0ZSBzZXJ2aWNlcy5cbiAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY29tcG9uZW50cyBhbmQgcHJpdmF0ZSBzZXJ2aWNlcyBjYW4gYWNjZXNzIHByaXZhdGUgc2VydmljZXMuXG4gICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQcm92aWRlciAmJiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gZXhwb3J0cy5Qcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaW5zdGFuY2VzLmdldChkZXAudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFbGVtZW50LnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXApIHtcbiAgICAgICAgICB2YXIgY3VyckVsZW1lbnQgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgIGlmIChkZXAuaXNWYWx1ZSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBsaXRlcmFsKGRlcC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0ICYmICFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbERlcGVuZGVuY3kocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY2hlY2sgcGFyZW50IGVsZW1lbnRzXG4gICAgICAgICAgd2hpbGUgKCFyZXN1bHQgJiYgIWN1cnJFbGVtZW50LnBhcmVudC5pc051bGwoKSkge1xuICAgICAgICAgICAgICBjdXJyRWxlbWVudCA9IGN1cnJFbGVtZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gY3VyckVsZW1lbnQuX2dldExvY2FsRGVwZW5kZW5jeShleHBvcnRzLlByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBuZXcgQ29tcGlsZURpRGVwZW5kZW5jeU1ldGFkYXRhKHsgdG9rZW46IGRlcC50b2tlbiB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGluamVjdEZyb21WaWV3UGFyZW50SW5qZWN0b3IoZGVwLnRva2VuLCBkZXAuaXNPcHRpb25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IE5VTExfRVhQUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldFByb3BlcnR5SW5WaWV3KHJlc3VsdCwgdGhpcy52aWV3LCBjdXJyRWxlbWVudC52aWV3KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZUVsZW1lbnQ7XG4gIH0oQ29tcGlsZU5vZGUpKTtcbiAgZnVuY3Rpb24gY3JlYXRlSW5qZWN0SW50ZXJuYWxDb25kaXRpb24obm9kZUluZGV4LCBjaGlsZE5vZGVDb3VudCwgcHJvdmlkZXIsIHByb3ZpZGVyRXhwcikge1xuICAgICAgdmFyIGluZGV4Q29uZGl0aW9uO1xuICAgICAgaWYgKGNoaWxkTm9kZUNvdW50ID4gMCkge1xuICAgICAgICAgIGluZGV4Q29uZGl0aW9uID0gbGl0ZXJhbChub2RlSW5kZXgpXG4gICAgICAgICAgICAgIC5sb3dlckVxdWFscyhJbmplY3RNZXRob2RWYXJzLnJlcXVlc3ROb2RlSW5kZXgpXG4gICAgICAgICAgICAgIC5hbmQoSW5qZWN0TWV0aG9kVmFycy5yZXF1ZXN0Tm9kZUluZGV4Lmxvd2VyRXF1YWxzKGxpdGVyYWwobm9kZUluZGV4ICsgY2hpbGROb2RlQ291bnQpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBpbmRleENvbmRpdGlvbiA9IGxpdGVyYWwobm9kZUluZGV4KS5pZGVudGljYWwoSW5qZWN0TWV0aG9kVmFycy5yZXF1ZXN0Tm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgSWZTdG10KEluamVjdE1ldGhvZFZhcnMudG9rZW4uaWRlbnRpY2FsKGNyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHByb3ZpZGVyLnRva2VuKSkuYW5kKGluZGV4Q29uZGl0aW9uKSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQocHJvdmlkZXJFeHByKV0pO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3ZpZGVyUHJvcGVydHkocHJvcE5hbWUsIHByb3ZpZGVyLCBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMsIGlzTXVsdGksIGlzRWFnZXIsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgICB2YXIgdmlldyA9IGNvbXBpbGVFbGVtZW50LnZpZXc7XG4gICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcjtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgaWYgKGlzTXVsdGkpIHtcbiAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gbGl0ZXJhbEFycihwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMpO1xuICAgICAgICAgIHR5cGUgPSBuZXcgQXJyYXlUeXBlKERZTkFNSUNfVFlQRSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zWzBdO1xuICAgICAgICAgIHR5cGUgPSBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnNbMF0udHlwZTtcbiAgICAgIH1cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHR5cGUgPSBEWU5BTUlDX1RZUEU7XG4gICAgICB9XG4gICAgICBpZiAoaXNFYWdlcikge1xuICAgICAgICAgIHZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQocHJvcE5hbWUsIHR5cGUpKTtcbiAgICAgICAgICB2aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKHByb3BOYW1lKS5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGludGVybmFsRmllbGQgPSBcIl9cIiArIHByb3BOYW1lO1xuICAgICAgICAgIHZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoaW50ZXJuYWxGaWVsZCwgdHlwZSkpO1xuICAgICAgICAgIHZhciBnZXR0ZXIgPSBuZXcgQ29tcGlsZU1ldGhvZCh2aWV3KTtcbiAgICAgICAgICBnZXR0ZXIucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBjb21waWxlRWxlbWVudC5zb3VyY2VBc3QpO1xuICAgICAgICAgIC8vIE5vdGU6IEVxdWFscyBpcyBpbXBvcnRhbnQgZm9yIEpTIHNvIHRoYXQgaXQgYWxzbyBjaGVja3MgdGhlIHVuZGVmaW5lZCBjYXNlIVxuICAgICAgICAgIGdldHRlci5hZGRTdG10KG5ldyBJZlN0bXQoVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkuaXNCbGFuaygpLCBbVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkuc2V0KHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIpLnRvU3RtdCgpXSkpO1xuICAgICAgICAgIGdldHRlci5hZGRTdG10KG5ldyBSZXR1cm5TdGF0ZW1lbnQoVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkpKTtcbiAgICAgICAgICB2aWV3LmdldHRlcnMucHVzaChuZXcgQ2xhc3NHZXR0ZXIocHJvcE5hbWUsIGdldHRlci5maW5pc2goKSwgdHlwZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRISVNfRVhQUi5wcm9wKHByb3BOYW1lKTtcbiAgfVxuICB2YXIgX1F1ZXJ5V2l0aFJlYWQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX1F1ZXJ5V2l0aFJlYWQocXVlcnksIG1hdGNoKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgIHRoaXMucmVhZCA9IGlzUHJlc2VudChxdWVyeS5tZXRhLnJlYWQpID8gcXVlcnkubWV0YS5yZWFkIDogbWF0Y2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gX1F1ZXJ5V2l0aFJlYWQ7XG4gIH0oKSk7XG5cbiAgdmFyIENvbXBpbGVQaXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVQaXBlKHZpZXcsIG1ldGEpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgICAgICB0aGlzLl9wdXJlUGlwZVByb3h5Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBUSElTX0VYUFIucHJvcChcIl9waXBlX1wiICsgbWV0YS5uYW1lICsgXCJfXCIgKyB2aWV3LnBpcGVDb3VudCsrKTtcbiAgICAgICAgICB2YXIgZGVwcyA9IHRoaXMubWV0YS50eXBlLmRpRGVwcy5tYXAoZnVuY3Rpb24gKGRpRGVwKSB7XG4gICAgICAgICAgICAgIGlmIChkaURlcC50b2tlbi5yZWZlcmVuY2UgPT09XG4gICAgICAgICAgICAgICAgICByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUluVmlldyhUSElTX0VYUFIucHJvcCgncmVmJyksIF90aGlzLnZpZXcsIF90aGlzLnZpZXcuY29tcG9uZW50Vmlldyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGluamVjdEZyb21WaWV3UGFyZW50SW5qZWN0b3IoZGlEZXAudG9rZW4sIGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQodGhpcy5pbnN0YW5jZS5uYW1lLCBpbXBvcnRUeXBlKHRoaXMubWV0YS50eXBlKSkpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QucmVzZXREZWJ1Z0luZm8obnVsbCwgbnVsbCk7XG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KFRISVNfRVhQUi5wcm9wKHRoaXMuaW5zdGFuY2UubmFtZSlcbiAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHRoaXMubWV0YS50eXBlKS5pbnN0YW50aWF0ZShkZXBzKSlcbiAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgICAgIENvbXBpbGVQaXBlLmNhbGwgPSBmdW5jdGlvbiAodmlldywgbmFtZSwgYXJncykge1xuICAgICAgICAgIHZhciBjb21wVmlldyA9IHZpZXcuY29tcG9uZW50VmlldztcbiAgICAgICAgICB2YXIgbWV0YSA9IF9maW5kUGlwZU1ldGEoY29tcFZpZXcsIG5hbWUpO1xuICAgICAgICAgIHZhciBwaXBlO1xuICAgICAgICAgIGlmIChtZXRhLnB1cmUpIHtcbiAgICAgICAgICAgICAgLy8gcHVyZSBwaXBlcyBsaXZlIG9uIHRoZSBjb21wb25lbnQgdmlld1xuICAgICAgICAgICAgICBwaXBlID0gY29tcFZpZXcucHVyZVBpcGVzLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKCFwaXBlKSB7XG4gICAgICAgICAgICAgICAgICBwaXBlID0gbmV3IENvbXBpbGVQaXBlKGNvbXBWaWV3LCBtZXRhKTtcbiAgICAgICAgICAgICAgICAgIGNvbXBWaWV3LnB1cmVQaXBlcy5zZXQobmFtZSwgcGlwZSk7XG4gICAgICAgICAgICAgICAgICBjb21wVmlldy5waXBlcy5wdXNoKHBpcGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb24gcHVyZSBwaXBlcyBsaXZlIG9uIHRoZSB2aWV3IHRoYXQgY2FsbGVkIGl0XG4gICAgICAgICAgICAgIHBpcGUgPSBuZXcgQ29tcGlsZVBpcGUodmlldywgbWV0YSk7XG4gICAgICAgICAgICAgIHZpZXcucGlwZXMucHVzaChwaXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBpcGUuX2NhbGwodmlldywgYXJncyk7XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVQaXBlLnByb3RvdHlwZSwgXCJwdXJlXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubWV0YS5wdXJlOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIENvbXBpbGVQaXBlLnByb3RvdHlwZS5fY2FsbCA9IGZ1bmN0aW9uIChjYWxsaW5nVmlldywgYXJncykge1xuICAgICAgICAgIGlmICh0aGlzLm1ldGEucHVyZSkge1xuICAgICAgICAgICAgICAvLyBQdXJlUGlwZVByb3hpZXMgbGl2ZSBvbiB0aGUgdmlldyB0aGF0IGNhbGxlZCB0aGVtLlxuICAgICAgICAgICAgICB2YXIgcHVyZVBpcGVQcm94eUluc3RhbmNlID0gVEhJU19FWFBSLnByb3AodGhpcy5pbnN0YW5jZS5uYW1lICsgXCJfXCIgKyB0aGlzLl9wdXJlUGlwZVByb3h5Q291bnQrKyk7XG4gICAgICAgICAgICAgIHZhciBwaXBlSW5zdGFuY2VTZWVuRnJvbVB1cmVQcm94eSA9IGdldFByb3BlcnR5SW5WaWV3KHRoaXMuaW5zdGFuY2UsIGNhbGxpbmdWaWV3LCB0aGlzLnZpZXcpO1xuICAgICAgICAgICAgICBjcmVhdGVQdXJlUHJveHkocGlwZUluc3RhbmNlU2VlbkZyb21QdXJlUHJveHkucHJvcCgndHJhbnNmb3JtJylcbiAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQmluZCwgW3BpcGVJbnN0YW5jZVNlZW5Gcm9tUHVyZVByb3h5XSksIGFyZ3MubGVuZ3RoLCBwdXJlUGlwZVByb3h5SW5zdGFuY2UsIGNhbGxpbmdWaWV3KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY2FzdEJ5VmFsdWUpKVxuICAgICAgICAgICAgICAgICAgLmNhbGxGbihbcHVyZVBpcGVQcm94eUluc3RhbmNlLCBwaXBlSW5zdGFuY2VTZWVuRnJvbVB1cmVQcm94eS5wcm9wKCd0cmFuc2Zvcm0nKV0pXG4gICAgICAgICAgICAgICAgICAuY2FsbEZuKGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFByb3BlcnR5SW5WaWV3KHRoaXMuaW5zdGFuY2UsIGNhbGxpbmdWaWV3LCB0aGlzLnZpZXcpLmNhbGxNZXRob2QoJ3RyYW5zZm9ybScsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZVBpcGU7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9maW5kUGlwZU1ldGEodmlldywgbmFtZSkge1xuICAgICAgdmFyIHBpcGVNZXRhID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSB2aWV3LnBpcGVNZXRhcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBsb2NhbFBpcGVNZXRhID0gdmlldy5waXBlTWV0YXNbaV07XG4gICAgICAgICAgaWYgKGxvY2FsUGlwZU1ldGEubmFtZSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgIHBpcGVNZXRhID0gbG9jYWxQaXBlTWV0YTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwaXBlTWV0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvdWxkIG5vdCBmaW5kIHBpcGUgXCIgKyBuYW1lICsgXCIgYWx0aG91Z2ggdGhlIHBhcnNlciBzaG91bGQgaGF2ZSBkZXRlY3RlZCB0aGlzIGVycm9yIVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwaXBlTWV0YTtcbiAgfVxuXG4gIHZhciBDb21waWxlVmlldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlVmlldyhjb21wb25lbnQsIGdlbkNvbmZpZywgcGlwZU1ldGFzLCBzdHlsZXMsIGFuaW1hdGlvbnMsIHZpZXdJbmRleCwgZGVjbGFyYXRpb25FbGVtZW50LCB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgIHRoaXMuZ2VuQ29uZmlnID0gZ2VuQ29uZmlnO1xuICAgICAgICAgIHRoaXMucGlwZU1ldGFzID0gcGlwZU1ldGFzO1xuICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG4gICAgICAgICAgdGhpcy52aWV3SW5kZXggPSB2aWV3SW5kZXg7XG4gICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkVsZW1lbnQgPSBkZWNsYXJhdGlvbkVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MgPSB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3M7XG4gICAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICAgIC8vIHJvb3Qgbm9kZXMgb3IgQXBwRWxlbWVudHMgZm9yIFZpZXdDb250YWluZXJzXG4gICAgICAgICAgdGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzID0gW107XG4gICAgICAgICAgdGhpcy5iaW5kaW5ncyA9IFtdO1xuICAgICAgICAgIHRoaXMuY2xhc3NTdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJNZXRob2RzID0gW107XG4gICAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2FibGVzID0gW107XG4gICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgICAgdGhpcy5wdXJlUGlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5waXBlcyA9IFtdO1xuICAgICAgICAgIHRoaXMubG9jYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMubGl0ZXJhbEFycmF5Q291bnQgPSAwO1xuICAgICAgICAgIHRoaXMubGl0ZXJhbE1hcENvdW50ID0gMDtcbiAgICAgICAgICB0aGlzLnBpcGVDb3VudCA9IDA7XG4gICAgICAgICAgdGhpcy5jcmVhdGVNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbkJpbmRpbmdzTWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5pbmplY3RvckdldE1ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZCA9IG5ldyBDb21waWxlTWV0aG9kKHRoaXMpO1xuICAgICAgICAgIHRoaXMuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5kZXN0cm95TWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QodGhpcyk7XG4gICAgICAgICAgdGhpcy5kZXRhY2hNZXRob2QgPSBuZXcgQ29tcGlsZU1ldGhvZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLnZpZXdUeXBlID0gZ2V0Vmlld1R5cGUoY29tcG9uZW50LCB2aWV3SW5kZXgpO1xuICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJfVmlld19cIiArIGNvbXBvbmVudC50eXBlLm5hbWUgKyB2aWV3SW5kZXg7XG4gICAgICAgICAgdGhpcy5jbGFzc1R5cGUgPSBpbXBvcnRUeXBlKG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogdGhpcy5jbGFzc05hbWUgfSkpO1xuICAgICAgICAgIHRoaXMudmlld0ZhY3RvcnkgPSB2YXJpYWJsZShnZXRWaWV3RmFjdG9yeU5hbWUoY29tcG9uZW50LCB2aWV3SW5kZXgpKTtcbiAgICAgICAgICBpZiAodGhpcy52aWV3VHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UIHx8IHRoaXMudmlld1R5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRWaWV3ID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VmlldyA9IHRoaXMuZGVjbGFyYXRpb25FbGVtZW50LnZpZXcuY29tcG9uZW50VmlldztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jb21wb25lbnRDb250ZXh0ID1cbiAgICAgICAgICAgICAgZ2V0UHJvcGVydHlJblZpZXcoVEhJU19FWFBSLnByb3AoJ2NvbnRleHQnKSwgdGhpcywgdGhpcy5jb21wb25lbnRWaWV3KTtcbiAgICAgICAgICB2YXIgdmlld1F1ZXJpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgaWYgKHRoaXMudmlld1R5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBUSElTX0VYUFIucHJvcCgnY29udGV4dCcpO1xuICAgICAgICAgICAgICBMaXN0V3JhcHBlci5mb3JFYWNoV2l0aEluZGV4KHRoaXMuY29tcG9uZW50LnZpZXdRdWVyaWVzLCBmdW5jdGlvbiAocXVlcnlNZXRhLCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBcIl92aWV3UXVlcnlfXCIgKyBxdWVyeU1ldGEuc2VsZWN0b3JzWzBdLm5hbWUgKyBcIl9cIiArIHF1ZXJ5SW5kZXg7XG4gICAgICAgICAgICAgICAgICB2YXIgcXVlcnlMaXN0ID0gY3JlYXRlUXVlcnlMaXN0KHF1ZXJ5TWV0YSwgZGlyZWN0aXZlSW5zdGFuY2UsIHByb3BOYW1lLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgQ29tcGlsZVF1ZXJ5KHF1ZXJ5TWV0YSwgcXVlcnlMaXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgYWRkUXVlcnlUb1Rva2VuTWFwKHZpZXdRdWVyaWVzLCBxdWVyeSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB2YXIgY29uc3RydWN0b3JWaWV3UXVlcnlDb3VudCA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnR5cGUuZGlEZXBzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZXAudmlld1F1ZXJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeUxpc3QgPSBUSElTX0VYUFIucHJvcCgnZGVjbGFyYXRpb25BcHBFbGVtZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb3AoJ2NvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJpZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAua2V5KGxpdGVyYWwoY29uc3RydWN0b3JWaWV3UXVlcnlDb3VudCsrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IENvbXBpbGVRdWVyeShkZXAudmlld1F1ZXJ5LCBxdWVyeUxpc3QsIG51bGwsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRRdWVyeVRvVG9rZW5NYXAodmlld1F1ZXJpZXMsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSB2aWV3UXVlcmllcztcbiAgICAgICAgICB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgX3RoaXMubG9jYWxzLnNldChlbnRyeVsxXSwgVEhJU19FWFBSLnByb3AoJ2NvbnRleHQnKS5wcm9wKGVudHJ5WzBdKSk7IH0pO1xuICAgICAgICAgIGlmICghdGhpcy5kZWNsYXJhdGlvbkVsZW1lbnQuaXNOdWxsKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkVsZW1lbnQuc2V0RW1iZWRkZWRWaWV3KHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIENvbXBpbGVWaWV3LnByb3RvdHlwZS5jYWxsUGlwZSA9IGZ1bmN0aW9uIChuYW1lLCBpbnB1dCwgYXJncykge1xuICAgICAgICAgIHJldHVybiBDb21waWxlUGlwZS5jYWxsKHRoaXMsIG5hbWUsIFtpbnB1dF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlVmlldy5wcm90b3R5cGUuZ2V0TG9jYWwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGlmIChuYW1lID09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycy5ldmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGN1cnJWaWV3ID0gdGhpcztcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gY3VyclZpZXcubG9jYWxzLmdldChuYW1lKTtcbiAgICAgICAgICB3aGlsZSAoIXJlc3VsdCAmJiBpc1ByZXNlbnQoY3VyclZpZXcuZGVjbGFyYXRpb25FbGVtZW50LnZpZXcpKSB7XG4gICAgICAgICAgICAgIGN1cnJWaWV3ID0gY3VyclZpZXcuZGVjbGFyYXRpb25FbGVtZW50LnZpZXc7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnJWaWV3LmxvY2Fscy5nZXQobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQocmVzdWx0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0UHJvcGVydHlJblZpZXcocmVzdWx0LCB0aGlzLCBjdXJyVmlldyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQ29tcGlsZVZpZXcucHJvdG90eXBlLmNyZWF0ZUxpdGVyYWxBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5FTVBUWV9BUlJBWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJveHlFeHByID0gVEhJU19FWFBSLnByb3AoXCJfYXJyX1wiICsgdGhpcy5saXRlcmFsQXJyYXlDb3VudCsrKTtcbiAgICAgICAgICB2YXIgcHJveHlQYXJhbXMgPSBbXTtcbiAgICAgICAgICB2YXIgcHJveHlSZXR1cm5FbnRyaWVzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IFwicFwiICsgaTtcbiAgICAgICAgICAgICAgcHJveHlQYXJhbXMucHVzaChuZXcgRm5QYXJhbShwYXJhbU5hbWUpKTtcbiAgICAgICAgICAgICAgcHJveHlSZXR1cm5FbnRyaWVzLnB1c2godmFyaWFibGUocGFyYW1OYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNyZWF0ZVB1cmVQcm94eShmbihwcm94eVBhcmFtcywgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihwcm94eVJldHVybkVudHJpZXMpKV0sIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFKSksIHZhbHVlcy5sZW5ndGgsIHByb3h5RXhwciwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHByb3h5RXhwci5jYWxsRm4odmFsdWVzKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlVmlldy5wcm90b3R5cGUuY3JlYXRlTGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVNUFRZX01BUCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJveHlFeHByID0gVEhJU19FWFBSLnByb3AoXCJfbWFwX1wiICsgdGhpcy5saXRlcmFsTWFwQ291bnQrKyk7XG4gICAgICAgICAgdmFyIHByb3h5UGFyYW1zID0gW107XG4gICAgICAgICAgdmFyIHByb3h5UmV0dXJuRW50cmllcyA9IFtdO1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IFwicFwiICsgaTtcbiAgICAgICAgICAgICAgcHJveHlQYXJhbXMucHVzaChuZXcgRm5QYXJhbShwYXJhbU5hbWUpKTtcbiAgICAgICAgICAgICAgcHJveHlSZXR1cm5FbnRyaWVzLnB1c2goW2VudHJpZXNbaV1bMF0sIHZhcmlhYmxlKHBhcmFtTmFtZSldKTtcbiAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZW50cmllc1tpXVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNyZWF0ZVB1cmVQcm94eShmbihwcm94eVBhcmFtcywgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbE1hcChwcm94eVJldHVybkVudHJpZXMpKV0sIG5ldyBNYXBUeXBlKERZTkFNSUNfVFlQRSkpLCBlbnRyaWVzLmxlbmd0aCwgcHJveHlFeHByLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm4gcHJveHlFeHByLmNhbGxGbih2YWx1ZXMpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVWaWV3LnByb3RvdHlwZS5hZnRlck5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgTWFwV3JhcHBlci52YWx1ZXModGhpcy52aWV3UXVlcmllcylcbiAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJpZXMpIHsgcmV0dXJuIHF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnkpIHsgcmV0dXJuIHF1ZXJ5LmFmdGVyQ2hpbGRyZW4oX3RoaXMuY3JlYXRlTWV0aG9kLCBfdGhpcy51cGRhdGVWaWV3UXVlcmllc01ldGhvZCk7IH0pOyB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZVZpZXc7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGdldFZpZXdUeXBlKGNvbXBvbmVudCwgZW1iZWRkZWRUZW1wbGF0ZUluZGV4KSB7XG4gICAgICBpZiAoZW1iZWRkZWRUZW1wbGF0ZUluZGV4ID4gMCkge1xuICAgICAgICAgIHJldHVybiBWaWV3VHlwZS5FTUJFRERFRDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC50eXBlLmlzSG9zdCkge1xuICAgICAgICAgIHJldHVybiBWaWV3VHlwZS5IT1NUO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFZpZXdUeXBlLkNPTVBPTkVOVDtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIENvbXBpbGVCaW5kaW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVCaW5kaW5nKG5vZGUsIHNvdXJjZUFzdCkge1xuICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgdGhpcy5zb3VyY2VBc3QgPSBzb3VyY2VBc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gQ29tcGlsZUJpbmRpbmc7XG4gIH0oKSk7XG5cbiAgdmFyIEV4cHJlc3Npb25XaXRoV3JhcHBlZFZhbHVlSW5mbyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBFeHByZXNzaW9uV2l0aFdyYXBwZWRWYWx1ZUluZm8oZXhwcmVzc2lvbiwgbmVlZHNWYWx1ZVVud3JhcHBlciwgdGVtcG9yYXJ5Q291bnQpIHtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMubmVlZHNWYWx1ZVVud3JhcHBlciA9IG5lZWRzVmFsdWVVbndyYXBwZXI7XG4gICAgICAgICAgdGhpcy50ZW1wb3JhcnlDb3VudCA9IHRlbXBvcmFyeUNvdW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIEV4cHJlc3Npb25XaXRoV3JhcHBlZFZhbHVlSW5mbztcbiAgfSgpKTtcbiAgZnVuY3Rpb24gY29udmVydENkRXhwcmVzc2lvblRvSXIobmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBleHByZXNzaW9uLCB2YWx1ZVVud3JhcHBlciwgYmluZGluZ0luZGV4KSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IobmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCB2YWx1ZVVud3JhcHBlciwgYmluZGluZ0luZGV4KTtcbiAgICAgIHZhciBpckFzdCA9IGV4cHJlc3Npb24udmlzaXQodmlzaXRvciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25XaXRoV3JhcHBlZFZhbHVlSW5mbyhpckFzdCwgdmlzaXRvci5uZWVkc1ZhbHVlVW53cmFwcGVyLCB2aXNpdG9yLnRlbXBvcmFyeUNvdW50KTtcbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0Q2RTdGF0ZW1lbnRUb0lyKG5hbWVSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgc3RtdCwgYmluZGluZ0luZGV4KSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IobmFtZVJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBudWxsLCBiaW5kaW5nSW5kZXgpO1xuICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgIGZsYXR0ZW5TdGF0ZW1lbnRzKHN0bXQudmlzaXQodmlzaXRvciwgX01vZGUuU3RhdGVtZW50KSwgc3RhdGVtZW50cyk7XG4gICAgICBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModmlzaXRvci50ZW1wb3JhcnlDb3VudCwgYmluZGluZ0luZGV4LCBzdGF0ZW1lbnRzKTtcbiAgICAgIHJldHVybiBzdGF0ZW1lbnRzO1xuICB9XG4gIGZ1bmN0aW9uIHRlbXBvcmFyeU5hbWUoYmluZGluZ0luZGV4LCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICAgIHJldHVybiBcInRtcF9cIiArIGJpbmRpbmdJbmRleCArIFwiX1wiICsgdGVtcG9yYXJ5TnVtYmVyO1xuICB9XG4gIGZ1bmN0aW9uIHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJbmRleCwgdGVtcG9yYXJ5TnVtYmVyKSB7XG4gICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHRlbXBvcmFyeU5hbWUoYmluZGluZ0luZGV4LCB0ZW1wb3JhcnlOdW1iZXIpLCBOVUxMX0VYUFIpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBlbmRUZW1wb3JhcnlEZWNscyh0ZW1wb3JhcnlDb3VudCwgYmluZGluZ0luZGV4LCBzdGF0ZW1lbnRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGVtcG9yYXJ5Q291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHN0YXRlbWVudHMudW5zaGlmdCh0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSW5kZXgsIGkpKTtcbiAgICAgIH1cbiAgfVxuICB2YXIgX01vZGU7XG4gIChmdW5jdGlvbiAoX01vZGUpIHtcbiAgICAgIF9Nb2RlW19Nb2RlW1wiU3RhdGVtZW50XCJdID0gMF0gPSBcIlN0YXRlbWVudFwiO1xuICAgICAgX01vZGVbX01vZGVbXCJFeHByZXNzaW9uXCJdID0gMV0gPSBcIkV4cHJlc3Npb25cIjtcbiAgfSkoX01vZGUgfHwgKF9Nb2RlID0ge30pKTtcbiAgZnVuY3Rpb24gZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpIHtcbiAgICAgIGlmIChtb2RlICE9PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHN0YXRlbWVudCwgYnV0IHNhdyBcIiArIGFzdCk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KSB7XG4gICAgICBpZiAobW9kZSAhPT0gX01vZGUuRXhwcmVzc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGFuIGV4cHJlc3Npb24sIGJ1dCBzYXcgXCIgKyBhc3QpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGV4cHIpIHtcbiAgICAgIGlmIChtb2RlID09PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZXhwci50b1N0bXQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgfVxuICB9XG4gIHZhciBfQXN0VG9JclZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0FzdFRvSXJWaXNpdG9yKF9uYW1lUmVzb2x2ZXIsIF9pbXBsaWNpdFJlY2VpdmVyLCBfdmFsdWVVbndyYXBwZXIsIGJpbmRpbmdJbmRleCkge1xuICAgICAgICAgIHRoaXMuX25hbWVSZXNvbHZlciA9IF9uYW1lUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlciA9IF9pbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICAgIHRoaXMuX3ZhbHVlVW53cmFwcGVyID0gX3ZhbHVlVW53cmFwcGVyO1xuICAgICAgICAgIHRoaXMuYmluZGluZ0luZGV4ID0gYmluZGluZ0luZGV4O1xuICAgICAgICAgIHRoaXMuX25vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fcmVzdWx0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUZW1wb3JhcnkgPSAwO1xuICAgICAgICAgIHRoaXMubmVlZHNWYWx1ZVVud3JhcHBlciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSAwO1xuICAgICAgfVxuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgb3A7XG4gICAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5QbHVzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5NaW51cztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkRpdmlkZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTW9kdWxvO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQW5kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuT3I7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5FcXVhbHM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTG93ZXI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBvcGVyYXRpb24gXCIgKyBhc3Qub3BlcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIob3AsIHRoaXMudmlzaXQoYXN0LmxlZnQsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLnZpc2l0KGFzdC5yaWdodCwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hhaW4gPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgbW9kZSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmlzaXQoYXN0LmNvbmRpdGlvbiwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHZhbHVlLmNvbmRpdGlvbmFsKHRoaXMudmlzaXQoYXN0LnRydWVFeHAsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLnZpc2l0KGFzdC5mYWxzZUV4cCwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLnZpc2l0KGFzdC5leHAsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fbmFtZVJlc29sdmVyLmNhbGxQaXBlKGFzdC5uYW1lLCBpbnB1dCwgYXJncyk7XG4gICAgICAgICAgdGhpcy5uZWVkc1ZhbHVlVW53cmFwcGVyID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy5fdmFsdWVVbndyYXBwZXIuY2FsbE1ldGhvZCgndW53cmFwJywgW3ZhbHVlXSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMudmlzaXQoYXN0LnRhcmdldCwgX01vZGUuRXhwcmVzc2lvbikuY2FsbEZuKHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICAgIHZhciBhcmdzID0gW2xpdGVyYWwoYXN0LmV4cHJlc3Npb25zLmxlbmd0aCldO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2ldKSk7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uc1tpXSwgX01vZGUuRXhwcmVzc2lvbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbChhc3Quc3RyaW5nc1thc3Quc3RyaW5ncy5sZW5ndGggLSAxXSkpO1xuICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLmludGVycG9sYXRlKSkuY2FsbEZuKGFyZ3MpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMudmlzaXQoYXN0Lm9iaiwgX01vZGUuRXhwcmVzc2lvbikua2V5KHRoaXMudmlzaXQoYXN0LmtleSwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgb2JqID0gdGhpcy52aXNpdChhc3Qub2JqLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICB2YXIga2V5ID0gdGhpcy52aXNpdChhc3Qua2V5LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG9iai5rZXkoa2V5KS5zZXQodmFsdWUpKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0aGlzLl9uYW1lUmVzb2x2ZXIuY3JlYXRlTGl0ZXJhbEFycmF5KHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBtb2RlKSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXN0LmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChbYXN0LmtleXNbaV0sIHRoaXMudmlzaXQoYXN0LnZhbHVlc1tpXSwgX01vZGUuRXhwcmVzc2lvbildKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMuX25hbWVSZXNvbHZlci5jcmVhdGVMaXRlcmFsTWFwKHBhcnRzKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGxpdGVyYWwoYXN0LnZhbHVlKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgdmFyIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFyRXhwciA9IHRoaXMuX25hbWVSZXNvbHZlci5nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHZhckV4cHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFyRXhwci5jYWxsRm4oYXJncyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzQmxhbmsocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY2FsbE1ldGhvZChhc3QubmFtZSwgYXJncyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5vdCh0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgdmFyIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9uYW1lUmVzb2x2ZXIuZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc0JsYW5rKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLnByb3AoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgIHZhciB2YXJFeHByID0gdGhpcy5fbmFtZVJlc29sdmVyLmdldExvY2FsKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh2YXJFeHByKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIGEgcmVmZXJlbmNlIG9yIHZhcmlhYmxlIScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCByZWNlaXZlci5wcm9wKGFzdC5uYW1lKS5zZXQodGhpcy52aXNpdChhc3QudmFsdWUsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KSwgbW9kZSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGwgPSBmdW5jdGlvbiAoYXN0cywgbW9kZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFzdHMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIF90aGlzLnZpc2l0KGFzdCwgbW9kZSk7IH0pO1xuICAgICAgfTtcbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1b3RlcyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgZXZhbHVhdGlvbiEnKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9yZXN1bHRNYXAuZ2V0KGFzdCk7XG4gICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICByZXR1cm4gKHRoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh0aGlzLCBtb2RlKTtcbiAgICAgIH07XG4gICAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLmNvbnZlcnRTYWZlQWNjZXNzID0gZnVuY3Rpb24gKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGV4cHJlc3Npb24gY29udGFpbnMgYSBzYWZlIGFjY2VzcyBub2RlIG9uIHRoZSBsZWZ0IGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0b1xuICAgICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgICAgLy8gZXhlY3V0aW9uIHByb2NlZWRzIGZyb20gbGVmdCB0byByaWdodCwgdGhlIGxlZnQgbW9zdCBwYXJ0IG9mIHRoZSBleHByZXNzaW9uIG11c3QgYmUgZ3VhcmRlZFxuICAgICAgICAgIC8vIGZpcnN0IGJ1dCwgYmVjYXVzZSBtZW1iZXIgYWNjZXNzIGlzIGxlZnQgYXNzb2NpYXRpdmUsIHRoZSByaWdodCBzaWRlIG9mIHRoZSBleHByZXNzaW9uIGlzIGF0XG4gICAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIHRoZSBsZWZ0IHBhcnQgb2YgdGhlXG4gICAgICAgICAgLy8gZXhwcmVzc2lvbiB1cCB0byB0ZXN0IGl0IGZvciBibGFuayBiZWZvcmUgZ2VuZXJhdGluZyB0aGUgdW5ndWFyZGVkIHZlcnNpb24uXG4gICAgICAgICAgLy8gQ29uc2lkZXIsIGZvciBleGFtcGxlIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbjogYT8uYi5jPy5kLmVcbiAgICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gdGhlIGFzdDpcbiAgICAgICAgICAvLyAgICAgICAgIC5cbiAgICAgICAgICAvLyAgICAgICAgLyBcXFxuICAgICAgICAgIC8vICAgICAgID8uICAgZVxuICAgICAgICAgIC8vICAgICAgLyAgXFxcbiAgICAgICAgICAvLyAgICAgLiAgICBkXG4gICAgICAgICAgLy8gICAgLyBcXFxuICAgICAgICAgIC8vICAgPy4gIGNcbiAgICAgICAgICAvLyAgLyAgXFxcbiAgICAgICAgICAvLyBhICAgIGJcbiAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHRyZWUgc2hvdWxkIGJlIGdlbmVyYXRlZDpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgICAgICAvLS0tLSA/IC0tLS1cXFxuICAgICAgICAgIC8vICAgICAgIC8gICAgICB8ICAgICAgXFxcbiAgICAgICAgICAvLyAgICAgYSAgIC8tLS0gPyAtLS1cXCAgbnVsbFxuICAgICAgICAgIC8vICAgICAgICAvICAgICB8ICAgICBcXFxuICAgICAgICAgIC8vICAgICAgIC4gICAgICAuICAgICBudWxsXG4gICAgICAgICAgLy8gICAgICAvIFxcICAgIC8gXFxcbiAgICAgICAgICAvLyAgICAgLiAgYyAgIC4gICBlXG4gICAgICAgICAgLy8gICAgLyBcXCAgICAvIFxcXG4gICAgICAgICAgLy8gICBhICAgYiAgLCAgIGRcbiAgICAgICAgICAvLyAgICAgICAgIC8gXFxcbiAgICAgICAgICAvLyAgICAgICAgLiAgIGNcbiAgICAgICAgICAvLyAgICAgICAvIFxcXG4gICAgICAgICAgLy8gICAgICBhICAgYlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gTm90aWNlIHRoYXQgdGhlIGZpcnN0IGd1YXJkIGNvbmRpdGlvbiBpcyB0aGUgbGVmdCBoYW5kIG9mIHRoZSBsZWZ0IG1vc3Qgc2FmZSBhY2Nlc3Mgbm9kZVxuICAgICAgICAgIC8vIHdoaWNoIGNvbWVzIGluIGFzIGxlZnRNb3N0U2FmZSB0byB0aGlzIHJvdXRpbmUuXG4gICAgICAgICAgdmFyIGd1YXJkZWRFeHByZXNzaW9uID0gdGhpcy52aXNpdChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgIHZhciB0ZW1wb3Jhcnk7XG4gICAgICAgICAgaWYgKHRoaXMubmVlZHNUZW1wb3JhcnkobGVmdE1vc3RTYWZlLnJlY2VpdmVyKSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBoYXMgbWV0aG9kIGNhbGxzIG9yIHBpcGVzIHRoZW4gd2UgbmVlZCB0byBzYXZlIHRoZSByZXN1bHQgaW50byBhXG4gICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBhdm9pZCBjYWxsaW5nIHN0YXRlZnVsIG9yIGltcHVyZSBjb2RlIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgICAgICB0ZW1wb3JhcnkgPSB0aGlzLmFsbG9jYXRlVGVtcG9yYXJ5KCk7XG4gICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSByZXN1bHQgaW4gdGhlIHRlbXBvcmFyeSB2YXJpYWJsZVxuICAgICAgICAgICAgICBndWFyZGVkRXhwcmVzc2lvbiA9IHRlbXBvcmFyeS5zZXQoZ3VhcmRlZEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAvLyBFbnN1cmUgYWxsIGZ1cnRoZXIgcmVmZXJlbmNlcyB0byB0aGUgZ3VhcmRlZCBleHByZXNzaW9uIHJlZmVyIHRvIHRoZSB0ZW1wb3JhcnkgaW5zdGVhZC5cbiAgICAgICAgICAgICAgdGhpcy5fcmVzdWx0TWFwLnNldChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIHRlbXBvcmFyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb25kaXRpb24gPSBndWFyZGVkRXhwcmVzc2lvbi5pc0JsYW5rKCk7XG4gICAgICAgICAgLy8gQ29udmVydCB0aGUgYXN0IHRvIGFuIHVuZ3VhcmRlZCBhY2Nlc3MgdG8gdGhlIHJlY2VpdmVyJ3MgbWVtYmVyLiBUaGUgbWFwIHdpbGwgc3Vic3RpdHV0ZVxuICAgICAgICAgIC8vIGxlZnRNb3N0Tm9kZSB3aXRoIGl0cyB1bmd1YXJkZWQgdmVyc2lvbiBpbiB0aGUgY2FsbCB0byBgdGhpcy52aXNpdCgpYC5cbiAgICAgICAgICBpZiAobGVmdE1vc3RTYWZlIGluc3RhbmNlb2YgU2FmZU1ldGhvZENhbGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgTWV0aG9kQ2FsbChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBsZWZ0TW9zdFNhZmUubmFtZSwgbGVmdE1vc3RTYWZlLmFyZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX25vZGVNYXAuc2V0KGxlZnRNb3N0U2FmZSwgbmV3IFByb3BlcnR5UmVhZChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBsZWZ0TW9zdFNhZmUubmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHRoZSBub2RlIG5vdyB3aXRob3V0IHRoZSBndWFyZGVkIG1lbWJlciBhY2Nlc3MuXG4gICAgICAgICAgdmFyIGFjY2VzcyA9IHRoaXMudmlzaXQoYXN0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIG1hcHBpbmcuIFRoaXMgaXMgbm90IHN0cmljdGx5IHJlcXVpcmVkIGFzIHRoZSBjb252ZXJ0ZXIgb25seSB0cmF2ZXJzZXMgZWFjaCBub2RlXG4gICAgICAgICAgLy8gb25jZSBidXQgaXMgc2FmZXIgaWYgdGhlIGNvbnZlcnNpb24gaXMgY2hhbmdlZCB0byB0cmF2ZXJzZSB0aGUgbm9kZXMgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgICAgdGhpcy5fbm9kZU1hcC5kZWxldGUobGVmdE1vc3RTYWZlKTtcbiAgICAgICAgICAvLyBJZiB3ZSBhbGxjb2F0ZWQgYSB0ZW1wb3JhcnksIHJlbGVhc2UgaXQuXG4gICAgICAgICAgaWYgKHRlbXBvcmFyeSkge1xuICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUHJvZHVjZSB0aGUgY29uZGl0aW9uYWxcbiAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY29uZGl0aW9uLmNvbmRpdGlvbmFsKGxpdGVyYWwobnVsbCksIGFjY2VzcykpO1xuICAgICAgfTtcbiAgICAgIC8vIEdpdmVuIGEgZXhwcmVzc2lvbiBvZiB0aGUgZm9ybSBhPy5iLmM/LmQuZSB0aGUgdGhlIGxlZnQgbW9zdCBzYWZlIG5vZGUgaXNcbiAgICAgIC8vIHRoZSAoYT8uYikuIFRoZSAuIGFuZCA/LiBhcmUgbGVmdCBhc3NvY2lhdGl2ZSB0aHVzIGNhbiBiZSByZXdyaXR0ZW4gYXM6XG4gICAgICAvLyAoKCgoYT8uYykuYikuYyk/LmQpLmUuIFRoaXMgcmV0dXJucyB0aGUgbW9zdCBkZWVwbHkgbmVzdGVkIHNhZmUgcmVhZCBvclxuICAgICAgLy8gc2FmZSBtZXRob2QgY2FsbCBhcyB0aGlzIG5lZWRzIGJlIHRyYW5zZm9ybSBpbml0aWFsbHkgdG86XG4gICAgICAvLyAgIGEgPT0gbnVsbCA/IG51bGwgOiBhLmMuYi5jPy5kLmVcbiAgICAgIC8vIHRoZW4gdG86XG4gICAgICAvLyAgIGEgPT0gbnVsbCA/IG51bGwgOiBhLmIuYyA9PSBudWxsID8gbnVsbCA6IGEuYi5jLmQuZVxuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5sZWZ0TW9zdFNhZmVOb2RlID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0Q2hhaW46IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRLZXllZFJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5vYmopOyB9LFxuICAgICAgICAgICAgICB2aXNpdEtleWVkV3JpdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpOyB9LFxuICAgICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UHJlZml4Tm90OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdFF1b3RlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDsgfSxcbiAgICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKSB8fCBhc3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICAvLyBSZXR1cm5zIHRydWUgb2YgdGhlIEFTVCBpbmNsdWRlcyBhIG1ldGhvZCBvciBhIHBpcGUgaW5kaWNhdGluZyB0aGF0LCBpZiB0aGVcbiAgICAgIC8vIGV4cHJlc3Npb24gaXMgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIGEgc2FmZSBwcm9wZXJ0eSBvciBtZXRob2QgYWNjZXNzIHRoZW5cbiAgICAgIC8vIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBzdG9yZWQgaW50byBhIHRlbXBvcmFyeSB2YXJpYWJsZS5cbiAgICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUubmVlZHNUZW1wb3JhcnkgPSBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBhc3QgJiYgKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdmlzaXRTb21lID0gZnVuY3Rpb24gKHZpc2l0b3IsIGFzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXN0LnNvbWUoZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodmlzaXRvciwgYXN0KTsgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5sZWZ0KSB8fCB2aXNpdCh0aGlzLCBhc3QucmlnaHQpOyB9LFxuICAgICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5jb25kaXRpb24pIHx8IHZpc2l0KHRoaXMsIGFzdC50cnVlRXhwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIHZpc2l0KHRoaXMsIGFzdC5mYWxzZUV4cCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgICB2aXNpdEludGVycG9sYXRpb246IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0U29tZSh0aGlzLCBhc3QuZXhwcmVzc2lvbnMpOyB9LFxuICAgICAgICAgICAgICB2aXNpdEtleWVkUmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5OiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0TWV0aG9kQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgICAgdmlzaXRQaXBlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pOyB9LFxuICAgICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UHJvcGVydHlXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAgIHZpc2l0UXVvdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVNZXRob2RDYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5hbGxvY2F0ZVRlbXBvcmFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgdGVtcE51bWJlciA9IHRoaXMuX2N1cnJlbnRUZW1wb3JhcnkrKztcbiAgICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gTWF0aC5tYXgodGhpcy5fY3VycmVudFRlbXBvcmFyeSwgdGhpcy50ZW1wb3JhcnlDb3VudCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWFkVmFyRXhwcih0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0luZGV4LCB0ZW1wTnVtYmVyKSk7XG4gICAgICB9O1xuICAgICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5yZWxlYXNlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKHRlbXBvcmFyeSkge1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRUZW1wb3JhcnktLTtcbiAgICAgICAgICBpZiAodGVtcG9yYXJ5Lm5hbWUgIT0gdGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJbmRleCwgdGhpcy5fY3VycmVudFRlbXBvcmFyeSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcG9yYXJ5IFwiICsgdGVtcG9yYXJ5Lm5hbWUgKyBcIiByZWxlYXNlZCBvdXQgb2Ygb3JkZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfQXN0VG9JclZpc2l0b3I7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGZsYXR0ZW5TdGF0ZW1lbnRzKGFyZywgb3V0cHV0KSB7XG4gICAgICBpZiAoaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBmbGF0dGVuU3RhdGVtZW50cyhlbnRyeSwgb3V0cHV0KTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChhcmcpO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIENvbXBpbGVFdmVudExpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENvbXBpbGVFdmVudExpc3RlbmVyKGNvbXBpbGVFbGVtZW50LCBldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudFBoYXNlLCBsaXN0ZW5lckluZGV4KSB7XG4gICAgICAgICAgdGhpcy5jb21waWxlRWxlbWVudCA9IGNvbXBpbGVFbGVtZW50O1xuICAgICAgICAgIHRoaXMuZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldDtcbiAgICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgICB0aGlzLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlO1xuICAgICAgICAgIHRoaXMuX2hhc0NvbXBvbmVudEhvc3RMaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2FjdGlvblJlc3VsdEV4cHJzID0gW107XG4gICAgICAgICAgdGhpcy5fbWV0aG9kID0gbmV3IENvbXBpbGVNZXRob2QoY29tcGlsZUVsZW1lbnQudmlldyk7XG4gICAgICAgICAgdGhpcy5fbWV0aG9kTmFtZSA9XG4gICAgICAgICAgICAgIFwiX2hhbmRsZV9cIiArIHNhbnRpdGl6ZUV2ZW50TmFtZShldmVudE5hbWUpICsgXCJfXCIgKyBjb21waWxlRWxlbWVudC5ub2RlSW5kZXggKyBcIl9cIiArIGxpc3RlbmVySW5kZXg7XG4gICAgICAgICAgdGhpcy5fZXZlbnRQYXJhbSA9IG5ldyBGblBhcmFtKEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSwgaW1wb3J0VHlwZSh0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlckV2ZW50KSk7XG4gICAgICB9XG4gICAgICBDb21waWxlRXZlbnRMaXN0ZW5lci5nZXRPckNyZWF0ZSA9IGZ1bmN0aW9uIChjb21waWxlRWxlbWVudCwgZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRQaGFzZSwgdGFyZ2V0RXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0YXJnZXRFdmVudExpc3RlbmVycy5maW5kKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIuZXZlbnRUYXJnZXQgPT0gZXZlbnRUYXJnZXQgJiYgbGlzdGVuZXIuZXZlbnROYW1lID09IGV2ZW50TmFtZSAmJlxuICAgICAgICAgICAgICBsaXN0ZW5lci5ldmVudFBoYXNlID09IGV2ZW50UGhhc2U7IH0pO1xuICAgICAgICAgIGlmICghbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIgPSBuZXcgQ29tcGlsZUV2ZW50TGlzdGVuZXIoY29tcGlsZUVsZW1lbnQsIGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50UGhhc2UsIHRhcmdldEV2ZW50TGlzdGVuZXJzLmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRhcmdldEV2ZW50TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVFdmVudExpc3RlbmVyLnByb3RvdHlwZSwgXCJtZXRob2ROYW1lXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21ldGhvZE5hbWU7IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLmFkZEFjdGlvbiA9IGZ1bmN0aW9uIChob3N0RXZlbnQsIGRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRpcmVjdGl2ZSkgJiYgZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2hhc0NvbXBvbmVudEhvc3RMaXN0ZW5lciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21ldGhvZC5yZXNldERlYnVnSW5mbyh0aGlzLmNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgaG9zdEV2ZW50KTtcbiAgICAgICAgICB2YXIgY29udGV4dCA9IGlzUHJlc2VudChkaXJlY3RpdmVJbnN0YW5jZSkgPyBkaXJlY3RpdmVJbnN0YW5jZSA6XG4gICAgICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5jb21wb25lbnRDb250ZXh0O1xuICAgICAgICAgIHZhciBhY3Rpb25TdG10cyA9IGNvbnZlcnRDZFN0YXRlbWVudFRvSXIodGhpcy5jb21waWxlRWxlbWVudC52aWV3LCBjb250ZXh0LCBob3N0RXZlbnQuaGFuZGxlciwgdGhpcy5jb21waWxlRWxlbWVudC5ub2RlSW5kZXgpO1xuICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBhY3Rpb25TdG10cy5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICB2YXIgbGFzdFN0YXRlbWVudCA9IGFjdGlvblN0bXRzW2xhc3RJbmRleF07XG4gICAgICAgICAgICAgIHZhciByZXR1cm5FeHByID0gY29udmVydFN0bXRJbnRvRXhwcmVzc2lvbihsYXN0U3RhdGVtZW50KTtcbiAgICAgICAgICAgICAgdmFyIHByZXZlbnREZWZhdWx0VmFyID0gdmFyaWFibGUoXCJwZF9cIiArIHRoaXMuX2FjdGlvblJlc3VsdEV4cHJzLmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRoaXMuX2FjdGlvblJlc3VsdEV4cHJzLnB1c2gocHJldmVudERlZmF1bHRWYXIpO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHJldHVybkV4cHIpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIGNhc3QgdGhlIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwgdG8gZHluYW1pYyxcbiAgICAgICAgICAgICAgICAgIC8vIGFzIGl0IG1pZ2h0IGJlIGEgdm9pZCBtZXRob2QhXG4gICAgICAgICAgICAgICAgICBhY3Rpb25TdG10c1tsYXN0SW5kZXhdID1cbiAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdFZhci5zZXQocmV0dXJuRXhwci5jYXN0KERZTkFNSUNfVFlQRSkubm90SWRlbnRpY2FsKGxpdGVyYWwoZmFsc2UpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21ldGhvZC5hZGRTdG10cyhhY3Rpb25TdG10cyk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZUV2ZW50TGlzdGVuZXIucHJvdG90eXBlLmZpbmlzaE1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbWFya1BhdGhUb1Jvb3RTdGFydCA9IHRoaXMuX2hhc0NvbXBvbmVudEhvc3RMaXN0ZW5lciA/XG4gICAgICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQuYXBwRWxlbWVudC5wcm9wKCdjb21wb25lbnRWaWV3JykgOlxuICAgICAgICAgICAgICBUSElTX0VYUFI7XG4gICAgICAgICAgdmFyIHJlc3VsdEV4cHIgPSBsaXRlcmFsKHRydWUpO1xuICAgICAgICAgIHRoaXMuX2FjdGlvblJlc3VsdEV4cHJzLmZvckVhY2goZnVuY3Rpb24gKGV4cHIpIHsgcmVzdWx0RXhwciA9IHJlc3VsdEV4cHIuYW5kKGV4cHIpOyB9KTtcbiAgICAgICAgICB2YXIgc3RtdHMgPSBbbWFya1BhdGhUb1Jvb3RTdGFydC5jYWxsTWV0aG9kKCdtYXJrUGF0aFRvUm9vdEFzQ2hlY2tPbmNlJywgW10pLnRvU3RtdCgpXVxuICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuX21ldGhvZC5maW5pc2goKSlcbiAgICAgICAgICAgICAgLmNvbmNhdChbbmV3IFJldHVyblN0YXRlbWVudChyZXN1bHRFeHByKV0pO1xuICAgICAgICAgIC8vIHByaXZhdGUgaXMgZmluZSBoZXJlIGFzIG5vIGNoaWxkIHZpZXcgd2lsbCByZWZlcmVuY2UgdGhlIGV2ZW50IGhhbmRsZXIuLi5cbiAgICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuZXZlbnRIYW5kbGVyTWV0aG9kcy5wdXNoKG5ldyBDbGFzc01ldGhvZCh0aGlzLl9tZXRob2ROYW1lLCBbdGhpcy5fZXZlbnRQYXJhbV0sIHN0bXRzLCBCT09MX1RZUEUsIFtTdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUubGlzdGVuVG9SZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbGlzdGVuRXhwcjtcbiAgICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IFRISVNfRVhQUi5jYWxsTWV0aG9kKCdldmVudEhhbmRsZXInLCBbVEhJU19FWFBSLnByb3AodGhpcy5fbWV0aG9kTmFtZSkuY2FsbE1ldGhvZChCdWlsdGluTWV0aG9kLkJpbmQsIFtUSElTX0VYUFJdKV0pO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5ldmVudFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgbGlzdGVuRXhwciA9IFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2xpc3Rlbkdsb2JhbCcsIFtsaXRlcmFsKHRoaXMuZXZlbnRUYXJnZXQpLCBsaXRlcmFsKHRoaXMuZXZlbnROYW1lKSwgZXZlbnRMaXN0ZW5lcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbGlzdGVuRXhwciA9IFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2xpc3RlbicsIFt0aGlzLmNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGUsIGxpdGVyYWwodGhpcy5ldmVudE5hbWUpLCBldmVudExpc3RlbmVyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkaXNwb3NhYmxlID0gdmFyaWFibGUoXCJkaXNwb3NhYmxlX1wiICsgdGhpcy5jb21waWxlRWxlbWVudC52aWV3LmRpc3Bvc2FibGVzLmxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5jb21waWxlRWxlbWVudC52aWV3LmRpc3Bvc2FibGVzLnB1c2goZGlzcG9zYWJsZSk7XG4gICAgICAgICAgLy8gcHJpdmF0ZSBpcyBmaW5lIGhlcmUgYXMgbm8gY2hpbGQgdmlldyB3aWxsIHJlZmVyZW5jZSB0aGUgZXZlbnQgaGFuZGxlci4uLlxuICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChkaXNwb3NhYmxlLnNldChsaXN0ZW5FeHByKS50b0RlY2xTdG10KEZVTkNUSU9OX1RZUEUsIFtTdG10TW9kaWZpZXIuUHJpdmF0ZV0pKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlRXZlbnRMaXN0ZW5lci5wcm90b3R5cGUubGlzdGVuVG9BbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG91dHB1dExpc3RlbmVyID0gVEhJU19FWFBSLmNhbGxNZXRob2QoJ2V2ZW50SGFuZGxlcicsIFtUSElTX0VYUFIucHJvcCh0aGlzLl9tZXRob2ROYW1lKS5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuQmluZCwgW1RISVNfRVhQUl0pXSk7XG4gICAgICAgICAgLy8gdGllIHRoZSBwcm9wZXJ0eSBjYWxsYmFjayBtZXRob2QgdG8gdGhlIHZpZXcgYW5pbWF0aW9ucyBtYXBcbiAgICAgICAgICB2YXIgc3RtdCA9IFRISVNfRVhQUlxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgncmVnaXN0ZXJBbmltYXRpb25PdXRwdXQnLCBbXG4gICAgICAgICAgICAgIHRoaXMuY29tcGlsZUVsZW1lbnQucmVuZGVyTm9kZSwgbGl0ZXJhbCh0aGlzLmV2ZW50TmFtZSksXG4gICAgICAgICAgICAgIGxpdGVyYWwodGhpcy5ldmVudFBoYXNlKSwgb3V0cHV0TGlzdGVuZXJcbiAgICAgICAgICBdKVxuICAgICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICAgICAgdGhpcy5jb21waWxlRWxlbWVudC52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KHN0bXQpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVFdmVudExpc3RlbmVyLnByb3RvdHlwZS5saXN0ZW5Ub0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVJbnN0YW5jZSwgb2JzZXJ2YWJsZVByb3BOYW1lKSB7XG4gICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHZhcmlhYmxlKFwic3Vic2NyaXB0aW9uX1wiICsgdGhpcy5jb21waWxlRWxlbWVudC52aWV3LnN1YnNjcmlwdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBUSElTX0VYUFIuY2FsbE1ldGhvZCgnZXZlbnRIYW5kbGVyJywgW1RISVNfRVhQUi5wcm9wKHRoaXMuX21ldGhvZE5hbWUpLmNhbGxNZXRob2QoQnVpbHRpbk1ldGhvZC5CaW5kLCBbVEhJU19FWFBSXSldKTtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVFbGVtZW50LnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgIC5zZXQoZGlyZWN0aXZlSW5zdGFuY2UucHJvcChvYnNlcnZhYmxlUHJvcE5hbWUpXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKEJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZSwgW2V2ZW50TGlzdGVuZXJdKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQ29tcGlsZUV2ZW50TGlzdGVuZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGNvbGxlY3RFdmVudExpc3RlbmVycyhob3N0RXZlbnRzLCBkaXJzLCBjb21waWxlRWxlbWVudCkge1xuICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgICBob3N0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RFdmVudCkge1xuICAgICAgICAgIGNvbXBpbGVFbGVtZW50LnZpZXcuYmluZGluZ3MucHVzaChuZXcgQ29tcGlsZUJpbmRpbmcoY29tcGlsZUVsZW1lbnQsIGhvc3RFdmVudCkpO1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IENvbXBpbGVFdmVudExpc3RlbmVyLmdldE9yQ3JlYXRlKGNvbXBpbGVFbGVtZW50LCBob3N0RXZlbnQudGFyZ2V0LCBob3N0RXZlbnQubmFtZSwgaG9zdEV2ZW50LnBoYXNlLCBldmVudExpc3RlbmVycyk7XG4gICAgICAgICAgbGlzdGVuZXIuYWRkQWN0aW9uKGhvc3RFdmVudCwgbnVsbCwgbnVsbCk7XG4gICAgICB9KTtcbiAgICAgIGRpcnMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZUluc3RhbmNlID0gY29tcGlsZUVsZW1lbnQuaW5zdGFuY2VzLmdldChpZGVudGlmaWVyVG9rZW4oZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS50eXBlKS5yZWZlcmVuY2UpO1xuICAgICAgICAgIGRpcmVjdGl2ZUFzdC5ob3N0RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RFdmVudCkge1xuICAgICAgICAgICAgICBjb21waWxlRWxlbWVudC52aWV3LmJpbmRpbmdzLnB1c2gobmV3IENvbXBpbGVCaW5kaW5nKGNvbXBpbGVFbGVtZW50LCBob3N0RXZlbnQpKTtcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gQ29tcGlsZUV2ZW50TGlzdGVuZXIuZ2V0T3JDcmVhdGUoY29tcGlsZUVsZW1lbnQsIGhvc3RFdmVudC50YXJnZXQsIGhvc3RFdmVudC5uYW1lLCBob3N0RXZlbnQucGhhc2UsIGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIuYWRkQWN0aW9uKGhvc3RFdmVudCwgZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIuZmluaXNoTWV0aG9kKCk7IH0pO1xuICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXJzO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVPdXRwdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLm91dHB1dHMpLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmFibGVQcm9wTmFtZSkge1xuICAgICAgICAgIHZhciBldmVudE5hbWUgPSBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLm91dHB1dHNbb2JzZXJ2YWJsZVByb3BOYW1lXTtcbiAgICAgICAgICBldmVudExpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lci5ldmVudE5hbWUgPT0gZXZlbnROYW1lOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5Ub0RpcmVjdGl2ZShkaXJlY3RpdmVJbnN0YW5jZSwgb2JzZXJ2YWJsZVByb3BOYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRSZW5kZXJPdXRwdXRzKGV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgIGlmIChsaXN0ZW5lci5ldmVudFBoYXNlKSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlblRvQW5pbWF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5Ub1JlbmRlcmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydFN0bXRJbnRvRXhwcmVzc2lvbihzdG10KSB7XG4gICAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gc3RtdC5leHByO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RtdCBpbnN0YW5jZW9mIFJldHVyblN0YXRlbWVudCkge1xuICAgICAgICAgIHJldHVybiBzdG10LnZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gc2FudGl0aXplRXZlbnROYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwobmFtZSwgL1teYS16QS1aX10vZywgJ18nKTtcbiAgfVxuXG4gIHZhciBTVEFURV9JU19ORVZFUl9DSEVDS0VEID0gVEhJU19FWFBSLnByb3AoJ251bWJlck9mQ2hlY2tzJykuaWRlbnRpY2FsKG5ldyBMaXRlcmFsRXhwcigwKSk7XG4gIHZhciBOT1RfVEhST1dfT05fQ0hBTkdFUyA9IG5vdChEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlKTtcbiAgZnVuY3Rpb24gYmluZERpcmVjdGl2ZURldGVjdENoYW5nZXNMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICAgIHZhciBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QgPSB2aWV3LmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZDtcbiAgICAgIHZhciBsaWZlY3ljbGVIb29rcyA9IGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudHlwZS5saWZlY3ljbGVIb29rcztcbiAgICAgIGlmIChsaWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcykgIT09IC0xICYmIGRpcmVjdGl2ZUFzdC5pbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZC5hZGRTdG10KG5ldyBJZlN0bXQoRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlcy5ub3RJZGVudGljYWwoTlVMTF9FWFBSKSwgW2RpcmVjdGl2ZUluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25DaGFuZ2VzJywgW0RldGVjdENoYW5nZXNWYXJzLmNoYW5nZXNdKS50b1N0bXQoKV0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uSW5pdCkgIT09IC0xKSB7XG4gICAgICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXQobmV3IElmU3RtdChTVEFURV9JU19ORVZFUl9DSEVDS0VELmFuZChOT1RfVEhST1dfT05fQ0hBTkdFUyksIFtkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ09uSW5pdCcsIFtdKS50b1N0bXQoKV0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLkRvQ2hlY2spICE9PSAtMSkge1xuICAgICAgICAgIGRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZC5hZGRTdG10KG5ldyBJZlN0bXQoTk9UX1RIUk9XX09OX0NIQU5HRVMsIFtkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0RvQ2hlY2snLCBbXSkudG9TdG10KCldKSk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmluZERpcmVjdGl2ZUFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVNZXRhLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICAgIHZhciBsaWZlY3ljbGVIb29rcyA9IGRpcmVjdGl2ZU1ldGEudHlwZS5saWZlY3ljbGVIb29rcztcbiAgICAgIHZhciBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QgPSB2aWV3LmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZDtcbiAgICAgIGFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGNvbXBpbGVFbGVtZW50LnNvdXJjZUFzdCk7XG4gICAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0KSAhPT0gLTEpIHtcbiAgICAgICAgICBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChuZXcgSWZTdG10KFNUQVRFX0lTX05FVkVSX0NIRUNLRUQsIFtkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyQ29udGVudEluaXQnLCBbXSkudG9TdG10KCldKSk7XG4gICAgICB9XG4gICAgICBpZiAobGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkKSAhPT0gLTEpIHtcbiAgICAgICAgICBhZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QuYWRkU3RtdChkaXJlY3RpdmVJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ0FmdGVyQ29udGVudENoZWNrZWQnLCBbXSkudG9TdG10KCkpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVBZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlTWV0YSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgICB2YXIgdmlldyA9IGNvbXBpbGVFbGVtZW50LnZpZXc7XG4gICAgICB2YXIgbGlmZWN5Y2xlSG9va3MgPSBkaXJlY3RpdmVNZXRhLnR5cGUubGlmZWN5Y2xlSG9va3M7XG4gICAgICB2YXIgYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kID0gdmlldy5hZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2Q7XG4gICAgICBhZnRlclZpZXdMaWZlY3ljbGVDYWxsYmFja3NNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBjb21waWxlRWxlbWVudC5zb3VyY2VBc3QpO1xuICAgICAgaWYgKGxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdCkgIT09IC0xKSB7XG4gICAgICAgICAgYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmFkZFN0bXQobmV3IElmU3RtdChTVEFURV9JU19ORVZFUl9DSEVDS0VELCBbZGlyZWN0aXZlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdBZnRlclZpZXdJbml0JywgW10pLnRvU3RtdCgpXSkpO1xuICAgICAgfVxuICAgICAgaWYgKGxpZmVjeWNsZUhvb2tzLmluZGV4T2YoTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZCkgIT09IC0xKSB7XG4gICAgICAgICAgYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmFkZFN0bXQoZGlyZWN0aXZlSW5zdGFuY2UuY2FsbE1ldGhvZCgnbmdBZnRlclZpZXdDaGVja2VkJywgW10pLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiaW5kSW5qZWN0YWJsZURlc3Ryb3lMaWZlY3ljbGVDYWxsYmFja3MocHJvdmlkZXIsIHByb3ZpZGVySW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KSB7XG4gICAgICB2YXIgb25EZXN0cm95TWV0aG9kID0gY29tcGlsZUVsZW1lbnQudmlldy5kZXN0cm95TWV0aG9kO1xuICAgICAgb25EZXN0cm95TWV0aG9kLnJlc2V0RGVidWdJbmZvKGNvbXBpbGVFbGVtZW50Lm5vZGVJbmRleCwgY29tcGlsZUVsZW1lbnQuc291cmNlQXN0KTtcbiAgICAgIGlmIChwcm92aWRlci5saWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xKSB7XG4gICAgICAgICAgb25EZXN0cm95TWV0aG9kLmFkZFN0bXQocHJvdmlkZXJJbnN0YW5jZS5jYWxsTWV0aG9kKCduZ09uRGVzdHJveScsIFtdKS50b1N0bXQoKSk7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmluZFBpcGVEZXN0cm95TGlmZWN5Y2xlQ2FsbGJhY2tzKHBpcGVNZXRhLCBwaXBlSW5zdGFuY2UsIHZpZXcpIHtcbiAgICAgIHZhciBvbkRlc3Ryb3lNZXRob2QgPSB2aWV3LmRlc3Ryb3lNZXRob2Q7XG4gICAgICBpZiAocGlwZU1ldGEudHlwZS5saWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xKSB7XG4gICAgICAgICAgb25EZXN0cm95TWV0aG9kLmFkZFN0bXQocGlwZUluc3RhbmNlLmNhbGxNZXRob2QoJ25nT25EZXN0cm95JywgW10pLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJpbmRGaWVsZEV4cHIoZXhwckluZGV4KSB7XG4gICAgICByZXR1cm4gVEhJU19FWFBSLnByb3AoXCJfZXhwcl9cIiArIGV4cHJJbmRleCk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ3VyclZhbHVlRXhwcihleHBySW5kZXgpIHtcbiAgICAgIHJldHVybiB2YXJpYWJsZShcImN1cnJWYWxfXCIgKyBleHBySW5kZXgpOyAvLyBmaXggc3ludGF4IGhpZ2hsaWdodGluZzogYFxuICB9XG4gIGZ1bmN0aW9uIGJpbmQodmlldywgY3VyclZhbEV4cHIsIGZpZWxkRXhwciwgcGFyc2VkRXhwcmVzc2lvbiwgY29udGV4dCwgYWN0aW9ucywgbWV0aG9kLCBiaW5kaW5nSW5kZXgpIHtcbiAgICAgIHZhciBjaGVja0V4cHJlc3Npb24gPSBjb252ZXJ0Q2RFeHByZXNzaW9uVG9Jcih2aWV3LCBjb250ZXh0LCBwYXJzZWRFeHByZXNzaW9uLCBEZXRlY3RDaGFuZ2VzVmFycy52YWxVbndyYXBwZXIsIGJpbmRpbmdJbmRleCk7XG4gICAgICBpZiAoIWNoZWNrRXhwcmVzc2lvbi5leHByZXNzaW9uKSB7XG4gICAgICAgICAgLy8gZS5nLiBhbiBlbXB0eSBleHByZXNzaW9uIHdhcyBnaXZlblxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0V4cHJlc3Npb24udGVtcG9yYXJ5Q291bnQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrRXhwcmVzc2lvbi50ZW1wb3JhcnlDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIG1ldGhvZC5hZGRTdG10KHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJbmRleCwgaSkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHByaXZhdGUgaXMgZmluZSBoZXJlIGFzIG5vIGNoaWxkIHZpZXcgd2lsbCByZWZlcmVuY2UgdGhlIGNhY2hlZCB2YWx1ZS4uLlxuICAgICAgdmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChmaWVsZEV4cHIubmFtZSwgbnVsbCwgW1N0bXRNb2RpZmllci5Qcml2YXRlXSkpO1xuICAgICAgdmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIucHJvcChmaWVsZEV4cHIubmFtZSlcbiAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVU5JTklUSUFMSVpFRCkpKVxuICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICBpZiAoY2hlY2tFeHByZXNzaW9uLm5lZWRzVmFsdWVVbndyYXBwZXIpIHtcbiAgICAgICAgICB2YXIgaW5pdFZhbHVlVW53cmFwcGVyU3RtdCA9IERldGVjdENoYW5nZXNWYXJzLnZhbFVud3JhcHBlci5jYWxsTWV0aG9kKCdyZXNldCcsIFtdKS50b1N0bXQoKTtcbiAgICAgICAgICBtZXRob2QuYWRkU3RtdChpbml0VmFsdWVVbndyYXBwZXJTdG10KTtcbiAgICAgIH1cbiAgICAgIG1ldGhvZC5hZGRTdG10KGN1cnJWYWxFeHByLnNldChjaGVja0V4cHJlc3Npb24uZXhwcmVzc2lvbikudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgICAgdmFyIGNvbmRpdGlvbiA9IGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY2hlY2tCaW5kaW5nKSkuY2FsbEZuKFtcbiAgICAgICAgICBEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlLCBmaWVsZEV4cHIsIGN1cnJWYWxFeHByXG4gICAgICBdKTtcbiAgICAgIGlmIChjaGVja0V4cHJlc3Npb24ubmVlZHNWYWx1ZVVud3JhcHBlcikge1xuICAgICAgICAgIGNvbmRpdGlvbiA9IERldGVjdENoYW5nZXNWYXJzLnZhbFVud3JhcHBlci5wcm9wKCdoYXNXcmFwcGVkVmFsdWUnKS5vcihjb25kaXRpb24pO1xuICAgICAgfVxuICAgICAgbWV0aG9kLmFkZFN0bXQobmV3IElmU3RtdChjb25kaXRpb24sIGFjdGlvbnMuY29uY2F0KFtUSElTX0VYUFIucHJvcChmaWVsZEV4cHIubmFtZSkuc2V0KGN1cnJWYWxFeHByKS50b1N0bXQoKV0pKSk7XG4gIH1cbiAgZnVuY3Rpb24gYmluZFJlbmRlclRleHQoYm91bmRUZXh0LCBjb21waWxlTm9kZSwgdmlldykge1xuICAgICAgdmFyIGJpbmRpbmdJbmRleCA9IHZpZXcuYmluZGluZ3MubGVuZ3RoO1xuICAgICAgdmlldy5iaW5kaW5ncy5wdXNoKG5ldyBDb21waWxlQmluZGluZyhjb21waWxlTm9kZSwgYm91bmRUZXh0KSk7XG4gICAgICB2YXIgY3VyclZhbEV4cHIgPSBjcmVhdGVDdXJyVmFsdWVFeHByKGJpbmRpbmdJbmRleCk7XG4gICAgICB2YXIgdmFsdWVGaWVsZCA9IGNyZWF0ZUJpbmRGaWVsZEV4cHIoYmluZGluZ0luZGV4KTtcbiAgICAgIHZpZXcuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZU5vZGUubm9kZUluZGV4LCBib3VuZFRleHQpO1xuICAgICAgYmluZCh2aWV3LCBjdXJyVmFsRXhwciwgdmFsdWVGaWVsZCwgYm91bmRUZXh0LnZhbHVlLCB2aWV3LmNvbXBvbmVudENvbnRleHQsIFtUSElTX0VYUFIucHJvcCgncmVuZGVyZXInKVxuICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnc2V0VGV4dCcsIFtjb21waWxlTm9kZS5yZW5kZXJOb2RlLCBjdXJyVmFsRXhwcl0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKV0sIHZpZXcuZGV0ZWN0Q2hhbmdlc1JlbmRlclByb3BlcnRpZXNNZXRob2QsIGJpbmRpbmdJbmRleCk7XG4gIH1cbiAgZnVuY3Rpb24gYmluZEFuZFdyaXRlVG9SZW5kZXJlcihib3VuZFByb3BzLCBjb250ZXh0LCBjb21waWxlRWxlbWVudCwgaXNIb3N0UHJvcCkge1xuICAgICAgdmFyIHZpZXcgPSBjb21waWxlRWxlbWVudC52aWV3O1xuICAgICAgdmFyIHJlbmRlck5vZGUgPSBjb21waWxlRWxlbWVudC5yZW5kZXJOb2RlO1xuICAgICAgYm91bmRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChib3VuZFByb3ApIHtcbiAgICAgICAgICB2YXIgYmluZGluZ0luZGV4ID0gdmlldy5iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgdmlldy5iaW5kaW5ncy5wdXNoKG5ldyBDb21waWxlQmluZGluZyhjb21waWxlRWxlbWVudCwgYm91bmRQcm9wKSk7XG4gICAgICAgICAgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGJvdW5kUHJvcCk7XG4gICAgICAgICAgdmFyIGZpZWxkRXhwciA9IGNyZWF0ZUJpbmRGaWVsZEV4cHIoYmluZGluZ0luZGV4KTtcbiAgICAgICAgICB2YXIgY3VyclZhbEV4cHIgPSBjcmVhdGVDdXJyVmFsdWVFeHByKGJpbmRpbmdJbmRleCk7XG4gICAgICAgICAgdmFyIHJlbmRlck1ldGhvZDtcbiAgICAgICAgICB2YXIgb2xkUmVuZGVyVmFsdWUgPSBzYW5pdGl6ZWRWYWx1ZShib3VuZFByb3AsIGZpZWxkRXhwcik7XG4gICAgICAgICAgdmFyIHJlbmRlclZhbHVlID0gc2FuaXRpemVkVmFsdWUoYm91bmRQcm9wLCBjdXJyVmFsRXhwcik7XG4gICAgICAgICAgdmFyIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICAgICAgdmFyIGNvbXBpbGVNZXRob2QgPSB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kO1xuICAgICAgICAgIHN3aXRjaCAoYm91bmRQcm9wLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHk6XG4gICAgICAgICAgICAgICAgICBpZiAodmlldy5nZW5Db25maWcubG9nQmluZGluZ1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2gobG9nQmluZGluZ1VwZGF0ZVN0bXQocmVuZGVyTm9kZSwgYm91bmRQcm9wLm5hbWUsIHJlbmRlclZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKCdyZW5kZXJlcicpXG4gICAgICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldEVsZW1lbnRQcm9wZXJ0eScsIFtyZW5kZXJOb2RlLCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlOlxuICAgICAgICAgICAgICAgICAgcmVuZGVyVmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclZhbHVlLmlzQmxhbmsoKS5jb25kaXRpb25hbChOVUxMX0VYUFIsIHJlbmRlclZhbHVlLmNhbGxNZXRob2QoJ3RvU3RyaW5nJywgW10pKTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2goVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJylcbiAgICAgICAgICAgICAgICAgICAgICAuY2FsbE1ldGhvZCgnc2V0RWxlbWVudEF0dHJpYnV0ZScsIFtyZW5kZXJOb2RlLCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3M6XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKFRISVNfRVhQUi5wcm9wKCdyZW5kZXJlcicpXG4gICAgICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ3NldEVsZW1lbnRDbGFzcycsIFtyZW5kZXJOb2RlLCBsaXRlcmFsKGJvdW5kUHJvcC5uYW1lKSwgcmVuZGVyVmFsdWVdKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBleHBvcnRzLlByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGU6XG4gICAgICAgICAgICAgICAgICB2YXIgc3RyVmFsdWUgPSByZW5kZXJWYWx1ZS5jYWxsTWV0aG9kKCd0b1N0cmluZycsIFtdKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYm91bmRQcm9wLnVuaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RyVmFsdWUgPSBzdHJWYWx1ZS5wbHVzKGxpdGVyYWwoYm91bmRQcm9wLnVuaXQpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJlbmRlclZhbHVlID0gcmVuZGVyVmFsdWUuaXNCbGFuaygpLmNvbmRpdGlvbmFsKE5VTExfRVhQUiwgc3RyVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaChUSElTX0VYUFIucHJvcCgncmVuZGVyZXInKVxuICAgICAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdzZXRFbGVtZW50U3R5bGUnLCBbcmVuZGVyTm9kZSwgbGl0ZXJhbChib3VuZFByb3AubmFtZSksIHJlbmRlclZhbHVlXSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbjpcbiAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25OYW1lID0gYm91bmRQcm9wLm5hbWU7XG4gICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Vmlld0V4cHIgPSBUSElTX0VYUFI7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNIb3N0UHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFZpZXdFeHByID0gY29tcGlsZUVsZW1lbnQuYXBwRWxlbWVudC5wcm9wKCdjb21wb25lbnRWaWV3Jyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb21waWxlTWV0aG9kID0gdmlldy5hbmltYXRpb25CaW5kaW5nc01ldGhvZDtcbiAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25GbkV4cHIgPSB0YXJnZXRWaWV3RXhwci5wcm9wKCdjb21wb25lbnRUeXBlJykucHJvcCgnYW5pbWF0aW9ucycpLmtleShsaXRlcmFsKGFuaW1hdGlvbk5hbWUpKTtcbiAgICAgICAgICAgICAgICAgIC8vIGl0J3MgaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSB0aGUgdm9pZCB2YWx1ZSBhcyBgdm9pZGAgZXhwbGljaXRseVxuICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGUgc3R5bGVzIGRhdGEgY2FuIGJlIG9idGFpbmVkIGZyb20gdGhlIHN0cmluZ21hcFxuICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5U3RhdGVWYWx1ZSA9IGxpdGVyYWwoRU1QVFlfQU5JTUFUSU9OX1NUQVRFKTtcbiAgICAgICAgICAgICAgICAgIC8vIHZvaWQgPT4gLi4uXG4gICAgICAgICAgICAgICAgICB2YXIgb2xkUmVuZGVyVmFyID0gdmFyaWFibGUoJ29sZFJlbmRlclZhcicpO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaChvbGRSZW5kZXJWYXIuc2V0KG9sZFJlbmRlclZhbHVlKS50b0RlY2xTdG10KCkpO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlU3RtdHMucHVzaChuZXcgSWZTdG10KG9sZFJlbmRlclZhci5lcXVhbHMoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5VTklOSVRJQUxJWkVEKSkpLCBbb2xkUmVuZGVyVmFyLnNldChlbXB0eVN0YXRlVmFsdWUpLnRvU3RtdCgpXSkpO1xuICAgICAgICAgICAgICAgICAgLy8gLi4uID0+IHZvaWRcbiAgICAgICAgICAgICAgICAgIHZhciBuZXdSZW5kZXJWYXIgPSB2YXJpYWJsZSgnbmV3UmVuZGVyVmFyJyk7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKG5ld1JlbmRlclZhci5zZXQocmVuZGVyVmFsdWUpLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKG5ldyBJZlN0bXQobmV3UmVuZGVyVmFyLmVxdWFscyhpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlVOSU5JVElBTElaRUQpKSksIFtuZXdSZW5kZXJWYXIuc2V0KGVtcHR5U3RhdGVWYWx1ZSkudG9TdG10KCldKSk7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoKGFuaW1hdGlvbkZuRXhwci5jYWxsRm4oW1RISVNfRVhQUiwgcmVuZGVyTm9kZSwgb2xkUmVuZGVyVmFyLCBuZXdSZW5kZXJWYXJdKS50b1N0bXQoKSk7XG4gICAgICAgICAgICAgICAgICB2aWV3LmRldGFjaE1ldGhvZC5hZGRTdG10KGFuaW1hdGlvbkZuRXhwci5jYWxsRm4oW1RISVNfRVhQUiwgcmVuZGVyTm9kZSwgb2xkUmVuZGVyVmFsdWUsIGVtcHR5U3RhdGVWYWx1ZV0pXG4gICAgICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaW5kKHZpZXcsIGN1cnJWYWxFeHByLCBmaWVsZEV4cHIsIGJvdW5kUHJvcC52YWx1ZSwgY29udGV4dCwgdXBkYXRlU3RtdHMsIGNvbXBpbGVNZXRob2QsIHZpZXcuYmluZGluZ3MubGVuZ3RoKTtcbiAgICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNhbml0aXplZFZhbHVlKGJvdW5kUHJvcCwgcmVuZGVyVmFsdWUpIHtcbiAgICAgIHZhciBlbnVtVmFsdWU7XG4gICAgICBzd2l0Y2ggKGJvdW5kUHJvcC5zZWN1cml0eUNvbnRleHQpIHtcbiAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkU6XG4gICAgICAgICAgICAgIHJldHVybiByZW5kZXJWYWx1ZTsgLy8gTm8gc2FuaXRpemF0aW9uIG5lZWRlZC5cbiAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LkhUTUw6XG4gICAgICAgICAgICAgIGVudW1WYWx1ZSA9ICdIVE1MJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5TVFlMRTpcbiAgICAgICAgICAgICAgZW51bVZhbHVlID0gJ1NUWUxFJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5TQ1JJUFQ6XG4gICAgICAgICAgICAgIGVudW1WYWx1ZSA9ICdTQ1JJUFQnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlVSTDpcbiAgICAgICAgICAgICAgZW51bVZhbHVlID0gJ1VSTCc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMOlxuICAgICAgICAgICAgICBlbnVtVmFsdWUgPSAnUkVTT1VSQ0VfVVJMJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWwgZXJyb3IsIHVuZXhwZWN0ZWQgU2VjdXJpdHlDb250ZXh0IFwiICsgYm91bmRQcm9wLnNlY3VyaXR5Q29udGV4dCArIFwiLlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBjdHggPSBWaWV3UHJvcGVydGllcy52aWV3VXRpbHMucHJvcCgnc2FuaXRpemVyJyk7XG4gICAgICB2YXIgYXJncyA9IFtpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlNlY3VyaXR5Q29udGV4dCkpLnByb3AoZW51bVZhbHVlKSwgcmVuZGVyVmFsdWVdO1xuICAgICAgcmV0dXJuIGN0eC5jYWxsTWV0aG9kKCdzYW5pdGl6ZScsIGFyZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRSZW5kZXJJbnB1dHMoYm91bmRQcm9wcywgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIGJpbmRBbmRXcml0ZVRvUmVuZGVyZXIoYm91bmRQcm9wcywgY29tcGlsZUVsZW1lbnQudmlldy5jb21wb25lbnRDb250ZXh0LCBjb21waWxlRWxlbWVudCwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVIb3N0UHJvcHMoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIGJpbmRBbmRXcml0ZVRvUmVuZGVyZXIoZGlyZWN0aXZlQXN0Lmhvc3RQcm9wZXJ0aWVzLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQsIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmREaXJlY3RpdmVJbnB1dHMoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpIHtcbiAgICAgIGlmIChkaXJlY3RpdmVBc3QuaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3ID0gY29tcGlsZUVsZW1lbnQudmlldztcbiAgICAgIHZhciBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QgPSB2aWV3LmRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZDtcbiAgICAgIGRldGVjdENoYW5nZXNJbklucHV0c01ldGhvZC5yZXNldERlYnVnSW5mbyhjb21waWxlRWxlbWVudC5ub2RlSW5kZXgsIGNvbXBpbGVFbGVtZW50LnNvdXJjZUFzdCk7XG4gICAgICB2YXIgbGlmZWN5Y2xlSG9va3MgPSBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnR5cGUubGlmZWN5Y2xlSG9va3M7XG4gICAgICB2YXIgY2FsY0NoYW5nZXNNYXAgPSBsaWZlY3ljbGVIb29rcy5pbmRleE9mKExpZmVjeWNsZUhvb2tzLk9uQ2hhbmdlcykgIT09IC0xO1xuICAgICAgdmFyIGlzT25QdXNoQ29tcCA9IGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQgJiZcbiAgICAgICAgICAhaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3koZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZS5jaGFuZ2VEZXRlY3Rpb24pO1xuICAgICAgaWYgKGNhbGNDaGFuZ2VzTWFwKSB7XG4gICAgICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXQoRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlcy5zZXQoTlVMTF9FWFBSKS50b1N0bXQoKSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPblB1c2hDb21wKSB7XG4gICAgICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXQoRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlZC5zZXQobGl0ZXJhbChmYWxzZSkpLnRvU3RtdCgpKTtcbiAgICAgIH1cbiAgICAgIGRpcmVjdGl2ZUFzdC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgYmluZGluZ0luZGV4ID0gdmlldy5iaW5kaW5ncy5sZW5ndGg7XG4gICAgICAgICAgdmlldy5iaW5kaW5ncy5wdXNoKG5ldyBDb21waWxlQmluZGluZyhjb21waWxlRWxlbWVudCwgaW5wdXQpKTtcbiAgICAgICAgICBkZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QucmVzZXREZWJ1Z0luZm8oY29tcGlsZUVsZW1lbnQubm9kZUluZGV4LCBpbnB1dCk7XG4gICAgICAgICAgdmFyIGZpZWxkRXhwciA9IGNyZWF0ZUJpbmRGaWVsZEV4cHIoYmluZGluZ0luZGV4KTtcbiAgICAgICAgICB2YXIgY3VyclZhbEV4cHIgPSBjcmVhdGVDdXJyVmFsdWVFeHByKGJpbmRpbmdJbmRleCk7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbZGlyZWN0aXZlSW5zdGFuY2UucHJvcChpbnB1dC5kaXJlY3RpdmVOYW1lKS5zZXQoY3VyclZhbEV4cHIpLnRvU3RtdCgpXTtcbiAgICAgICAgICBpZiAoY2FsY0NoYW5nZXNNYXApIHtcbiAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5ldyBJZlN0bXQoRGV0ZWN0Q2hhbmdlc1ZhcnMuY2hhbmdlcy5pZGVudGljYWwoTlVMTF9FWFBSKSwgW0RldGVjdENoYW5nZXNWYXJzLmNoYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICAuc2V0KGxpdGVyYWxNYXAoW10sIG5ldyBNYXBUeXBlKGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuU2ltcGxlQ2hhbmdlKSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdG10KCldKSk7XG4gICAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VzLmtleShsaXRlcmFsKGlucHV0LmRpcmVjdGl2ZU5hbWUpKVxuICAgICAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlNpbXBsZUNoYW5nZSkpXG4gICAgICAgICAgICAgICAgICAuaW5zdGFudGlhdGUoW2ZpZWxkRXhwciwgY3VyclZhbEV4cHJdKSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc09uUHVzaENvbXApIHtcbiAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKERldGVjdENoYW5nZXNWYXJzLmNoYW5nZWQuc2V0KGxpdGVyYWwodHJ1ZSkpLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZpZXcuZ2VuQ29uZmlnLmxvZ0JpbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKGxvZ0JpbmRpbmdVcGRhdGVTdG10KGNvbXBpbGVFbGVtZW50LnJlbmRlck5vZGUsIGlucHV0LmRpcmVjdGl2ZU5hbWUsIGN1cnJWYWxFeHByKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpbmQodmlldywgY3VyclZhbEV4cHIsIGZpZWxkRXhwciwgaW5wdXQudmFsdWUsIHZpZXcuY29tcG9uZW50Q29udGV4dCwgc3RhdGVtZW50cywgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLCBiaW5kaW5nSW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXNPblB1c2hDb21wKSB7XG4gICAgICAgICAgZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmFkZFN0bXQobmV3IElmU3RtdChEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkLCBbXG4gICAgICAgICAgICAgIGNvbXBpbGVFbGVtZW50LmFwcEVsZW1lbnQucHJvcCgnY29tcG9uZW50VmlldycpLmNhbGxNZXRob2QoJ21hcmtBc0NoZWNrT25jZScsIFtdKS50b1N0bXQoKVxuICAgICAgICAgIF0pKTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsb2dCaW5kaW5nVXBkYXRlU3RtdChyZW5kZXJOb2RlLCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciB0cnlTdG10ID0gVEhJU19FWFBSLnByb3AoJ3JlbmRlcmVyJylcbiAgICAgICAgICAuY2FsbE1ldGhvZCgnc2V0QmluZGluZ0RlYnVnSW5mbycsIFtcbiAgICAgICAgICByZW5kZXJOb2RlLCBsaXRlcmFsKFwibmctcmVmbGVjdC1cIiArIGNhbWVsQ2FzZVRvRGFzaENhc2UocHJvcE5hbWUpKSxcbiAgICAgICAgICB2YWx1ZS5pc0JsYW5rKCkuY29uZGl0aW9uYWwoTlVMTF9FWFBSLCB2YWx1ZS5jYWxsTWV0aG9kKCd0b1N0cmluZycsIFtdKSlcbiAgICAgIF0pXG4gICAgICAgICAgLnRvU3RtdCgpO1xuICAgICAgdmFyIGNhdGNoU3RtdCA9IFRISVNfRVhQUi5wcm9wKCdyZW5kZXJlcicpXG4gICAgICAgICAgLmNhbGxNZXRob2QoJ3NldEJpbmRpbmdEZWJ1Z0luZm8nLCBbXG4gICAgICAgICAgcmVuZGVyTm9kZSwgbGl0ZXJhbChcIm5nLXJlZmxlY3QtXCIgKyBjYW1lbENhc2VUb0Rhc2hDYXNlKHByb3BOYW1lKSksXG4gICAgICAgICAgbGl0ZXJhbCgnW0VSUk9SXSBFeGNlcHRpb24gd2hpbGUgdHJ5aW5nIHRvIHNlcmlhbGl6ZSB0aGUgdmFsdWUnKVxuICAgICAgXSlcbiAgICAgICAgICAudG9TdG10KCk7XG4gICAgICByZXR1cm4gbmV3IFRyeUNhdGNoU3RtdChbdHJ5U3RtdF0sIFtjYXRjaFN0bXRdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmRWaWV3KHZpZXcsIHBhcnNlZFRlbXBsYXRlKSB7XG4gICAgICB2YXIgdmlzaXRvciA9IG5ldyBWaWV3QmluZGVyVmlzaXRvcih2aWV3KTtcbiAgICAgIHRlbXBsYXRlVmlzaXRBbGwodmlzaXRvciwgcGFyc2VkVGVtcGxhdGUpO1xuICAgICAgdmlldy5waXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlKSB7IGJpbmRQaXBlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcyhwaXBlLm1ldGEsIHBpcGUuaW5zdGFuY2UsIHBpcGUudmlldyk7IH0pO1xuICB9XG4gIHZhciBWaWV3QmluZGVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3QmluZGVyVmlzaXRvcih2aWV3KSB7XG4gICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgICB0aGlzLl9ub2RlSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnZpZXcubm9kZXNbdGhpcy5fbm9kZUluZGV4KytdO1xuICAgICAgICAgIGJpbmRSZW5kZXJUZXh0KGFzdCwgbm9kZSwgdGhpcy52aWV3KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5fbm9kZUluZGV4Kys7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TmdDb250ZW50ID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IHRoaXMudmlldy5ub2Rlc1t0aGlzLl9ub2RlSW5kZXgrK107XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgICAgICAgY29sbGVjdEV2ZW50TGlzdGVuZXJzKGFzdC5vdXRwdXRzLCBhc3QuZGlyZWN0aXZlcywgY29tcGlsZUVsZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJzLnB1c2goZW50cnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJpbmRSZW5kZXJJbnB1dHMoYXN0LmlucHV0cywgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIGJpbmRSZW5kZXJPdXRwdXRzKGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QpIHtcbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUluc3RhbmNlID0gY29tcGlsZUVsZW1lbnQuaW5zdGFuY2VzLmdldChkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUlucHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgICAgIGJpbmREaXJlY3RpdmVEZXRlY3RDaGFuZ2VzTGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUhvc3RQcm9wcyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgICAgIGJpbmREaXJlY3RpdmVPdXRwdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGV2ZW50TGlzdGVuZXJzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbiwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIC8vIGFmdGVyQ29udGVudCBhbmQgYWZ0ZXJWaWV3IGxpZmVjeWNsZXMgbmVlZCB0byBiZSBjYWxsZWQgYm90dG9tIHVwXG4gICAgICAgICAgLy8gc28gdGhhdCBjaGlsZHJlbiBhcmUgbm90aWZpZWQgYmVmb3JlIHBhcmVudHNcbiAgICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QpIHtcbiAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZUluc3RhbmNlID0gY29tcGlsZUVsZW1lbnQuaW5zdGFuY2VzLmdldChkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlQWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzKGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUsIGRpcmVjdGl2ZUluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXN0LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlckFzdCkge1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJJbnN0YW5jZSA9IGNvbXBpbGVFbGVtZW50Lmluc3RhbmNlcy5nZXQocHJvdmlkZXJBc3QudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgYmluZEluamVjdGFibGVEZXN0cm95TGlmZWN5Y2xlQ2FsbGJhY2tzKHByb3ZpZGVyQXN0LCBwcm92aWRlckluc3RhbmNlLCBjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IHRoaXMudmlldy5ub2Rlc1t0aGlzLl9ub2RlSW5kZXgrK107XG4gICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gY29sbGVjdEV2ZW50TGlzdGVuZXJzKGFzdC5vdXRwdXRzLCBhc3QuZGlyZWN0aXZlcywgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIGFzdC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZUFzdCkge1xuICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlSW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5pbnN0YW5jZXMuZ2V0KGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlSW5wdXRzKGRpcmVjdGl2ZUFzdCwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZURldGVjdENoYW5nZXNMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICBiaW5kRGlyZWN0aXZlT3V0cHV0cyhkaXJlY3RpdmVBc3QsIGRpcmVjdGl2ZUluc3RhbmNlLCBldmVudExpc3RlbmVycyk7XG4gICAgICAgICAgICAgIGJpbmREaXJlY3RpdmVBZnRlckNvbnRlbnRMaWZlY3ljbGVDYWxsYmFja3MoZGlyZWN0aXZlQXN0LmRpcmVjdGl2ZSwgZGlyZWN0aXZlSW5zdGFuY2UsIGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICAgICAgYmluZERpcmVjdGl2ZUFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrcyhkaXJlY3RpdmVBc3QuZGlyZWN0aXZlLCBkaXJlY3RpdmVJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFzdC5wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocHJvdmlkZXJBc3QpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVySW5zdGFuY2UgPSBjb21waWxlRWxlbWVudC5pbnN0YW5jZXMuZ2V0KHByb3ZpZGVyQXN0LnRva2VuLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgIGJpbmRJbmplY3RhYmxlRGVzdHJveUxpZmVjeWNsZUNhbGxiYWNrcyhwcm92aWRlckFzdCwgcHJvdmlkZXJJbnN0YW5jZSwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJpbmRWaWV3KGNvbXBpbGVFbGVtZW50LmVtYmVkZGVkVmlldywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBldmVudFRhcmdldEFuZE5hbWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0JpbmRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VmFyaWFibGUgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBWaWV3QmluZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFZpZXdCaW5kZXJWaXNpdG9yO1xuICB9KCkpO1xuXG4gIHZhciBJTVBMSUNJVF9URU1QTEFURV9WQVIgPSAnXFwkaW1wbGljaXQnO1xuICB2YXIgQ0xBU1NfQVRUUiQxID0gJ2NsYXNzJztcbiAgdmFyIFNUWUxFX0FUVFIgPSAnc3R5bGUnO1xuICB2YXIgTkdfQ09OVEFJTkVSX1RBRyA9ICduZy1jb250YWluZXInO1xuICB2YXIgcGFyZW50UmVuZGVyTm9kZVZhciA9IHZhcmlhYmxlKCdwYXJlbnRSZW5kZXJOb2RlJyk7XG4gIHZhciByb290U2VsZWN0b3JWYXIgPSB2YXJpYWJsZSgncm9vdFNlbGVjdG9yJyk7XG4gIHZhciBWaWV3RmFjdG9yeURlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0ZhY3RvcnlEZXBlbmRlbmN5KGNvbXAsIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgdGhpcy5jb21wID0gY29tcDtcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gVmlld0ZhY3RvcnlEZXBlbmRlbmN5O1xuICB9KCkpO1xuICB2YXIgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3koY29tcCwgcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeTtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gYnVpbGRWaWV3KHZpZXcsIHRlbXBsYXRlLCB0YXJnZXREZXBlbmRlbmNpZXMpIHtcbiAgICAgIHZhciBidWlsZGVyVmlzaXRvciA9IG5ldyBWaWV3QnVpbGRlclZpc2l0b3IodmlldywgdGFyZ2V0RGVwZW5kZW5jaWVzKTtcbiAgICAgIHRlbXBsYXRlVmlzaXRBbGwoYnVpbGRlclZpc2l0b3IsIHRlbXBsYXRlLCB2aWV3LmRlY2xhcmF0aW9uRWxlbWVudC5pc051bGwoKSA/IHZpZXcuZGVjbGFyYXRpb25FbGVtZW50IDogdmlldy5kZWNsYXJhdGlvbkVsZW1lbnQucGFyZW50KTtcbiAgICAgIHJldHVybiBidWlsZGVyVmlzaXRvci5uZXN0ZWRWaWV3Q291bnQ7XG4gIH1cbiAgZnVuY3Rpb24gZmluaXNoVmlldyh2aWV3LCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICB2aWV3LmFmdGVyTm9kZXMoKTtcbiAgICAgIGNyZWF0ZVZpZXdUb3BMZXZlbFN0bXRzKHZpZXcsIHRhcmdldFN0YXRlbWVudHMpO1xuICAgICAgdmlldy5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb21waWxlRWxlbWVudCAmJiBub2RlLmhhc0VtYmVkZGVkVmlldykge1xuICAgICAgICAgICAgICBmaW5pc2hWaWV3KG5vZGUuZW1iZWRkZWRWaWV3LCB0YXJnZXRTdGF0ZW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICB2YXIgVmlld0J1aWxkZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFZpZXdCdWlsZGVyVmlzaXRvcih2aWV3LCB0YXJnZXREZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgIHRoaXMudGFyZ2V0RGVwZW5kZW5jaWVzID0gdGFyZ2V0RGVwZW5kZW5jaWVzO1xuICAgICAgICAgIHRoaXMubmVzdGVkVmlld0NvdW50ID0gMDtcbiAgICAgIH1cbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX2lzUm9vdE5vZGUgPSBmdW5jdGlvbiAocGFyZW50KSB7IHJldHVybiBwYXJlbnQudmlldyAhPT0gdGhpcy52aWV3OyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS5fYWRkUm9vdE5vZGVBbmRQcm9qZWN0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgcHJvamVjdGVkTm9kZSA9IF9nZXRPdXRlckNvbnRhaW5lck9yU2VsZihub2RlKTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcHJvamVjdGVkTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIG5nQ29udGVudEluZGV4ID0gcHJvamVjdGVkTm9kZS5zb3VyY2VBc3QubmdDb250ZW50SW5kZXg7XG4gICAgICAgICAgdmFyIHZjQXBwRWwgPSAobm9kZSBpbnN0YW5jZW9mIENvbXBpbGVFbGVtZW50ICYmIG5vZGUuaGFzVmlld0NvbnRhaW5lcikgPyBub2RlLmFwcEVsZW1lbnQgOiBudWxsO1xuICAgICAgICAgIGlmICh0aGlzLl9pc1Jvb3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgLy8gc3RvcmUgYXBwRWxlbWVudCBhcyByb290IG5vZGUgb25seSBmb3IgVmlld0NvbnRhaW5lcnNcbiAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy52aWV3VHlwZSAhPT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZpZXcucm9vdE5vZGVzT3JBcHBFbGVtZW50cy5wdXNoKGlzUHJlc2VudCh2Y0FwcEVsKSA/IHZjQXBwRWwgOiBub2RlLnJlbmRlck5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwYXJlbnQuY29tcG9uZW50KSAmJiBpc1ByZXNlbnQobmdDb250ZW50SW5kZXgpKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5hZGRDb250ZW50Tm9kZShuZ0NvbnRlbnRJbmRleCwgaXNQcmVzZW50KHZjQXBwRWwpID8gdmNBcHBFbCA6IG5vZGUucmVuZGVyTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX2dldFBhcmVudFJlbmRlck5vZGUgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50ID0gX2dldE91dGVyQ29udGFpbmVyUGFyZW50T3JTZWxmKHBhcmVudCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2lzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRSZW5kZXJOb2RlVmFyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gcm9vdCBub2RlIG9mIGFuIGVtYmVkZGVkL2hvc3Qgdmlld1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIE5VTExfRVhQUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChwYXJlbnQuY29tcG9uZW50KSAmJlxuICAgICAgICAgICAgICAgICAgcGFyZW50LmNvbXBvbmVudC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uICE9PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5hdGl2ZSA/XG4gICAgICAgICAgICAgICAgICBOVUxMX0VYUFIgOlxuICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbmRlck5vZGU7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb3VuZFRleHQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0KGFzdCwgJycsIHBhcmVudCk7XG4gICAgICB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0KGFzdCwgYXN0LnZhbHVlLCBwYXJlbnQpO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIHZhbHVlLCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgZmllbGROYW1lID0gXCJfdGV4dF9cIiArIHRoaXMudmlldy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgdGhpcy52aWV3LmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGZpZWxkTmFtZSwgaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlclRleHQpKSk7XG4gICAgICAgICAgdmFyIHJlbmRlck5vZGUgPSBUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpO1xuICAgICAgICAgIHZhciBjb21waWxlTm9kZSA9IG5ldyBDb21waWxlTm9kZShwYXJlbnQsIHRoaXMudmlldywgdGhpcy52aWV3Lm5vZGVzLmxlbmd0aCwgcmVuZGVyTm9kZSwgYXN0KTtcbiAgICAgICAgICB2YXIgY3JlYXRlUmVuZGVyTm9kZSA9IFRISVNfRVhQUi5wcm9wKGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgLnNldChWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdjcmVhdGVUZXh0JywgW1xuICAgICAgICAgICAgICB0aGlzLl9nZXRQYXJlbnRSZW5kZXJOb2RlKHBhcmVudCksIGxpdGVyYWwodmFsdWUpLFxuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLnJlc2V0RGVidWdJbmZvRXhwcih0aGlzLnZpZXcubm9kZXMubGVuZ3RoLCBhc3QpXG4gICAgICAgICAgXSkpXG4gICAgICAgICAgICAgIC50b1N0bXQoKTtcbiAgICAgICAgICB0aGlzLnZpZXcubm9kZXMucHVzaChjb21waWxlTm9kZSk7XG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KGNyZWF0ZVJlbmRlck5vZGUpO1xuICAgICAgICAgIHRoaXMuX2FkZFJvb3ROb2RlQW5kUHJvamVjdChjb21waWxlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vZGU7XG4gICAgICB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5nQ29udGVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICAgIC8vIHRoZSBwcm9qZWN0ZWQgbm9kZXMgb3JpZ2luYXRlIGZyb20gYSBkaWZmZXJlbnQgdmlldywgc28gd2UgZG9uJ3RcbiAgICAgICAgICAvLyBoYXZlIGRlYnVnIGluZm9ybWF0aW9uIGZvciB0aGVtLi4uXG4gICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5yZXNldERlYnVnSW5mbyhudWxsLCBhc3QpO1xuICAgICAgICAgIHZhciBwYXJlbnRSZW5kZXJOb2RlID0gdGhpcy5fZ2V0UGFyZW50UmVuZGVyTm9kZShwYXJlbnQpO1xuICAgICAgICAgIHZhciBub2Rlc0V4cHJlc3Npb24gPSBWaWV3UHJvcGVydGllcy5wcm9qZWN0YWJsZU5vZGVzLmtleShsaXRlcmFsKGFzdC5pbmRleCksIG5ldyBBcnJheVR5cGUoaW1wb3J0VHlwZSh0aGlzLnZpZXcuZ2VuQ29uZmlnLnJlbmRlclR5cGVzLnJlbmRlck5vZGUpKSk7XG4gICAgICAgICAgaWYgKHBhcmVudFJlbmRlck5vZGUgIT09IE5VTExfRVhQUikge1xuICAgICAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoVmlld1Byb3BlcnRpZXMucmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdwcm9qZWN0Tm9kZXMnLCBbXG4gICAgICAgICAgICAgICAgICBwYXJlbnRSZW5kZXJOb2RlLFxuICAgICAgICAgICAgICAgICAgaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5mbGF0dGVuTmVzdGVkVmlld1JlbmRlck5vZGVzKSlcbiAgICAgICAgICAgICAgICAgICAgICAuY2FsbEZuKFtub2Rlc0V4cHJlc3Npb25dKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNSb290Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcudmlld1R5cGUgIT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgcm9vdCBub2RlcyBvbmx5IGZvciBlbWJlZGRlZC9ob3N0IHZpZXdzXG4gICAgICAgICAgICAgICAgICB0aGlzLnZpZXcucm9vdE5vZGVzT3JBcHBFbGVtZW50cy5wdXNoKG5vZGVzRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50LmNvbXBvbmVudCkgJiYgaXNQcmVzZW50KGFzdC5uZ0NvbnRlbnRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudC5hZGRDb250ZW50Tm9kZShhc3QubmdDb250ZW50SW5kZXgsIG5vZGVzRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBwYXJlbnQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLnZpZXcubm9kZXMubGVuZ3RoO1xuICAgICAgICAgIHZhciBjcmVhdGVSZW5kZXJOb2RlRXhwcjtcbiAgICAgICAgICB2YXIgZGVidWdDb250ZXh0RXhwciA9IHRoaXMudmlldy5jcmVhdGVNZXRob2QucmVzZXREZWJ1Z0luZm9FeHByKG5vZGVJbmRleCwgYXN0KTtcbiAgICAgICAgICBpZiAobm9kZUluZGV4ID09PSAwICYmIHRoaXMudmlldy52aWV3VHlwZSA9PT0gVmlld1R5cGUuSE9TVCkge1xuICAgICAgICAgICAgICBjcmVhdGVSZW5kZXJOb2RlRXhwciA9IFRISVNfRVhQUi5jYWxsTWV0aG9kKCdzZWxlY3RPckNyZWF0ZUhvc3RFbGVtZW50JywgW2xpdGVyYWwoYXN0Lm5hbWUpLCByb290U2VsZWN0b3JWYXIsIGRlYnVnQ29udGV4dEV4cHJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChhc3QubmFtZSA9PT0gTkdfQ09OVEFJTkVSX1RBRykge1xuICAgICAgICAgICAgICAgICAgY3JlYXRlUmVuZGVyTm9kZUV4cHIgPSBWaWV3UHJvcGVydGllcy5yZW5kZXJlci5jYWxsTWV0aG9kKCdjcmVhdGVUZW1wbGF0ZUFuY2hvcicsIFt0aGlzLl9nZXRQYXJlbnRSZW5kZXJOb2RlKHBhcmVudCksIGRlYnVnQ29udGV4dEV4cHJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlbmRlck5vZGVFeHByID0gVmlld1Byb3BlcnRpZXMucmVuZGVyZXIuY2FsbE1ldGhvZCgnY3JlYXRlRWxlbWVudCcsIFt0aGlzLl9nZXRQYXJlbnRSZW5kZXJOb2RlKHBhcmVudCksIGxpdGVyYWwoYXN0Lm5hbWUpLCBkZWJ1Z0NvbnRleHRFeHByXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IFwiX2VsX1wiICsgbm9kZUluZGV4O1xuICAgICAgICAgIHRoaXMudmlldy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChmaWVsZE5hbWUsIGltcG9ydFR5cGUodGhpcy52aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJFbGVtZW50KSkpO1xuICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChUSElTX0VYUFIucHJvcChmaWVsZE5hbWUpLnNldChjcmVhdGVSZW5kZXJOb2RlRXhwcikudG9TdG10KCkpO1xuICAgICAgICAgIHZhciByZW5kZXJOb2RlID0gVEhJU19FWFBSLnByb3AoZmllbGROYW1lKTtcbiAgICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IGFzdC5kaXJlY3RpdmVzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7IHJldHVybiBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlOyB9KTtcbiAgICAgICAgICB2YXIgY29tcG9uZW50ID0gZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgICAgICAgdmFyIGh0bWxBdHRycyA9IF9yZWFkSHRtbEF0dHJzKGFzdC5hdHRycyk7XG4gICAgICAgICAgdmFyIGF0dHJOYW1lQW5kVmFsdWVzID0gX21lcmdlSHRtbEFuZERpcmVjdGl2ZUF0dHJzKGh0bWxBdHRycywgZGlyZWN0aXZlcyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyTmFtZUFuZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSBhdHRyTmFtZUFuZFZhbHVlc1tpXVswXTtcbiAgICAgICAgICAgICAgaWYgKGFzdC5uYW1lICE9PSBOR19DT05UQUlORVJfVEFHKSB7XG4gICAgICAgICAgICAgICAgICAvLyA8bmctY29udGFpbmVyPiBhcmUgbm90IHJlbmRlcmVkIGluIHRoZSBET01cbiAgICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyTmFtZUFuZFZhbHVlc1tpXVsxXTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QuYWRkU3RtdChWaWV3UHJvcGVydGllcy5yZW5kZXJlclxuICAgICAgICAgICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdzZXRFbGVtZW50QXR0cmlidXRlJywgW3JlbmRlck5vZGUsIGxpdGVyYWwoYXR0ck5hbWUpLCBsaXRlcmFsKGF0dHJWYWx1ZSldKVxuICAgICAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbXBpbGVFbGVtZW50ID0gbmV3IENvbXBpbGVFbGVtZW50KHBhcmVudCwgdGhpcy52aWV3LCBub2RlSW5kZXgsIHJlbmRlck5vZGUsIGFzdCwgY29tcG9uZW50LCBkaXJlY3RpdmVzLCBhc3QucHJvdmlkZXJzLCBhc3QuaGFzVmlld0NvbnRhaW5lciwgZmFsc2UsIGFzdC5yZWZlcmVuY2VzKTtcbiAgICAgICAgICB0aGlzLnZpZXcubm9kZXMucHVzaChjb21waWxlRWxlbWVudCk7XG4gICAgICAgICAgdmFyIGNvbXBWaWV3RXhwciA9IG51bGw7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChjb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHZhciBuZXN0ZWRDb21wb25lbnRJZGVudGlmaWVyID0gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiBnZXRWaWV3RmFjdG9yeU5hbWUoY29tcG9uZW50LCAwKSB9KTtcbiAgICAgICAgICAgICAgdGhpcy50YXJnZXREZXBlbmRlbmNpZXMucHVzaChuZXcgVmlld0ZhY3RvcnlEZXBlbmRlbmN5KGNvbXBvbmVudC50eXBlLCBuZXN0ZWRDb21wb25lbnRJZGVudGlmaWVyKSk7XG4gICAgICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudElkZW50aWZpZXJzID0gY29tcG9uZW50LmVudHJ5Q29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaWQgPSBuZXcgQ29tcGlsZUlkZW50aWZpZXJNZXRhZGF0YSh7IG5hbWU6IGVudHJ5Q29tcG9uZW50Lm5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXREZXBlbmRlbmNpZXMucHVzaChuZXcgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3koZW50cnlDb21wb25lbnQsIGlkKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb21waWxlRWxlbWVudC5jcmVhdGVDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoZW50cnlDb21wb25lbnRJZGVudGlmaWVycyk7XG4gICAgICAgICAgICAgIGNvbXBWaWV3RXhwciA9IHZhcmlhYmxlKFwiY29tcFZpZXdfXCIgKyBub2RlSW5kZXgpOyAvLyBmaXggaGlnaGxpZ2h0aW5nOiBgXG4gICAgICAgICAgICAgIGNvbXBpbGVFbGVtZW50LnNldENvbXBvbmVudFZpZXcoY29tcFZpZXdFeHByKTtcbiAgICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KGNvbXBWaWV3RXhwclxuICAgICAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKG5lc3RlZENvbXBvbmVudElkZW50aWZpZXIpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICBWaWV3UHJvcGVydGllcy52aWV3VXRpbHMsIGNvbXBpbGVFbGVtZW50LmluamVjdG9yLCBjb21waWxlRWxlbWVudC5hcHBFbGVtZW50XG4gICAgICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXBpbGVFbGVtZW50LmJlZm9yZUNoaWxkcmVuKCk7XG4gICAgICAgICAgdGhpcy5fYWRkUm9vdE5vZGVBbmRQcm9qZWN0KGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbiwgY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIGNvbXBpbGVFbGVtZW50LmFmdGVyQ2hpbGRyZW4odGhpcy52aWV3Lm5vZGVzLmxlbmd0aCAtIG5vZGVJbmRleCAtIDEpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29tcFZpZXdFeHByKSkge1xuICAgICAgICAgICAgICB2YXIgY29kZUdlbkNvbnRlbnROb2RlcztcbiAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5jb21wb25lbnQudHlwZS5pc0hvc3QpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGVHZW5Db250ZW50Tm9kZXMgPSBWaWV3UHJvcGVydGllcy5wcm9qZWN0YWJsZU5vZGVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29kZUdlbkNvbnRlbnROb2RlcyA9IGxpdGVyYWxBcnIoY29tcGlsZUVsZW1lbnQuY29udGVudE5vZGVzQnlOZ0NvbnRlbnRJbmRleC5tYXAoZnVuY3Rpb24gKG5vZGVzKSB7IHJldHVybiBjcmVhdGVGbGF0QXJyYXkobm9kZXMpOyB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy52aWV3LmNyZWF0ZU1ldGhvZC5hZGRTdG10KGNvbXBWaWV3RXhwclxuICAgICAgICAgICAgICAgICAgLmNhbGxNZXRob2QoJ2NyZWF0ZScsIFtjb21waWxlRWxlbWVudC5nZXRDb21wb25lbnQoKSwgY29kZUdlbkNvbnRlbnROb2RlcywgTlVMTF9FWFBSXSlcbiAgICAgICAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbWJlZGRlZFRlbXBsYXRlID0gZnVuY3Rpb24gKGFzdCwgcGFyZW50KSB7XG4gICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMudmlldy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IFwiX2FuY2hvcl9cIiArIG5vZGVJbmRleDtcbiAgICAgICAgICB0aGlzLnZpZXcuZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoZmllbGROYW1lLCBpbXBvcnRUeXBlKHRoaXMudmlldy5nZW5Db25maWcucmVuZGVyVHlwZXMucmVuZGVyQ29tbWVudCkpKTtcbiAgICAgICAgICB0aGlzLnZpZXcuY3JlYXRlTWV0aG9kLmFkZFN0bXQoVEhJU19FWFBSLnByb3AoZmllbGROYW1lKVxuICAgICAgICAgICAgICAuc2V0KFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2NyZWF0ZVRlbXBsYXRlQW5jaG9yJywgW1xuICAgICAgICAgICAgICB0aGlzLl9nZXRQYXJlbnRSZW5kZXJOb2RlKHBhcmVudCksXG4gICAgICAgICAgICAgIHRoaXMudmlldy5jcmVhdGVNZXRob2QucmVzZXREZWJ1Z0luZm9FeHByKG5vZGVJbmRleCwgYXN0KVxuICAgICAgICAgIF0pKVxuICAgICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAgIHZhciByZW5kZXJOb2RlID0gVEhJU19FWFBSLnByb3AoZmllbGROYW1lKTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVWYXJpYWJsZUJpbmRpbmdzID0gYXN0LnZhcmlhYmxlcy5tYXAoZnVuY3Rpb24gKHZhckFzdCkgeyByZXR1cm4gW3ZhckFzdC52YWx1ZS5sZW5ndGggPiAwID8gdmFyQXN0LnZhbHVlIDogSU1QTElDSVRfVEVNUExBVEVfVkFSLCB2YXJBc3QubmFtZV07IH0pO1xuICAgICAgICAgIHZhciBkaXJlY3RpdmVzID0gYXN0LmRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmVBc3QpIHsgcmV0dXJuIGRpcmVjdGl2ZUFzdC5kaXJlY3RpdmU7IH0pO1xuICAgICAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IG5ldyBDb21waWxlRWxlbWVudChwYXJlbnQsIHRoaXMudmlldywgbm9kZUluZGV4LCByZW5kZXJOb2RlLCBhc3QsIG51bGwsIGRpcmVjdGl2ZXMsIGFzdC5wcm92aWRlcnMsIGFzdC5oYXNWaWV3Q29udGFpbmVyLCB0cnVlLCBhc3QucmVmZXJlbmNlcyk7XG4gICAgICAgICAgdGhpcy52aWV3Lm5vZGVzLnB1c2goY29tcGlsZUVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMubmVzdGVkVmlld0NvdW50Kys7XG4gICAgICAgICAgdmFyIGVtYmVkZGVkVmlldyA9IG5ldyBDb21waWxlVmlldyh0aGlzLnZpZXcuY29tcG9uZW50LCB0aGlzLnZpZXcuZ2VuQ29uZmlnLCB0aGlzLnZpZXcucGlwZU1ldGFzLCBOVUxMX0VYUFIsIHRoaXMudmlldy5hbmltYXRpb25zLCB0aGlzLnZpZXcudmlld0luZGV4ICsgdGhpcy5uZXN0ZWRWaWV3Q291bnQsIGNvbXBpbGVFbGVtZW50LCB0ZW1wbGF0ZVZhcmlhYmxlQmluZGluZ3MpO1xuICAgICAgICAgIHRoaXMubmVzdGVkVmlld0NvdW50ICs9IGJ1aWxkVmlldyhlbWJlZGRlZFZpZXcsIGFzdC5jaGlsZHJlbiwgdGhpcy50YXJnZXREZXBlbmRlbmNpZXMpO1xuICAgICAgICAgIGNvbXBpbGVFbGVtZW50LmJlZm9yZUNoaWxkcmVuKCk7XG4gICAgICAgICAgdGhpcy5fYWRkUm9vdE5vZGVBbmRQcm9qZWN0KGNvbXBpbGVFbGVtZW50KTtcbiAgICAgICAgICBjb21waWxlRWxlbWVudC5hZnRlckNoaWxkcmVuKDApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFdmVudCA9IGZ1bmN0aW9uIChhc3QsIGV2ZW50VGFyZ2V0QW5kTmFtZXMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBWaWV3QnVpbGRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcmlhYmxlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVmlld0J1aWxkZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERpcmVjdGl2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAgIFZpZXdCdWlsZGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFZpZXdCdWlsZGVyVmlzaXRvcjtcbiAgfSgpKTtcbiAgLyoqXG4gICAqIFdhbGtzIHVwIHRoZSBub2RlcyB3aGlsZSB0aGUgZGlyZWN0IHBhcmVudCBpcyBhIGNvbnRhaW5lci5cbiAgICpcbiAgICogUmV0dXJucyB0aGUgb3V0ZXIgY29udGFpbmVyIG9yIHRoZSBub2RlIGl0c2VsZiB3aGVuIGl0IGlzIG5vdCBhIGRpcmVjdCBjaGlsZCBvZiBhIGNvbnRhaW5lci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0T3V0ZXJDb250YWluZXJPclNlbGYobm9kZSkge1xuICAgICAgdmFyIHZpZXcgPSBub2RlLnZpZXc7XG4gICAgICB3aGlsZSAoX2lzTmdDb250YWluZXIobm9kZS5wYXJlbnQsIHZpZXcpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFdhbGtzIHVwIHRoZSBub2RlcyB3aGlsZSB0aGV5IGFyZSBjb250YWluZXIgYW5kIHJldHVybnMgdGhlIGZpcnN0IHBhcmVudCB3aGljaCBpcyBub3QuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGUgb3V0ZXIgY29udGFpbmVyIG9yIHRoZSBub2RlIGl0c2VsZiB3aGVuIGl0IGlzIG5vdCBhIGNvbnRhaW5lci5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0T3V0ZXJDb250YWluZXJQYXJlbnRPclNlbGYoZWwpIHtcbiAgICAgIHZhciB2aWV3ID0gZWwudmlldztcbiAgICAgIHdoaWxlIChfaXNOZ0NvbnRhaW5lcihlbCwgdmlldykpIHtcbiAgICAgICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbDtcbiAgfVxuICBmdW5jdGlvbiBfaXNOZ0NvbnRhaW5lcihub2RlLCB2aWV3KSB7XG4gICAgICByZXR1cm4gIW5vZGUuaXNOdWxsKCkgJiYgbm9kZS5zb3VyY2VBc3QubmFtZSA9PT0gTkdfQ09OVEFJTkVSX1RBRyAmJlxuICAgICAgICAgIG5vZGUudmlldyA9PT0gdmlldztcbiAgfVxuICBmdW5jdGlvbiBfbWVyZ2VIdG1sQW5kRGlyZWN0aXZlQXR0cnMoZGVjbGFyZWRIdG1sQXR0cnMsIGRpcmVjdGl2ZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIE9iamVjdC5rZXlzKGRlY2xhcmVkSHRtbEF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmVzdWx0W2tleV0gPSBkZWNsYXJlZEh0bWxBdHRyc1trZXldOyB9KTtcbiAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlTWV0YSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZU1ldGEuaG9zdEF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGlyZWN0aXZlTWV0YS5ob3N0QXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHJlc3VsdFtuYW1lXTtcbiAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gaXNQcmVzZW50KHByZXZWYWx1ZSkgPyBtZXJnZUF0dHJpYnV0ZVZhbHVlKG5hbWUsIHByZXZWYWx1ZSwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXBUb0tleVZhbHVlQXJyYXkocmVzdWx0KTtcbiAgfVxuICBmdW5jdGlvbiBfcmVhZEh0bWxBdHRycyhhdHRycykge1xuICAgICAgdmFyIGh0bWxBdHRycyA9IHt9O1xuICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7IGh0bWxBdHRyc1thc3QubmFtZV0gPSBhc3QudmFsdWU7IH0pO1xuICAgICAgcmV0dXJuIGh0bWxBdHRycztcbiAgfVxuICBmdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZVZhbHVlKGF0dHJOYW1lLCBhdHRyVmFsdWUxLCBhdHRyVmFsdWUyKSB7XG4gICAgICBpZiAoYXR0ck5hbWUgPT0gQ0xBU1NfQVRUUiQxIHx8IGF0dHJOYW1lID09IFNUWUxFX0FUVFIpIHtcbiAgICAgICAgICByZXR1cm4gYXR0clZhbHVlMSArIFwiIFwiICsgYXR0clZhbHVlMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhdHRyVmFsdWUyO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcFRvS2V5VmFsdWVBcnJheShkYXRhKSB7XG4gICAgICB2YXIgZW50cnlBcnJheSA9IFtdO1xuICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyBlbnRyeUFycmF5LnB1c2goW25hbWUsIGRhdGFbbmFtZV1dKTsgfSk7XG4gICAgICAvLyBXZSBuZWVkIHRvIHNvcnQgdG8gZ2V0IGEgZGVmaW5lZCBvdXRwdXQgb3JkZXJcbiAgICAgIC8vIGZvciB0ZXN0cyBhbmQgZm9yIGNhY2hpbmcgZ2VuZXJhdGVkIGFydGlmYWN0cy4uLlxuICAgICAgTGlzdFdyYXBwZXIuc29ydChlbnRyeUFycmF5LCBmdW5jdGlvbiAoZW50cnkxLCBlbnRyeTIpIHsgcmV0dXJuIFN0cmluZ1dyYXBwZXIuY29tcGFyZShlbnRyeTFbMF0sIGVudHJ5MlswXSk7IH0pO1xuICAgICAgcmV0dXJuIGVudHJ5QXJyYXk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlVmlld1RvcExldmVsU3RtdHModmlldywgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgdmFyIG5vZGVEZWJ1Z0luZm9zVmFyID0gTlVMTF9FWFBSO1xuICAgICAgaWYgKHZpZXcuZ2VuQ29uZmlnLmdlbkRlYnVnSW5mbykge1xuICAgICAgICAgIG5vZGVEZWJ1Z0luZm9zVmFyID0gdmFyaWFibGUoXCJub2RlRGVidWdJbmZvc19cIiArIHZpZXcuY29tcG9uZW50LnR5cGUubmFtZSArIHZpZXcudmlld0luZGV4KTsgLy8gZml4IGhpZ2hsaWdodGluZzogYFxuICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaChub2RlRGVidWdJbmZvc1ZhclxuICAgICAgICAgICAgICAuc2V0KGxpdGVyYWxBcnIodmlldy5ub2Rlcy5tYXAoY3JlYXRlU3RhdGljTm9kZURlYnVnSW5mbyksIG5ldyBBcnJheVR5cGUobmV3IEV4dGVybmFsVHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5TdGF0aWNOb2RlRGVidWdJbmZvKSksIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSkpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVuZGVyQ29tcFR5cGVWYXIgPSB2YXJpYWJsZShcInJlbmRlclR5cGVfXCIgKyB2aWV3LmNvbXBvbmVudC50eXBlLm5hbWUpOyAvLyBmaXggaGlnaGxpZ2h0aW5nOiBgXG4gICAgICBpZiAodmlldy52aWV3SW5kZXggPT09IDApIHtcbiAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2gocmVuZGVyQ29tcFR5cGVWYXIuc2V0KE5VTExfRVhQUilcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5SZW5kZXJDb21wb25lbnRUeXBlKSkpKTtcbiAgICAgIH1cbiAgICAgIHZhciB2aWV3Q2xhc3MgPSBjcmVhdGVWaWV3Q2xhc3ModmlldywgcmVuZGVyQ29tcFR5cGVWYXIsIG5vZGVEZWJ1Z0luZm9zVmFyKTtcbiAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaCh2aWV3Q2xhc3MpO1xuICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKGNyZWF0ZVZpZXdGYWN0b3J5KHZpZXcsIHZpZXdDbGFzcywgcmVuZGVyQ29tcFR5cGVWYXIpKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVTdGF0aWNOb2RlRGVidWdJbmZvKG5vZGUpIHtcbiAgICAgIHZhciBjb21waWxlRWxlbWVudCA9IG5vZGUgaW5zdGFuY2VvZiBDb21waWxlRWxlbWVudCA/IG5vZGUgOiBudWxsO1xuICAgICAgdmFyIHByb3ZpZGVyVG9rZW5zID0gW107XG4gICAgICB2YXIgY29tcG9uZW50VG9rZW4gPSBOVUxMX0VYUFI7XG4gICAgICB2YXIgdmFyVG9rZW5FbnRyaWVzID0gW107XG4gICAgICBpZiAoaXNQcmVzZW50KGNvbXBpbGVFbGVtZW50KSkge1xuICAgICAgICAgIHByb3ZpZGVyVG9rZW5zID0gY29tcGlsZUVsZW1lbnQuZ2V0UHJvdmlkZXJUb2tlbnMoKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBpbGVFbGVtZW50LmNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50VG9rZW4gPSBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbihpZGVudGlmaWVyVG9rZW4oY29tcGlsZUVsZW1lbnQuY29tcG9uZW50LnR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmtleXMoY29tcGlsZUVsZW1lbnQucmVmZXJlbmNlVG9rZW5zKS5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciB0b2tlbiA9IGNvbXBpbGVFbGVtZW50LnJlZmVyZW5jZVRva2Vuc1t2YXJOYW1lXTtcbiAgICAgICAgICAgICAgdmFyVG9rZW5FbnRyaWVzLnB1c2goW3Zhck5hbWUsIGlzUHJlc2VudCh0b2tlbikgPyBjcmVhdGVEaVRva2VuRXhwcmVzc2lvbih0b2tlbikgOiBOVUxMX0VYUFJdKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlN0YXRpY05vZGVEZWJ1Z0luZm8pKVxuICAgICAgICAgIC5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgbGl0ZXJhbEFycihwcm92aWRlclRva2VucywgbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUsIFtUeXBlTW9kaWZpZXIuQ29uc3RdKSksXG4gICAgICAgICAgY29tcG9uZW50VG9rZW4sXG4gICAgICAgICAgbGl0ZXJhbE1hcCh2YXJUb2tlbkVudHJpZXMsIG5ldyBNYXBUeXBlKERZTkFNSUNfVFlQRSwgW1R5cGVNb2RpZmllci5Db25zdF0pKVxuICAgICAgXSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5TdGF0aWNOb2RlRGVidWdJbmZvKSwgbnVsbCwgW1R5cGVNb2RpZmllci5Db25zdF0pKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVWaWV3Q2xhc3ModmlldywgcmVuZGVyQ29tcFR5cGVWYXIsIG5vZGVEZWJ1Z0luZm9zVmFyKSB7XG4gICAgICB2YXIgdmlld0NvbnN0cnVjdG9yQXJncyA9IFtcbiAgICAgICAgICBuZXcgRm5QYXJhbShWaWV3Q29uc3RydWN0b3JWYXJzLnZpZXdVdGlscy5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlZpZXdVdGlscykpKSxcbiAgICAgICAgICBuZXcgRm5QYXJhbShWaWV3Q29uc3RydWN0b3JWYXJzLnBhcmVudEluamVjdG9yLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuSW5qZWN0b3IpKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVmlld0NvbnN0cnVjdG9yVmFycy5kZWNsYXJhdGlvbkVsLm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwRWxlbWVudCkpKVxuICAgICAgXTtcbiAgICAgIHZhciBzdXBlckNvbnN0cnVjdG9yQXJncyA9IFtcbiAgICAgICAgICB2YXJpYWJsZSh2aWV3LmNsYXNzTmFtZSksIHJlbmRlckNvbXBUeXBlVmFyLCBWaWV3VHlwZUVudW0uZnJvbVZhbHVlKHZpZXcudmlld1R5cGUpLFxuICAgICAgICAgIFZpZXdDb25zdHJ1Y3RvclZhcnMudmlld1V0aWxzLCBWaWV3Q29uc3RydWN0b3JWYXJzLnBhcmVudEluamVjdG9yLFxuICAgICAgICAgIFZpZXdDb25zdHJ1Y3RvclZhcnMuZGVjbGFyYXRpb25FbCxcbiAgICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c0VudW0uZnJvbVZhbHVlKGdldENoYW5nZURldGVjdGlvbk1vZGUodmlldykpXG4gICAgICBdO1xuICAgICAgaWYgKHZpZXcuZ2VuQ29uZmlnLmdlbkRlYnVnSW5mbykge1xuICAgICAgICAgIHN1cGVyQ29uc3RydWN0b3JBcmdzLnB1c2gobm9kZURlYnVnSW5mb3NWYXIpO1xuICAgICAgfVxuICAgICAgdmFyIHZpZXdDb25zdHJ1Y3RvciA9IG5ldyBDbGFzc01ldGhvZChudWxsLCB2aWV3Q29uc3RydWN0b3JBcmdzLCBbU1VQRVJfRVhQUi5jYWxsRm4oc3VwZXJDb25zdHJ1Y3RvckFyZ3MpLnRvU3RtdCgpXSk7XG4gICAgICB2YXIgdmlld01ldGhvZHMgPSBbXG4gICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdjcmVhdGVJbnRlcm5hbCcsIFtuZXcgRm5QYXJhbShyb290U2VsZWN0b3JWYXIubmFtZSwgU1RSSU5HX1RZUEUpXSwgZ2VuZXJhdGVDcmVhdGVNZXRob2QodmlldyksIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwRWxlbWVudCkpKSxcbiAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2luamVjdG9yR2V0SW50ZXJuYWwnLCBbXG4gICAgICAgICAgICAgIG5ldyBGblBhcmFtKEluamVjdE1ldGhvZFZhcnMudG9rZW4ubmFtZSwgRFlOQU1JQ19UWVBFKSxcbiAgICAgICAgICAgICAgLy8gTm90ZTogQ2FuJ3QgdXNlIG8uSU5UX1RZUEUgaGVyZSBhcyB0aGUgbWV0aG9kIGluIEFwcFZpZXcgdXNlcyBudW1iZXJcbiAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oSW5qZWN0TWV0aG9kVmFycy5yZXF1ZXN0Tm9kZUluZGV4Lm5hbWUsIE5VTUJFUl9UWVBFKSxcbiAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oSW5qZWN0TWV0aG9kVmFycy5ub3RGb3VuZFJlc3VsdC5uYW1lLCBEWU5BTUlDX1RZUEUpXG4gICAgICAgICAgXSwgYWRkUmV0dXJuVmFsdWVmTm90RW1wdHkodmlldy5pbmplY3RvckdldE1ldGhvZC5maW5pc2goKSwgSW5qZWN0TWV0aG9kVmFycy5ub3RGb3VuZFJlc3VsdCksIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdkZXRlY3RDaGFuZ2VzSW50ZXJuYWwnLCBbbmV3IEZuUGFyYW0oRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZS5uYW1lLCBCT09MX1RZUEUpXSwgZ2VuZXJhdGVEZXRlY3RDaGFuZ2VzTWV0aG9kKHZpZXcpKSxcbiAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2RpcnR5UGFyZW50UXVlcmllc0ludGVybmFsJywgW10sIHZpZXcuZGlydHlQYXJlbnRRdWVyaWVzTWV0aG9kLmZpbmlzaCgpKSxcbiAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2Rlc3Ryb3lJbnRlcm5hbCcsIFtdLCB2aWV3LmRlc3Ryb3lNZXRob2QuZmluaXNoKCkpLFxuICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZGV0YWNoSW50ZXJuYWwnLCBbXSwgdmlldy5kZXRhY2hNZXRob2QuZmluaXNoKCkpXG4gICAgICBdLmNvbmNhdCh2aWV3LmV2ZW50SGFuZGxlck1ldGhvZHMpO1xuICAgICAgdmFyIHN1cGVyQ2xhc3MgPSB2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8gPyBJZGVudGlmaWVycy5EZWJ1Z0FwcFZpZXcgOiBJZGVudGlmaWVycy5BcHBWaWV3O1xuICAgICAgdmFyIHZpZXdDbGFzcyA9IG5ldyBDbGFzc1N0bXQodmlldy5jbGFzc05hbWUsIGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoc3VwZXJDbGFzcyksIFtnZXRDb250ZXh0VHlwZSh2aWV3KV0pLCB2aWV3LmZpZWxkcywgdmlldy5nZXR0ZXJzLCB2aWV3Q29uc3RydWN0b3IsIHZpZXdNZXRob2RzLmZpbHRlcihmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBtZXRob2QuYm9keS5sZW5ndGggPiAwOyB9KSk7XG4gICAgICByZXR1cm4gdmlld0NsYXNzO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVZpZXdGYWN0b3J5KHZpZXcsIHZpZXdDbGFzcywgcmVuZGVyQ29tcFR5cGVWYXIpIHtcbiAgICAgIHZhciB2aWV3RmFjdG9yeUFyZ3MgPSBbXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMubmFtZSwgaW1wb3J0VHlwZShyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3VXRpbHMpKSksXG4gICAgICAgICAgbmV3IEZuUGFyYW0oVmlld0NvbnN0cnVjdG9yVmFycy5wYXJlbnRJbmplY3Rvci5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkluamVjdG9yKSkpLFxuICAgICAgICAgIG5ldyBGblBhcmFtKFZpZXdDb25zdHJ1Y3RvclZhcnMuZGVjbGFyYXRpb25FbC5uYW1lLCBpbXBvcnRUeXBlKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFwcEVsZW1lbnQpKSlcbiAgICAgIF07XG4gICAgICB2YXIgaW5pdFJlbmRlckNvbXBUeXBlU3RtdHMgPSBbXTtcbiAgICAgIHZhciB0ZW1wbGF0ZVVybEluZm87XG4gICAgICBpZiAodmlldy5jb21wb25lbnQudGVtcGxhdGUudGVtcGxhdGVVcmwgPT0gdmlldy5jb21wb25lbnQudHlwZS5tb2R1bGVVcmwpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVVybEluZm8gPVxuICAgICAgICAgICAgICB2aWV3LmNvbXBvbmVudC50eXBlLm1vZHVsZVVybCArIFwiIGNsYXNzIFwiICsgdmlldy5jb21wb25lbnQudHlwZS5uYW1lICsgXCIgLSBpbmxpbmUgdGVtcGxhdGVcIjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRlbXBsYXRlVXJsSW5mbyA9IHZpZXcuY29tcG9uZW50LnRlbXBsYXRlLnRlbXBsYXRlVXJsO1xuICAgICAgfVxuICAgICAgaWYgKHZpZXcudmlld0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbnNFeHByID0gbGl0ZXJhbE1hcCh2aWV3LmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gW2VudHJ5Lm5hbWUsIGVudHJ5LmZuRXhwXTsgfSkpO1xuICAgICAgICAgIGluaXRSZW5kZXJDb21wVHlwZVN0bXRzID0gW25ldyBJZlN0bXQocmVuZGVyQ29tcFR5cGVWYXIuaWRlbnRpY2FsKE5VTExfRVhQUiksIFtyZW5kZXJDb21wVHlwZVZhclxuICAgICAgICAgICAgICAgICAgICAgIC5zZXQoVmlld0NvbnN0cnVjdG9yVmFycy52aWV3VXRpbHMuY2FsbE1ldGhvZCgnY3JlYXRlUmVuZGVyQ29tcG9uZW50VHlwZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICB2aWV3LmdlbkNvbmZpZy5nZW5EZWJ1Z0luZm8gPyBsaXRlcmFsKHRlbXBsYXRlVXJsSW5mbykgOiBsaXRlcmFsKCcnKSxcbiAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKHZpZXcuY29tcG9uZW50LnRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgIFZpZXdFbmNhcHN1bGF0aW9uRW51bS5mcm9tVmFsdWUodmlldy5jb21wb25lbnQudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgdmlldy5zdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uc0V4cHIsXG4gICAgICAgICAgICAgICAgICBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAudG9TdG10KCldKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZm4odmlld0ZhY3RvcnlBcmdzLCBpbml0UmVuZGVyQ29tcFR5cGVTdG10cy5jb25jYXQoW25ldyBSZXR1cm5TdGF0ZW1lbnQodmFyaWFibGUodmlld0NsYXNzLm5hbWUpXG4gICAgICAgICAgICAgIC5pbnN0YW50aWF0ZSh2aWV3Q2xhc3MuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHZhcmlhYmxlKHBhcmFtLm5hbWUpOyB9KSkpXSksIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQXBwVmlldyksIFtnZXRDb250ZXh0VHlwZSh2aWV3KV0pKVxuICAgICAgICAgIC50b0RlY2xTdG10KHZpZXcudmlld0ZhY3RvcnkubmFtZSwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ3JlYXRlTWV0aG9kKHZpZXcpIHtcbiAgICAgIHZhciBwYXJlbnRSZW5kZXJOb2RlRXhwciA9IE5VTExfRVhQUjtcbiAgICAgIHZhciBwYXJlbnRSZW5kZXJOb2RlU3RtdHMgPSBbXTtcbiAgICAgIGlmICh2aWV3LnZpZXdUeXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICBwYXJlbnRSZW5kZXJOb2RlRXhwciA9IFZpZXdQcm9wZXJ0aWVzLnJlbmRlcmVyLmNhbGxNZXRob2QoJ2NyZWF0ZVZpZXdSb290JywgW1RISVNfRVhQUi5wcm9wKCdkZWNsYXJhdGlvbkFwcEVsZW1lbnQnKS5wcm9wKCduYXRpdmVFbGVtZW50JyldKTtcbiAgICAgICAgICBwYXJlbnRSZW5kZXJOb2RlU3RtdHMgPVxuICAgICAgICAgICAgICBbcGFyZW50UmVuZGVyTm9kZVZhci5zZXQocGFyZW50UmVuZGVyTm9kZUV4cHIpXG4gICAgICAgICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoaW1wb3J0VHlwZSh2aWV3LmdlbkNvbmZpZy5yZW5kZXJUeXBlcy5yZW5kZXJOb2RlKSwgW1N0bXRNb2RpZmllci5GaW5hbF0pXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRFeHByO1xuICAgICAgaWYgKHZpZXcudmlld1R5cGUgPT09IFZpZXdUeXBlLkhPU1QpIHtcbiAgICAgICAgICByZXN1bHRFeHByID0gdmlldy5ub2Rlc1swXS5hcHBFbGVtZW50O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0RXhwciA9IE5VTExfRVhQUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRSZW5kZXJOb2RlU3RtdHMuY29uY2F0KHZpZXcuY3JlYXRlTWV0aG9kLmZpbmlzaCgpLCBbXG4gICAgICAgICAgVEhJU19FWFBSXG4gICAgICAgICAgICAgIC5jYWxsTWV0aG9kKCdpbml0JywgW1xuICAgICAgICAgICAgICBjcmVhdGVGbGF0QXJyYXkodmlldy5yb290Tm9kZXNPckFwcEVsZW1lbnRzKSxcbiAgICAgICAgICAgICAgbGl0ZXJhbEFycih2aWV3Lm5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5yZW5kZXJOb2RlOyB9KSksIGxpdGVyYWxBcnIodmlldy5kaXNwb3NhYmxlcyksXG4gICAgICAgICAgICAgIGxpdGVyYWxBcnIodmlldy5zdWJzY3JpcHRpb25zKVxuICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC50b1N0bXQoKSxcbiAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KHJlc3VsdEV4cHIpXG4gICAgICBdKTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZURldGVjdENoYW5nZXNNZXRob2Qodmlldykge1xuICAgICAgdmFyIHN0bXRzID0gW107XG4gICAgICBpZiAodmlldy5hbmltYXRpb25CaW5kaW5nc01ldGhvZC5pc0VtcHR5KCkgJiYgdmlldy5kZXRlY3RDaGFuZ2VzSW5JbnB1dHNNZXRob2QuaXNFbXB0eSgpICYmXG4gICAgICAgICAgdmlldy51cGRhdGVDb250ZW50UXVlcmllc01ldGhvZC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICB2aWV3LmFmdGVyQ29udGVudExpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICB2aWV3LmRldGVjdENoYW5nZXNSZW5kZXJQcm9wZXJ0aWVzTWV0aG9kLmlzRW1wdHkoKSAmJlxuICAgICAgICAgIHZpZXcudXBkYXRlVmlld1F1ZXJpZXNNZXRob2QuaXNFbXB0eSgpICYmIHZpZXcuYWZ0ZXJWaWV3TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmlzRW1wdHkoKSkge1xuICAgICAgICAgIHJldHVybiBzdG10cztcbiAgICAgIH1cbiAgICAgIExpc3RXcmFwcGVyLmFkZEFsbChzdG10cywgdmlldy5hbmltYXRpb25CaW5kaW5nc01ldGhvZC5maW5pc2goKSk7XG4gICAgICBMaXN0V3JhcHBlci5hZGRBbGwoc3RtdHMsIHZpZXcuZGV0ZWN0Q2hhbmdlc0luSW5wdXRzTWV0aG9kLmZpbmlzaCgpKTtcbiAgICAgIHN0bXRzLnB1c2goVEhJU19FWFBSLmNhbGxNZXRob2QoJ2RldGVjdENvbnRlbnRDaGlsZHJlbkNoYW5nZXMnLCBbRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZV0pXG4gICAgICAgICAgLnRvU3RtdCgpKTtcbiAgICAgIHZhciBhZnRlckNvbnRlbnRTdG10cyA9IHZpZXcudXBkYXRlQ29udGVudFF1ZXJpZXNNZXRob2QuZmluaXNoKCkuY29uY2F0KHZpZXcuYWZ0ZXJDb250ZW50TGlmZWN5Y2xlQ2FsbGJhY2tzTWV0aG9kLmZpbmlzaCgpKTtcbiAgICAgIGlmIChhZnRlckNvbnRlbnRTdG10cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3RtdHMucHVzaChuZXcgSWZTdG10KG5vdChEZXRlY3RDaGFuZ2VzVmFycy50aHJvd09uQ2hhbmdlKSwgYWZ0ZXJDb250ZW50U3RtdHMpKTtcbiAgICAgIH1cbiAgICAgIExpc3RXcmFwcGVyLmFkZEFsbChzdG10cywgdmlldy5kZXRlY3RDaGFuZ2VzUmVuZGVyUHJvcGVydGllc01ldGhvZC5maW5pc2goKSk7XG4gICAgICBzdG10cy5wdXNoKFRISVNfRVhQUi5jYWxsTWV0aG9kKCdkZXRlY3RWaWV3Q2hpbGRyZW5DaGFuZ2VzJywgW0RldGVjdENoYW5nZXNWYXJzLnRocm93T25DaGFuZ2VdKVxuICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICB2YXIgYWZ0ZXJWaWV3U3RtdHMgPSB2aWV3LnVwZGF0ZVZpZXdRdWVyaWVzTWV0aG9kLmZpbmlzaCgpLmNvbmNhdCh2aWV3LmFmdGVyVmlld0xpZmVjeWNsZUNhbGxiYWNrc01ldGhvZC5maW5pc2goKSk7XG4gICAgICBpZiAoYWZ0ZXJWaWV3U3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0bXRzLnB1c2gobmV3IElmU3RtdChub3QoRGV0ZWN0Q2hhbmdlc1ZhcnMudGhyb3dPbkNoYW5nZSksIGFmdGVyVmlld1N0bXRzKSk7XG4gICAgICB9XG4gICAgICB2YXIgdmFyU3RtdHMgPSBbXTtcbiAgICAgIHZhciByZWFkVmFycyA9IGZpbmRSZWFkVmFyTmFtZXMoc3RtdHMpO1xuICAgICAgaWYgKHJlYWRWYXJzLmhhcyhEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkLm5hbWUpKSB7XG4gICAgICAgICAgdmFyU3RtdHMucHVzaChEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VkLnNldChsaXRlcmFsKHRydWUpKS50b0RlY2xTdG10KEJPT0xfVFlQRSkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWRWYXJzLmhhcyhEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VzLm5hbWUpKSB7XG4gICAgICAgICAgdmFyU3RtdHMucHVzaChEZXRlY3RDaGFuZ2VzVmFycy5jaGFuZ2VzLnNldChOVUxMX0VYUFIpXG4gICAgICAgICAgICAgIC50b0RlY2xTdG10KG5ldyBNYXBUeXBlKGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuU2ltcGxlQ2hhbmdlKSkpKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVhZFZhcnMuaGFzKERldGVjdENoYW5nZXNWYXJzLnZhbFVud3JhcHBlci5uYW1lKSkge1xuICAgICAgICAgIHZhclN0bXRzLnB1c2goRGV0ZWN0Q2hhbmdlc1ZhcnMudmFsVW53cmFwcGVyXG4gICAgICAgICAgICAgIC5zZXQoaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WYWx1ZVVud3JhcHBlcikpLmluc3RhbnRpYXRlKFtdKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YXJTdG10cy5jb25jYXQoc3RtdHMpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFJldHVyblZhbHVlZk5vdEVtcHR5KHN0YXRlbWVudHMsIHZhbHVlKSB7XG4gICAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHMuY29uY2F0KFtuZXcgUmV0dXJuU3RhdGVtZW50KHZhbHVlKV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q29udGV4dFR5cGUodmlldykge1xuICAgICAgaWYgKHZpZXcudmlld1R5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgIHJldHVybiBpbXBvcnRUeXBlKHZpZXcuY29tcG9uZW50LnR5cGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIERZTkFNSUNfVFlQRTtcbiAgfVxuICBmdW5jdGlvbiBnZXRDaGFuZ2VEZXRlY3Rpb25Nb2RlKHZpZXcpIHtcbiAgICAgIHZhciBtb2RlO1xuICAgICAgaWYgKHZpZXcudmlld1R5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCkge1xuICAgICAgICAgIG1vZGUgPSBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSh2aWV3LmNvbXBvbmVudC5jaGFuZ2VEZXRlY3Rpb24pID9cbiAgICAgICAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tBbHdheXMgOlxuICAgICAgICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1cy5DaGVja09uY2U7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBtb2RlID0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tBbHdheXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZTtcbiAgfVxuXG4gIHZhciBWaWV3Q29tcGlsZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBWaWV3Q29tcGlsZVJlc3VsdChzdGF0ZW1lbnRzLCB2aWV3RmFjdG9yeVZhciwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgICB0aGlzLnZpZXdGYWN0b3J5VmFyID0gdmlld0ZhY3RvcnlWYXI7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gVmlld0NvbXBpbGVSZXN1bHQ7XG4gIH0oKSk7XG4gIHZhciBWaWV3Q29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVmlld0NvbXBpbGVyKF9nZW5Db25maWcpIHtcbiAgICAgICAgICB0aGlzLl9nZW5Db25maWcgPSBfZ2VuQ29uZmlnO1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNvbXBpbGVyID0gbmV3IEFuaW1hdGlvbkNvbXBpbGVyKCk7XG4gICAgICB9XG4gICAgICBWaWV3Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0ZW1wbGF0ZSwgc3R5bGVzLCBwaXBlcywgY29tcGlsZWRBbmltYXRpb25zKSB7XG4gICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICAgIHZhciB2aWV3ID0gbmV3IENvbXBpbGVWaWV3KGNvbXBvbmVudCwgdGhpcy5fZ2VuQ29uZmlnLCBwaXBlcywgc3R5bGVzLCBjb21waWxlZEFuaW1hdGlvbnMsIDAsIENvbXBpbGVFbGVtZW50LmNyZWF0ZU51bGwoKSwgW10pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgICAgYnVpbGRWaWV3KHZpZXcsIHRlbXBsYXRlLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgICAgIC8vIE5lZWQgdG8gc2VwYXJhdGUgYmluZGluZyBmcm9tIGNyZWF0aW9uIHRvIGJlIGFibGUgdG8gcmVmZXIgdG9cbiAgICAgICAgICAvLyB2YXJpYWJsZXMgdGhhdCBoYXZlIGJlZW4gZGVjbGFyZWQgYWZ0ZXIgdXNhZ2UuXG4gICAgICAgICAgYmluZFZpZXcodmlldywgdGVtcGxhdGUpO1xuICAgICAgICAgIGZpbmlzaFZpZXcodmlldywgc3RhdGVtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBWaWV3Q29tcGlsZVJlc3VsdChzdGF0ZW1lbnRzLCB2aWV3LnZpZXdGYWN0b3J5Lm5hbWUsIGRlcGVuZGVuY2llcyk7XG4gICAgICB9O1xuICAgICAgVmlld0NvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFZpZXdDb21waWxlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IENvbXBpbGVyQ29uZmlnLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBWaWV3Q29tcGlsZXI7XG4gIH0oKSk7XG5cbiAgdmFyIFNvdXJjZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTb3VyY2VNb2R1bGUobW9kdWxlVXJsLCBzb3VyY2UpIHtcbiAgICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTb3VyY2VNb2R1bGU7XG4gIH0oKSk7XG4gIHZhciBOZ01vZHVsZXNTdW1tYXJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlc1N1bW1hcnkobmdNb2R1bGVCeUNvbXBvbmVudCkge1xuICAgICAgICAgIHRoaXMubmdNb2R1bGVCeUNvbXBvbmVudCA9IG5nTW9kdWxlQnlDb21wb25lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmdNb2R1bGVzU3VtbWFyeTtcbiAgfSgpKTtcbiAgdmFyIE9mZmxpbmVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBPZmZsaW5lQ29tcGlsZXIoX21ldGFkYXRhUmVzb2x2ZXIsIF9kaXJlY3RpdmVOb3JtYWxpemVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfbmdNb2R1bGVDb21waWxlciwgX291dHB1dEVtaXR0ZXIsIF9sb2NhbGVJZCwgX3RyYW5zbGF0aW9uRm9ybWF0KSB7XG4gICAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciA9IF9tZXRhZGF0YVJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIgPSBfZGlyZWN0aXZlTm9ybWFsaXplcjtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZVBhcnNlciA9IF90ZW1wbGF0ZVBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgICAgdGhpcy5fdmlld0NvbXBpbGVyID0gX3ZpZXdDb21waWxlcjtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyID0gX25nTW9kdWxlQ29tcGlsZXI7XG4gICAgICAgICAgdGhpcy5fb3V0cHV0RW1pdHRlciA9IF9vdXRwdXRFbWl0dGVyO1xuICAgICAgICAgIHRoaXMuX2xvY2FsZUlkID0gX2xvY2FsZUlkO1xuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uRm9ybWF0ID0gX3RyYW5zbGF0aW9uRm9ybWF0O1xuICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblBhcnNlciA9IG5ldyBBbmltYXRpb25QYXJzZXIoKTtcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25Db21waWxlciA9IG5ldyBBbmltYXRpb25Db21waWxlcigpO1xuICAgICAgfVxuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5hbmFseXplTW9kdWxlcyA9IGZ1bmN0aW9uIChuZ01vZHVsZXMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBuZ01vZHVsZUJ5Q29tcG9uZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICAgIG5nTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZ01vZHVsZSkge1xuICAgICAgICAgICAgICB2YXIgbmdNb2R1bGVNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShuZ01vZHVsZSk7XG4gICAgICAgICAgICAgIG5nTW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyTWV0YSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGRpck1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBuZ01vZHVsZUJ5Q29tcG9uZW50LnNldChkaXJNZXRhLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZU1ldGEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IE5nTW9kdWxlc1N1bW1hcnkobmdNb2R1bGVCeUNvbXBvbmVudCk7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIG5nTW9kdWxlc1N1bW1hcnksIGNvbXBvbmVudHMsIG5nTW9kdWxlcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGZpbGVTdWZmaXggPSBfc3BsaXRUeXBlc2NyaXB0U3VmZml4KG1vZHVsZVVybClbMV07XG4gICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgICB2YXIgZXhwb3J0ZWRWYXJzID0gW107XG4gICAgICAgICAgdmFyIG91dHB1dFNvdXJjZU1vZHVsZXMgPSBbXTtcbiAgICAgICAgICAvLyBjb21waWxlIGFsbCBuZyBtb2R1bGVzXG4gICAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2guYXBwbHkoZXhwb3J0ZWRWYXJzLCBuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlTW9kdWxlKG5nTW9kdWxlVHlwZSwgc3RhdGVtZW50cyk7IH0pKTtcbiAgICAgICAgICAvLyBjb21waWxlIGNvbXBvbmVudHNcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgICAuYWxsKGNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChjb21wVHlwZSkge1xuICAgICAgICAgICAgICB2YXIgY29tcE1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShjb21wVHlwZSk7XG4gICAgICAgICAgICAgIHZhciBuZ01vZHVsZSA9IG5nTW9kdWxlc1N1bW1hcnkubmdNb2R1bGVCeUNvbXBvbmVudC5nZXQoY29tcFR5cGUpO1xuICAgICAgICAgICAgICBpZiAoIW5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGV0ZXJtaW5lIHRoZSBtb2R1bGUgZm9yIGNvbXBvbmVudCBcIiArIGNvbXBNZXRhLnR5cGUubmFtZSArIFwiIVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgLmFsbChbY29tcE1ldGFdLmNvbmNhdChuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMpLm1hcChmdW5jdGlvbiAoZGlyTWV0YSkgeyByZXR1cm4gX3RoaXMuX2RpcmVjdGl2ZU5vcm1hbGl6ZXIubm9ybWFsaXplRGlyZWN0aXZlKGRpck1ldGEpLmFzeW5jUmVzdWx0OyB9KSlcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChub3JtYWxpemVkQ29tcFdpdGhEaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29tcE1ldGEgPSBub3JtYWxpemVkQ29tcFdpdGhEaXJlY3RpdmVzWzBdLCBkaXJNZXRhcyA9IG5vcm1hbGl6ZWRDb21wV2l0aERpcmVjdGl2ZXMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICBfYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbXBpbGUgc3R5bGVzXG4gICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzQ29tcGlsZVJlc3VsdHMgPSBfdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgICAgICAgIHN0eWxlc0NvbXBpbGVSZXN1bHRzLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcGlsZWRTdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0U291cmNlTW9kdWxlcy5wdXNoKF90aGlzLl9jb2RnZW5TdHlsZXMoY29tcGlsZWRTdHlsZVNoZWV0LCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2goX3RoaXMuX2NvbXBpbGVDb21wb25lbnRGYWN0b3J5KGNvbXBNZXRhLCBmaWxlU3VmZml4LCBzdGF0ZW1lbnRzKSwgX3RoaXMuX2NvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIGRpck1ldGFzLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLnBpcGVzLCBuZ01vZHVsZS5zY2hlbWFzLCBzdHlsZXNDb21waWxlUmVzdWx0cy5jb21wb25lbnRTdHlsZXNoZWV0LCBmaWxlU3VmZml4LCBzdGF0ZW1lbnRzKSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFNvdXJjZU1vZHVsZXMudW5zaGlmdChfdGhpcy5fY29kZWdlblNvdXJjZU1vZHVsZShfbmdmYWN0b3J5TW9kdWxlVXJsKG1vZHVsZVVybCksIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXRTb3VyY2VNb2R1bGVzO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGUgPSBmdW5jdGlvbiAobmdNb2R1bGVUeXBlLCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICAgICAgdmFyIG5nTW9kdWxlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG5nTW9kdWxlVHlwZSk7XG4gICAgICAgICAgdmFyIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICAgIGlmICh0aGlzLl9sb2NhbGVJZCkge1xuICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaChuZXcgQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgdG9rZW46IHJlc29sdmVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuTE9DQUxFX0lEKSxcbiAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0aGlzLl9sb2NhbGVJZCxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fdHJhbnNsYXRpb25Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2gobmV3IENvbXBpbGVQcm92aWRlck1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIHRva2VuOiByZXNvbHZlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLlRSQU5TTEFUSU9OU19GT1JNQVQpLFxuICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRoaXMuX3RyYW5zbGF0aW9uRm9ybWF0XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFwcENvbXBpbGVSZXN1bHQgPSB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyLmNvbXBpbGUobmdNb2R1bGUsIHByb3ZpZGVycyk7XG4gICAgICAgICAgYXBwQ29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgICAgIGRlcC5wbGFjZWhvbGRlci5uYW1lID0gX2NvbXBvbmVudEZhY3RvcnlOYW1lKGRlcC5jb21wKTtcbiAgICAgICAgICAgICAgZGVwLnBsYWNlaG9sZGVyLm1vZHVsZVVybCA9IF9uZ2ZhY3RvcnlNb2R1bGVVcmwoZGVwLmNvbXAubW9kdWxlVXJsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgYXBwQ29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gYXBwQ29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXI7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcE1ldGEsIGZpbGVTdWZmaXgsIHRhcmdldFN0YXRlbWVudHMpIHtcbiAgICAgICAgICB2YXIgaG9zdE1ldGEgPSBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wTWV0YSk7XG4gICAgICAgICAgdmFyIGhvc3RWaWV3RmFjdG9yeVZhciA9IHRoaXMuX2NvbXBpbGVDb21wb25lbnQoaG9zdE1ldGEsIFtjb21wTWV0YV0sIFtdLCBbXSwgbnVsbCwgZmlsZVN1ZmZpeCwgdGFyZ2V0U3RhdGVtZW50cyk7XG4gICAgICAgICAgdmFyIGNvbXBGYWN0b3J5VmFyID0gX2NvbXBvbmVudEZhY3RvcnlOYW1lKGNvbXBNZXRhLnR5cGUpO1xuICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaCh2YXJpYWJsZShjb21wRmFjdG9yeVZhcilcbiAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnkpLCBbaW1wb3J0VHlwZShjb21wTWV0YS50eXBlKV0pXG4gICAgICAgICAgICAgIC5pbnN0YW50aWF0ZShbXG4gICAgICAgICAgICAgIGxpdGVyYWwoY29tcE1ldGEuc2VsZWN0b3IpLFxuICAgICAgICAgICAgICB2YXJpYWJsZShob3N0Vmlld0ZhY3RvcnlWYXIpLFxuICAgICAgICAgICAgICBpbXBvcnRFeHByKGNvbXBNZXRhLnR5cGUpLFxuICAgICAgICAgIF0sIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSksIFtpbXBvcnRUeXBlKGNvbXBNZXRhLnR5cGUpXSwgW1R5cGVNb2RpZmllci5Db25zdF0pKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICAgICAgICByZXR1cm4gY29tcEZhY3RvcnlWYXI7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wTWV0YSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIGNvbXBvbmVudFN0eWxlcywgZmlsZVN1ZmZpeCwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICAgIHZhciBwYXJzZWRBbmltYXRpb25zID0gdGhpcy5fYW5pbWF0aW9uUGFyc2VyLnBhcnNlQ29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICB2YXIgcGFyc2VkVGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCBjb21wTWV0YS50eXBlLm5hbWUpO1xuICAgICAgICAgIHZhciBzdHlsZXNFeHByID0gY29tcG9uZW50U3R5bGVzID8gdmFyaWFibGUoY29tcG9uZW50U3R5bGVzLnN0eWxlc1ZhcikgOiBsaXRlcmFsQXJyKFtdKTtcbiAgICAgICAgICB2YXIgY29tcGlsZWRBbmltYXRpb25zID0gdGhpcy5fYW5pbWF0aW9uQ29tcGlsZXIuY29tcGlsZShjb21wTWV0YS50eXBlLm5hbWUsIHBhcnNlZEFuaW1hdGlvbnMpO1xuICAgICAgICAgIHZhciB2aWV3UmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCBzdHlsZXNFeHByLCBwaXBlcywgY29tcGlsZWRBbmltYXRpb25zKTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50U3R5bGVzKSB7XG4gICAgICAgICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaC5hcHBseSh0YXJnZXRTdGF0ZW1lbnRzLCBfcmVzb2x2ZVN0eWxlU3RhdGVtZW50cyhjb21wb25lbnRTdHlsZXMsIGZpbGVTdWZmaXgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcGlsZWRBbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IGVudHJ5LnN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVtZW50KSB7IHRhcmdldFN0YXRlbWVudHMucHVzaChzdGF0ZW1lbnQpOyB9KTsgfSk7XG4gICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoLmFwcGx5KHRhcmdldFN0YXRlbWVudHMsIF9yZXNvbHZlVmlld1N0YXRlbWVudHModmlld1Jlc3VsdCkpO1xuICAgICAgICAgIHJldHVybiB2aWV3UmVzdWx0LnZpZXdGYWN0b3J5VmFyO1xuICAgICAgfTtcbiAgICAgIE9mZmxpbmVDb21waWxlci5wcm90b3R5cGUuX2NvZGdlblN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXNDb21waWxlUmVzdWx0LCBmaWxlU3VmZml4KSB7XG4gICAgICAgICAgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHMoc3R5bGVzQ29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGVnZW5Tb3VyY2VNb2R1bGUoX3N0eWxlc01vZHVsZVVybChzdHlsZXNDb21waWxlUmVzdWx0Lm1ldGEubW9kdWxlVXJsLCBzdHlsZXNDb21waWxlUmVzdWx0LmlzU2hpbW1lZCwgZmlsZVN1ZmZpeCksIHN0eWxlc0NvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgW3N0eWxlc0NvbXBpbGVSZXN1bHQuc3R5bGVzVmFyXSk7XG4gICAgICB9O1xuICAgICAgT2ZmbGluZUNvbXBpbGVyLnByb3RvdHlwZS5fY29kZWdlblNvdXJjZU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycykge1xuICAgICAgICAgIHJldHVybiBuZXcgU291cmNlTW9kdWxlKG1vZHVsZVVybCwgdGhpcy5fb3V0cHV0RW1pdHRlci5lbWl0U3RhdGVtZW50cyhtb2R1bGVVcmwsIHN0YXRlbWVudHMsIGV4cG9ydGVkVmFycykpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBPZmZsaW5lQ29tcGlsZXI7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9yZXNvbHZlVmlld1N0YXRlbWVudHMoY29tcGlsZVJlc3VsdCkge1xuICAgICAgY29tcGlsZVJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgaWYgKGRlcCBpbnN0YW5jZW9mIFZpZXdGYWN0b3J5RGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICB2YXIgdmZkID0gZGVwO1xuICAgICAgICAgICAgICB2ZmQucGxhY2Vob2xkZXIubW9kdWxlVXJsID0gX25nZmFjdG9yeU1vZHVsZVVybCh2ZmQuY29tcC5tb2R1bGVVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChkZXAgaW5zdGFuY2VvZiBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgICB2YXIgY2ZkID0gZGVwO1xuICAgICAgICAgICAgICBjZmQucGxhY2Vob2xkZXIubmFtZSA9IF9jb21wb25lbnRGYWN0b3J5TmFtZShjZmQuY29tcCk7XG4gICAgICAgICAgICAgIGNmZC5wbGFjZWhvbGRlci5tb2R1bGVVcmwgPSBfbmdmYWN0b3J5TW9kdWxlVXJsKGNmZC5jb21wLm1vZHVsZVVybCk7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzO1xuICB9XG4gIGZ1bmN0aW9uIF9yZXNvbHZlU3R5bGVTdGF0ZW1lbnRzKGNvbXBpbGVSZXN1bHQsIGZpbGVTdWZmaXgpIHtcbiAgICAgIGNvbXBpbGVSZXN1bHQuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgIGRlcC52YWx1ZVBsYWNlaG9sZGVyLm1vZHVsZVVybCA9IF9zdHlsZXNNb2R1bGVVcmwoZGVwLm1vZHVsZVVybCwgZGVwLmlzU2hpbW1lZCwgZmlsZVN1ZmZpeCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb21waWxlUmVzdWx0LnN0YXRlbWVudHM7XG4gIH1cbiAgZnVuY3Rpb24gX25nZmFjdG9yeU1vZHVsZVVybChjb21wVXJsKSB7XG4gICAgICB2YXIgdXJsV2l0aFN1ZmZpeCA9IF9zcGxpdFR5cGVzY3JpcHRTdWZmaXgoY29tcFVybCk7XG4gICAgICByZXR1cm4gdXJsV2l0aFN1ZmZpeFswXSArIFwiLm5nZmFjdG9yeVwiICsgdXJsV2l0aFN1ZmZpeFsxXTtcbiAgfVxuICBmdW5jdGlvbiBfY29tcG9uZW50RmFjdG9yeU5hbWUoY29tcCkge1xuICAgICAgcmV0dXJuIGNvbXAubmFtZSArIFwiTmdGYWN0b3J5XCI7XG4gIH1cbiAgZnVuY3Rpb24gX3N0eWxlc01vZHVsZVVybChzdHlsZXNoZWV0VXJsLCBzaGltLCBzdWZmaXgpIHtcbiAgICAgIHJldHVybiBzaGltID8gc3R5bGVzaGVldFVybCArIFwiLnNoaW1cIiArIHN1ZmZpeCA6IFwiXCIgKyBzdHlsZXNoZWV0VXJsICsgc3VmZml4O1xuICB9XG4gIGZ1bmN0aW9uIF9hc3NlcnRDb21wb25lbnQobWV0YSkge1xuICAgICAgaWYgKCFtZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBpbGUgJ1wiICsgbWV0YS50eXBlLm5hbWUgKyBcIicgYmVjYXVzZSBpdCBpcyBub3QgYSBjb21wb25lbnQuXCIpO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9zcGxpdFR5cGVzY3JpcHRTdWZmaXgocGF0aCkge1xuICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy5kLnRzJykpIHtcbiAgICAgICAgICByZXR1cm4gW3BhdGguc2xpY2UoMCwgLTUpLCAnLnRzJ107XG4gICAgICB9XG4gICAgICB2YXIgbGFzdERvdCA9IHBhdGgubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChsYXN0RG90ICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBbcGF0aC5zdWJzdHJpbmcoMCwgbGFzdERvdCksIHBhdGguc3Vic3RyaW5nKGxhc3REb3QpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbcGF0aCwgJyddO1xuICB9XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICAvKipcbiAgICogQW4gaW50ZXJmYWNlIGZvciByZXRyaWV2aW5nIGRvY3VtZW50cyBieSBVUkwgdGhhdCB0aGUgY29tcGlsZXIgdXNlc1xuICAgKiB0byBsb2FkIHRlbXBsYXRlcy5cbiAgICovXG4gIHZhciBSZXNvdXJjZUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlcigpIHtcbiAgICAgIH1cbiAgICAgIFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgcmV0dXJuIFJlc291cmNlTG9hZGVyO1xuICB9KCkpO1xuXG4gIHZhciBfQVNTRVRfU0NIRU1FID0gJ2Fzc2V0Oic7XG4gIGZ1bmN0aW9uIGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIoKSB7XG4gICAgICByZXR1cm4gbmV3IFVybFJlc29sdmVyKF9BU1NFVF9TQ0hFTUUpO1xuICB9XG4gIC8qKlxuICAgKiBBIGRlZmF1bHQgcHJvdmlkZXIgZm9yIHtAbGluayBQQUNLQUdFX1JPT1RfVVJMfSB0aGF0IG1hcHMgdG8gJy8nLlxuICAgKi9cbiAgdmFyIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIgPSB7XG4gICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlBBQ0tBR0VfUk9PVF9VUkwsXG4gICAgICB1c2VWYWx1ZTogJy8nXG4gIH07XG4gIC8qKlxuICAgKiBVc2VkIGJ5IHRoZSB7QGxpbmsgQ29tcGlsZXJ9IHdoZW4gcmVzb2x2aW5nIEhUTUwgYW5kIENTUyB0ZW1wbGF0ZSBVUkxzLlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAgICpcbiAgICogU2VlIHtAbGluayBDb21waWxlcn1cbiAgICpcbiAgICogIyMgRXhhbXBsZVxuICAgKlxuICAgKiB7QGV4YW1wbGUgY29tcGlsZXIvdHMvdXJsX3Jlc29sdmVyL3VybF9yZXNvbHZlci50cyByZWdpb249J3VybF9yZXNvbHZlcid9XG4gICAqXG4gICAqIEBzZWN1cml0eSAgV2hlbiBjb21waWxpbmcgdGVtcGxhdGVzIGF0IHJ1bnRpbWUsIHlvdSBtdXN0XG4gICAqIGVuc3VyZSB0aGF0IHRoZSBlbnRpcmUgdGVtcGxhdGUgY29tZXMgZnJvbSBhIHRydXN0ZWQgc291cmNlLlxuICAgKiBBdHRhY2tlci1jb250cm9sbGVkIGRhdGEgaW50cm9kdWNlZCBieSBhIHRlbXBsYXRlIGNvdWxkIGV4cG9zZSB5b3VyXG4gICAqIGFwcGxpY2F0aW9uIHRvIFhTUyByaXNrcy4gRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgKi9cbiAgdmFyIFVybFJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFVybFJlc29sdmVyKF9wYWNrYWdlUHJlZml4KSB7XG4gICAgICAgICAgaWYgKF9wYWNrYWdlUHJlZml4ID09PSB2b2lkIDApIHsgX3BhY2thZ2VQcmVmaXggPSBudWxsOyB9XG4gICAgICAgICAgdGhpcy5fcGFja2FnZVByZWZpeCA9IF9wYWNrYWdlUHJlZml4O1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBSZXNvbHZlcyB0aGUgYHVybGAgZ2l2ZW4gdGhlIGBiYXNlVXJsYDpcbiAgICAgICAqIC0gd2hlbiB0aGUgYHVybGAgaXMgbnVsbCwgdGhlIGBiYXNlVXJsYCBpcyByZXR1cm5lZCxcbiAgICAgICAqIC0gaWYgYHVybGAgaXMgcmVsYXRpdmUgKCdwYXRoL3RvL2hlcmUnLCAnLi9wYXRoL3RvL2hlcmUnKSwgdGhlIHJlc29sdmVkIHVybCBpcyBhIGNvbWJpbmF0aW9uIG9mXG4gICAgICAgKiBgYmFzZVVybGAgYW5kIGB1cmxgLFxuICAgICAgICogLSBpZiBgdXJsYCBpcyBhYnNvbHV0ZSAoaXQgaGFzIGEgc2NoZW1lOiAnaHR0cDovLycsICdodHRwczovLycgb3Igc3RhcnQgd2l0aCAnLycpLCB0aGUgYHVybGAgaXNcbiAgICAgICAqIHJldHVybmVkIGFzIGlzIChpZ25vcmluZyB0aGUgYGJhc2VVcmxgKVxuICAgICAgICovXG4gICAgICBVcmxSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChiYXNlVXJsLCB1cmwpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRVcmwgPSB1cmw7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChiYXNlVXJsKSAmJiBiYXNlVXJsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBfcmVzb2x2ZVVybChiYXNlVXJsLCByZXNvbHZlZFVybCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXNvbHZlZFBhcnRzID0gX3NwbGl0KHJlc29sdmVkVXJsKTtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5fcGFja2FnZVByZWZpeDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHByZWZpeCkgJiYgaXNQcmVzZW50KHJlc29sdmVkUGFydHMpICYmXG4gICAgICAgICAgICAgIHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPT0gJ3BhY2thZ2UnKSB7XG4gICAgICAgICAgICAgIHZhciBwYXRoID0gcmVzb2x2ZWRQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wYWNrYWdlUHJlZml4ID09PSBfQVNTRVRfU0NIRU1FKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGF0aFNlZ2VtZW50cyA9IHBhdGguc3BsaXQoL1xcLy8pO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRVcmwgPSBcImFzc2V0OlwiICsgcGF0aFNlZ2VtZW50c1swXSArIFwiL2xpYi9cIiArIHBhdGhTZWdlbWVudHMuc2xpY2UoMSkuam9pbignLycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJlZml4ID0gU3RyaW5nV3JhcHBlci5zdHJpcFJpZ2h0KHByZWZpeCwgJy8nKTtcbiAgICAgICAgICAgICAgICAgIHBhdGggPSBTdHJpbmdXcmFwcGVyLnN0cmlwTGVmdChwYXRoLCAnLycpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIFwiL1wiICsgcGF0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRVcmw7XG4gICAgICB9O1xuICAgICAgVXJsUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgVXJsUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbX2FuZ3VsYXJfY29yZS5QQUNLQUdFX1JPT1RfVVJMLF0gfSxdIH0sXG4gICAgICBdO1xuICAgICAgcmV0dXJuIFVybFJlc29sdmVyO1xuICB9KCkpO1xuICAvKipcbiAgICogRXh0cmFjdCB0aGUgc2NoZW1lIG9mIGEgVVJMLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VXJsU2NoZW1lKHVybCkge1xuICAgICAgdmFyIG1hdGNoID0gX3NwbGl0KHVybCk7XG4gICAgICByZXR1cm4gKG1hdGNoICYmIG1hdGNoW19Db21wb25lbnRJbmRleC5TY2hlbWVdKSB8fCAnJztcbiAgfVxuICAvLyBUaGUgY29kZSBiZWxvdyBpcyBhZGFwdGVkIGZyb20gVHJhY2V1cjpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS90cmFjZXVyLWNvbXBpbGVyL2Jsb2IvOTUxMWMxZGFmYTk3MmJmMGRlMTIwMmE4YTg2M2JhZDAyZjBmOTVhOC9zcmMvcnVudGltZS91cmwuanNcbiAgLyoqXG4gICAqIEJ1aWxkcyBhIFVSSSBzdHJpbmcgZnJvbSBhbHJlYWR5LWVuY29kZWQgcGFydHMuXG4gICAqXG4gICAqIE5vIGVuY29kaW5nIGlzIHBlcmZvcm1lZC4gIEFueSBjb21wb25lbnQgbWF5IGJlIG9taXR0ZWQgYXMgZWl0aGVyIG51bGwgb3JcbiAgICogdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0X3NjaGVtZSBUaGUgc2NoZW1lIHN1Y2ggYXMgJ2h0dHAnLlxuICAgKiBAcGFyYW0gb3B0X3VzZXJJbmZvIFRoZSB1c2VyIG5hbWUgYmVmb3JlIHRoZSAnQCcuXG4gICAqIEBwYXJhbSBvcHRfZG9tYWluIFRoZSBkb21haW4gc3VjaCBhcyAnd3d3Lmdvb2dsZS5jb20nLCBhbHJlYWR5XG4gICAqICAgICBVUkktZW5jb2RlZC5cbiAgICogQHBhcmFtIG9wdF9wb3J0IFRoZSBwb3J0IG51bWJlci5cbiAgICogQHBhcmFtIG9wdF9wYXRoIFRoZSBwYXRoLCBhbHJlYWR5IFVSSS1lbmNvZGVkLiAgSWYgaXQgaXMgbm90XG4gICAqICAgICBlbXB0eSwgaXQgbXVzdCBiZWdpbiB3aXRoIGEgc2xhc2guXG4gICAqIEBwYXJhbSBvcHRfcXVlcnlEYXRhIFRoZSBVUkktZW5jb2RlZCBxdWVyeSBkYXRhLlxuICAgKiBAcGFyYW0gb3B0X2ZyYWdtZW50IFRoZSBVUkktZW5jb2RlZCBmcmFnbWVudCBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIFRoZSBmdWxseSBjb21iaW5lZCBVUkkuXG4gICAqL1xuICBmdW5jdGlvbiBfYnVpbGRGcm9tRW5jb2RlZFBhcnRzKG9wdF9zY2hlbWUsIG9wdF91c2VySW5mbywgb3B0X2RvbWFpbiwgb3B0X3BvcnQsIG9wdF9wYXRoLCBvcHRfcXVlcnlEYXRhLCBvcHRfZnJhZ21lbnQpIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGlmIChpc1ByZXNlbnQob3B0X3NjaGVtZSkpIHtcbiAgICAgICAgICBvdXQucHVzaChvcHRfc2NoZW1lICsgJzonKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ByZXNlbnQob3B0X2RvbWFpbikpIHtcbiAgICAgICAgICBvdXQucHVzaCgnLy8nKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KG9wdF91c2VySW5mbykpIHtcbiAgICAgICAgICAgICAgb3V0LnB1c2gob3B0X3VzZXJJbmZvICsgJ0AnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0LnB1c2gob3B0X2RvbWFpbik7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChvcHRfcG9ydCkpIHtcbiAgICAgICAgICAgICAgb3V0LnB1c2goJzonICsgb3B0X3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1ByZXNlbnQob3B0X3BhdGgpKSB7XG4gICAgICAgICAgb3V0LnB1c2gob3B0X3BhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJlc2VudChvcHRfcXVlcnlEYXRhKSkge1xuICAgICAgICAgIG91dC5wdXNoKCc/JyArIG9wdF9xdWVyeURhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJlc2VudChvcHRfZnJhZ21lbnQpKSB7XG4gICAgICAgICAgb3V0LnB1c2goJyMnICsgb3B0X2ZyYWdtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQuam9pbignJyk7XG4gIH1cbiAgLyoqXG4gICAqIEEgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXG4gICAqXG4gICAqIHtAbGluayBodHRwOi8vd3d3LmdiaXYuY29tL3Byb3RvY29scy91cmkvcmZjL3JmYzM5ODYuaHRtbCNSRkMyMjM0fSBzYXlzXG4gICAqIEFzIHRoZSBcImZpcnN0LW1hdGNoLXdpbnNcIiBhbGdvcml0aG0gaXMgaWRlbnRpY2FsIHRvIHRoZSBcImdyZWVkeVwiXG4gICAqIGRpc2FtYmlndWF0aW9uIG1ldGhvZCB1c2VkIGJ5IFBPU0lYIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGl0IGlzIG5hdHVyYWwgYW5kXG4gICAqIGNvbW1vbnBsYWNlIHRvIHVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgcGFyc2luZyB0aGUgcG90ZW50aWFsIGZpdmVcbiAgICogY29tcG9uZW50cyBvZiBhIFVSSSByZWZlcmVuY2UuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgbGluZSBpcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZy1kb3duIGFcbiAgICogd2VsbC1mb3JtZWQgVVJJIHJlZmVyZW5jZSBpbnRvIGl0cyBjb21wb25lbnRzLlxuICAgKlxuICAgKiA8cHJlPlxuICAgKiBeKChbXjovPyNdKyk6KT8oLy8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/XG4gICAqICAxMiAgICAgICAgICAgIDMgIDQgICAgICAgICAgNSAgICAgICA2ICA3ICAgICAgICA4IDlcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIFRoZSBudW1iZXJzIGluIHRoZSBzZWNvbmQgbGluZSBhYm92ZSBhcmUgb25seSB0byBhc3Npc3QgcmVhZGFiaWxpdHk7IHRoZXlcbiAgICogaW5kaWNhdGUgdGhlIHJlZmVyZW5jZSBwb2ludHMgZm9yIGVhY2ggc3ViZXhwcmVzc2lvbiAoaS5lLiwgZWFjaCBwYWlyZWRcbiAgICogcGFyZW50aGVzaXMpLiBXZSByZWZlciB0byB0aGUgdmFsdWUgbWF0Y2hlZCBmb3Igc3ViZXhwcmVzc2lvbiA8bj4gYXMgJDxuPi5cbiAgICogRm9yIGV4YW1wbGUsIG1hdGNoaW5nIHRoZSBhYm92ZSBleHByZXNzaW9uIHRvXG4gICAqIDxwcmU+XG4gICAqICAgICBodHRwOi8vd3d3Lmljcy51Y2kuZWR1L3B1Yi9pZXRmL3VyaS8jUmVsYXRlZFxuICAgKiA8L3ByZT5cbiAgICogcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHN1YmV4cHJlc3Npb24gbWF0Y2hlczpcbiAgICogPHByZT5cbiAgICogICAgJDEgPSBodHRwOlxuICAgKiAgICAkMiA9IGh0dHBcbiAgICogICAgJDMgPSAvL3d3dy5pY3MudWNpLmVkdVxuICAgKiAgICAkNCA9IHd3dy5pY3MudWNpLmVkdVxuICAgKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvXG4gICAqICAgICQ2ID0gPHVuZGVmaW5lZD5cbiAgICogICAgJDcgPSA8dW5kZWZpbmVkPlxuICAgKiAgICAkOCA9ICNSZWxhdGVkXG4gICAqICAgICQ5ID0gUmVsYXRlZFxuICAgKiA8L3ByZT5cbiAgICogd2hlcmUgPHVuZGVmaW5lZD4gaW5kaWNhdGVzIHRoYXQgdGhlIGNvbXBvbmVudCBpcyBub3QgcHJlc2VudCwgYXMgaXMgdGhlXG4gICAqIGNhc2UgZm9yIHRoZSBxdWVyeSBjb21wb25lbnQgaW4gdGhlIGFib3ZlIGV4YW1wbGUuIFRoZXJlZm9yZSwgd2UgY2FuXG4gICAqIGRldGVybWluZSB0aGUgdmFsdWUgb2YgdGhlIGZpdmUgY29tcG9uZW50cyBhc1xuICAgKiA8cHJlPlxuICAgKiAgICBzY2hlbWUgICAgPSAkMlxuICAgKiAgICBhdXRob3JpdHkgPSAkNFxuICAgKiAgICBwYXRoICAgICAgPSAkNVxuICAgKiAgICBxdWVyeSAgICAgPSAkN1xuICAgKiAgICBmcmFnbWVudCAgPSAkOVxuICAgKiA8L3ByZT5cbiAgICpcbiAgICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBoYXMgYmVlbiBtb2RpZmllZCBzbGlnaHRseSB0byBleHBvc2UgdGhlXG4gICAqIHVzZXJJbmZvLCBkb21haW4sIGFuZCBwb3J0IHNlcGFyYXRlbHkgZnJvbSB0aGUgYXV0aG9yaXR5LlxuICAgKiBUaGUgbW9kaWZpZWQgdmVyc2lvbiB5aWVsZHNcbiAgICogPHByZT5cbiAgICogICAgJDEgPSBodHRwICAgICAgICAgICAgICBzY2hlbWVcbiAgICogICAgJDIgPSA8dW5kZWZpbmVkPiAgICAgICB1c2VySW5mbyAtXFxcbiAgICogICAgJDMgPSB3d3cuaWNzLnVjaS5lZHUgICBkb21haW4gICAgIHwgYXV0aG9yaXR5XG4gICAqICAgICQ0ID0gPHVuZGVmaW5lZD4gICAgICAgcG9ydCAgICAgLS9cbiAgICogICAgJDUgPSAvcHViL2lldGYvdXJpLyAgICBwYXRoXG4gICAqICAgICQ2ID0gPHVuZGVmaW5lZD4gICAgICAgcXVlcnkgd2l0aG91dCA/XG4gICAqICAgICQ3ID0gUmVsYXRlZCAgICAgICAgICAgZnJhZ21lbnQgd2l0aG91dCAjXG4gICAqIDwvcHJlPlxuICAgKiBAdHlwZSB7IVJlZ0V4cH1cbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YXIgX3NwbGl0UmUgPSBuZXcgUmVnRXhwKCdeJyArXG4gICAgICAnKD86JyArXG4gICAgICAnKFteOi8/Iy5dKyknICtcbiAgICAgIC8vIHVzZWQgYnkgb3RoZXIgVVJMIHBhcnRzIHN1Y2ggYXMgOixcbiAgICAgIC8vID8sIC8sICMsIGFuZCAuXG4gICAgICAnOik/JyArXG4gICAgICAnKD86Ly8nICtcbiAgICAgICcoPzooW14vPyNdKilAKT8nICtcbiAgICAgICcoW1xcXFx3XFxcXGRcXFxcLVxcXFx1MDEwMC1cXFxcdWZmZmYuJV0qKScgK1xuICAgICAgLy8gZGlnaXRzLCBkYXNoZXMsIGRvdHMsIHBlcmNlbnRcbiAgICAgIC8vIGVzY2FwZXMsIGFuZCB1bmljb2RlIGNoYXJhY3RlcnMuXG4gICAgICAnKD86OihbMC05XSspKT8nICtcbiAgICAgICcpPycgK1xuICAgICAgJyhbXj8jXSspPycgK1xuICAgICAgJyg/OlxcXFw/KFteI10qKSk/JyArXG4gICAgICAnKD86IyguKikpPycgK1xuICAgICAgJyQnKTtcbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiBlYWNoIFVSSSBjb21wb25lbnQgaW4gdGhlIHJldHVybiB2YWx1ZSBvZiBnb29nLnVyaS51dGlscy5zcGxpdC5cbiAgICogQGVudW0ge251bWJlcn1cbiAgICovXG4gIHZhciBfQ29tcG9uZW50SW5kZXg7XG4gIChmdW5jdGlvbiAoX0NvbXBvbmVudEluZGV4KSB7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiU2NoZW1lXCJdID0gMV0gPSBcIlNjaGVtZVwiO1xuICAgICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlVzZXJJbmZvXCJdID0gMl0gPSBcIlVzZXJJbmZvXCI7XG4gICAgICBfQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4W1wiRG9tYWluXCJdID0gM10gPSBcIkRvbWFpblwiO1xuICAgICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlBvcnRcIl0gPSA0XSA9IFwiUG9ydFwiO1xuICAgICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlBhdGhcIl0gPSA1XSA9IFwiUGF0aFwiO1xuICAgICAgX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleFtcIlF1ZXJ5RGF0YVwiXSA9IDZdID0gXCJRdWVyeURhdGFcIjtcbiAgICAgIF9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXhbXCJGcmFnbWVudFwiXSA9IDddID0gXCJGcmFnbWVudFwiO1xuICB9KShfQ29tcG9uZW50SW5kZXggfHwgKF9Db21wb25lbnRJbmRleCA9IHt9KSk7XG4gIC8qKlxuICAgKiBTcGxpdHMgYSBVUkkgaW50byBpdHMgY29tcG9uZW50IHBhcnRzLlxuICAgKlxuICAgKiBFYWNoIGNvbXBvbmVudCBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSBjb21wb25lbnQgaW5kaWNlczsgZm9yIGV4YW1wbGU6XG4gICAqIDxwcmU+XG4gICAqIGdvb2cudXJpLnV0aWxzLnNwbGl0KHNvbWVTdHIpW2dvb2cudXJpLnV0aWxzLkNvbXBvbnRlbnRJbmRleC5RVUVSWV9EQVRBXTtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB1cmkgVGhlIFVSSSBzdHJpbmcgdG8gZXhhbWluZS5cbiAgICogQHJldHVybiBFYWNoIGNvbXBvbmVudCBzdGlsbCBVUkktZW5jb2RlZC5cbiAgICogICAgIEVhY2ggY29tcG9uZW50IHRoYXQgaXMgcHJlc2VudCB3aWxsIGNvbnRhaW4gdGhlIGVuY29kZWQgdmFsdWUsIHdoZXJlYXNcbiAgICogICAgIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHByZXNlbnQgd2lsbCBiZSB1bmRlZmluZWQgb3IgZW1wdHksIGRlcGVuZGluZ1xuICAgKiAgICAgb24gdGhlIGJyb3dzZXIncyByZWd1bGFyIGV4cHJlc3Npb24gaW1wbGVtZW50YXRpb24uICBOZXZlciBudWxsLCBzaW5jZVxuICAgKiAgICAgYXJiaXRyYXJ5IHN0cmluZ3MgbWF5IHN0aWxsIGxvb2sgbGlrZSBwYXRoIG5hbWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gX3NwbGl0KHVyaSkge1xuICAgICAgcmV0dXJuIHVyaS5tYXRjaChfc3BsaXRSZSk7XG4gIH1cbiAgLyoqXG4gICAgKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBpbiBnaXZlbiBwYXRoIGNvbXBvbmVudCwgYXMgZGVzY3JpYmVkIGluXG4gICAgKiBSRkMgMzk4Niwgc2VjdGlvbiA1LjIuNC5cbiAgICAqXG4gICAgKiBAcGFyYW0gcGF0aCBBIG5vbi1lbXB0eSBwYXRoIGNvbXBvbmVudC5cbiAgICAqIEByZXR1cm4gUGF0aCBjb21wb25lbnQgd2l0aCByZW1vdmVkIGRvdCBzZWdtZW50cy5cbiAgICAqL1xuICBmdW5jdGlvbiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCkge1xuICAgICAgaWYgKHBhdGggPT0gJy8nKVxuICAgICAgICAgIHJldHVybiAnLyc7XG4gICAgICB2YXIgbGVhZGluZ1NsYXNoID0gcGF0aFswXSA9PSAnLycgPyAnLycgOiAnJztcbiAgICAgIHZhciB0cmFpbGluZ1NsYXNoID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycgPyAnLycgOiAnJztcbiAgICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIHZhciB1cCA9IDA7XG4gICAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBzZWdtZW50cy5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1twb3NdO1xuICAgICAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xuICAgICAgICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICcuLic6XG4gICAgICAgICAgICAgICAgICBpZiAob3V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXQucG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB1cCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBvdXQucHVzaChzZWdtZW50KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVhZGluZ1NsYXNoID09ICcnKSB7XG4gICAgICAgICAgd2hpbGUgKHVwLS0gPiAwKSB7XG4gICAgICAgICAgICAgIG91dC51bnNoaWZ0KCcuLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3V0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgb3V0LnB1c2goJy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWFkaW5nU2xhc2ggKyBvdXQuam9pbignLycpICsgdHJhaWxpbmdTbGFzaDtcbiAgfVxuICAvKipcbiAgICogVGFrZXMgYW4gYXJyYXkgb2YgdGhlIHBhcnRzIGZyb20gc3BsaXQgYW5kIGNhbm9uaWNhbGl6ZXMgdGhlIHBhdGggcGFydFxuICAgKiBhbmQgdGhlbiBqb2lucyBhbGwgdGhlIHBhcnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICAgIHBhdGggPSBpc0JsYW5rKHBhdGgpID8gJycgOiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCk7XG4gICAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBwYXRoO1xuICAgICAgcmV0dXJuIF9idWlsZEZyb21FbmNvZGVkUGFydHMocGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0sIHBhcnRzW19Db21wb25lbnRJbmRleC5Vc2VySW5mb10sIHBhcnRzW19Db21wb25lbnRJbmRleC5Eb21haW5dLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUG9ydF0sIHBhdGgsIHBhcnRzW19Db21wb25lbnRJbmRleC5RdWVyeURhdGFdLCBwYXJ0c1tfQ29tcG9uZW50SW5kZXguRnJhZ21lbnRdKTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZXMgYSBVUkwuXG4gICAqIEBwYXJhbSBiYXNlIFRoZSBVUkwgYWN0aW5nIGFzIHRoZSBiYXNlIFVSTC5cbiAgICogQHBhcmFtIHRvIFRoZSBVUkwgdG8gcmVzb2x2ZS5cbiAgICovXG4gIGZ1bmN0aW9uIF9yZXNvbHZlVXJsKGJhc2UsIHVybCkge1xuICAgICAgdmFyIHBhcnRzID0gX3NwbGl0KGVuY29kZVVSSSh1cmwpKTtcbiAgICAgIHZhciBiYXNlUGFydHMgPSBfc3BsaXQoYmFzZSk7XG4gICAgICBpZiAoaXNQcmVzZW50KHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdKSkge1xuICAgICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gPSBiYXNlUGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gX0NvbXBvbmVudEluZGV4LlNjaGVtZTsgaSA8PSBfQ29tcG9uZW50SW5kZXguUG9ydDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGlzQmxhbmsocGFydHNbaV0pKSB7XG4gICAgICAgICAgICAgIHBhcnRzW2ldID0gYmFzZVBhcnRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF1bMF0gPT0gJy8nKSB7XG4gICAgICAgICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gICAgICB9XG4gICAgICB2YXIgcGF0aCA9IGJhc2VQYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICBpZiAoaXNCbGFuayhwYXRoKSlcbiAgICAgICAgICBwYXRoID0gJy8nO1xuICAgICAgdmFyIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIGluZGV4ICsgMSkgKyBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF07XG4gICAgICBwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF0gPSBwYXRoO1xuICAgICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG4gIH1cblxuICB2YXIgRGlyZWN0aXZlTm9ybWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBEaXJlY3RpdmVOb3JtYWxpemVyKF9yZXNvdXJjZUxvYWRlciwgX3VybFJlc29sdmVyLCBfaHRtbFBhcnNlciwgX2NvbmZpZykge1xuICAgICAgICAgIHRoaXMuX3Jlc291cmNlTG9hZGVyID0gX3Jlc291cmNlTG9hZGVyO1xuICAgICAgICAgIHRoaXMuX3VybFJlc29sdmVyID0gX3VybFJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICAgIHRoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmNsZWFyKCk7IH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKG5vcm1hbGl6ZWREaXJlY3RpdmUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICghbm9ybWFsaXplZERpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Jlc291cmNlTG9hZGVyQ2FjaGUuZGVsZXRlKG5vcm1hbGl6ZWREaXJlY3RpdmUudGVtcGxhdGUudGVtcGxhdGVVcmwpO1xuICAgICAgICAgIG5vcm1hbGl6ZWREaXJlY3RpdmUudGVtcGxhdGUuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZXNoZWV0KSB7IF90aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmRlbGV0ZShzdHlsZXNoZWV0Lm1vZHVsZVVybCk7IH0pO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLl9mZXRjaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5nZXQodXJsKTtcbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9yZXNvdXJjZUxvYWRlci5nZXQodXJsKTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5zZXQodXJsLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZURpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICghZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIC8vIEZvciBub24gY29tcG9uZW50cyB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIG5vcm1hbGl6ZWQgeWV0LlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChkaXJlY3RpdmUsIFByb21pc2UucmVzb2x2ZShkaXJlY3RpdmUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMgPSBudWxsO1xuICAgICAgICAgIHZhciBub3JtYWxpemVkVGVtcGxhdGVBc3luYztcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGRpcmVjdGl2ZS50ZW1wbGF0ZS50ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlU3luYyA9IHRoaXMubm9ybWFsaXplVGVtcGxhdGVTeW5jKGRpcmVjdGl2ZS50eXBlLCBkaXJlY3RpdmUudGVtcGxhdGUpO1xuICAgICAgICAgICAgICBub3JtYWxpemVkVGVtcGxhdGVBc3luYyA9IFByb21pc2UucmVzb2x2ZShub3JtYWxpemVkVGVtcGxhdGVTeW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aXZlLnRlbXBsYXRlLnRlbXBsYXRlVXJsKSB7XG4gICAgICAgICAgICAgIG5vcm1hbGl6ZWRUZW1wbGF0ZUFzeW5jID0gdGhpcy5ub3JtYWxpemVUZW1wbGF0ZUFzeW5jKGRpcmVjdGl2ZS50eXBlLCBkaXJlY3RpdmUudGVtcGxhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGVtcGxhdGUgc3BlY2lmaWVkIGZvciBjb21wb25lbnQgXCIgKyBkaXJlY3RpdmUudHlwZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMgJiYgbm9ybWFsaXplZFRlbXBsYXRlU3luYy5zdHlsZVVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIHN5bmMgY2FzZVxuICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZERpcmVjdGl2ZSA9IF9jbG9uZURpcmVjdGl2ZVdpdGhUZW1wbGF0ZShkaXJlY3RpdmUsIG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChub3JtYWxpemVkRGlyZWN0aXZlLCBQcm9taXNlLnJlc29sdmUobm9ybWFsaXplZERpcmVjdGl2ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYXN5bmMgY2FzZVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChudWxsLCBub3JtYWxpemVkVGVtcGxhdGVBc3luY1xuICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG5vcm1hbGl6ZWRUZW1wbGF0ZSkgeyByZXR1cm4gX3RoaXMubm9ybWFsaXplRXh0ZXJuYWxTdHlsZXNoZWV0cyhub3JtYWxpemVkVGVtcGxhdGUpOyB9KVxuICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG5vcm1hbGl6ZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jbG9uZURpcmVjdGl2ZVdpdGhUZW1wbGF0ZShkaXJlY3RpdmUsIG5vcm1hbGl6ZWRUZW1wbGF0ZSk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplVGVtcGxhdGVTeW5jID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUsIHRlbXBsYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUoZGlyZWN0aXZlVHlwZSwgdGVtcGxhdGUsIHRlbXBsYXRlLnRlbXBsYXRlLCBkaXJlY3RpdmVUeXBlLm1vZHVsZVVybCk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplVGVtcGxhdGVBc3luYyA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlLCB0ZW1wbGF0ZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHRlbXBsYXRlVXJsID0gdGhpcy5fdXJsUmVzb2x2ZXIucmVzb2x2ZShkaXJlY3RpdmVUeXBlLm1vZHVsZVVybCwgdGVtcGxhdGUudGVtcGxhdGVVcmwpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9mZXRjaCh0ZW1wbGF0ZVVybClcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZShkaXJlY3RpdmVUeXBlLCB0ZW1wbGF0ZSwgdmFsdWUsIHRlbXBsYXRlVXJsKTsgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplTG9hZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSwgdGVtcGxhdGVNZXRhLCB0ZW1wbGF0ZSwgdGVtcGxhdGVBYnNVcmwpIHtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KHRlbXBsYXRlTWV0YS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICB2YXIgcm9vdE5vZGVzQW5kRXJyb3JzID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgZGlyZWN0aXZlVHlwZS5uYW1lLCBmYWxzZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgaWYgKHJvb3ROb2Rlc0FuZEVycm9ycy5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSByb290Tm9kZXNBbmRFcnJvcnMuZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW1wbGF0ZSBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0ZW1wbGF0ZU1ldGFkYXRhU3R5bGVzID0gdGhpcy5ub3JtYWxpemVTdHlsZXNoZWV0KG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgc3R5bGVzOiB0ZW1wbGF0ZU1ldGEuc3R5bGVzLFxuICAgICAgICAgICAgICBzdHlsZVVybHM6IHRlbXBsYXRlTWV0YS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogZGlyZWN0aXZlVHlwZS5tb2R1bGVVcmxcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IoKTtcbiAgICAgICAgICB2aXNpdEFsbCh2aXNpdG9yLCByb290Tm9kZXNBbmRFcnJvcnMucm9vdE5vZGVzKTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVTdHlsZXMgPSB0aGlzLm5vcm1hbGl6ZVN0eWxlc2hlZXQobmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IHZpc2l0b3Iuc3R5bGVzLCBzdHlsZVVybHM6IHZpc2l0b3Iuc3R5bGVVcmxzLCBtb2R1bGVVcmw6IHRlbXBsYXRlQWJzVXJsIH0pKTtcbiAgICAgICAgICB2YXIgZW5jYXBzdWxhdGlvbiA9IHRlbXBsYXRlTWV0YS5lbmNhcHN1bGF0aW9uO1xuICAgICAgICAgIGlmIChpc0JsYW5rKGVuY2Fwc3VsYXRpb24pKSB7XG4gICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb24gPSB0aGlzLl9jb25maWcuZGVmYXVsdEVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHlsZXMgPSB0ZW1wbGF0ZU1ldGFkYXRhU3R5bGVzLnN0eWxlcy5jb25jYXQodGVtcGxhdGVTdHlsZXMuc3R5bGVzKTtcbiAgICAgICAgICB2YXIgc3R5bGVVcmxzID0gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcy5zdHlsZVVybHMuY29uY2F0KHRlbXBsYXRlU3R5bGVzLnN0eWxlVXJscyk7XG4gICAgICAgICAgaWYgKGVuY2Fwc3VsYXRpb24gPT09IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQgJiYgc3R5bGVzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICBzdHlsZVVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb24gPSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBlbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiB0ZW1wbGF0ZUFic1VybCwgc3R5bGVzOiBzdHlsZXMsIHN0eWxlVXJsczogc3R5bGVVcmxzLFxuICAgICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzOiB0ZW1wbGF0ZU1ldGEuZXh0ZXJuYWxTdHlsZXNoZWV0cyxcbiAgICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB2aXNpdG9yLm5nQ29udGVudFNlbGVjdG9ycyxcbiAgICAgICAgICAgICAgYW5pbWF0aW9uczogdGVtcGxhdGVNZXRhLmFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgIGludGVycG9sYXRpb246IHRlbXBsYXRlTWV0YS5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZUV4dGVybmFsU3R5bGVzaGVldHMgPSBmdW5jdGlvbiAodGVtcGxhdGVNZXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyh0ZW1wbGF0ZU1ldGEuc3R5bGVVcmxzKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZXh0ZXJuYWxTdHlsZXNoZWV0cykgeyByZXR1cm4gbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogdGVtcGxhdGVNZXRhLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZU1ldGEudGVtcGxhdGUsXG4gICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiB0ZW1wbGF0ZU1ldGEudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgIHN0eWxlczogdGVtcGxhdGVNZXRhLnN0eWxlcyxcbiAgICAgICAgICAgICAgc3R5bGVVcmxzOiB0ZW1wbGF0ZU1ldGEuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzOiBleHRlcm5hbFN0eWxlc2hlZXRzLFxuICAgICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHRlbXBsYXRlTWV0YS5uZ0NvbnRlbnRTZWxlY3RvcnMsXG4gICAgICAgICAgICAgIGFuaW1hdGlvbnM6IHRlbXBsYXRlTWV0YS5hbmltYXRpb25zLFxuICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uOiB0ZW1wbGF0ZU1ldGEuaW50ZXJwb2xhdGlvblxuICAgICAgICAgIH0pOyB9KTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5fbG9hZE1pc3NpbmdFeHRlcm5hbFN0eWxlc2hlZXRzID0gZnVuY3Rpb24gKHN0eWxlVXJscywgbG9hZGVkU3R5bGVzaGVldHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmIChsb2FkZWRTdHlsZXNoZWV0cyA9PT0gdm9pZCAwKSB7IGxvYWRlZFN0eWxlc2hlZXRzID0gbmV3IE1hcCgpOyB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VcbiAgICAgICAgICAgICAgLmFsbChzdHlsZVVybHMuZmlsdGVyKGZ1bmN0aW9uIChzdHlsZVVybCkgeyByZXR1cm4gIWxvYWRlZFN0eWxlc2hlZXRzLmhhcyhzdHlsZVVybCk7IH0pXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiBfdGhpcy5fZmV0Y2goc3R5bGVVcmwpLnRoZW4oZnVuY3Rpb24gKGxvYWRlZFN0eWxlKSB7XG4gICAgICAgICAgICAgIHZhciBzdHlsZXNoZWV0ID0gX3RoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogW2xvYWRlZFN0eWxlXSwgbW9kdWxlVXJsOiBzdHlsZVVybCB9KSk7XG4gICAgICAgICAgICAgIGxvYWRlZFN0eWxlc2hlZXRzLnNldChzdHlsZVVybCwgc3R5bGVzaGVldCk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbG9hZE1pc3NpbmdFeHRlcm5hbFN0eWxlc2hlZXRzKHN0eWxlc2hlZXQuc3R5bGVVcmxzLCBsb2FkZWRTdHlsZXNoZWV0cyk7XG4gICAgICAgICAgfSk7IH0pKVxuICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoXykgeyByZXR1cm4gTWFwV3JhcHBlci52YWx1ZXMobG9hZGVkU3R5bGVzaGVldHMpOyB9KTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVTdHlsZXNoZWV0ID0gZnVuY3Rpb24gKHN0eWxlc2hlZXQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBhbGxTdHlsZVVybHMgPSBzdHlsZXNoZWV0LnN0eWxlVXJscy5maWx0ZXIoaXNTdHlsZVVybFJlc29sdmFibGUpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gX3RoaXMuX3VybFJlc29sdmVyLnJlc29sdmUoc3R5bGVzaGVldC5tb2R1bGVVcmwsIHVybCk7IH0pO1xuICAgICAgICAgIHZhciBhbGxTdHlsZXMgPSBzdHlsZXNoZWV0LnN0eWxlcy5tYXAoZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICAgIHZhciBzdHlsZVdpdGhJbXBvcnRzID0gZXh0cmFjdFN0eWxlVXJscyhfdGhpcy5fdXJsUmVzb2x2ZXIsIHN0eWxlc2hlZXQubW9kdWxlVXJsLCBzdHlsZSk7XG4gICAgICAgICAgICAgIGFsbFN0eWxlVXJscy5wdXNoLmFwcGx5KGFsbFN0eWxlVXJscywgc3R5bGVXaXRoSW1wb3J0cy5zdHlsZVVybHMpO1xuICAgICAgICAgICAgICByZXR1cm4gc3R5bGVXaXRoSW1wb3J0cy5zdHlsZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEoeyBzdHlsZXM6IGFsbFN0eWxlcywgc3R5bGVVcmxzOiBhbGxTdHlsZVVybHMsIG1vZHVsZVVybDogc3R5bGVzaGVldC5tb2R1bGVVcmwgfSk7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICBdO1xuICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICBEaXJlY3RpdmVOb3JtYWxpemVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogUmVzb3VyY2VMb2FkZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBVcmxSZXNvbHZlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IEh0bWxQYXJzZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gRGlyZWN0aXZlTm9ybWFsaXplcjtcbiAgfSgpKTtcbiAgdmFyIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCkge1xuICAgICAgICAgIHRoaXMubmdDb250ZW50U2VsZWN0b3JzID0gW107XG4gICAgICAgICAgdGhpcy5zdHlsZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQgPSAwO1xuICAgICAgfVxuICAgICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgICB2YXIgcHJlcGFyc2VkRWxlbWVudCA9IHByZXBhcnNlRWxlbWVudChhc3QpO1xuICAgICAgICAgIHN3aXRjaCAocHJlcGFyc2VkRWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDpcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMucHVzaChwcmVwYXJzZWRFbGVtZW50LnNlbGVjdEF0dHIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEU6XG4gICAgICAgICAgICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICAgIGFzdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnQgKz0gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQ6XG4gICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlVXJscy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XG4gICAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICByZXR1cm4gVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3I7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIF9jbG9uZURpcmVjdGl2ZVdpdGhUZW1wbGF0ZShkaXJlY3RpdmUsIHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XG4gICAgICAgICAgdHlwZTogZGlyZWN0aXZlLnR5cGUsXG4gICAgICAgICAgaXNDb21wb25lbnQ6IGRpcmVjdGl2ZS5pc0NvbXBvbmVudCxcbiAgICAgICAgICBzZWxlY3RvcjogZGlyZWN0aXZlLnNlbGVjdG9yLFxuICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmUuZXhwb3J0QXMsXG4gICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBkaXJlY3RpdmUuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgIGlucHV0czogZGlyZWN0aXZlLmlucHV0cyxcbiAgICAgICAgICBvdXRwdXRzOiBkaXJlY3RpdmUub3V0cHV0cyxcbiAgICAgICAgICBob3N0TGlzdGVuZXJzOiBkaXJlY3RpdmUuaG9zdExpc3RlbmVycyxcbiAgICAgICAgICBob3N0UHJvcGVydGllczogZGlyZWN0aXZlLmhvc3RQcm9wZXJ0aWVzLFxuICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBkaXJlY3RpdmUuaG9zdEF0dHJpYnV0ZXMsXG4gICAgICAgICAgcHJvdmlkZXJzOiBkaXJlY3RpdmUucHJvdmlkZXJzLFxuICAgICAgICAgIHZpZXdQcm92aWRlcnM6IGRpcmVjdGl2ZS52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgIHF1ZXJpZXM6IGRpcmVjdGl2ZS5xdWVyaWVzLFxuICAgICAgICAgIHZpZXdRdWVyaWVzOiBkaXJlY3RpdmUudmlld1F1ZXJpZXMsXG4gICAgICAgICAgZW50cnlDb21wb25lbnRzOiBkaXJlY3RpdmUuZW50cnlDb21wb25lbnRzLCB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICB9KTtcbiAgfVxuXG4gIC8qXG4gICAqIFJlc29sdmUgYSBgVHlwZWAgZm9yIHtAbGluayBEaXJlY3RpdmV9LlxuICAgKlxuICAgKiBUaGlzIGludGVyZmFjZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIHRvIGNyZWF0ZSBjdXN0b20gYmVoYXZpb3IuXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgQ29tcGlsZXJ9XG4gICAqL1xuICB2YXIgRGlyZWN0aXZlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRGlyZWN0aXZlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IHJlZmxlY3RvcjsgfVxuICAgICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB7QGxpbmsgRGlyZWN0aXZlfSBmb3IgYSBnaXZlbiBgVHlwZWAuXG4gICAgICAgKi9cbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgICAgdmFyIHR5cGVNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgICBpZiAodHlwZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHR5cGVNZXRhZGF0YS5maW5kKGlzRGlyZWN0aXZlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLnByb3BNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZVdpdGhQcm9wZXJ0eU1ldGFkYXRhKG1ldGFkYXRhLCBwcm9wZXJ0eU1ldGFkYXRhLCB0eXBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIERpcmVjdGl2ZSBhbm5vdGF0aW9uIGZvdW5kIG9uIFwiICsgc3RyaW5naWZ5KHR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9tZXJnZVdpdGhQcm9wZXJ0eU1ldGFkYXRhID0gZnVuY3Rpb24gKGRtLCBwcm9wZXJ0eU1ldGFkYXRhLCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgICAgdmFyIGlucHV0cyA9IFtdO1xuICAgICAgICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgICAgICAgdmFyIGhvc3QgPSB7fTtcbiAgICAgICAgICB2YXIgcXVlcmllcyA9IHt9O1xuICAgICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnR5TWV0YWRhdGEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5JbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBhLmJpbmRpbmdQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLk91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuYmluZGluZ1Byb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBvdXRwdXQuYmluZGluZ1Byb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RCaW5kaW5nID0gYTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0WyhcIltcIiArIGhvc3RCaW5kaW5nLmhvc3RQcm9wZXJ0eU5hbWUgKyBcIl1cIildID0gcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0WyhcIltcIiArIHByb3BOYW1lICsgXCJdXCIpXSA9IHByb3BOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBob3N0TGlzdGVuZXIgPSBhO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gaG9zdExpc3RlbmVyLmFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgaG9zdFsoXCIoXCIgKyBob3N0TGlzdGVuZXIuZXZlbnROYW1lICsgXCIpXCIpXSA9IHByb3BOYW1lICsgXCIoXCIgKyBhcmdzLmpvaW4oJywnKSArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzW3Byb3BOYW1lXSA9IGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZShkbSwgaW5wdXRzLCBvdXRwdXRzLCBob3N0LCBxdWVyaWVzLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgIH07XG4gICAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX2V4dHJhY3RQdWJsaWNOYW1lID0gZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gc3BsaXRBdENvbG9uKGRlZiwgW251bGwsIGRlZl0pWzFdLnRyaW0oKTsgfTtcbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fbWVyZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aXZlLCBpbnB1dHMsIG91dHB1dHMsIGhvc3QsIHF1ZXJpZXMsIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBtZXJnZWRJbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgdmFyIGlucHV0TmFtZXNfMSA9IGRpcmVjdGl2ZS5pbnB1dHMubWFwKGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIF90aGlzLl9leHRyYWN0UHVibGljTmFtZShkZWYpOyB9KTtcbiAgICAgICAgICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0RGVmKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHVibGljTmFtZSA9IF90aGlzLl9leHRyYWN0UHVibGljTmFtZShpbnB1dERlZik7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXROYW1lc18xLmluZGV4T2YocHVibGljTmFtZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0ICdcIiArIHB1YmxpY05hbWUgKyBcIicgZGVmaW5lZCBtdWx0aXBsZSB0aW1lcyBpbiAnXCIgKyBzdHJpbmdpZnkoZGlyZWN0aXZlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtZXJnZWRJbnB1dHMudW5zaGlmdC5hcHBseShtZXJnZWRJbnB1dHMsIGRpcmVjdGl2ZS5pbnB1dHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWVyZ2VkT3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgIHZhciBvdXRwdXROYW1lc18xID0gZGlyZWN0aXZlLm91dHB1dHMubWFwKGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIF90aGlzLl9leHRyYWN0UHVibGljTmFtZShkZWYpOyB9KTtcbiAgICAgICAgICAgICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXREZWYpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBwdWJsaWNOYW1lID0gX3RoaXMuX2V4dHJhY3RQdWJsaWNOYW1lKG91dHB1dERlZik7XG4gICAgICAgICAgICAgICAgICBpZiAob3V0cHV0TmFtZXNfMS5pbmRleE9mKHB1YmxpY05hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdXRwdXQgZXZlbnQgJ1wiICsgcHVibGljTmFtZSArIFwiJyBkZWZpbmVkIG11bHRpcGxlIHRpbWVzIGluICdcIiArIHN0cmluZ2lmeShkaXJlY3RpdmVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1lcmdlZE91dHB1dHMudW5zaGlmdC5hcHBseShtZXJnZWRPdXRwdXRzLCBkaXJlY3RpdmUub3V0cHV0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZXJnZWRIb3N0ID0gZGlyZWN0aXZlLmhvc3QgPyBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKGRpcmVjdGl2ZS5ob3N0LCBob3N0KSA6IGhvc3Q7XG4gICAgICAgICAgdmFyIG1lcmdlZFF1ZXJpZXMgPSBkaXJlY3RpdmUucXVlcmllcyA/IFN0cmluZ01hcFdyYXBwZXIubWVyZ2UoZGlyZWN0aXZlLnF1ZXJpZXMsIHF1ZXJpZXMpIDogcXVlcmllcztcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RvcjogZGlyZWN0aXZlLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgaW5wdXRzOiBtZXJnZWRJbnB1dHMsXG4gICAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXJnZWRPdXRwdXRzLFxuICAgICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcbiAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmUuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgICBtb2R1bGVJZDogZGlyZWN0aXZlLm1vZHVsZUlkLFxuICAgICAgICAgICAgICAgICAgcXVlcmllczogbWVyZ2VkUXVlcmllcyxcbiAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogZGlyZWN0aXZlLmNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogZGlyZWN0aXZlLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IGRpcmVjdGl2ZS52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBkaXJlY3RpdmUuZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGRpcmVjdGl2ZS50ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBkaXJlY3RpdmUudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgICBzdHlsZXM6IGRpcmVjdGl2ZS5zdHlsZXMsXG4gICAgICAgICAgICAgICAgICBzdHlsZVVybHM6IGRpcmVjdGl2ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBkaXJlY3RpdmUuZW5jYXBzdWxhdGlvbixcbiAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGRpcmVjdGl2ZS5hbmltYXRpb25zLFxuICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogZGlyZWN0aXZlLmludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICBpbnB1dHM6IG1lcmdlZElucHV0cyxcbiAgICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXG4gICAgICAgICAgICAgICAgICBob3N0OiBtZXJnZWRIb3N0LFxuICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6IGRpcmVjdGl2ZS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1lcmdlZFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRpcmVjdGl2ZS5wcm92aWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIERpcmVjdGl2ZVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogUmVmbGVjdG9yUmVhZGVyLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBEaXJlY3RpdmVSZXNvbHZlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gaXNEaXJlY3RpdmVNZXRhZGF0YSh0eXBlKSB7XG4gICAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlO1xuICB9XG5cbiAgdmFyIExJRkVDWUNMRV9JTlRFUkZBQ0VTID0gTWFwV3JhcHBlci5jcmVhdGVGcm9tUGFpcnMoW1xuICAgICAgW0xpZmVjeWNsZUhvb2tzLk9uSW5pdCwgX2FuZ3VsYXJfY29yZS5PbkluaXRdLFxuICAgICAgW0xpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSwgX2FuZ3VsYXJfY29yZS5PbkRlc3Ryb3ldLFxuICAgICAgW0xpZmVjeWNsZUhvb2tzLkRvQ2hlY2ssIF9hbmd1bGFyX2NvcmUuRG9DaGVja10sXG4gICAgICBbTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzLCBfYW5ndWxhcl9jb3JlLk9uQ2hhbmdlc10sXG4gICAgICBbTGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50SW5pdCwgX2FuZ3VsYXJfY29yZS5BZnRlckNvbnRlbnRJbml0XSxcbiAgICAgIFtMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkLCBfYW5ndWxhcl9jb3JlLkFmdGVyQ29udGVudENoZWNrZWRdLFxuICAgICAgW0xpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQsIF9hbmd1bGFyX2NvcmUuQWZ0ZXJWaWV3SW5pdF0sXG4gICAgICBbTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZCwgX2FuZ3VsYXJfY29yZS5BZnRlclZpZXdDaGVja2VkXSxcbiAgXSk7XG4gIHZhciBMSUZFQ1lDTEVfUFJPUFMgPSBNYXBXcmFwcGVyLmNyZWF0ZUZyb21QYWlycyhbXG4gICAgICBbTGlmZWN5Y2xlSG9va3MuT25Jbml0LCAnbmdPbkluaXQnXSxcbiAgICAgIFtMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3ksICduZ09uRGVzdHJveSddLFxuICAgICAgW0xpZmVjeWNsZUhvb2tzLkRvQ2hlY2ssICduZ0RvQ2hlY2snXSxcbiAgICAgIFtMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXMsICduZ09uQ2hhbmdlcyddLFxuICAgICAgW0xpZmVjeWNsZUhvb2tzLkFmdGVyQ29udGVudEluaXQsICduZ0FmdGVyQ29udGVudEluaXQnXSxcbiAgICAgIFtMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkLCAnbmdBZnRlckNvbnRlbnRDaGVja2VkJ10sXG4gICAgICBbTGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3SW5pdCwgJ25nQWZ0ZXJWaWV3SW5pdCddLFxuICAgICAgW0xpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0NoZWNrZWQsICduZ0FmdGVyVmlld0NoZWNrZWQnXSxcbiAgXSk7XG4gIGZ1bmN0aW9uIGhhc0xpZmVjeWNsZUhvb2soaG9vaywgdG9rZW4pIHtcbiAgICAgIHZhciBsY0ludGVyZmFjZSA9IExJRkVDWUNMRV9JTlRFUkZBQ0VTLmdldChob29rKTtcbiAgICAgIHZhciBsY1Byb3AgPSBMSUZFQ1lDTEVfUFJPUFMuZ2V0KGhvb2spO1xuICAgICAgcmV0dXJuIHJlZmxlY3Rvci5oYXNMaWZlY3ljbGVIb29rKHRva2VuLCBsY0ludGVyZmFjZSwgbGNQcm9wKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc05nTW9kdWxlTWV0YWRhdGEob2JqKSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZXMgdHlwZXMgdG8ge0BsaW5rIE5nTW9kdWxlfS5cbiAgICovXG4gIHZhciBOZ01vZHVsZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IHJlZmxlY3RvcjsgfVxuICAgICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICB9XG4gICAgICBOZ01vZHVsZVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKHR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgICAgdmFyIG5nTW9kdWxlTWV0YSA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyh0eXBlKS5maW5kKF9pc05nTW9kdWxlTWV0YWRhdGEpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQobmdNb2R1bGVNZXRhKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbmdNb2R1bGVNZXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTmdNb2R1bGUgbWV0YWRhdGEgZm91bmQgZm9yICdcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiJy5cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIE5nTW9kdWxlUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgTmdNb2R1bGVSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IFJlZmxlY3RvclJlYWRlciwgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gTmdNb2R1bGVSZXNvbHZlcjtcbiAgfSgpKTtcblxuICBmdW5jdGlvbiBfaXNQaXBlTWV0YWRhdGEodHlwZSkge1xuICAgICAgcmV0dXJuIHR5cGUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLlBpcGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlc29sdmUgYSBgVHlwZWAgZm9yIHtAbGluayBQaXBlfS5cbiAgICpcbiAgICogVGhpcyBpbnRlcmZhY2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciB0byBjcmVhdGUgY3VzdG9tIGJlaGF2aW9yLlxuICAgKlxuICAgKiBTZWUge0BsaW5rIENvbXBpbGVyfVxuICAgKi9cbiAgdmFyIFBpcGVSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBQaXBlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IHJlZmxlY3RvcjsgfVxuICAgICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiB7QGxpbmsgUGlwZX0gZm9yIGEgZ2l2ZW4gYFR5cGVgLlxuICAgICAgICovXG4gICAgICBQaXBlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgICB2YXIgbWV0YXMgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMoX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChtZXRhcykpIHtcbiAgICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBtZXRhcy5maW5kKF9pc1BpcGVNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUGlwZSBkZWNvcmF0b3IgZm91bmQgb24gXCIgKyBzdHJpbmdpZnkodHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBQaXBlUmVzb2x2ZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgUGlwZVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogUmVmbGVjdG9yUmVhZGVyLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBQaXBlUmVzb2x2ZXI7XG4gIH0oKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICB2YXIgX19leHRlbmRzJDE1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICB9O1xuICB2YXIgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoX25nTW9kdWxlUmVzb2x2ZXIsIF9kaXJlY3RpdmVSZXNvbHZlciwgX3BpcGVSZXNvbHZlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfcmVmbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKF9yZWZsZWN0b3IgPT09IHZvaWQgMCkgeyBfcmVmbGVjdG9yID0gcmVmbGVjdG9yOyB9XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVSZXNvbHZlciA9IF9uZ01vZHVsZVJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyID0gX2RpcmVjdGl2ZVJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX3BpcGVSZXNvbHZlciA9IF9waXBlUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9waXBlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fYW5vbnltb3VzVHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgdGhpcy5fYW5vbnltb3VzVHlwZUluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5zYW5pdGl6ZVRva2VuTmFtZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gc3RyaW5naWZ5KHRva2VuKTtcbiAgICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAgICAgICAvLyBjYXNlOiBhbm9ueW1vdXMgZnVuY3Rpb25zIVxuICAgICAgICAgICAgICB2YXIgZm91bmQgPSB0aGlzLl9hbm9ueW1vdXNUeXBlcy5nZXQodG9rZW4pO1xuICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hbm9ueW1vdXNUeXBlcy5zZXQodG9rZW4sIHRoaXMuX2Fub255bW91c1R5cGVJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5fYW5vbnltb3VzVHlwZXMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZGVudGlmaWVyID0gXCJhbm9ueW1vdXNfdG9rZW5fXCIgKyBmb3VuZCArIFwiX1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2FuaXRpemVJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgICAgdGhpcy5fcGlwZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuZGVsZXRlKHR5cGUpO1xuICAgICAgICAgIC8vIENsZWFyIGFsbCBvZiB0aGUgTmdNb2R1bGUgYXMgdGhleSBjb250YWluIHRyYW5zaXRpdmUgaW5mb3JtYXRpb24hXG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgdGhpcy5fcGlwZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5jbGVhcigpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRBbmltYXRpb25FbnRyeU1ldGFkYXRhID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZGVmcyA9IGVudHJ5LmRlZmluaXRpb25zLm1hcChmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBfdGhpcy5nZXRBbmltYXRpb25TdGF0ZU1ldGFkYXRhKGRlZik7IH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvbkVudHJ5TWV0YWRhdGEoZW50cnkubmFtZSwgZGVmcyk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSkge1xuICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gdGhpcy5nZXRBbmltYXRpb25TdHlsZU1ldGFkYXRhKHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSh2YWx1ZS5zdGF0ZU5hbWVFeHByLCBzdHlsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKHZhbHVlLnN0YXRlQ2hhbmdlRXhwciwgdGhpcy5nZXRBbmltYXRpb25NZXRhZGF0YSh2YWx1ZS5zdGVwcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEodmFsdWUub2Zmc2V0LCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRBbmltYXRpb25NZXRhZGF0YSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BbmltYXRpb25TdHlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFuaW1hdGlvblN0eWxlTWV0YWRhdGEodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSh2YWx1ZS5zdGVwcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBfdGhpcy5nZXRBbmltYXRpb25TdHlsZU1ldGFkYXRhKGVudHJ5KTsgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSkge1xuICAgICAgICAgICAgICB2YXIgYW5pbWF0ZURhdGEgPSB0aGlzXG4gICAgICAgICAgICAgICAgICAuZ2V0QW5pbWF0aW9uTWV0YWRhdGEodmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKHZhbHVlLnRpbWluZ3MsIGFuaW1hdGVEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSkge1xuICAgICAgICAgICAgICB2YXIgc3RlcHMgPSB2YWx1ZS5zdGVwcy5tYXAoZnVuY3Rpb24gKHN0ZXApIHsgcmV0dXJuIF90aGlzLmdldEFuaW1hdGlvbk1ldGFkYXRhKHN0ZXApOyB9KTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5BbmltYXRpb25Hcm91cE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhKHN0ZXBzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldERpcmVjdGl2ZU1ldGFkYXRhID0gZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgICBkaXJlY3RpdmVUeXBlID0gX2FuZ3VsYXJfY29yZS5yZXNvbHZlRm9yd2FyZFJlZihkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICB2YXIgbWV0YSA9IHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmdldChkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgICAgICAgdmFyIGRpck1ldGEgPSB0aGlzLl9kaXJlY3RpdmVSZXNvbHZlci5yZXNvbHZlKGRpcmVjdGl2ZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgICAgICAgIGlmICghZGlyTWV0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlTWV0YSA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciB2aWV3UHJvdmlkZXJzID0gW107XG4gICAgICAgICAgICAgIHZhciBtb2R1bGVVcmwgPSBzdGF0aWNUeXBlTW9kdWxlVXJsKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICB2YXIgZW50cnlDb21wb25lbnRNZXRhZGF0YSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBkaXJNZXRhLnNlbGVjdG9yO1xuICAgICAgICAgICAgICBpZiAoZGlyTWV0YSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAvLyBDb21wb25lbnRcbiAgICAgICAgICAgICAgICAgIGFzc2VydEFycmF5T2ZTdHJpbmdzKCdzdHlsZXMnLCBkaXJNZXRhLnN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICBhc3NlcnRBcnJheU9mU3RyaW5ncygnc3R5bGVVcmxzJywgZGlyTWV0YS5zdHlsZVVybHMpO1xuICAgICAgICAgICAgICAgICAgYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoJ2ludGVycG9sYXRpb24nLCBkaXJNZXRhLmludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBkaXJNZXRhLmFuaW1hdGlvbnMgP1xuICAgICAgICAgICAgICAgICAgICAgIGRpck1ldGEuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmdldEFuaW1hdGlvbkVudHJ5TWV0YWRhdGEoZSk7IH0pIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgICAgICAgdGVtcGxhdGVNZXRhID0gbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBkaXJNZXRhLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGRpck1ldGEudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IGRpck1ldGEudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBkaXJNZXRhLnN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZVVybHM6IGRpck1ldGEuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogZGlyTWV0YS5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gZGlyTWV0YS5jaGFuZ2VEZXRlY3Rpb247XG4gICAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YS52aWV3UHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmlld1Byb3ZpZGVycyA9IHRoaXMuZ2V0UHJvdmlkZXJzTWV0YWRhdGEoZGlyTWV0YS52aWV3UHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLCBcInZpZXdQcm92aWRlcnMgZm9yIFxcXCJcIiArIHN0cmluZ2lmeShkaXJlY3RpdmVUeXBlKSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG1vZHVsZVVybCA9IGNvbXBvbmVudE1vZHVsZVVybCh0aGlzLl9yZWZsZWN0b3IsIGRpcmVjdGl2ZVR5cGUsIGRpck1ldGEpO1xuICAgICAgICAgICAgICAgICAgaWYgKGRpck1ldGEuZW50cnlDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRNZXRhZGF0YSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5BcnJheShkaXJNZXRhLmVudHJ5Q29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHR5cGUpKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZW50cnlDb21wb25lbnRNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXREZWZhdWx0Q29tcG9uZW50RWxlbWVudE5hbWUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIERpcmVjdGl2ZVxuICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpcmVjdGl2ZSBcIiArIHN0cmluZ2lmeShkaXJlY3RpdmVUeXBlKSArIFwiIGhhcyBubyBzZWxlY3RvciwgcGxlYXNlIGFkZCBpdCFcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRpck1ldGEucHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzID0gdGhpcy5nZXRQcm92aWRlcnNNZXRhZGF0YShkaXJNZXRhLnByb3ZpZGVycywgZW50cnlDb21wb25lbnRNZXRhZGF0YSwgXCJwcm92aWRlcnMgZm9yIFxcXCJcIiArIHN0cmluZ2lmeShkaXJlY3RpdmVUeXBlKSArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgcXVlcmllcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgdmlld1F1ZXJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkaXJNZXRhLnF1ZXJpZXMpKSB7XG4gICAgICAgICAgICAgICAgICBxdWVyaWVzID0gdGhpcy5nZXRRdWVyaWVzTWV0YWRhdGEoZGlyTWV0YS5xdWVyaWVzLCBmYWxzZSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICAgICAgICB2aWV3UXVlcmllcyA9IHRoaXMuZ2V0UXVlcmllc01ldGFkYXRhKGRpck1ldGEucXVlcmllcywgdHJ1ZSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWV0YSA9IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6IGRpck1ldGEuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgICBpc0NvbXBvbmVudDogISF0ZW1wbGF0ZU1ldGEsXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldFR5cGVNZXRhZGF0YShkaXJlY3RpdmVUeXBlLCBtb2R1bGVVcmwpLFxuICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlTWV0YSxcbiAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICBpbnB1dHM6IGRpck1ldGEuaW5wdXRzLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0czogZGlyTWV0YS5vdXRwdXRzLFxuICAgICAgICAgICAgICAgICAgaG9zdDogZGlyTWV0YS5ob3N0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiB2aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgICAgcXVlcmllczogcXVlcmllcyxcbiAgICAgICAgICAgICAgICAgIHZpZXdRdWVyaWVzOiB2aWV3UXVlcmllcyxcbiAgICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogZW50cnlDb21wb25lbnRNZXRhZGF0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aXZlQ2FjaGUuc2V0KGRpcmVjdGl2ZVR5cGUsIG1ldGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWV0YTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0TmdNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgICAgbW9kdWxlVHlwZSA9IF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYobW9kdWxlVHlwZSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVNZXRhID0gdGhpcy5fbmdNb2R1bGVDYWNoZS5nZXQobW9kdWxlVHlwZSk7XG4gICAgICAgICAgaWYgKCFjb21waWxlTWV0YSkge1xuICAgICAgICAgICAgICB2YXIgbWV0YSA9IHRoaXMuX25nTW9kdWxlUmVzb2x2ZXIucmVzb2x2ZShtb2R1bGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpO1xuICAgICAgICAgICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBkZWNsYXJlZERpcmVjdGl2ZXNfMSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgZXhwb3J0ZWREaXJlY3RpdmVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGRlY2xhcmVkUGlwZXNfMSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgZXhwb3J0ZWRQaXBlc18xID0gW107XG4gICAgICAgICAgICAgIHZhciBpbXBvcnRlZE1vZHVsZXNfMSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgZXhwb3J0ZWRNb2R1bGVzXzEgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyc18xID0gW107XG4gICAgICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudHNfMSA9IFtdO1xuICAgICAgICAgICAgICB2YXIgYm9vdHN0cmFwQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgc2NoZW1hcyA9IFtdO1xuICAgICAgICAgICAgICBpZiAobWV0YS5pbXBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICBmbGF0dGVuQXJyYXkobWV0YS5pbXBvcnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChpbXBvcnRlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0ZWRNb2R1bGVUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkVHlwZShpbXBvcnRlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlVHlwZSA9IGltcG9ydGVkVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW1wb3J0ZWRUeXBlICYmIGltcG9ydGVkVHlwZS5uZ01vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kdWxlV2l0aFByb3ZpZGVycyA9IGltcG9ydGVkVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVUeXBlID0gbW9kdWxlV2l0aFByb3ZpZGVycy5uZ01vZHVsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZVdpdGhQcm92aWRlcnMucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnNfMS5wdXNoLmFwcGx5KHByb3ZpZGVyc18xLCBfdGhpcy5nZXRQcm92aWRlcnNNZXRhZGF0YShtb2R1bGVXaXRoUHJvdmlkZXJzLnByb3ZpZGVycywgZW50cnlDb21wb25lbnRzXzEsIFwicHJvdmlkZXIgZm9yIHRoZSBOZ01vZHVsZSAnXCIgKyBzdHJpbmdpZnkoaW1wb3J0ZWRNb2R1bGVUeXBlKSArIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1wb3J0ZWRNZXRhID0gX3RoaXMuZ2V0TmdNb2R1bGVNZXRhZGF0YShpbXBvcnRlZE1vZHVsZVR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydGVkTWV0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIF90aGlzLl9nZXRUeXBlRGVzY3JpcHRvcihpbXBvcnRlZFR5cGUpICsgXCIgJ1wiICsgc3RyaW5naWZ5KGltcG9ydGVkVHlwZSkgKyBcIicgaW1wb3J0ZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVzXzEucHVzaChpbXBvcnRlZE1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnkoaW1wb3J0ZWRUeXBlKSArIFwiJyBpbXBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobWV0YS5leHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgICBmbGF0dGVuQXJyYXkobWV0YS5leHBvcnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChleHBvcnRlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKGV4cG9ydGVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnkoZXhwb3J0ZWRUeXBlKSArIFwiJyBleHBvcnRlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9ydGVkRGlyTWV0YTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb3J0ZWRQaXBlTWV0YTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb3J0ZWRNb2R1bGVNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBvcnRlZERpck1ldGEgPSBfdGhpcy5nZXREaXJlY3RpdmVNZXRhZGF0YShleHBvcnRlZFR5cGUsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXNfMS5wdXNoKGV4cG9ydGVkRGlyTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4cG9ydGVkUGlwZU1ldGEgPSBfdGhpcy5nZXRQaXBlTWV0YWRhdGEoZXhwb3J0ZWRUeXBlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRQaXBlc18xLnB1c2goZXhwb3J0ZWRQaXBlTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4cG9ydGVkTW9kdWxlTWV0YSA9IF90aGlzLmdldE5nTW9kdWxlTWV0YWRhdGEoZXhwb3J0ZWRUeXBlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRNb2R1bGVzXzEucHVzaChleHBvcnRlZE1vZHVsZU1ldGEpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIF90aGlzLl9nZXRUeXBlRGVzY3JpcHRvcihleHBvcnRlZFR5cGUpICsgXCIgJ1wiICsgc3RyaW5naWZ5KGV4cG9ydGVkVHlwZSkgKyBcIicgZXhwb3J0ZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gTm90ZTogVGhpcyB3aWxsIGJlIG1vZGlmaWVkIGxhdGVyLCBzbyB3ZSByZWx5IG9uXG4gICAgICAgICAgICAgIC8vIGdldHRpbmcgYSBuZXcgaW5zdGFuY2UgZXZlcnkgdGltZSFcbiAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpdmVNb2R1bGVfMSA9IHRoaXMuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhKGltcG9ydGVkTW9kdWxlc18xLCBleHBvcnRlZE1vZHVsZXNfMSk7XG4gICAgICAgICAgICAgIGlmIChtZXRhLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgZmxhdHRlbkFycmF5KG1ldGEuZGVjbGFyYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChkZWNsYXJlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKGRlY2xhcmVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnkoZGVjbGFyZWRUeXBlKSArIFwiJyBkZWNsYXJlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2xhcmVkRGlyTWV0YTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjbGFyZWRQaXBlTWV0YTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVjbGFyZWREaXJNZXRhID0gX3RoaXMuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGVjbGFyZWRUeXBlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZERpcmVjdGl2ZVRvTW9kdWxlKGRlY2xhcmVkRGlyTWV0YSwgbW9kdWxlVHlwZSwgdHJhbnNpdGl2ZU1vZHVsZV8xLCBkZWNsYXJlZERpcmVjdGl2ZXNfMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlY2xhcmVkUGlwZU1ldGEgPSBfdGhpcy5nZXRQaXBlTWV0YWRhdGEoZGVjbGFyZWRUeXBlLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFBpcGVUb01vZHVsZShkZWNsYXJlZFBpcGVNZXRhLCBtb2R1bGVUeXBlLCB0cmFuc2l0aXZlTW9kdWxlXzEsIGRlY2xhcmVkUGlwZXNfMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgX3RoaXMuX2dldFR5cGVEZXNjcmlwdG9yKGRlY2xhcmVkVHlwZSkgKyBcIiAnXCIgKyBzdHJpbmdpZnkoZGVjbGFyZWRUeXBlKSArIFwiJyBkZWNsYXJlZCBieSB0aGUgbW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBUaGUgcHJvdmlkZXJzIG9mIHRoZSBtb2R1bGUgaGF2ZSB0byBnbyBsYXN0XG4gICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSBvdmVyd3JpdGUgYW55IG90aGVyIHByb3ZpZGVyIHdlIGFscmVhZHkgYWRkZWQuXG4gICAgICAgICAgICAgIGlmIChtZXRhLnByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzXzEucHVzaC5hcHBseShwcm92aWRlcnNfMSwgdGhpcy5nZXRQcm92aWRlcnNNZXRhZGF0YShtZXRhLnByb3ZpZGVycywgZW50cnlDb21wb25lbnRzXzEsIFwicHJvdmlkZXIgZm9yIHRoZSBOZ01vZHVsZSAnXCIgKyBzdHJpbmdpZnkobW9kdWxlVHlwZSkgKyBcIidcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtZXRhLmVudHJ5Q29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzXzEucHVzaC5hcHBseShlbnRyeUNvbXBvbmVudHNfMSwgZmxhdHRlbkFycmF5KG1ldGEuZW50cnlDb21wb25lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHR5cGUpKTsgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtZXRhLmJvb3RzdHJhcCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHR5cGVNZXRhZGF0YSA9IGZsYXR0ZW5BcnJheShtZXRhLmJvb3RzdHJhcCkubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlICdcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiJyB1c2VkIGluIHRoZSBib290c3RyYXAgcHJvcGVydHkgb2YgbW9kdWxlICdcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgYm9vdHN0cmFwQ29tcG9uZW50cy5wdXNoLmFwcGx5KGJvb3RzdHJhcENvbXBvbmVudHMsIHR5cGVNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzXzEucHVzaC5hcHBseShlbnRyeUNvbXBvbmVudHNfMSwgYm9vdHN0cmFwQ29tcG9uZW50cyk7XG4gICAgICAgICAgICAgIGlmIChtZXRhLnNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICAgIHNjaGVtYXMucHVzaC5hcHBseShzY2hlbWFzLCBmbGF0dGVuQXJyYXkobWV0YS5zY2hlbWFzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKF9hID0gdHJhbnNpdGl2ZU1vZHVsZV8xLmVudHJ5Q29tcG9uZW50cykucHVzaC5hcHBseShfYSwgZW50cnlDb21wb25lbnRzXzEpO1xuICAgICAgICAgICAgICAoX2IgPSB0cmFuc2l0aXZlTW9kdWxlXzEucHJvdmlkZXJzKS5wdXNoLmFwcGx5KF9iLCBwcm92aWRlcnNfMSk7XG4gICAgICAgICAgICAgIGNvbXBpbGVNZXRhID0gbmV3IENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKG1vZHVsZVR5cGUsIHN0YXRpY1R5cGVNb2R1bGVVcmwobW9kdWxlVHlwZSkpLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnNfMSxcbiAgICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogZW50cnlDb21wb25lbnRzXzEsXG4gICAgICAgICAgICAgICAgICBib290c3RyYXBDb21wb25lbnRzOiBib290c3RyYXBDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgc2NoZW1hczogc2NoZW1hcyxcbiAgICAgICAgICAgICAgICAgIGRlY2xhcmVkRGlyZWN0aXZlczogZGVjbGFyZWREaXJlY3RpdmVzXzEsXG4gICAgICAgICAgICAgICAgICBleHBvcnRlZERpcmVjdGl2ZXM6IGV4cG9ydGVkRGlyZWN0aXZlc18xLFxuICAgICAgICAgICAgICAgICAgZGVjbGFyZWRQaXBlczogZGVjbGFyZWRQaXBlc18xLFxuICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRQaXBlczogZXhwb3J0ZWRQaXBlc18xLFxuICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVzOiBpbXBvcnRlZE1vZHVsZXNfMSxcbiAgICAgICAgICAgICAgICAgIGV4cG9ydGVkTW9kdWxlczogZXhwb3J0ZWRNb2R1bGVzXzEsXG4gICAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlOiB0cmFuc2l0aXZlTW9kdWxlXzEsXG4gICAgICAgICAgICAgICAgICBpZDogbWV0YS5pZCxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGVfMS5tb2R1bGVzLnB1c2goY29tcGlsZU1ldGEpO1xuICAgICAgICAgICAgICB0aGlzLl92ZXJpZnlNb2R1bGUoY29tcGlsZU1ldGEpO1xuICAgICAgICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLnNldChtb2R1bGVUeXBlLCBjb21waWxlTWV0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21waWxlTWV0YTtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fdmVyaWZ5TW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZU1ldGEpIHtcbiAgICAgICAgICBtb2R1bGVNZXRhLmV4cG9ydGVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJNZXRhKSB7XG4gICAgICAgICAgICAgIGlmICghbW9kdWxlTWV0YS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXNTZXQuaGFzKGRpck1ldGEudHlwZS5yZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBleHBvcnQgZGlyZWN0aXZlIFwiICsgc3RyaW5naWZ5KGRpck1ldGEudHlwZS5yZWZlcmVuY2UpICsgXCIgZnJvbSBcIiArIHN0cmluZ2lmeShtb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSArIFwiIGFzIGl0IHdhcyBuZWl0aGVyIGRlY2xhcmVkIG5vciBpbXBvcnRlZCFcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtb2R1bGVNZXRhLmV4cG9ydGVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZU1ldGEpIHtcbiAgICAgICAgICAgICAgaWYgKCFtb2R1bGVNZXRhLnRyYW5zaXRpdmVNb2R1bGUucGlwZXNTZXQuaGFzKHBpcGVNZXRhLnR5cGUucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZXhwb3J0IHBpcGUgXCIgKyBzdHJpbmdpZnkocGlwZU1ldGEudHlwZS5yZWZlcmVuY2UpICsgXCIgZnJvbSBcIiArIHN0cmluZ2lmeShtb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSArIFwiIGFzIGl0IHdhcyBuZWl0aGVyIGRlY2xhcmVkIG5vciBpbXBvcnRlZCFcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFR5cGVEZXNjcmlwdG9yID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIucmVzb2x2ZSh0eXBlLCBmYWxzZSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fcGlwZVJlc29sdmVyLnJlc29sdmUodHlwZSwgZmFsc2UpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiAncGlwZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9uZ01vZHVsZVJlc29sdmVyLnJlc29sdmUodHlwZSwgZmFsc2UpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnbW9kdWxlJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUucHJvdmlkZSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ3Byb3ZpZGVyJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9hZGRUeXBlVG9Nb2R1bGUgPSBmdW5jdGlvbiAodHlwZSwgbW9kdWxlVHlwZSkge1xuICAgICAgICAgIHZhciBvbGRNb2R1bGUgPSB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgICAgIGlmIChvbGRNb2R1bGUgJiYgb2xkTW9kdWxlICE9PSBtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJUeXBlIFwiICsgc3RyaW5naWZ5KHR5cGUpICsgXCIgaXMgcGFydCBvZiB0aGUgZGVjbGFyYXRpb25zIG9mIDIgbW9kdWxlczogXCIgKyBzdHJpbmdpZnkob2xkTW9kdWxlKSArIFwiIGFuZCBcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiISBcIikgK1xuICAgICAgICAgICAgICAgICAgKFwiUGxlYXNlIGNvbnNpZGVyIG1vdmluZyBcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiIHRvIGEgaGlnaGVyIG1vZHVsZSB0aGF0IGltcG9ydHMgXCIgKyBzdHJpbmdpZnkob2xkTW9kdWxlKSArIFwiIGFuZCBcIiArIHN0cmluZ2lmeShtb2R1bGVUeXBlKSArIFwiLiBcIikgK1xuICAgICAgICAgICAgICAgICAgKFwiWW91IGNhbiBhbHNvIGNyZWF0ZSBhIG5ldyBOZ01vZHVsZSB0aGF0IGV4cG9ydHMgYW5kIGluY2x1ZGVzIFwiICsgc3RyaW5naWZ5KHR5cGUpICsgXCIgdGhlbiBpbXBvcnQgdGhhdCBOZ01vZHVsZSBpbiBcIiArIHN0cmluZ2lmeShvbGRNb2R1bGUpICsgXCIgYW5kIFwiICsgc3RyaW5naWZ5KG1vZHVsZVR5cGUpICsgXCIuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzLnNldCh0eXBlLCBtb2R1bGVUeXBlKTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFRyYW5zaXRpdmVOZ01vZHVsZU1ldGFkYXRhID0gZnVuY3Rpb24gKGltcG9ydGVkTW9kdWxlcywgZXhwb3J0ZWRNb2R1bGVzKSB7XG4gICAgICAgICAgLy8gY29sbGVjdCBgcHJvdmlkZXJzYCAvIGBlbnRyeUNvbXBvbmVudHNgIGZyb20gYWxsIGltcG9ydGVkIGFuZCBhbGwgZXhwb3J0ZWQgbW9kdWxlc1xuICAgICAgICAgIHZhciB0cmFuc2l0aXZlTW9kdWxlcyA9IGdldFRyYW5zaXRpdmVNb2R1bGVzKGltcG9ydGVkTW9kdWxlcy5jb25jYXQoZXhwb3J0ZWRNb2R1bGVzKSwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIHByb3ZpZGVycyA9IGZsYXR0ZW5BcnJheSh0cmFuc2l0aXZlTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBuZ01vZHVsZS5wcm92aWRlcnM7IH0pKTtcbiAgICAgICAgICB2YXIgZW50cnlDb21wb25lbnRzID0gZmxhdHRlbkFycmF5KHRyYW5zaXRpdmVNb2R1bGVzLm1hcChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIG5nTW9kdWxlLmVudHJ5Q29tcG9uZW50czsgfSkpO1xuICAgICAgICAgIHZhciB0cmFuc2l0aXZlRXhwb3J0ZWRNb2R1bGVzID0gZ2V0VHJhbnNpdGl2ZU1vZHVsZXMoaW1wb3J0ZWRNb2R1bGVzLCBmYWxzZSk7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBmbGF0dGVuQXJyYXkodHJhbnNpdGl2ZUV4cG9ydGVkTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBuZ01vZHVsZS5leHBvcnRlZERpcmVjdGl2ZXM7IH0pKTtcbiAgICAgICAgICB2YXIgcGlwZXMgPSBmbGF0dGVuQXJyYXkodHJhbnNpdGl2ZUV4cG9ydGVkTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBuZ01vZHVsZS5leHBvcnRlZFBpcGVzOyB9KSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEodHJhbnNpdGl2ZU1vZHVsZXMsIHByb3ZpZGVycywgZW50cnlDb21wb25lbnRzLCBkaXJlY3RpdmVzLCBwaXBlcyk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9hZGREaXJlY3RpdmVUb01vZHVsZSA9IGZ1bmN0aW9uIChkaXJNZXRhLCBtb2R1bGVUeXBlLCB0cmFuc2l0aXZlTW9kdWxlLCBkZWNsYXJlZERpcmVjdGl2ZXMsIGZvcmNlKSB7XG4gICAgICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHsgZm9yY2UgPSBmYWxzZTsgfVxuICAgICAgICAgIGlmIChmb3JjZSB8fCAhdHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzU2V0LmhhcyhkaXJNZXRhLnR5cGUucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXNTZXQuYWRkKGRpck1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMucHVzaChkaXJNZXRhKTtcbiAgICAgICAgICAgICAgZGVjbGFyZWREaXJlY3RpdmVzLnB1c2goZGlyTWV0YSk7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZFR5cGVUb01vZHVsZShkaXJNZXRhLnR5cGUucmVmZXJlbmNlLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2FkZFBpcGVUb01vZHVsZSA9IGZ1bmN0aW9uIChwaXBlTWV0YSwgbW9kdWxlVHlwZSwgdHJhbnNpdGl2ZU1vZHVsZSwgZGVjbGFyZWRQaXBlcywgZm9yY2UpIHtcbiAgICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XG4gICAgICAgICAgaWYgKGZvcmNlIHx8ICF0cmFuc2l0aXZlTW9kdWxlLnBpcGVzU2V0LmhhcyhwaXBlTWV0YS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5waXBlc1NldC5hZGQocGlwZU1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLnBpcGVzLnB1c2gocGlwZU1ldGEpO1xuICAgICAgICAgICAgICBkZWNsYXJlZFBpcGVzLnB1c2gocGlwZU1ldGEpO1xuICAgICAgICAgICAgICB0aGlzLl9hZGRUeXBlVG9Nb2R1bGUocGlwZU1ldGEudHlwZS5yZWZlcmVuY2UsIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRUeXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSwgbW9kdWxlVXJsLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICAgIHR5cGUgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHR5cGUpO1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZVR5cGVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMuc2FuaXRpemVUb2tlbk5hbWUodHlwZSksXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogbW9kdWxlVXJsLFxuICAgICAgICAgICAgICByZWZlcmVuY2U6IHR5cGUsXG4gICAgICAgICAgICAgIGRpRGVwczogdGhpcy5nZXREZXBlbmRlbmNpZXNNZXRhZGF0YSh0eXBlLCBkZXBlbmRlbmNpZXMpLFxuICAgICAgICAgICAgICBsaWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUy5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhhc0xpZmVjeWNsZUhvb2soaG9vaywgdHlwZSk7IH0pLFxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRGYWN0b3J5TWV0YWRhdGEgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbW9kdWxlVXJsLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICAgIGZhY3RvcnkgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKGZhY3RvcnkpO1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZUZhY3RvcnlNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIG5hbWU6IHRoaXMuc2FuaXRpemVUb2tlbk5hbWUoZmFjdG9yeSksXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogbW9kdWxlVXJsLFxuICAgICAgICAgICAgICByZWZlcmVuY2U6IGZhY3RvcnksXG4gICAgICAgICAgICAgIGRpRGVwczogdGhpcy5nZXREZXBlbmRlbmNpZXNNZXRhZGF0YShmYWN0b3J5LCBkZXBlbmRlbmNpZXMpXG4gICAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFBpcGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChwaXBlVHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgICBwaXBlVHlwZSA9IF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYocGlwZVR5cGUpO1xuICAgICAgICAgIHZhciBtZXRhID0gdGhpcy5fcGlwZUNhY2hlLmdldChwaXBlVHlwZSk7XG4gICAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgICAgIHZhciBwaXBlTWV0YSA9IHRoaXMuX3BpcGVSZXNvbHZlci5yZXNvbHZlKHBpcGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpO1xuICAgICAgICAgICAgICBpZiAoIXBpcGVNZXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtZXRhID0gbmV3IENvbXBpbGVQaXBlTWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5nZXRUeXBlTWV0YWRhdGEocGlwZVR5cGUsIHN0YXRpY1R5cGVNb2R1bGVVcmwocGlwZVR5cGUpKSxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHBpcGVNZXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICBwdXJlOiBwaXBlTWV0YS5wdXJlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLl9waXBlQ2FjaGUuc2V0KHBpcGVUeXBlLCBtZXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1ldGE7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldERlcGVuZGVuY2llc01ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMsIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGhhc1Vua25vd25EZXBzID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHBhcmFtcyA9IGRlcGVuZGVuY2llcyB8fCB0aGlzLl9yZWZsZWN0b3IucGFyYW1ldGVycyh0eXBlT3JGdW5jKSB8fCBbXTtcbiAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzTWV0YWRhdGEgPSBwYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgICB2YXIgaXNBdHRyaWJ1dGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdmFyIGlzSG9zdCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgaXNTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBpc1NraXBTZWxmID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBpc09wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgIHZhciBxdWVyeSA9IG51bGw7XG4gICAgICAgICAgICAgIHZhciB2aWV3UXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmFtLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0hvc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5TZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzU2tpcFNlbGYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIF9hbmd1bGFyX2NvcmUuQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbUVudHJ5LmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLlF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbUVudHJ5LmlzVmlld1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3UXVlcnkgPSBwYXJhbUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBwYXJhbUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLkluamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnkudG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWRUeXBlKHBhcmFtRW50cnkpICYmIGlzQmxhbmsodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzQmxhbmsodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICBoYXNVbmtub3duRGVwcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVEaURlcGVuZGVuY3lNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICBpc0F0dHJpYnV0ZTogaXNBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICBpc0hvc3Q6IGlzSG9zdCxcbiAgICAgICAgICAgICAgICAgIGlzU2VsZjogaXNTZWxmLFxuICAgICAgICAgICAgICAgICAgaXNTa2lwU2VsZjogaXNTa2lwU2VsZixcbiAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnkgPyBfdGhpcy5nZXRRdWVyeU1ldGFkYXRhKHF1ZXJ5LCBudWxsLCB0eXBlT3JGdW5jKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICB2aWV3UXVlcnk6IHZpZXdRdWVyeSA/IF90aGlzLmdldFF1ZXJ5TWV0YWRhdGEodmlld1F1ZXJ5LCBudWxsLCB0eXBlT3JGdW5jKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICB0b2tlbjogX3RoaXMuZ2V0VG9rZW5NZXRhZGF0YSh0b2tlbilcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGhhc1Vua25vd25EZXBzKSB7XG4gICAgICAgICAgICAgIHZhciBkZXBzVG9rZW5zID0gZGVwZW5kZW5jaWVzTWV0YWRhdGEubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIGRlcCA/IHN0cmluZ2lmeShkZXAudG9rZW4pIDogJz8nOyB9KS5qb2luKCcsICcpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZXNvbHZlIGFsbCBwYXJhbWV0ZXJzIGZvciBcIiArIHN0cmluZ2lmeSh0eXBlT3JGdW5jKSArIFwiOiAoXCIgKyBkZXBzVG9rZW5zICsgXCIpLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY2llc01ldGFkYXRhO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRUb2tlbk1ldGFkYXRhID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdG9rZW4gPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHRva2VuKTtcbiAgICAgICAgICB2YXIgY29tcGlsZVRva2VuO1xuICAgICAgICAgIGlmIChpc1N0cmluZyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgY29tcGlsZVRva2VuID0gbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHsgdmFsdWU6IHRva2VuIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY29tcGlsZVRva2VuID0gbmV3IENvbXBpbGVUb2tlbk1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuc2FuaXRpemVUb2tlbk5hbWUodG9rZW4pLFxuICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZVVybDogc3RhdGljVHlwZU1vZHVsZVVybCh0b2tlbilcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcGlsZVRva2VuO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQcm92aWRlcnNNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY29tcGlsZVByb3ZpZGVycyA9IFtdO1xuICAgICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlciwgcHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYW5ndWxhcl9jb3JlLnJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlciA9PSAnb2JqZWN0JyAmJiBwcm92aWRlci5oYXNPd25Qcm9wZXJ0eSgncHJvdmlkZScpKSB7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlciA9IG5ldyBQcm92aWRlck1ldGEocHJvdmlkZXIucHJvdmlkZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjb21waWxlUHJvdmlkZXI7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgY29tcGlsZVByb3ZpZGVyID0gX3RoaXMuZ2V0UHJvdmlkZXJzTWV0YWRhdGEocHJvdmlkZXIsIHRhcmdldEVudHJ5Q29tcG9uZW50cywgZGVidWdJbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlciBpbnN0YW5jZW9mIFByb3ZpZGVyTWV0YSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHRva2VuTWV0YSA9IF90aGlzLmdldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgaWYgKHRva2VuTWV0YS5yZWZlcmVuY2UgPT09XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTKS5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbnRyeUNvbXBvbmVudHMucHVzaC5hcHBseSh0YXJnZXRFbnRyeUNvbXBvbmVudHMsIF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudHNGcm9tUHJvdmlkZXIocHJvdmlkZXIpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGVQcm92aWRlciA9IF90aGlzLmdldFByb3ZpZGVyTWV0YWRhdGEocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsaWRUeXBlKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgY29tcGlsZVByb3ZpZGVyID0gX3RoaXMuZ2V0VHlwZU1ldGFkYXRhKHByb3ZpZGVyLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJzSW5mbyA9IHByb3ZpZGVycy5yZWR1Y2UoZnVuY3Rpb24gKHNvRmFyLCBzZWVuUHJvdmlkZXIsIHNlZW5Qcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVuUHJvdmlkZXJJZHggPCBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiXCIgKyBzdHJpbmdpZnkoc2VlblByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5Qcm92aWRlcklkeCA9PSBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiP1wiICsgc3RyaW5naWZ5KHNlZW5Qcm92aWRlcikgKyBcIj9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlZW5Qcm92aWRlcklkeCA9PSBwcm92aWRlcklkeCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIucHVzaCgnLi4uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb0ZhcjtcbiAgICAgICAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBcIiArIChkZWJ1Z0luZm8gPyBkZWJ1Z0luZm8gOiAncHJvdmlkZXInKSArIFwiIC0gb25seSBpbnN0YW5jZXMgb2YgUHJvdmlkZXIgYW5kIFR5cGUgYXJlIGFsbG93ZWQsIGdvdDogW1wiICsgcHJvdmlkZXJzSW5mbyArIFwiXVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29tcGlsZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICBjb21waWxlUHJvdmlkZXJzLnB1c2goY29tcGlsZVByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBjb21waWxlUHJvdmlkZXJzO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0RW50cnlDb21wb25lbnRzRnJvbVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICAgIHZhciBjb2xsZWN0ZWRJZGVudGlmaWVycyA9IFtdO1xuICAgICAgICAgIGlmIChwcm92aWRlci51c2VGYWN0b3J5IHx8IHByb3ZpZGVyLnVzZUV4aXN0aW5nIHx8IHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgdXNlVmFsdWUhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTIHRva2VuIG9ubHkgc3VwcG9ydHMgJ211bHRpID0gdHJ1ZSchXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb252ZXJ0VG9Db21waWxlVmFsdWUocHJvdmlkZXIudXNlVmFsdWUsIGNvbGxlY3RlZElkZW50aWZpZXJzKTtcbiAgICAgICAgICBjb2xsZWN0ZWRJZGVudGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIHZhciBkaXJNZXRhID0gX3RoaXMuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoaWRlbnRpZmllci5yZWZlcmVuY2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgaWYgKGRpck1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChkaXJNZXRhLnR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFByb3ZpZGVyTWV0YWRhdGEgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZURlcHM7XG4gICAgICAgICAgdmFyIGNvbXBpbGVUeXBlTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICAgIHZhciBjb21waWxlRmFjdG9yeU1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgICBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY29tcGlsZVR5cGVNZXRhZGF0YSA9IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKHByb3ZpZGVyLnVzZUNsYXNzLCBzdGF0aWNUeXBlTW9kdWxlVXJsKHByb3ZpZGVyLnVzZUNsYXNzKSwgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgY29tcGlsZURlcHMgPSBjb21waWxlVHlwZU1ldGFkYXRhLmRpRGVwcztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgICBjb21waWxlRmFjdG9yeU1ldGFkYXRhID0gdGhpcy5nZXRGYWN0b3J5TWV0YWRhdGEocHJvdmlkZXIudXNlRmFjdG9yeSwgc3RhdGljVHlwZU1vZHVsZVVybChwcm92aWRlci51c2VGYWN0b3J5KSwgcHJvdmlkZXIuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgY29tcGlsZURlcHMgPSBjb21waWxlRmFjdG9yeU1ldGFkYXRhLmRpRGVwcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlUHJvdmlkZXJNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHRva2VuOiB0aGlzLmdldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudG9rZW4pLFxuICAgICAgICAgICAgICB1c2VDbGFzczogY29tcGlsZVR5cGVNZXRhZGF0YSxcbiAgICAgICAgICAgICAgdXNlVmFsdWU6IGNvbnZlcnRUb0NvbXBpbGVWYWx1ZShwcm92aWRlci51c2VWYWx1ZSwgW10pLFxuICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBjb21waWxlRmFjdG9yeU1ldGFkYXRhLFxuICAgICAgICAgICAgICB1c2VFeGlzdGluZzogcHJvdmlkZXIudXNlRXhpc3RpbmcgPyB0aGlzLmdldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudXNlRXhpc3RpbmcpIDogbnVsbCxcbiAgICAgICAgICAgICAgZGVwczogY29tcGlsZURlcHMsXG4gICAgICAgICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRRdWVyaWVzTWV0YWRhdGEgPSBmdW5jdGlvbiAocXVlcmllcywgaXNWaWV3UXVlcnksIGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhxdWVyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gcXVlcmllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICBpZiAocXVlcnkuaXNWaWV3UXVlcnkgPT09IGlzVmlld1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICByZXMucHVzaChfdGhpcy5nZXRRdWVyeU1ldGFkYXRhKHF1ZXJ5LCBwcm9wZXJ0eU5hbWUsIGRpcmVjdGl2ZVR5cGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICB9O1xuICAgICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9xdWVyeVZhckJpbmRpbmdzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3Rvci5zcGxpdCgvXFxzKixcXHMqLyk7IH07XG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UXVlcnlNZXRhZGF0YSA9IGZ1bmN0aW9uIChxLCBwcm9wZXJ0eU5hbWUsIHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzZWxlY3RvcnM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBxLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBzZWxlY3RvcnMgPSB0aGlzLl9xdWVyeVZhckJpbmRpbmdzKHEuc2VsZWN0b3IpLm1hcChmdW5jdGlvbiAodmFyTmFtZSkgeyByZXR1cm4gX3RoaXMuZ2V0VG9rZW5NZXRhZGF0YSh2YXJOYW1lKTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXEuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnN0cnVjdCBhIHF1ZXJ5IGZvciB0aGUgcHJvcGVydHkgXFxcIlwiICsgcHJvcGVydHlOYW1lICsgXCJcXFwiIG9mIFxcXCJcIiArIHN0cmluZ2lmeSh0eXBlT3JGdW5jKSArIFwiXFxcIiBzaW5jZSB0aGUgcXVlcnkgc2VsZWN0b3Igd2Fzbid0IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNlbGVjdG9ycyA9IFt0aGlzLmdldFRva2VuTWV0YWRhdGEocS5zZWxlY3RvcildO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVRdWVyeU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMsXG4gICAgICAgICAgICAgIGZpcnN0OiBxLmZpcnN0LFxuICAgICAgICAgICAgICBkZXNjZW5kYW50czogcS5kZXNjZW5kYW50cywgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgIHJlYWQ6IHEucmVhZCA/IHRoaXMuZ2V0VG9rZW5NZXRhZGF0YShxLnJlYWQpIDogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogTmdNb2R1bGVSZXNvbHZlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IERpcmVjdGl2ZVJlc29sdmVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogUGlwZVJlc29sdmVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB9LFxuICAgICAgICAgIHsgdHlwZTogUmVmbGVjdG9yUmVhZGVyLCB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBDb21waWxlTWV0YWRhdGFSZXNvbHZlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZ2V0VHJhbnNpdGl2ZU1vZHVsZXMobW9kdWxlcywgaW5jbHVkZUltcG9ydHMsIHRhcmdldE1vZHVsZXMsIHZpc2l0ZWRNb2R1bGVzKSB7XG4gICAgICBpZiAodGFyZ2V0TW9kdWxlcyA9PT0gdm9pZCAwKSB7IHRhcmdldE1vZHVsZXMgPSBbXTsgfVxuICAgICAgaWYgKHZpc2l0ZWRNb2R1bGVzID09PSB2b2lkIDApIHsgdmlzaXRlZE1vZHVsZXMgPSBuZXcgU2V0KCk7IH1cbiAgICAgIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGUpIHtcbiAgICAgICAgICBpZiAoIXZpc2l0ZWRNb2R1bGVzLmhhcyhuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgdmlzaXRlZE1vZHVsZXMuYWRkKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgdmFyIG5lc3RlZE1vZHVsZXMgPSBpbmNsdWRlSW1wb3J0cyA/XG4gICAgICAgICAgICAgICAgICBuZ01vZHVsZS5pbXBvcnRlZE1vZHVsZXMuY29uY2F0KG5nTW9kdWxlLmV4cG9ydGVkTW9kdWxlcykgOlxuICAgICAgICAgICAgICAgICAgbmdNb2R1bGUuZXhwb3J0ZWRNb2R1bGVzO1xuICAgICAgICAgICAgICBnZXRUcmFuc2l0aXZlTW9kdWxlcyhuZXN0ZWRNb2R1bGVzLCBpbmNsdWRlSW1wb3J0cywgdGFyZ2V0TW9kdWxlcywgdmlzaXRlZE1vZHVsZXMpO1xuICAgICAgICAgICAgICAvLyBBZGQgYWZ0ZXIgcmVjdXJzaW5nIHNvIGltcG9ydGVkL2V4cG9ydGVkIG1vZHVsZXMgYXJlIGJlZm9yZSB0aGUgbW9kdWxlIGl0c2VsZi5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIG92ZXJ3cml0aW5nIHByb3ZpZGVycyBvZiBpbXBvcnRlZCBtb2R1bGVzIVxuICAgICAgICAgICAgICB0YXJnZXRNb2R1bGVzLnB1c2gobmdNb2R1bGUpO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRhcmdldE1vZHVsZXM7XG4gIH1cbiAgZnVuY3Rpb24gZmxhdHRlbkFycmF5KHRyZWUsIG91dCkge1xuICAgICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7IG91dCA9IFtdOyB9XG4gICAgICBpZiAodHJlZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hbmd1bGFyX2NvcmUucmVzb2x2ZUZvcndhcmRSZWYodHJlZVtpXSk7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICBmbGF0dGVuQXJyYXkoaXRlbSwgb3V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgfVxuICBmdW5jdGlvbiBpc1ZhbGlkVHlwZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzU3RhdGljU3ltYm9sKHZhbHVlKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBfYW5ndWxhcl9jb3JlLlR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXRpY1R5cGVNb2R1bGVVcmwodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1N0YXRpY1N5bWJvbCh2YWx1ZSkgPyB2YWx1ZS5maWxlUGF0aCA6IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gY29tcG9uZW50TW9kdWxlVXJsKHJlZmxlY3RvciwgdHlwZSwgY21wTWV0YWRhdGEpIHtcbiAgICAgIGlmIChpc1N0YXRpY1N5bWJvbCh0eXBlKSkge1xuICAgICAgICAgIHJldHVybiBzdGF0aWNUeXBlTW9kdWxlVXJsKHR5cGUpO1xuICAgICAgfVxuICAgICAgdmFyIG1vZHVsZUlkID0gY21wTWV0YWRhdGEubW9kdWxlSWQ7XG4gICAgICBpZiAodHlwZW9mIG1vZHVsZUlkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBzY2hlbWUgPSBnZXRVcmxTY2hlbWUobW9kdWxlSWQpO1xuICAgICAgICAgIHJldHVybiBzY2hlbWUgPyBtb2R1bGVJZCA6IFwicGFja2FnZTpcIiArIG1vZHVsZUlkICsgTU9EVUxFX1NVRkZJWDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1vZHVsZUlkICE9PSBudWxsICYmIG1vZHVsZUlkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwibW9kdWxlSWQgc2hvdWxkIGJlIGEgc3RyaW5nIGluIFxcXCJcIiArIHN0cmluZ2lmeSh0eXBlKSArIFwiXFxcIi4gU2VlIGh0dHBzOi8vZ29vLmdsL3dJRERpTCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG5cIikgK1xuICAgICAgICAgICAgICBcIklmIHlvdSdyZSB1c2luZyBXZWJwYWNrIHlvdSBzaG91bGQgaW5saW5lIHRoZSB0ZW1wbGF0ZSBhbmQgdGhlIHN0eWxlcywgc2VlIGh0dHBzOi8vZ29vLmdsL1gySjh6Yy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmbGVjdG9yLmltcG9ydFVyaSh0eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0VG9Db21waWxlVmFsdWUodmFsdWUsIHRhcmdldElkZW50aWZpZXJzKSB7XG4gICAgICByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgbmV3IF9Db21waWxlVmFsdWVDb252ZXJ0ZXIoKSwgdGFyZ2V0SWRlbnRpZmllcnMpO1xuICB9XG4gIHZhciBfQ29tcGlsZVZhbHVlQ29udmVydGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxNShfQ29tcGlsZVZhbHVlQ29udmVydGVyLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIF9Db21waWxlVmFsdWVDb252ZXJ0ZXIucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIHRhcmdldElkZW50aWZpZXJzKSB7XG4gICAgICAgICAgdmFyIGlkZW50aWZpZXI7XG4gICAgICAgICAgaWYgKGlzU3RhdGljU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgICBpZGVudGlmaWVyID0gbmV3IENvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEoeyBuYW1lOiB2YWx1ZS5uYW1lLCBtb2R1bGVVcmw6IHZhbHVlLmZpbGVQYXRoLCByZWZlcmVuY2U6IHZhbHVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWRlbnRpZmllciA9IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgcmVmZXJlbmNlOiB2YWx1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0SWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcjtcbiAgfShWYWx1ZVRyYW5zZm9ybWVyKSk7XG5cbiAgdmFyIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5JDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3koY29tcCwgcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeTtcbiAgfSgpKTtcbiAgdmFyIE5nTW9kdWxlQ29tcGlsZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBOZ01vZHVsZUNvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgbmdNb2R1bGVGYWN0b3J5VmFyLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICAgIHRoaXMubmdNb2R1bGVGYWN0b3J5VmFyID0gbmdNb2R1bGVGYWN0b3J5VmFyO1xuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5nTW9kdWxlQ29tcGlsZVJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIE5nTW9kdWxlQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTmdNb2R1bGVDb21waWxlcigpIHtcbiAgICAgIH1cbiAgICAgIE5nTW9kdWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAobmdNb2R1bGVNZXRhLCBleHRyYVByb3ZpZGVycykge1xuICAgICAgICAgIHZhciBzb3VyY2VGaWxlTmFtZSA9IGlzUHJlc2VudChuZ01vZHVsZU1ldGEudHlwZS5tb2R1bGVVcmwpID9cbiAgICAgICAgICAgICAgXCJpbiBOZ01vZHVsZSBcIiArIG5nTW9kdWxlTWV0YS50eXBlLm5hbWUgKyBcIiBpbiBcIiArIG5nTW9kdWxlTWV0YS50eXBlLm1vZHVsZVVybCA6XG4gICAgICAgICAgICAgIFwiaW4gTmdNb2R1bGUgXCIgKyBuZ01vZHVsZU1ldGEudHlwZS5uYW1lO1xuICAgICAgICAgIHZhciBzb3VyY2VGaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZSgnJywgc291cmNlRmlsZU5hbWUpO1xuICAgICAgICAgIHZhciBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCBudWxsLCBudWxsLCBudWxsKSwgbmV3IFBhcnNlTG9jYXRpb24oc291cmNlRmlsZSwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuICAgICAgICAgIHZhciBkZXBzID0gW107XG4gICAgICAgICAgdmFyIGJvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcyA9IFtdO1xuICAgICAgICAgIHZhciBlbnRyeUNvbXBvbmVudEZhY3RvcmllcyA9IG5nTW9kdWxlTWV0YS50cmFuc2l0aXZlTW9kdWxlLmVudHJ5Q29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHZhciBpZCA9IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogZW50cnlDb21wb25lbnQubmFtZSB9KTtcbiAgICAgICAgICAgICAgaWYgKG5nTW9kdWxlTWV0YS5ib290c3RyYXBDb21wb25lbnRzLmluZGV4T2YoZW50cnlDb21wb25lbnQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllcy5wdXNoKGlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZXBzLnB1c2gobmV3IENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5JDEoZW50cnlDb21wb25lbnQsIGlkKSk7XG4gICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBfSW5qZWN0b3JCdWlsZGVyKG5nTW9kdWxlTWV0YSwgZW50cnlDb21wb25lbnRGYWN0b3JpZXMsIGJvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllcywgc291cmNlU3Bhbik7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyUGFyc2VyID0gbmV3IE5nTW9kdWxlUHJvdmlkZXJBbmFseXplcihuZ01vZHVsZU1ldGEsIGV4dHJhUHJvdmlkZXJzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICBwcm92aWRlclBhcnNlci5wYXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBidWlsZGVyLmFkZFByb3ZpZGVyKHByb3ZpZGVyKTsgfSk7XG4gICAgICAgICAgdmFyIGluamVjdG9yQ2xhc3MgPSBidWlsZGVyLmJ1aWxkKCk7XG4gICAgICAgICAgdmFyIG5nTW9kdWxlRmFjdG9yeVZhciA9IG5nTW9kdWxlTWV0YS50eXBlLm5hbWUgKyBcIk5nRmFjdG9yeVwiO1xuICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnlTdG10ID0gdmFyaWFibGUobmdNb2R1bGVGYWN0b3J5VmFyKVxuICAgICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuTmdNb2R1bGVGYWN0b3J5KSlcbiAgICAgICAgICAgICAgLmluc3RhbnRpYXRlKFt2YXJpYWJsZShpbmplY3RvckNsYXNzLm5hbWUpLCBpbXBvcnRFeHByKG5nTW9kdWxlTWV0YS50eXBlKV0sIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuTmdNb2R1bGVGYWN0b3J5KSwgW2ltcG9ydFR5cGUobmdNb2R1bGVNZXRhLnR5cGUpXSwgW1R5cGVNb2RpZmllci5Db25zdF0pKSlcbiAgICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICAgIHZhciBzdG10cyA9IFtpbmplY3RvckNsYXNzLCBuZ01vZHVsZUZhY3RvcnlTdG10XTtcbiAgICAgICAgICBpZiAobmdNb2R1bGVNZXRhLmlkKSB7XG4gICAgICAgICAgICAgIHZhciByZWdpc3RlckZhY3RvcnlTdG10ID0gaW1wb3J0RXhwcihyZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5SZWdpc3Rlck1vZHVsZUZhY3RvcnlGbikpXG4gICAgICAgICAgICAgICAgICAuY2FsbEZuKFtsaXRlcmFsKG5nTW9kdWxlTWV0YS5pZCksIHZhcmlhYmxlKG5nTW9kdWxlRmFjdG9yeVZhcildKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpO1xuICAgICAgICAgICAgICBzdG10cy5wdXNoKHJlZ2lzdGVyRmFjdG9yeVN0bXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IE5nTW9kdWxlQ29tcGlsZVJlc3VsdChzdG10cywgbmdNb2R1bGVGYWN0b3J5VmFyLCBkZXBzKTtcbiAgICAgIH07XG4gICAgICBOZ01vZHVsZUNvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIE5nTW9kdWxlQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgIHJldHVybiBOZ01vZHVsZUNvbXBpbGVyO1xuICB9KCkpO1xuICB2YXIgX0luamVjdG9yQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfSW5qZWN0b3JCdWlsZGVyKF9uZ01vZHVsZU1ldGEsIF9lbnRyeUNvbXBvbmVudEZhY3RvcmllcywgX2Jvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcywgX3NvdXJjZVNwYW4pIHtcbiAgICAgICAgICB0aGlzLl9uZ01vZHVsZU1ldGEgPSBfbmdNb2R1bGVNZXRhO1xuICAgICAgICAgIHRoaXMuX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzO1xuICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcyA9IF9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgICAgdGhpcy5fc291cmNlU3BhbiA9IF9zb3VyY2VTcGFuO1xuICAgICAgICAgIHRoaXMuX3Rva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2luc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9maWVsZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVTdG10cyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lTdG10cyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2dldHRlcnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLmFkZFByb3ZpZGVyID0gZnVuY3Rpb24gKHJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBfdGhpcy5fZ2V0UHJvdmlkZXJWYWx1ZShwcm92aWRlcik7IH0pO1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IFwiX1wiICsgcmVzb2x2ZWRQcm92aWRlci50b2tlbi5uYW1lICsgXCJfXCIgKyB0aGlzLl9pbnN0YW5jZXMuc2l6ZTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9jcmVhdGVQcm92aWRlclByb3BlcnR5KHByb3BOYW1lLCByZXNvbHZlZFByb3ZpZGVyLCBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMsIHJlc29sdmVkUHJvdmlkZXIubXVsdGlQcm92aWRlciwgcmVzb2x2ZWRQcm92aWRlci5lYWdlcik7XG4gICAgICAgICAgaWYgKHJlc29sdmVkUHJvdmlkZXIubGlmZWN5Y2xlSG9va3MuaW5kZXhPZihMaWZlY3ljbGVIb29rcy5PbkRlc3Ryb3kpICE9PSAtMSkge1xuICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95U3RtdHMucHVzaChpbnN0YW5jZS5jYWxsTWV0aG9kKCduZ09uRGVzdHJveScsIFtdKS50b1N0bXQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Rva2Vucy5wdXNoKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pO1xuICAgICAgICAgIHRoaXMuX2luc3RhbmNlcy5zZXQocmVzb2x2ZWRQcm92aWRlci50b2tlbi5yZWZlcmVuY2UsIGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBnZXRNZXRob2RTdG10cyA9IHRoaXMuX3Rva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlckV4cHIgPSBfdGhpcy5faW5zdGFuY2VzLmdldCh0b2tlbi5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IElmU3RtdChJbmplY3RNZXRob2RWYXJzJDEudG9rZW4uaWRlbnRpY2FsKGNyZWF0ZURpVG9rZW5FeHByZXNzaW9uKHRva2VuKSksIFtuZXcgUmV0dXJuU3RhdGVtZW50KHByb3ZpZGVyRXhwcildKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtcbiAgICAgICAgICAgICAgbmV3IENsYXNzTWV0aG9kKCdjcmVhdGVJbnRlcm5hbCcsIFtdLCB0aGlzLl9jcmVhdGVTdG10cy5jb25jYXQobmV3IFJldHVyblN0YXRlbWVudCh0aGlzLl9pbnN0YW5jZXMuZ2V0KHRoaXMuX25nTW9kdWxlTWV0YS50eXBlLnJlZmVyZW5jZSkpKSwgaW1wb3J0VHlwZSh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZSkpLFxuICAgICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2dldEludGVybmFsJywgW1xuICAgICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oSW5qZWN0TWV0aG9kVmFycyQxLnRva2VuLm5hbWUsIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShJbmplY3RNZXRob2RWYXJzJDEubm90Rm91bmRSZXN1bHQubmFtZSwgRFlOQU1JQ19UWVBFKVxuICAgICAgICAgICAgICBdLCBnZXRNZXRob2RTdG10cy5jb25jYXQoW25ldyBSZXR1cm5TdGF0ZW1lbnQoSW5qZWN0TWV0aG9kVmFycyQxLm5vdEZvdW5kUmVzdWx0KV0pLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2Rlc3Ryb3lJbnRlcm5hbCcsIFtdLCB0aGlzLl9kZXN0cm95U3RtdHMpLFxuICAgICAgICAgIF07XG4gICAgICAgICAgdmFyIGN0b3IgPSBuZXcgQ2xhc3NNZXRob2QobnVsbCwgW25ldyBGblBhcmFtKEluamVjdG9yUHJvcHMucGFyZW50Lm5hbWUsIGltcG9ydFR5cGUocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuSW5qZWN0b3IpKSldLCBbU1VQRVJfRVhQUlxuICAgICAgICAgICAgICAgICAgLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICB2YXJpYWJsZShJbmplY3RvclByb3BzLnBhcmVudC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgIGxpdGVyYWxBcnIodGhpcy5fZW50cnlDb21wb25lbnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5KSB7IHJldHVybiBpbXBvcnRFeHByKGNvbXBvbmVudEZhY3RvcnkpOyB9KSksXG4gICAgICAgICAgICAgICAgICBsaXRlcmFsQXJyKHRoaXMuX2Jvb3RzdHJhcENvbXBvbmVudEZhY3Rvcmllcy5tYXAoZnVuY3Rpb24gKGNvbXBvbmVudEZhY3RvcnkpIHsgcmV0dXJuIGltcG9ydEV4cHIoY29tcG9uZW50RmFjdG9yeSk7IH0pKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgLnRvU3RtdCgpXSk7XG4gICAgICAgICAgdmFyIGluakNsYXNzTmFtZSA9IHRoaXMuX25nTW9kdWxlTWV0YS50eXBlLm5hbWUgKyBcIkluamVjdG9yXCI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDbGFzc1N0bXQoaW5qQ2xhc3NOYW1lLCBpbXBvcnRFeHByKHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLk5nTW9kdWxlSW5qZWN0b3IpLCBbaW1wb3J0VHlwZSh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZSldKSwgdGhpcy5fZmllbGRzLCB0aGlzLl9nZXR0ZXJzLCBjdG9yLCBtZXRob2RzKTtcbiAgICAgIH07XG4gICAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5fZ2V0UHJvdmlkZXJWYWx1ZSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUV4aXN0aW5nKSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXREZXBlbmRlbmN5KG5ldyBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEoeyB0b2tlbjogcHJvdmlkZXIudXNlRXhpc3RpbmcgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1ByZXNlbnQocHJvdmlkZXIudXNlRmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgdmFyIGRlcHMgPSBpc1ByZXNlbnQocHJvdmlkZXIuZGVwcykgPyBwcm92aWRlci5kZXBzIDogcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHM7XG4gICAgICAgICAgICAgIHZhciBkZXBzRXhwciA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KGRlcCk7IH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSBpbXBvcnRFeHByKHByb3ZpZGVyLnVzZUZhY3RvcnkpLmNhbGxGbihkZXBzRXhwcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VDbGFzcykpIHtcbiAgICAgICAgICAgICAgdmFyIGRlcHMgPSBpc1ByZXNlbnQocHJvdmlkZXIuZGVwcykgPyBwcm92aWRlci5kZXBzIDogcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICB2YXIgZGVwc0V4cHIgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXApOyB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgIGltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MpLmluc3RhbnRpYXRlKGRlcHNFeHByLCBpbXBvcnRUeXBlKHByb3ZpZGVyLnVzZUNsYXNzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChwcm92aWRlci51c2VWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVByb3ZpZGVyUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHByb3ZpZGVyLCBwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMsIGlzTXVsdGksIGlzRWFnZXIpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcjtcbiAgICAgICAgICB2YXIgdHlwZTtcbiAgICAgICAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gbGl0ZXJhbEFycihwcm92aWRlclZhbHVlRXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICB0eXBlID0gbmV3IEFycmF5VHlwZShEWU5BTUlDX1RZUEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwciA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXTtcbiAgICAgICAgICAgICAgdHlwZSA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXS50eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgdHlwZSA9IERZTkFNSUNfVFlQRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRWFnZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQocHJvcE5hbWUsIHR5cGUpKTtcbiAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlU3RtdHMucHVzaChUSElTX0VYUFIucHJvcChwcm9wTmFtZSkuc2V0KHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIpLnRvU3RtdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBpbnRlcm5hbEZpZWxkID0gXCJfXCIgKyBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgdGhpcy5fZmllbGRzLnB1c2gobmV3IENsYXNzRmllbGQoaW50ZXJuYWxGaWVsZCwgdHlwZSkpO1xuICAgICAgICAgICAgICAvLyBOb3RlOiBFcXVhbHMgaXMgaW1wb3J0YW50IGZvciBKUyBzbyB0aGF0IGl0IGFsc28gY2hlY2tzIHRoZSB1bmRlZmluZWQgY2FzZSFcbiAgICAgICAgICAgICAgdmFyIGdldHRlclN0bXRzID0gW1xuICAgICAgICAgICAgICAgICAgbmV3IElmU3RtdChUSElTX0VYUFIucHJvcChpbnRlcm5hbEZpZWxkKS5pc0JsYW5rKCksIFtUSElTX0VYUFIucHJvcChpbnRlcm5hbEZpZWxkKS5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCldKSxcbiAgICAgICAgICAgICAgICAgIG5ldyBSZXR1cm5TdGF0ZW1lbnQoVEhJU19FWFBSLnByb3AoaW50ZXJuYWxGaWVsZCkpXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIHRoaXMuX2dldHRlcnMucHVzaChuZXcgQ2xhc3NHZXR0ZXIocHJvcE5hbWUsIGdldHRlclN0bXRzLCB0eXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBUSElTX0VYUFIucHJvcChwcm9wTmFtZSk7XG4gICAgICB9O1xuICAgICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgaWYgKGRlcC5pc1ZhbHVlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxpdGVyYWwoZGVwLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkZXAuaXNTa2lwU2VsZikge1xuICAgICAgICAgICAgICBpZiAoZGVwLnRva2VuICYmXG4gICAgICAgICAgICAgICAgICAoZGVwLnRva2VuLnJlZmVyZW5jZSA9PT0gcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5JbmplY3RvcikucmVmZXJlbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZGVwLnRva2VuLnJlZmVyZW5jZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFRISVNfRVhQUjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5faW5zdGFuY2VzLmdldChkZXAudG9rZW4ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICB2YXIgYXJncyA9IFtjcmVhdGVEaVRva2VuRXhwcmVzc2lvbihkZXAudG9rZW4pXTtcbiAgICAgICAgICAgICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzLnB1c2goTlVMTF9FWFBSKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSBJbmplY3RvclByb3BzLnBhcmVudC5jYWxsTWV0aG9kKCdnZXQnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0luamVjdG9yQnVpbGRlcjtcbiAgfSgpKTtcbiAgdmFyIEluamVjdG9yUHJvcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0b3JQcm9wcygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdG9yUHJvcHMucGFyZW50ID0gVEhJU19FWFBSLnByb3AoJ3BhcmVudCcpO1xuICAgICAgcmV0dXJuIEluamVjdG9yUHJvcHM7XG4gIH0oKSk7XG4gIHZhciBJbmplY3RNZXRob2RWYXJzJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gSW5qZWN0TWV0aG9kVmFycygpIHtcbiAgICAgIH1cbiAgICAgIEluamVjdE1ldGhvZFZhcnMudG9rZW4gPSB2YXJpYWJsZSgndG9rZW4nKTtcbiAgICAgIEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQgPSB2YXJpYWJsZSgnbm90Rm91bmRSZXN1bHQnKTtcbiAgICAgIHJldHVybiBJbmplY3RNZXRob2RWYXJzO1xuICB9KCkpO1xuXG4gIHZhciBfU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUgPSAvJ3xcXFxcfFxcbnxcXHJ8XFwkL2c7XG4gIHZhciBfTEVHQUxfSURFTlRJRklFUl9SRSA9IC9eWyRBLVpfXVswLTlBLVpfJF0qJC9pO1xuICB2YXIgQ0FUQ0hfRVJST1JfVkFSJDIgPSB2YXJpYWJsZSgnZXJyb3InKTtcbiAgdmFyIENBVENIX1NUQUNLX1ZBUiQyID0gdmFyaWFibGUoJ3N0YWNrJyk7XG4gIHZhciBfRW1pdHRlZExpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX0VtaXR0ZWRMaW5lKGluZGVudCkge1xuICAgICAgICAgIHRoaXMuaW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfRW1pdHRlZExpbmU7XG4gIH0oKSk7XG4gIHZhciBFbWl0dGVyVmlzaXRvckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gRW1pdHRlclZpc2l0b3JDb250ZXh0KF9leHBvcnRlZFZhcnMsIF9pbmRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9leHBvcnRlZFZhcnMgPSBfZXhwb3J0ZWRWYXJzO1xuICAgICAgICAgIHRoaXMuX2luZGVudCA9IF9pbmRlbnQ7XG4gICAgICAgICAgdGhpcy5fY2xhc3NlcyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2xpbmVzID0gW25ldyBfRW1pdHRlZExpbmUoX2luZGVudCldO1xuICAgICAgfVxuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiAoZXhwb3J0ZWRWYXJzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBFbWl0dGVyVmlzaXRvckNvbnRleHQoZXhwb3J0ZWRWYXJzLCAwKTtcbiAgICAgIH07XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJfY3VycmVudExpbmVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV07IH0sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5pc0V4cG9ydGVkVmFyID0gZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIHRoaXMuX2V4cG9ydGVkVmFycy5pbmRleE9mKHZhck5hbWUpICE9PSAtMTsgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHJpbnRsbiA9IGZ1bmN0aW9uIChsYXN0UGFydCkge1xuICAgICAgICAgIGlmIChsYXN0UGFydCA9PT0gdm9pZCAwKSB7IGxhc3RQYXJ0ID0gJyc7IH1cbiAgICAgICAgICB0aGlzLnByaW50KGxhc3RQYXJ0LCB0cnVlKTtcbiAgICAgIH07XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmxpbmVJc0VtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3VycmVudExpbmUucGFydHMubGVuZ3RoID09PSAwOyB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIChwYXJ0LCBuZXdMaW5lKSB7XG4gICAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3IF9FbWl0dGVkTGluZSh0aGlzLl9pbmRlbnQpKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5yZW1vdmVFbXB0eUxhc3RMaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGluZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuaW5jSW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX2luZGVudCsrO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICAgIH07XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmRlY0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9pbmRlbnQtLTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgICB9O1xuICAgICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5wdXNoQ2xhc3MgPSBmdW5jdGlvbiAoY2xhenopIHsgdGhpcy5fY2xhc3Nlcy5wdXNoKGNsYXp6KTsgfTtcbiAgICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucG9wQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jbGFzc2VzLnBvcCgpOyB9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUsIFwiY3VycmVudENsYXNzXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzZXMubGVuZ3RoID4gMCA/IHRoaXMuX2NsYXNzZXNbdGhpcy5fY2xhc3Nlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnRvU291cmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBsaW5lcyA9IHRoaXMuX2xpbmVzO1xuICAgICAgICAgIGlmIChsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgbGluZXMgPSBsaW5lcy5zbGljZSgwLCBsaW5lcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxpbmVzXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICAgICAgaWYgKGxpbmUucGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVJbmRlbnQobGluZS5pbmRlbnQpICsgbGluZS5wYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gRW1pdHRlclZpc2l0b3JDb250ZXh0O1xuICB9KCkpO1xuICB2YXIgQWJzdHJhY3RFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKF9lc2NhcGVEb2xsYXJJblN0cmluZ3MpIHtcbiAgICAgICAgICB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MgPSBfZXNjYXBlRG9sbGFySW5TdHJpbmdzO1xuICAgICAgfVxuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oJzsnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJldHVyblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwicmV0dXJuIFwiKTtcbiAgICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKCc7Jyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiaWYgKFwiKTtcbiAgICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpIHtcIik7XG4gICAgICAgICAgdmFyIGhhc0Vsc2VDYXNlID0gaXNQcmVzZW50KHN0bXQuZmFsc2VDYXNlKSAmJiBzdG10LmZhbHNlQ2FzZS5sZW5ndGggPiAwO1xuICAgICAgICAgIGlmIChzdG10LnRydWVDYXNlLmxlbmd0aCA8PSAxICYmICFoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIgXCIpO1xuICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICBjdHgucmVtb3ZlRW1wdHlMYXN0TGluZSgpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICAgIGlmIChoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgICAgICAgY3R4LnByaW50bG4oXCJ9IGVsc2Uge1wiKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJ0aHJvdyBcIik7XG4gICAgICAgICAgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB2YXIgbGluZXMgPSBzdG10LmNvbW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHsgY3R4LnByaW50bG4oXCIvLyBcIiArIGxpbmUpOyB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlVmFyRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICB2YXIgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcoJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlS2V5RXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgICB2YXIgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KCcoJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiW1wiKTtcbiAgICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIl0gPSBcIik7XG4gICAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJyknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJygnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIuXCIgKyBleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGV4cHIubmFtZTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuZ2V0QnVpbHRpbk1ldGhvZE5hbWUoZXhwci5idWlsdGluKTtcbiAgICAgICAgICAgICAgaWYgKGlzQmxhbmsobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHNvbWUgYnVpbHRpbnMganVzdCBtZWFuIHRvIHNraXAgdGhlIGNhbGwuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQoXCIuXCIgKyBuYW1lICsgXCIoXCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgXCIsXCIpO1xuICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgZXhwci5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIoXCIpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgdmFyTmFtZSA9IGFzdC5uYW1lO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXN0LmJ1aWx0aW4pKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5TdXBlcjpcbiAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gJ3N1cGVyJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5UaGlzOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAndGhpcyc7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lID0gQ0FUQ0hfRVJST1JfVkFSJDIubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9TVEFDS19WQVIkMi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gdmFyaWFibGUgXCIgKyBhc3QuYnVpbHRpbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KHZhck5hbWUpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5zdGFudGlhdGVFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwibmV3IFwiKTtcbiAgICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4LCBhYnNlbnRWYWx1ZSkge1xuICAgICAgICAgIGlmIChhYnNlbnRWYWx1ZSA9PT0gdm9pZCAwKSB7IGFic2VudFZhbHVlID0gJ251bGwnOyB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KGVzY2FwZUlkZW50aWZpZXIodmFsdWUsIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoYWJzZW50VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiKFwiKTtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludCgnPyAnKTtcbiAgICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KCc6ICcpO1xuICAgICAgICAgIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoJyEnKTtcbiAgICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIG9wU3RyO1xuICAgICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnPT0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnPT09JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFsczpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJyE9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJyE9PSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5BbmQ6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICcmJic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5PcjpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJ3x8JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICcrJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnLSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5EaXZpZGU6XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICcvJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnKic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Nb2R1bG86XG4gICAgICAgICAgICAgICAgICBvcFN0ciA9ICclJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkxvd2VyOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnPCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJzw9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjpcbiAgICAgICAgICAgICAgICAgIG9wU3RyID0gJz4nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgICAgb3BTdHIgPSAnPj0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIFwiICsgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KFwiKFwiKTtcbiAgICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIiBcIiArIG9wU3RyICsgXCIgXCIpO1xuICAgICAgICAgIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRQcm9wRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIuXCIpO1xuICAgICAgICAgIGN0eC5wcmludChhc3QubmFtZSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJbXCIpO1xuICAgICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJdXCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciB1c2VOZXdMaW5lID0gYXN0LmVudHJpZXMubGVuZ3RoID4gMTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJbXCIsIHVzZU5ld0xpbmUpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGN0eCwgJywnLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiXVwiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgdXNlTmV3TGluZSA9IGFzdC5lbnRyaWVzLmxlbmd0aCA+IDE7XG4gICAgICAgICAgY3R4LnByaW50KFwie1wiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGVudHJ5IC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChlc2NhcGVJZGVudGlmaWVyKGVudHJ5WzBdLCBfdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzLCBmYWxzZSkgKyBcIjogXCIpO1xuICAgICAgICAgICAgICBlbnRyeVsxXS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7XG4gICAgICAgICAgfSwgYXN0LmVudHJpZXMsIGN0eCwgJywnLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50KFwifVwiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAoZXhwciAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0sIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSk7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxPYmplY3RzID0gZnVuY3Rpb24gKGhhbmRsZXIsIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvciwgbmV3TGluZSkge1xuICAgICAgICAgIGlmIChuZXdMaW5lID09PSB2b2lkIDApIHsgbmV3TGluZSA9IGZhbHNlOyB9XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5wcmludChzZXBhcmF0b3IsIG5ld0xpbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGhhbmRsZXIoZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3TGluZSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnRsbigpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGN0eCk7IH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yO1xuICB9KCkpO1xuICBmdW5jdGlvbiBlc2NhcGVJZGVudGlmaWVyKGlucHV0LCBlc2NhcGVEb2xsYXIsIGFsd2F5c1F1b3RlKSB7XG4gICAgICBpZiAoYWx3YXlzUXVvdGUgPT09IHZvaWQgMCkgeyBhbHdheXNRdW90ZSA9IHRydWU7IH1cbiAgICAgIGlmIChpc0JsYW5rKGlucHV0KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGJvZHkgPSBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGxNYXBwZWQoaW5wdXQsIF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSwgZnVuY3Rpb24gKG1hdGNoIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgaWYgKG1hdGNoWzBdID09ICckJykge1xuICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlRG9sbGFyID8gJ1xcXFwkJyA6ICckJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXHInKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnXFxcXHInO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hbMF07XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgcmVxdWlyZXNRdW90ZXMgPSBhbHdheXNRdW90ZSB8fCAhX0xFR0FMX0lERU5USUZJRVJfUkUudGVzdChib2R5KTtcbiAgICAgIHJldHVybiByZXF1aXJlc1F1b3RlcyA/IFwiJ1wiICsgYm9keSArIFwiJ1wiIDogYm9keTtcbiAgfVxuICBmdW5jdGlvbiBfY3JlYXRlSW5kZW50KGNvdW50KSB7XG4gICAgICB2YXIgcmVzID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICByZXMgKz0gJyAgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBfZGVidWdNb2R1bGVVcmwgPSAnYXNzZXQ6Ly9kZWJ1Zy9saWInO1xuICBmdW5jdGlvbiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpIHtcbiAgICAgIHZhciBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IoX2RlYnVnTW9kdWxlVXJsKTtcbiAgICAgIHZhciBjdHggPSBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdChbXSk7XG4gICAgICB2YXIgYXN0cztcbiAgICAgIGlmIChpc0FycmF5KGFzdCkpIHtcbiAgICAgICAgICBhc3RzID0gYXN0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgYXN0cyA9IFthc3RdO1xuICAgICAgfVxuICAgICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgIGFzdC52aXNpdFN0YXRlbWVudChjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgYXN0LnZpc2l0RXhwcmVzc2lvbihjb252ZXJ0ZXIsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGFzdCBpbnN0YW5jZW9mIFR5cGUkMSkge1xuICAgICAgICAgICAgICBhc3QudmlzaXRUeXBlKGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRvbid0IGtub3cgaG93IHRvIHByaW50IGRlYnVnIGluZm8gZm9yIFwiICsgYXN0KTtcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdHgudG9Tb3VyY2UoKTtcbiAgfVxuICB2YXIgVHlwZVNjcmlwdEVtaXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gVHlwZVNjcmlwdEVtaXR0ZXIoX2ltcG9ydEdlbmVyYXRvcikge1xuICAgICAgICAgIHRoaXMuX2ltcG9ydEdlbmVyYXRvciA9IF9pbXBvcnRHZW5lcmF0b3I7XG4gICAgICB9XG4gICAgICBUeXBlU2NyaXB0RW1pdHRlci5wcm90b3R5cGUuZW1pdFN0YXRlbWVudHMgPSBmdW5jdGlvbiAobW9kdWxlVXJsLCBzdG10cywgZXhwb3J0ZWRWYXJzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgY29udmVydGVyID0gbmV3IF9Uc0VtaXR0ZXJWaXNpdG9yKG1vZHVsZVVybCk7XG4gICAgICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KGV4cG9ydGVkVmFycyk7XG4gICAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgY3R4KTtcbiAgICAgICAgICB2YXIgc3JjUGFydHMgPSBbXTtcbiAgICAgICAgICBjb252ZXJ0ZXIuaW1wb3J0c1dpdGhQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgsIGltcG9ydGVkTW9kdWxlVXJsKSB7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IGNhbid0IHdyaXRlIHRoZSByZWFsIHdvcmQgZm9yIGltcG9ydCBhcyBpdCBzY3Jld3MgdXAgc3lzdGVtLmpzIGF1dG8gZGV0ZWN0aW9uLi4uXG4gICAgICAgICAgICAgIHNyY1BhcnRzLnB1c2goXCJpbXBcIiArXG4gICAgICAgICAgICAgICAgICAoXCJvcnQgKiBhcyBcIiArIHByZWZpeCArIFwiIGZyb20gJ1wiICsgX3RoaXMuX2ltcG9ydEdlbmVyYXRvci5nZXRJbXBvcnRQYXRoKG1vZHVsZVVybCwgaW1wb3J0ZWRNb2R1bGVVcmwpICsgXCInO1wiKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3JjUGFydHMucHVzaChjdHgudG9Tb3VyY2UoKSk7XG4gICAgICAgICAgcmV0dXJuIHNyY1BhcnRzLmpvaW4oJ1xcbicpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBUeXBlU2NyaXB0RW1pdHRlcjtcbiAgfSgpKTtcbiAgdmFyIF9Uc0VtaXR0ZXJWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxNihfVHNFbWl0dGVyVmlzaXRvciwgX3N1cGVyKTtcbiAgICAgIGZ1bmN0aW9uIF9Uc0VtaXR0ZXJWaXNpdG9yKF9tb2R1bGVVcmwpIHtcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgdGhpcy5fbW9kdWxlVXJsID0gX21vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLmltcG9ydHNXaXRoUHJlZml4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHQsIGN0eCwgZGVmYXVsdFR5cGUpIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdFR5cGUgPT09IHZvaWQgMCkgeyBkZWZhdWx0VHlwZSA9ICdhbnknOyB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh0KSkge1xuICAgICAgICAgICAgICB0LnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KGRlZmF1bHRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIuY2FsbCh0aGlzLCBhc3QsIGN0eCwgJyhudWxsIGFzIGFueSknKTtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB0aGlzLl92aXNpdElkZW50aWZpZXIoYXN0LnZhbHVlLCBhc3QudHlwZVBhcmFtcywgY3R4KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCJleHBvcnQgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRmluYWwpKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcImNvbnN0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwidmFyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQoXCIgXCIgKyBzdG10Lm5hbWUgKyBcIjpcIik7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUoc3RtdC50eXBlLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIiA9IFwiKTtcbiAgICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiO1wiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcIig8XCIpO1xuICAgICAgICAgIGFzdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIj5cIik7XG4gICAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGN0eC5wdXNoQ2xhc3Moc3RtdCk7XG4gICAgICAgICAgaWYgKGN0eC5pc0V4cG9ydGVkVmFyKHN0bXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiZXhwb3J0IFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KFwiY2xhc3MgXCIgKyBzdG10Lm5hbWUpO1xuICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RtdC5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIiBleHRlbmRzIFwiKTtcbiAgICAgICAgICAgICAgc3RtdC5wYXJlbnQudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludGxuKFwiIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHN0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0ZpZWxkKGZpZWxkLCBjdHgpOyB9KTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0bXQuY29uc3RydWN0b3JNZXRob2QpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvcihzdG10LCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdG10LmdldHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZ2V0dGVyKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0dldHRlcihnZXR0ZXIsIGN0eCk7IH0pO1xuICAgICAgICAgIHN0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzTWV0aG9kKG1ldGhvZCwgY3R4KTsgfSk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgICAgICBjdHgucG9wQ2xhc3MoKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgY3R4KSB7XG4gICAgICAgICAgaWYgKGZpZWxkLmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5Qcml2YXRlKSkge1xuICAgICAgICAgICAgICAvLyBjb21tZW50IG91dCBhcyBhIHdvcmthcm91bmQgZm9yICMxMDk2N1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIvKnByaXZhdGUqLyBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludChmaWVsZC5uYW1lKTtcbiAgICAgICAgICBjdHgucHJpbnQoJzonKTtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZShmaWVsZC50eXBlLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiO1wiKTtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NHZXR0ZXIgPSBmdW5jdGlvbiAoZ2V0dGVyLCBjdHgpIHtcbiAgICAgICAgICBpZiAoZ2V0dGVyLmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5Qcml2YXRlKSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCJwcml2YXRlIFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KFwiZ2V0IFwiICsgZ2V0dGVyLm5hbWUgKyBcIigpXCIpO1xuICAgICAgICAgIGN0eC5wcmludCgnOicpO1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKGdldHRlci50eXBlLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwiY29uc3RydWN0b3IoXCIpO1xuICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kLCBjdHgpIHtcbiAgICAgICAgICBpZiAobWV0aG9kLmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5Qcml2YXRlKSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCJwcml2YXRlIFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KG1ldGhvZC5uYW1lICsgXCIoXCIpO1xuICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKTpcIik7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUobWV0aG9kLnR5cGUsIGN0eCwgJ3ZvaWQnKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIiB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhtZXRob2QuYm9keSwgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcIihcIik7XG4gICAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnQoXCIpOlwiKTtcbiAgICAgICAgICB0aGlzLnZpc2l0VHlwZShhc3QudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiID0+IHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnQoXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgaWYgKGN0eC5pc0V4cG9ydGVkVmFyKHN0bXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KFwiZXhwb3J0IFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnByaW50KFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoc3RtdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiKTpcIik7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUoc3RtdC50eXBlLCBjdHgsICd2b2lkJyk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJ5Q2F0Y2hTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludGxuKFwidHJ5IHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn0gY2F0Y2ggKFwiICsgQ0FUQ0hfRVJST1JfVkFSJDIubmFtZSArIFwiKSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB2YXIgY2F0Y2hTdG10cyA9IFtDQVRDSF9TVEFDS19WQVIkMi5zZXQoQ0FUQ0hfRVJST1JfVkFSJDIucHJvcCgnc3RhY2snKSkudG9EZWNsU3RtdChudWxsLCBbXG4gICAgICAgICAgICAgICAgICBTdG10TW9kaWZpZXIuRmluYWxcbiAgICAgICAgICAgICAgXSldLmNvbmNhdChzdG10LmNhdGNoU3RtdHMpO1xuICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGNhdGNoU3RtdHMsIGN0eCk7XG4gICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCdWlsdGludFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4KSB7XG4gICAgICAgICAgdmFyIHR5cGVTdHI7XG4gICAgICAgICAgc3dpdGNoICh0eXBlLm5hbWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuQm9vbDpcbiAgICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnYm9vbGVhbic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuRHluYW1pYzpcbiAgICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnYW55JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5GdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnRnVuY3Rpb24nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLk51bWJlcjpcbiAgICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5JbnQ6XG4gICAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuU3RyaW5nOlxuICAgICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBidWlsdGluIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnQodHlwZVN0cik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxUeXBlID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdGhpcy5fdmlzaXRJZGVudGlmaWVyKGFzdC52YWx1ZSwgYXN0LnR5cGVQYXJhbXMsIGN0eCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXJyYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGN0eCkge1xuICAgICAgICAgIHRoaXMudmlzaXRUeXBlKHR5cGUub2YsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwiW11cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWFwVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJ7W2tleTogc3RyaW5nXTpcIik7XG4gICAgICAgICAgdGhpcy52aXNpdFR5cGUodHlwZS52YWx1ZVR5cGUsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50KFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5OlxuICAgICAgICAgICAgICAgICAgbmFtZSA9ICdjb25jYXQnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlOlxuICAgICAgICAgICAgICAgICAgbmFtZSA9ICdzdWJzY3JpYmUnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgbmFtZSA9ICdiaW5kJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH07XG4gICAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAocGFyYW0gLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgY3R4LnByaW50KHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJzonKTtcbiAgICAgICAgICAgICAgX3RoaXMudmlzaXRUeXBlKHBhcmFtLnR5cGUsIGN0eCk7XG4gICAgICAgICAgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICB9O1xuICAgICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdElkZW50aWZpZXIgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGVQYXJhbXMsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUubmFtZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IHVua25vd24gaWRlbnRpZmllciBcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZS5tb2R1bGVVcmwpICYmIHZhbHVlLm1vZHVsZVVybCAhPSB0aGlzLl9tb2R1bGVVcmwpIHtcbiAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IHRoaXMuaW1wb3J0c1dpdGhQcmVmaXhlcy5nZXQodmFsdWUubW9kdWxlVXJsKTtcbiAgICAgICAgICAgICAgaWYgKGlzQmxhbmsocHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgcHJlZml4ID0gXCJpbXBvcnRcIiArIHRoaXMuaW1wb3J0c1dpdGhQcmVmaXhlcy5zaXplO1xuICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNldCh2YWx1ZS5tb2R1bGVVcmwsIHByZWZpeCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3R4LnByaW50KHByZWZpeCArIFwiLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlLnJlZmVyZW5jZSAmJiB2YWx1ZS5yZWZlcmVuY2UubWVtYmVycykge1xuICAgICAgICAgICAgICBjdHgucHJpbnQodmFsdWUucmVmZXJlbmNlLm5hbWUpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQoJy4nKTtcbiAgICAgICAgICAgICAgY3R4LnByaW50KHZhbHVlLnJlZmVyZW5jZS5tZW1iZXJzLmpvaW4oJy4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjdHgucHJpbnQodmFsdWUubmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1ByZXNlbnQodHlwZVBhcmFtcykgJiYgdHlwZVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIjxcIik7XG4gICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uICh0eXBlIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiB0eXBlLnZpc2l0VHlwZShfdGhpcywgY3R4KTsgfSwgdHlwZVBhcmFtcywgY3R4LCAnLCcpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCI+XCIpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX1RzRW1pdHRlclZpc2l0b3I7XG4gIH0oQWJzdHJhY3RFbWl0dGVyVmlzaXRvcikpO1xuXG4gIGZ1bmN0aW9uIGludGVycHJldFN0YXRlbWVudHMoc3RhdGVtZW50cywgcmVzdWx0VmFyKSB7XG4gICAgICB2YXIgc3RtdHNXaXRoUmV0dXJuID0gc3RhdGVtZW50cy5jb25jYXQoW25ldyBSZXR1cm5TdGF0ZW1lbnQodmFyaWFibGUocmVzdWx0VmFyKSldKTtcbiAgICAgIHZhciBjdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQobnVsbCwgbnVsbCwgbnVsbCwgbmV3IE1hcCgpKTtcbiAgICAgIHZhciB2aXNpdG9yID0gbmV3IFN0YXRlbWVudEludGVycHJldGVyKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gdmlzaXRvci52aXNpdEFsbFN0YXRlbWVudHMoc3RtdHNXaXRoUmV0dXJuLCBjdHgpO1xuICAgICAgcmV0dXJuIGlzUHJlc2VudChyZXN1bHQpID8gcmVzdWx0LnZhbHVlIDogbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyh2YXJOYW1lcywgdmFyVmFsdWVzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpIHtcbiAgICAgIHZhciBjaGlsZEN0eCA9IGN0eC5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZEN0eC52YXJzLnNldCh2YXJOYW1lc1tpXSwgdmFyVmFsdWVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB2aXNpdG9yLnZpc2l0QWxsU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjaGlsZEN0eCk7XG4gICAgICByZXR1cm4gaXNQcmVzZW50KHJlc3VsdCkgPyByZXN1bHQudmFsdWUgOiBudWxsO1xuICB9XG4gIHZhciBfRXhlY3V0aW9uQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBfRXhlY3V0aW9uQ29udGV4dChwYXJlbnQsIGluc3RhbmNlLCBjbGFzc05hbWUsIHZhcnMpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgdGhpcy52YXJzID0gdmFycztcbiAgICAgIH1cbiAgICAgIF9FeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBfRXhlY3V0aW9uQ29udGV4dCh0aGlzLCB0aGlzLmluc3RhbmNlLCB0aGlzLmNsYXNzTmFtZSwgbmV3IE1hcCgpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX0V4ZWN1dGlvbkNvbnRleHQ7XG4gIH0oKSk7XG4gIHZhciBSZXR1cm5WYWx1ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZXR1cm5WYWx1ZTtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gY3JlYXRlRHluYW1pY0NsYXNzKF9jbGFzc1N0bXQsIF9jdHgsIF92aXNpdG9yKSB7XG4gICAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9ycyA9IHt9O1xuICAgICAgX2NsYXNzU3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikge1xuICAgICAgICAgIC8vIE5vdGU6IHVzZSBgZnVuY3Rpb25gIGluc3RlYWQgb2YgYXJyb3cgZnVuY3Rpb24gdG8gY2FwdHVyZSBgdGhpc2BcbiAgICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3JzW2dldHRlci5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VDdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQoX2N0eCwgdGhpcywgX2NsYXNzU3RtdC5uYW1lLCBfY3R4LnZhcnMpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKFtdLCBbXSwgZ2V0dGVyLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBfY2xhc3NTdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgICAgdmFyIHBhcmFtTmFtZXMgPSBtZXRob2QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICAgIC8vIE5vdGU6IHVzZSBgZnVuY3Rpb25gIGluc3RlYWQgb2YgYXJyb3cgZnVuY3Rpb24gdG8gY2FwdHVyZSBgdGhpc2BcbiAgICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3JzW21ldGhvZC5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHMocGFyYW1OYW1lcywgYXJncywgbWV0aG9kLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICB2YXIgY3RvclBhcmFtTmFtZXMgPSBfY2xhc3NTdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgIC8vIE5vdGU6IHVzZSBgZnVuY3Rpb25gIGluc3RlYWQgb2YgYXJyb3cgZnVuY3Rpb24gdG8gY2FwdHVyZSBgdGhpc2BcbiAgICAgIHZhciBjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5zdGFuY2VDdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQoX2N0eCwgdGhpcywgX2NsYXNzU3RtdC5uYW1lLCBfY3R4LnZhcnMpO1xuICAgICAgICAgIF9jbGFzc1N0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IF90aGlzW2ZpZWxkLm5hbWVdID0gdW5kZWZpbmVkOyB9KTtcbiAgICAgICAgICBfZXhlY3V0ZUZ1bmN0aW9uU3RhdGVtZW50cyhjdG9yUGFyYW1OYW1lcywgYXJncywgX2NsYXNzU3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5LCBpbnN0YW5jZUN0eCwgX3Zpc2l0b3IpO1xuICAgICAgfTtcbiAgICAgIHZhciBzdXBlckNsYXNzID0gX2NsYXNzU3RtdC5wYXJlbnQudmlzaXRFeHByZXNzaW9uKF92aXNpdG9yLCBfY3R4KTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSwgcHJvcGVydHlEZXNjcmlwdG9ycyk7XG4gICAgICByZXR1cm4gY3RvcjtcbiAgfVxuICB2YXIgU3RhdGVtZW50SW50ZXJwcmV0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3RhdGVtZW50SW50ZXJwcmV0ZXIoKSB7XG4gICAgICB9XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUuZGVidWdBc3QgPSBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpOyB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnZhcnMuc2V0KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIGN1cnJDdHggPSBjdHg7XG4gICAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoY3VyckN0eC52YXJzLmhhcyhleHByLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyQ3R4LnZhcnMuc2V0KGV4cHIubmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGRlY2xhcmVkIHZhcmlhYmxlIFwiICsgZXhwci5uYW1lKTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciB2YXJOYW1lID0gYXN0Lm5hbWU7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChhc3QuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChhc3QuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlN1cGVyOlxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguaW5zdGFuY2UuX19wcm90b19fO1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlRoaXM6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaEVycm9yOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9FUlJPUl9WQVIkMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpblZhci5DYXRjaFN0YWNrOlxuICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9TVEFDS19WQVIkMTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIHZhcmlhYmxlIFwiICsgYXN0LmJ1aWx0aW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjdXJyQ3R4ID0gY3R4O1xuICAgICAgICAgIHdoaWxlIChjdXJyQ3R4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXModmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyQ3R4LnZhcnMuZ2V0KHZhck5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGRlY2xhcmVkIHZhcmlhYmxlIFwiICsgdmFyTmFtZSk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJlY2VpdmVyW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZVByb3BFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICAgIHZhciByZWNlaXZlciA9IGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICByZWNlaXZlcltleHByLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgdmFyIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB2YXIgYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCk7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KGV4cHIuYnVpbHRpbikpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChleHByLmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBMaXN0V3JhcHBlci5jb25jYXQocmVjZWl2ZXIsIGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuc3Vic2NyaWJlKHsgbmV4dDogYXJnc1swXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLmJpbmQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiBtZXRob2QgXCIgKyBleHByLmJ1aWx0aW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlcltleHByLm5hbWVdLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoc3RtdC5hcmdzLCBjdHgpO1xuICAgICAgICAgIHZhciBmbkV4cHIgPSBzdG10LmZuO1xuICAgICAgICAgIGlmIChmbkV4cHIgaW5zdGFuY2VvZiBSZWFkVmFyRXhwciAmJiBmbkV4cHIuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgICBjdHguaW5zdGFuY2UuY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmFwcGx5KGN0eC5pbnN0YW5jZSwgYXJncyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGZuID0gc3RtdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmV0dXJuVmFsdWUoc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB2YXIgY2xhenogPSBjcmVhdGVEeW5hbWljQ2xhc3Moc3RtdCwgY3R4LCB0aGlzKTtcbiAgICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBjbGF6eik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgcmV0dXJuIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJZlN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChzdG10LmZhbHNlQ2FzZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuYm9keVN0bXRzLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB2YXIgY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgICAgICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KENBVENIX0VSUk9SX1ZBUiQxLCBlKTtcbiAgICAgICAgICAgICAgY2hpbGRDdHgudmFycy5zZXQoQ0FUQ0hfU1RBQ0tfVkFSJDEsIGUuc3RhY2spO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjaGlsZEN0eCk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICB0aHJvdyBzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbW1lbnRTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY3R4KTtcbiAgICAgICAgICB2YXIgY2xhenogPSBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBuZXcgKGNsYXp6LmJpbmQuYXBwbHkoY2xhenosIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgcmV0dXJuIGFzdC52YWx1ZTsgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBhc3QudmFsdWUucmVmZXJlbmNlO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGlmIChhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChhc3QuZmFsc2VDYXNlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHJldHVybiAhYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHJldHVybiBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHBhcmFtTmFtZXMgPSBhc3QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICAgIHJldHVybiBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIGFzdC5zdGF0ZW1lbnRzLCBjdHgsIHRoaXMpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHBhcmFtTmFtZXMgPSBzdG10LnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgICBjdHgudmFycy5zZXQoc3RtdC5uYW1lLCBfZGVjbGFyZUZuKHBhcmFtTmFtZXMsIHN0bXQuc3RhdGVtZW50cywgY3R4LCB0aGlzKSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbGhzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYXN0Lmxocy52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH07XG4gICAgICAgICAgdmFyIHJocyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9O1xuICAgICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID09IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA9PT0gcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICE9IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAhPT0gcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICYmIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk9yOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIHx8IHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgKyByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAtIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkRpdmlkZTpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAvIHJocygpO1xuICAgICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICogcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICUgcmhzKCk7XG4gICAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPCByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA8PSByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPiByaHMoKTtcbiAgICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgPj0gcmhzKCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIFwiICsgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXJbYXN0Lm5hbWVdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgdmFyIHByb3AgPSBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgcmV0dXJuIHJlY2VpdmVyW3Byb3BdO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgpO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIHJlc3VsdFtlbnRyeVswXV0gPVxuICAgICAgICAgICAgICBlbnRyeVsxXS52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbnMsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgICAgfTtcbiAgICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBzdG10ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBTdGF0ZW1lbnRJbnRlcnByZXRlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gX2RlY2xhcmVGbih2YXJOYW1lcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCBhcmdzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpO1xuICAgICAgfTtcbiAgfVxuICB2YXIgQ0FUQ0hfRVJST1JfVkFSJDEgPSAnZXJyb3InO1xuICB2YXIgQ0FUQ0hfU1RBQ0tfVkFSJDEgPSAnc3RhY2snO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgdmFyIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTgoQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgICAgZnVuY3Rpb24gQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKCkge1xuICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgICB0aGlzLl92aXNpdENsYXNzQ29uc3RydWN0b3Ioc3RtdCwgY3R4KTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0bXQucGFyZW50KSkge1xuICAgICAgICAgICAgICBjdHgucHJpbnQoc3RtdC5uYW1lICsgXCIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcIik7XG4gICAgICAgICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgICBjdHgucHJpbnRsbihcIi5wcm90b3R5cGUpO1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoc3RtdCwgZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgICBzdG10Lm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc01ldGhvZChzdG10LCBtZXRob2QsIGN0eCk7IH0pO1xuICAgICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0bXQuY29uc3RydWN0b3JNZXRob2QpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQuY29uc3RydWN0b3JNZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgaWYgKGlzUHJlc2VudChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSkge1xuICAgICAgICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY29uc3RydWN0b3JNZXRob2QuYm9keSwgY3R4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9XCIpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NHZXR0ZXIgPSBmdW5jdGlvbiAoc3RtdCwgZ2V0dGVyLCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcIiArIHN0bXQubmFtZSArIFwiLnByb3RvdHlwZSwgJ1wiICsgZ2V0dGVyLm5hbWUgKyBcIicsIHsgZ2V0OiBmdW5jdGlvbigpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIGlmIChnZXR0ZXIuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoZ2V0dGVyLmJvZHksIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn19KTtcIik7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChzdG10LCBtZXRob2QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChzdG10Lm5hbWUgKyBcIi5wcm90b3R5cGUuXCIgKyBtZXRob2QubmFtZSArIFwiID0gZnVuY3Rpb24oXCIpO1xuICAgICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKG1ldGhvZC5wYXJhbXMsIGN0eCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCIpIHtcIik7XG4gICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgIGlmIChtZXRob2QuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludGxuKFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMobWV0aG9kLmJvZHksIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn07XCIpO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGlmIChhc3QuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5UaGlzKSB7XG4gICAgICAgICAgICAgIGN0eC5wcmludCgnc2VsZicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhc3QuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInc3VwZXInIG5lZWRzIHRvIGJlIGhhbmRsZWQgYXQgYSBwYXJlbnQgYXN0IG5vZGUsIG5vdCBhdCB0aGUgdmFyaWFibGUgbGV2ZWwhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgICAgY3R4LnByaW50KFwidmFyIFwiICsgc3RtdC5uYW1lICsgXCIgPSBcIik7XG4gICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIjtcIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgICAgdmFyIGZuRXhwciA9IGV4cHIuZm47XG4gICAgICAgICAgaWYgKGZuRXhwciBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIGZuRXhwci5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICAgIGN0eC5jdXJyZW50Q2xhc3MucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgICBjdHgucHJpbnQoXCIuY2FsbCh0aGlzXCIpO1xuICAgICAgICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGN0eC5wcmludChcIiwgXCIpO1xuICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN0eC5wcmludChcIilcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByLmNhbGwodGhpcywgZXhwciwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIGN0eC5wcmludChcImZ1bmN0aW9uKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhhc3QucGFyYW1zLCBjdHgpO1xuICAgICAgICAgIGN0eC5wcmludGxuKFwiKSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50KFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnQoXCJmdW5jdGlvbiBcIiArIHN0bXQubmFtZSArIFwiKFwiKTtcbiAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgICBjdHgucHJpbnRsbihcInRyeSB7XCIpO1xuICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgY3R4LnByaW50bG4oXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQyLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgdmFyIGNhdGNoU3RtdHMgPSBbQ0FUQ0hfU1RBQ0tfVkFSJDIuc2V0KENBVENIX0VSUk9SX1ZBUiQyLnByb3AoJ3N0YWNrJykpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgICAgU3RtdE1vZGlmaWVyLkZpbmFsXG4gICAgICAgICAgICAgIF0pXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhjYXRjaFN0bXRzLCBjdHgpO1xuICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICBjdHgucHJpbnRsbihcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAocGFyYW0gLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIGN0eC5wcmludChwYXJhbS5uYW1lKTsgfSwgcGFyYW1zLCBjdHgsICcsJyk7XG4gICAgICB9O1xuICAgICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRCdWlsdGluTWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ2NvbmNhdCc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ3N1YnNjcmliZSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkJpbmQ6XG4gICAgICAgICAgICAgICAgICBuYW1lID0gJ2JpbmQnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3I7XG4gIH0oQWJzdHJhY3RFbWl0dGVyVmlzaXRvcikpO1xuXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICpcbiAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgKi9cbiAgdmFyIF9fZXh0ZW5kcyQxNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgfTtcbiAgZnVuY3Rpb24gaml0U3RhdGVtZW50cyhzb3VyY2VVcmwsIHN0YXRlbWVudHMsIHJlc3VsdFZhcikge1xuICAgICAgdmFyIGNvbnZlcnRlciA9IG5ldyBKaXRFbWl0dGVyVmlzaXRvcigpO1xuICAgICAgdmFyIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KFtyZXN1bHRWYXJdKTtcbiAgICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY3R4KTtcbiAgICAgIHJldHVybiBldmFsRXhwcmVzc2lvbihzb3VyY2VVcmwsIHJlc3VsdFZhciwgY3R4LnRvU291cmNlKCksIGNvbnZlcnRlci5nZXRBcmdzKCkpO1xuICB9XG4gIHZhciBKaXRFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICBfX2V4dGVuZHMkMTcoSml0RW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBKaXRFbWl0dGVyVmlzaXRvcigpIHtcbiAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB0aGlzLl9ldmFsQXJnTmFtZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLl9ldmFsQXJnVmFsdWVzID0gW107XG4gICAgICB9XG4gICAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmFsQXJnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcmVzdWx0W3RoaXMuX2V2YWxBcmdOYW1lc1tpXV0gPSB0aGlzLl9ldmFsQXJnVmFsdWVzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIEppdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGFzdC52YWx1ZS5yZWZlcmVuY2U7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICBpZiAoaWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgIGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICAgIHRoaXMuX2V2YWxBcmdWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gaXNQcmVzZW50KGFzdC52YWx1ZS5uYW1lKSA/IHNhbml0aXplSWRlbnRpZmllcihhc3QudmFsdWUubmFtZSkgOiAndmFsJztcbiAgICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goc2FuaXRpemVJZGVudGlmaWVyKFwiaml0X1wiICsgbmFtZSArIGlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5wcmludCh0aGlzLl9ldmFsQXJnTmFtZXNbaWRdKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gSml0RW1pdHRlclZpc2l0b3I7XG4gIH0oQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKSk7XG5cbiAgLyoqXG4gICAqIEBsaWNlbnNlXG4gICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAqL1xuICAvKipcbiAgICogVGhpcyBmaWxlIGlzIGEgcG9ydCBvZiBzaGFkb3dDU1MgZnJvbSB3ZWJjb21wb25lbnRzLmpzIHRvIFR5cGVTY3JpcHQuXG4gICAqXG4gICAqIFBsZWFzZSBtYWtlIHN1cmUgdG8ga2VlcCB0byBlZGl0cyBpbiBzeW5jIHdpdGggdGhlIHNvdXJjZSBmaWxlLlxuICAgKlxuICAgKiBTb3VyY2U6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iLzRlZmVjZDdlMGUvc3JjL1NoYWRvd0NTUy9TaGFkb3dDU1MuanNcbiAgICpcbiAgICogVGhlIG9yaWdpbmFsIGZpbGUgbGV2ZWwgY29tbWVudCBpcyByZXByb2R1Y2VkIGJlbG93XG4gICAqL1xuICAvKlxuICAgIFRoaXMgaXMgYSBsaW1pdGVkIHNoaW0gZm9yIFNoYWRvd0RPTSBjc3Mgc3R5bGluZy5cbiAgICBodHRwczovL2R2Y3MudzMub3JnL2hnL3dlYmNvbXBvbmVudHMvcmF3LWZpbGUvdGlwL3NwZWMvc2hhZG93L2luZGV4Lmh0bWwjc3R5bGVzXG5cbiAgICBUaGUgaW50ZW50aW9uIGhlcmUgaXMgdG8gc3VwcG9ydCBvbmx5IHRoZSBzdHlsaW5nIGZlYXR1cmVzIHdoaWNoIGNhbiBiZVxuICAgIHJlbGF0aXZlbHkgc2ltcGx5IGltcGxlbWVudGVkLiBUaGUgZ29hbCBpcyB0byBhbGxvdyB1c2VycyB0byBhdm9pZCB0aGVcbiAgICBtb3N0IG9idmlvdXMgcGl0ZmFsbHMgYW5kIGRvIHNvIHdpdGhvdXQgY29tcHJvbWlzaW5nIHBlcmZvcm1hbmNlIHNpZ25pZmljYW50bHkuXG4gICAgRm9yIFNoYWRvd0RPTSBzdHlsaW5nIHRoYXQncyBub3QgY292ZXJlZCBoZXJlLCBhIHNldCBvZiBiZXN0IHByYWN0aWNlc1xuICAgIGNhbiBiZSBwcm92aWRlZCB0aGF0IHNob3VsZCBhbGxvdyB1c2VycyB0byBhY2NvbXBsaXNoIG1vcmUgY29tcGxleCBzdHlsaW5nLlxuXG4gICAgVGhlIGZvbGxvd2luZyBpcyBhIGxpc3Qgb2Ygc3BlY2lmaWMgU2hhZG93RE9NIHN0eWxpbmcgZmVhdHVyZXMgYW5kIGEgYnJpZWZcbiAgICBkaXNjdXNzaW9uIG9mIHRoZSBhcHByb2FjaCB1c2VkIHRvIHNoaW0uXG5cbiAgICBTaGltbWVkIGZlYXR1cmVzOlxuXG4gICAgKiA6aG9zdCwgOmhvc3QtY29udGV4dDogU2hhZG93RE9NIGFsbG93cyBzdHlsaW5nIG9mIHRoZSBzaGFkb3dSb290J3MgaG9zdFxuICAgIGVsZW1lbnQgdXNpbmcgdGhlIDpob3N0IHJ1bGUuIFRvIHNoaW0gdGhpcyBmZWF0dXJlLCB0aGUgOmhvc3Qgc3R5bGVzIGFyZVxuICAgIHJlZm9ybWF0dGVkIGFuZCBwcmVmaXhlZCB3aXRoIGEgZ2l2ZW4gc2NvcGUgbmFtZSBhbmQgcHJvbW90ZWQgdG8gYVxuICAgIGRvY3VtZW50IGxldmVsIHN0eWxlc2hlZXQuXG4gICAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiAuZm9vLCBhIHJ1bGUgbGlrZSB0aGlzOlxuXG4gICAgICA6aG9zdCB7XG4gICAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBiZWNvbWVzOlxuXG4gICAgICAuZm9vIHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgfVxuXG4gICAgKiBlbmNhcHN1bGF0aW9uOiBTdHlsZXMgZGVmaW5lZCB3aXRoaW4gU2hhZG93RE9NLCBhcHBseSBvbmx5IHRvXG4gICAgZG9tIGluc2lkZSB0aGUgU2hhZG93RE9NLiBQb2x5bWVyIHVzZXMgb25lIG9mIHR3byB0ZWNobmlxdWVzIHRvIGltcGxlbWVudFxuICAgIHRoaXMgZmVhdHVyZS5cblxuICAgIEJ5IGRlZmF1bHQsIHJ1bGVzIGFyZSBwcmVmaXhlZCB3aXRoIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWVcbiAgICBhcyBhIGRlc2NlbmRhbnQgc2VsZWN0b3IuIFRoaXMgZW5zdXJlcyBzdHlsaW5nIGRvZXMgbm90IGxlYWsgb3V0IG9mIHRoZSAndG9wJ1xuICAgIG9mIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NLiBGb3IgZXhhbXBsZSxcblxuICAgIGRpdiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgYmVjb21lczpcblxuICAgIHgtZm9vIGRpdiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgYmVjb21lczpcblxuXG4gICAgQWx0ZXJuYXRpdmVseSwgaWYgV2ViQ29tcG9uZW50cy5TaGFkb3dDU1Muc3RyaWN0U3R5bGluZyBpcyBzZXQgdG8gdHJ1ZSB0aGVuXG4gICAgc2VsZWN0b3JzIGFyZSBzY29wZWQgYnkgYWRkaW5nIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciBzdWZmaXggdG8gZWFjaFxuICAgIHNpbXBsZSBzZWxlY3RvciB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWUuIEVhY2ggZWxlbWVudFxuICAgIGluIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NIHRlbXBsYXRlIGlzIGFsc28gZ2l2ZW4gdGhlIHNjb3BlIGF0dHJpYnV0ZS5cbiAgICBUaHVzLCB0aGVzZSBydWxlcyBtYXRjaCBvbmx5IGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgc2NvcGUgYXR0cmlidXRlLlxuICAgIEZvciBleGFtcGxlLCBnaXZlbiBhIHNjb3BlIG5hbWUgb2YgeC1mb28sIGEgcnVsZSBsaWtlIHRoaXM6XG5cbiAgICAgIGRpdiB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgYmVjb21lczpcblxuICAgICAgZGl2W3gtZm9vXSB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgfVxuXG4gICAgTm90ZSB0aGF0IGVsZW1lbnRzIHRoYXQgYXJlIGR5bmFtaWNhbGx5IGFkZGVkIHRvIGEgc2NvcGUgbXVzdCBoYXZlIHRoZSBzY29wZVxuICAgIHNlbGVjdG9yIGFkZGVkIHRvIHRoZW0gbWFudWFsbHkuXG5cbiAgICAqIHVwcGVyL2xvd2VyIGJvdW5kIGVuY2Fwc3VsYXRpb246IFN0eWxlcyB3aGljaCBhcmUgZGVmaW5lZCBvdXRzaWRlIGFcbiAgICBzaGFkb3dSb290IHNob3VsZCBub3QgY3Jvc3MgdGhlIFNoYWRvd0RPTSBib3VuZGFyeSBhbmQgc2hvdWxkIG5vdCBhcHBseVxuICAgIGluc2lkZSBhIHNoYWRvd1Jvb3QuXG5cbiAgICBUaGlzIHN0eWxpbmcgYmVoYXZpb3IgaXMgbm90IGVtdWxhdGVkLiBTb21lIHBvc3NpYmxlIHdheXMgdG8gZG8gdGhpcyB0aGF0XG4gICAgd2VyZSByZWplY3RlZCBkdWUgdG8gY29tcGxleGl0eSBhbmQvb3IgcGVyZm9ybWFuY2UgY29uY2VybnMgaW5jbHVkZTogKDEpIHJlc2V0XG4gICAgZXZlcnkgcG9zc2libGUgcHJvcGVydHkgZm9yIGV2ZXJ5IHBvc3NpYmxlIHNlbGVjdG9yIGZvciBhIGdpdmVuIHNjb3BlIG5hbWU7XG4gICAgKDIpIHJlLWltcGxlbWVudCBjc3MgaW4gamF2YXNjcmlwdC5cblxuICAgIEFzIGFuIGFsdGVybmF0aXZlLCB1c2VycyBzaG91bGQgbWFrZSBzdXJlIHRvIHVzZSBzZWxlY3RvcnNcbiAgICBzcGVjaWZpYyB0byB0aGUgc2NvcGUgaW4gd2hpY2ggdGhleSBhcmUgd29ya2luZy5cblxuICAgICogOjpkaXN0cmlidXRlZDogVGhpcyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIEl0J3Mgb2Z0ZW4gbm90IG5lY2Vzc2FyeVxuICAgIHRvIHN0eWxlIHRoZSBjb250ZW50cyBvZiBhIHNwZWNpZmljIGluc2VydGlvbiBwb2ludCBhbmQgaW5zdGVhZCwgZGVzY2VuZGFudHNcbiAgICBvZiB0aGUgaG9zdCBlbGVtZW50IGNhbiBiZSBzdHlsZWQgc2VsZWN0aXZlbHkuIFVzZXJzIGNhbiBhbHNvIGNyZWF0ZSBhblxuICAgIGV4dHJhIG5vZGUgYXJvdW5kIGFuIGluc2VydGlvbiBwb2ludCBhbmQgc3R5bGUgdGhhdCBub2RlJ3MgY29udGVudHNcbiAgICB2aWEgZGVzY2VuZGVudCBzZWxlY3RvcnMuIEZvciBleGFtcGxlLCB3aXRoIGEgc2hhZG93Um9vdCBsaWtlIHRoaXM6XG5cbiAgICAgIDxzdHlsZT5cbiAgICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICAgIDxjb250ZW50PjwvY29udGVudD5cblxuICAgIGNvdWxkIGJlY29tZTpcblxuICAgICAgPHN0eWxlPlxuICAgICAgICAvICpAcG9seWZpbGwgLmNvbnRlbnQtY29udGFpbmVyIGRpdiAqIC9cbiAgICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LWNvbnRhaW5lclwiPlxuICAgICAgICA8Y29udGVudD48L2NvbnRlbnQ+XG4gICAgICA8L2Rpdj5cblxuICAgIE5vdGUgdGhlIHVzZSBvZiBAcG9seWZpbGwgaW4gdGhlIGNvbW1lbnQgYWJvdmUgYSBTaGFkb3dET00gc3BlY2lmaWMgc3R5bGVcbiAgICBkZWNsYXJhdGlvbi4gVGhpcyBpcyBhIGRpcmVjdGl2ZSB0byB0aGUgc3R5bGluZyBzaGltIHRvIHVzZSB0aGUgc2VsZWN0b3JcbiAgICBpbiBjb21tZW50cyBpbiBsaWV1IG9mIHRoZSBuZXh0IHNlbGVjdG9yIHdoZW4gcnVubmluZyB1bmRlciBwb2x5ZmlsbC5cbiAgKi9cbiAgdmFyIFNoYWRvd0NzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTaGFkb3dDc3MoKSB7XG4gICAgICAgICAgdGhpcy5zdHJpY3RTdHlsaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAqIFNoaW0gc29tZSBjc3NUZXh0IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yLiBSZXR1cm5zIGNzc1RleHQgdGhhdCBjYW5cbiAgICAgICogYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50IHZpYSBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5hZGRDc3NUb0RvY3VtZW50KGNzcykuXG4gICAgICAqXG4gICAgICAqIFdoZW4gc3RyaWN0U3R5bGluZyBpcyB0cnVlOlxuICAgICAgKiAtIHNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gYWxsIGVsZW1lbnRzIGluc2lkZSB0aGUgaG9zdCxcbiAgICAgICogLSBob3N0U2VsZWN0b3IgaXMgdGhlIGF0dHJpYnV0ZSBhZGRlZCB0byB0aGUgaG9zdCBpdHNlbGYuXG4gICAgICAqL1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5zaGltQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0LCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKGhvc3RTZWxlY3RvciA9PT0gdm9pZCAwKSB7IGhvc3RTZWxlY3RvciA9ICcnOyB9XG4gICAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmdVcmwgPSBleHRyYWN0U291cmNlTWFwcGluZ1VybChjc3NUZXh0KTtcbiAgICAgICAgICBjc3NUZXh0ID0gc3RyaXBDb21tZW50cyhjc3NUZXh0KTtcbiAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0RGlyZWN0aXZlcyhjc3NUZXh0KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpICsgc291cmNlTWFwcGluZ1VybDtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnREaXJlY3RpdmVzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgfTtcbiAgICAgIC8qXG4gICAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBjb252ZXJ0IG5hdGl2ZSBTaGFkb3dET00gcnVsZXMgdGhhdCB3aWxsIHRyaXBcbiAgICAgICAqIHVwIHRoZSBjc3MgcGFyc2VyOyB3ZSByZWx5IG9uIGRlY29yYXRpbmcgdGhlIHN0eWxlc2hlZXQgd2l0aCBpbmVydCBydWxlcy5cbiAgICAgICAqXG4gICAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XG4gICAgICAgKlxuICAgICAgICogcG9seWZpbGwtbmV4dC1zZWxlY3RvciB7IGNvbnRlbnQ6ICc6aG9zdCBtZW51LWl0ZW0nOyB9XG4gICAgICAgKiA6OmNvbnRlbnQgbWVudS1pdGVtIHtcbiAgICAgICAqXG4gICAgICAgKiB0byB0aGlzOlxuICAgICAgICpcbiAgICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0ge1xuICAgICAgICpcbiAgICAgICoqL1xuICAgICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShfY3NzQ29udGVudE5leHRTZWxlY3RvclJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBtWzJdICsgJ3snO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8qXG4gICAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBhZGQgcnVsZXMgd2hpY2ggd2lsbCBvbmx5IGFwcGx5IHVuZGVyIHRoZSBwb2x5ZmlsbFxuICAgICAgICpcbiAgICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgICAqXG4gICAgICAgKiBwb2x5ZmlsbC1ydWxlIHtcbiAgICAgICAqICAgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7XG4gICAgICAgKiAuLi5cbiAgICAgICAqIH1cbiAgICAgICAqXG4gICAgICAgKiB0byB0aGlzOlxuICAgICAgICpcbiAgICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0gey4uLn1cbiAgICAgICAqXG4gICAgICAqKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb250ZW50UnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBydWxlID0gbVswXS5yZXBsYWNlKG1bMV0sICcnKS5yZXBsYWNlKG1bMl0sICcnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG1bNF0gKyBydWxlO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIC8qIEVuc3VyZSBzdHlsZXMgYXJlIHNjb3BlZC4gUHNldWRvLXNjb3BpbmcgdGFrZXMgYSBydWxlIGxpa2U6XG4gICAgICAgKlxuICAgICAgICogIC5mb28gey4uLiB9XG4gICAgICAgKlxuICAgICAgICogIGFuZCBjb252ZXJ0cyB0aGlzIHRvXG4gICAgICAgKlxuICAgICAgICogIHNjb3BlTmFtZSAuZm9vIHsgLi4uIH1cbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zY29wZUNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIHVuc2NvcGVkUnVsZXMgPSB0aGlzLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICAgIC8vIHJlcGxhY2UgOmhvc3QgYW5kIDpob3N0LWNvbnRleHQgLXNoYWRvd2Nzc2hvc3QgYW5kIC1zaGFkb3djc3Nob3N0IHJlc3BlY3RpdmVseVxuICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCk7XG4gICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0KGNzc1RleHQpO1xuICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xuICAgICAgICAgIGlmIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9zY29wZVNlbGVjdG9ycyhjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dCArICdcXG4nICsgdW5zY29wZWRSdWxlcztcbiAgICAgICAgICByZXR1cm4gY3NzVGV4dC50cmltKCk7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXG4gICAgICAgKiBhbmQgZG8gbm90IHByb2Nlc3MgdmlhIENTU09NLiAoQ1NTT00gaXMgZGVzdHJ1Y3RpdmUgdG8gcnVsZXMgb24gcmFyZVxuICAgICAgICogb2NjYXNpb25zLCBlLmcuIC13ZWJraXQtY2FsYyBvbiBTYWZhcmkuKVxuICAgICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAgICpcbiAgICAgICAqIEBwb2x5ZmlsbC11bnNjb3BlZC1ydWxlIHtcbiAgICAgICAqICAgY29udGVudDogJ21lbnUtaXRlbSc7XG4gICAgICAgKiAuLi4gfVxuICAgICAgICpcbiAgICAgICAqIHRvIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogbWVudS1pdGVtIHsuLi59XG4gICAgICAgKlxuICAgICAgKiovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgICAgdmFyIHIgPSAnJztcbiAgICAgICAgICB2YXIgbTtcbiAgICAgICAgICBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtID0gX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZS5leGVjKGNzc1RleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcnVsZSA9IG1bMF0ucmVwbGFjZShtWzJdLCAnJykucmVwbGFjZShtWzFdLCBtWzRdKTtcbiAgICAgICAgICAgICAgciArPSBydWxlICsgJ1xcblxcbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgfTtcbiAgICAgIC8qXG4gICAgICAgKiBjb252ZXJ0IGEgcnVsZSBsaWtlIDpob3N0KC5mb28pID4gLmJhciB7IH1cbiAgICAgICAqXG4gICAgICAgKiB0b1xuICAgICAgICpcbiAgICAgICAqIC5mb288c2NvcGVOYW1lPiA+IC5iYXJcbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25Ib3N0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0UmUsIHRoaXMuX2NvbG9uSG9zdFBhcnRSZXBsYWNlcik7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIGNvbnZlcnQgYSBydWxlIGxpa2UgOmhvc3QtY29udGV4dCguZm9vKSA+IC5iYXIgeyB9XG4gICAgICAgKlxuICAgICAgICogdG9cbiAgICAgICAqXG4gICAgICAgKiAuZm9vPHNjb3BlTmFtZT4gPiAuYmFyLCAuZm9vIHNjb3BlTmFtZSA+IC5iYXIgeyB9XG4gICAgICAgKlxuICAgICAgICogYW5kXG4gICAgICAgKlxuICAgICAgICogOmhvc3QtY29udGV4dCguZm9vOmhvc3QpIC5iYXIgeyAuLi4gfVxuICAgICAgICpcbiAgICAgICAqIHRvXG4gICAgICAgKlxuICAgICAgICogLmZvbzxzY29wZU5hbWU+IC5iYXIgeyAuLi4gfVxuICAgICAgKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlLCB0aGlzLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyKTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0Q29sb25SdWxlID0gZnVuY3Rpb24gKGNzc1RleHQsIHJlZ0V4cCwgcGFydFJlcGxhY2VyKSB7XG4gICAgICAgICAgLy8gbVsxXSA9IDpob3N0KC1jb250ZXh0KSwgbVsyXSA9IGNvbnRlbnRzIG9mICgpLCBtWzNdIHJlc3Qgb2YgcnVsZVxuICAgICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UocmVnRXhwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBtWzJdLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcGFydHNbaV0udHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICghcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgci5wdXNoKHBhcnRSZXBsYWNlcihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yLCBwLCBtWzNdKSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gci5qb2luKCcsJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIG1bM107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICAgIGlmIChwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdCkgPiAtMSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKGhvc3QsIHBhcnQsIHN1ZmZpeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQgKyBzdWZmaXggKyAnLCAnICsgcGFydCArICcgJyArIGhvc3QgKyBzdWZmaXg7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gaG9zdCArIHBhcnQucmVwbGFjZShfcG9seWZpbGxIb3N0LCAnJykgKyBzdWZmaXg7XG4gICAgICB9O1xuICAgICAgLypcbiAgICAgICAqIENvbnZlcnQgY29tYmluYXRvcnMgbGlrZSA6OnNoYWRvdyBhbmQgcHNldWRvLWVsZW1lbnRzIGxpa2UgOjpjb250ZW50XG4gICAgICAgKiBieSByZXBsYWNpbmcgd2l0aCBzcGFjZS5cbiAgICAgICovXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgICByZXR1cm4gX3NoYWRvd0RPTVNlbGVjdG9yc1JlLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBwYXR0ZXJuKSB7IHJldHVybiByZXN1bHQucmVwbGFjZShwYXR0ZXJuLCAnICcpOyB9LCBjc3NUZXh0KTtcbiAgICAgIH07XG4gICAgICAvLyBjaGFuZ2UgYSBzZWxlY3RvciBsaWtlICdkaXYnIHRvICduYW1lIGRpdidcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3NSdWxlcyhjc3NUZXh0LCBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yO1xuICAgICAgICAgICAgICB2YXIgY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICAgICAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JbMF0gIT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3RvciA9XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njb3BlU2VsZWN0b3IocnVsZS5zZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBfdGhpcy5zdHJpY3RTdHlsaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BtZWRpYScpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHN1cHBvcnRzJykgfHxcbiAgICAgICAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHBhZ2UnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0Bkb2N1bWVudCcpKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50ID0gX3RoaXMuX3Njb3BlU2VsZWN0b3JzKHJ1bGUuY29udGVudCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX3Njb3BlU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvciwgc3RyaWN0KSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3Iuc3BsaXQoJywnKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnRyaW0oKS5zcGxpdChfc2hhZG93RGVlcFNlbGVjdG9ycyk7IH0pXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlZXBQYXJ0cykge1xuICAgICAgICAgICAgICB2YXIgc2hhbGxvd1BhcnQgPSBkZWVwUGFydHNbMF0sIG90aGVyUGFydHMgPSBkZWVwUGFydHMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgIHZhciBhcHBseVNjb3BlID0gZnVuY3Rpb24gKHNoYWxsb3dQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3NlbGVjdG9yTmVlZHNTY29waW5nKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGx5U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UGFydDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIFthcHBseVNjb3BlKHNoYWxsb3dQYXJ0KV0uY29uY2F0KG90aGVyUGFydHMpLmpvaW4oJyAnKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zZWxlY3Rvck5lZWRzU2NvcGluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICAgIHZhciByZSA9IHRoaXMuX21ha2VTY29wZU1hdGNoZXIoc2NvcGVTZWxlY3Rvcik7XG4gICAgICAgICAgcmV0dXJuICFyZS50ZXN0KHNlbGVjdG9yKTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9tYWtlU2NvcGVNYXRjaGVyID0gZnVuY3Rpb24gKHNjb3BlU2VsZWN0b3IpIHtcbiAgICAgICAgICB2YXIgbHJlID0gL1xcWy9nO1xuICAgICAgICAgIHZhciBycmUgPSAvXFxdL2c7XG4gICAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShscmUsICdcXFxcWycpLnJlcGxhY2UocnJlLCAnXFxcXF0nKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgc2NvcGVTZWxlY3RvciArICcpJyArIF9zZWxlY3RvclJlU3VmZml4LCAnbScpO1xuICAgICAgfTtcbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgLy8gRGlmZmVyZW5jZSBmcm9tIHdlYmNvbXBvbmVudHMuanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgIH07XG4gICAgICAvLyBzY29wZSB2aWEgbmFtZSBhbmQgW2lzPW5hbWVdXG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICAgIC8vIEluIEFuZHJvaWQgYnJvd3NlciwgdGhlIGxhc3RJbmRleCBpcyBub3QgcmVzZXQgd2hlbiB0aGUgcmVnZXggaXMgdXNlZCBpbiBTdHJpbmcucmVwbGFjZSgpXG4gICAgICAgICAgX3BvbHlmaWxsSG9zdFJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgaWYgKF9wb2x5ZmlsbEhvc3RSZS50ZXN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICB2YXIgcmVwbGFjZUJ5XzEgPSB0aGlzLnN0cmljdFN0eWxpbmcgPyBcIltcIiArIGhvc3RTZWxlY3RvciArIFwiXVwiIDogc2NvcGVTZWxlY3RvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCBmdW5jdGlvbiAoaG5jLCBzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IgKyByZXBsYWNlQnlfMTsgfSlcbiAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgcmVwbGFjZUJ5XzEgKyAnICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NvcGVTZWxlY3RvciArICcgJyArIHNlbGVjdG9yO1xuICAgICAgfTtcbiAgICAgIC8vIHJldHVybiBhIHNlbGVjdG9yIHdpdGggW25hbWVdIHN1ZmZpeCBvbiBlYWNoIHNpbXBsZSBzZWxlY3RvclxuICAgICAgLy8gZS5nLiAuZm9vLmJhciA+IC56b3QgYmVjb21lcyAuZm9vW25hbWVdLmJhcltuYW1lXSA+IC56b3RbbmFtZV0gIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgaXNSZSA9IC9cXFtpcz0oW15cXF1dKilcXF0vZztcbiAgICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGlzUmUsIGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgcGFydHNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBhdHRyTmFtZSA9ICdbJyArIHNjb3BlU2VsZWN0b3IgKyAnXSc7XG4gICAgICAgICAgdmFyIF9zY29wZVNlbGVjdG9yUGFydCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgIHZhciBzY29wZWRQID0gcC50cmltKCk7XG4gICAgICAgICAgICAgIGlmICghc2NvcGVkUCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwLmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgc2NvcGVkUCA9IF90aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSA6aG9zdCBzaW5jZSBpdCBzaG91bGQgYmUgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgIHZhciB0ID0gcC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgJycpO1xuICAgICAgICAgICAgICAgICAgaWYgKHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdC5tYXRjaCgvKFteOl0qKSg6KikoLiopLyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVkUCA9IG1hdGNoZXNbMV0gKyBhdHRyTmFtZSArIG1hdGNoZXNbMl0gKyBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2NvcGVkUDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBhdHRyU2VsZWN0b3JJbmRleCA9IDA7XG4gICAgICAgICAgdmFyIGF0dHJTZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgICAvLyByZXBsYWNlIGF0dHJpYnV0ZSBzZWxlY3RvcnMgd2l0aCBwbGFjZWhvbGRlcnMgdG8gYXZvaWQgaXNzdWUgd2l0aCB3aGl0ZSBzcGFjZSBiZWluZyB0cmVhdGVkXG4gICAgICAgICAgLy8gYXMgc2VwYXJhdG9yXG4gICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC9cXFtbXlxcXV0qXFxdL2csIGZ1bmN0aW9uIChhdHRyU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19hdHRyX3NlbF9cIiArIGF0dHJTZWxlY3RvckluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgICBhdHRyU2VsZWN0b3JzLnB1c2goYXR0clNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgYXR0clNlbGVjdG9ySW5kZXgrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VCeTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc2NvcGVkU2VsZWN0b3IgPSAnJztcbiAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgdmFyIHJlcztcbiAgICAgICAgICB2YXIgc2VwID0gLyggfD58XFwrfH4oPyE9KSlcXHMqL2c7XG4gICAgICAgICAgdmFyIHNjb3BlQWZ0ZXIgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpO1xuICAgICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gcmVzWzFdO1xuICAgICAgICAgICAgICB2YXIgcGFydCA9IHNlbGVjdG9yLnNsaWNlKHN0YXJ0SW5kZXgsIHJlcy5pbmRleCkudHJpbSgpO1xuICAgICAgICAgICAgICAvLyBpZiBhIHNlbGVjdG9yIGFwcGVhcnMgYmVmb3JlIDpob3N0LWNvbnRleHQgaXQgc2hvdWxkIG5vdCBiZSBzaGltbWVkIGFzIGl0XG4gICAgICAgICAgICAgIC8vIG1hdGNoZXMgb24gYW5jZXN0b3IgZWxlbWVudHMgYW5kIG5vdCBvbiBlbGVtZW50cyBpbiB0aGUgaG9zdCdzIHNoYWRvd1xuICAgICAgICAgICAgICB2YXIgc2NvcGVkUGFydCA9IHN0YXJ0SW5kZXggPj0gc2NvcGVBZnRlciA/IF9zY29wZVNlbGVjdG9yUGFydChwYXJ0KSA6IHBhcnQ7XG4gICAgICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNjb3BlZFBhcnQgKyBcIiBcIiArIHNlcGFyYXRvciArIFwiIFwiO1xuICAgICAgICAgICAgICBzdGFydEluZGV4ID0gc2VwLmxhc3RJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2NvcGVkU2VsZWN0b3IgKz0gX3Njb3BlU2VsZWN0b3JQYXJ0KHNlbGVjdG9yLnN1YnN0cmluZyhzdGFydEluZGV4KSk7XG4gICAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXJzIHdpdGggdGhlaXIgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgICAgcmV0dXJuIHNjb3BlZFNlbGVjdG9yLnJlcGxhY2UoL19fYXR0cl9zZWxfKFxcZCspX18vZywgZnVuY3Rpb24gKHBoLCBpbmRleCkgeyByZXR1cm4gYXR0clNlbGVjdG9yc1sraW5kZXhdOyB9KTtcbiAgICAgIH07XG4gICAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShfY29sb25Ib3N0Q29udGV4dFJlLCBfcG9seWZpbGxIb3N0Q29udGV4dClcbiAgICAgICAgICAgICAgLnJlcGxhY2UoX2NvbG9uSG9zdFJlLCBfcG9seWZpbGxIb3N0KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gU2hhZG93Q3NzO1xuICB9KCkpO1xuICB2YXIgX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSA9IC9wb2x5ZmlsbC1uZXh0LXNlbGVjdG9yW159XSpjb250ZW50OltcXHNdKj8oWydcIl0pKC4qPylcXDFbO1xcc10qfShbXntdKj8pey9naW07XG4gIHZhciBfY3NzQ29udGVudFJ1bGVSZSA9IC8ocG9seWZpbGwtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbiAgdmFyIF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUgPSAvKHBvbHlmaWxsLXVuc2NvcGVkLXJ1bGUpW159XSooY29udGVudDpbXFxzXSooWydcIl0pKC4qPylcXDMpWztcXHNdKltefV0qfS9naW07XG4gIHZhciBfcG9seWZpbGxIb3N0ID0gJy1zaGFkb3djc3Nob3N0JztcbiAgLy8gbm90ZTogOmhvc3QtY29udGV4dCBwcmUtcHJvY2Vzc2VkIHRvIC1zaGFkb3djc3Nob3N0Y29udGV4dC5cbiAgdmFyIF9wb2x5ZmlsbEhvc3RDb250ZXh0ID0gJy1zaGFkb3djc3Njb250ZXh0JztcbiAgdmFyIF9wYXJlblN1ZmZpeCA9ICcpKD86XFxcXCgoJyArXG4gICAgICAnKD86XFxcXChbXikoXSpcXFxcKXxbXikoXSopKz8nICtcbiAgICAgICcpXFxcXCkpPyhbXix7XSopJztcbiAgdmFyIF9jc3NDb2xvbkhvc3RSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xuICB2YXIgX2Nzc0NvbG9uSG9zdENvbnRleHRSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdENvbnRleHQgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbiAgdmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgPSBfcG9seWZpbGxIb3N0ICsgJy1uby1jb21iaW5hdG9yJztcbiAgdmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3JSZSA9IC8tc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yKFteXFxzXSopLztcbiAgdmFyIF9zaGFkb3dET01TZWxlY3RvcnNSZSA9IFtcbiAgICAgIC86OnNoYWRvdy9nLFxuICAgICAgLzo6Y29udGVudC9nLFxuICAgICAgLy8gRGVwcmVjYXRlZCBzZWxlY3RvcnNcbiAgICAgIC9cXC9zaGFkb3ctZGVlcFxcLy9nLFxuICAgICAgL1xcL3NoYWRvd1xcLy9nLFxuICBdO1xuICB2YXIgX3NoYWRvd0RlZXBTZWxlY3RvcnMgPSAvKD86Pj4+KXwoPzpcXC9kZWVwXFwvKS9nO1xuICB2YXIgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1xcWy4sezpdW1xcXFxzXFxcXFNdKik/JCc7XG4gIHZhciBfcG9seWZpbGxIb3N0UmUgPSAvLXNoYWRvd2Nzc2hvc3QvZ2ltO1xuICB2YXIgX2NvbG9uSG9zdFJlID0gLzpob3N0L2dpbTtcbiAgdmFyIF9jb2xvbkhvc3RDb250ZXh0UmUgPSAvOmhvc3QtY29udGV4dC9naW07XG4gIHZhciBfY29tbWVudFJlID0gL1xcL1xcKlxccypbXFxzXFxTXSo/XFwqXFwvL2c7XG4gIGZ1bmN0aW9uIHN0cmlwQ29tbWVudHMoaW5wdXQpIHtcbiAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKF9jb21tZW50UmUsICcnKTtcbiAgfVxuICAvLyBhbGwgY29tbWVudHMgZXhjZXB0IGlubGluZSBzb3VyY2UgbWFwcGluZ1xuICB2YXIgX3NvdXJjZU1hcHBpbmdVcmxSZSA9IC9cXC9cXCpcXHMqI1xccypzb3VyY2VNYXBwaW5nVVJMPVtcXHNcXFNdKz9cXCpcXC8vO1xuICBmdW5jdGlvbiBleHRyYWN0U291cmNlTWFwcGluZ1VybChpbnB1dCkge1xuICAgICAgdmFyIG1hdGNoZXIgPSBpbnB1dC5tYXRjaChfc291cmNlTWFwcGluZ1VybFJlKTtcbiAgICAgIHJldHVybiBtYXRjaGVyID8gbWF0Y2hlclswXSA6ICcnO1xuICB9XG4gIHZhciBfcnVsZVJlID0gLyhcXHMqKShbXjtcXHtcXH1dKz8pKFxccyopKCg/OnslQkxPQ0slfT9cXHMqOz8pfCg/Olxccyo7KSkvZztcbiAgdmFyIF9jdXJseVJlID0gLyhbe31dKS9nO1xuICB2YXIgT1BFTl9DVVJMWSA9ICd7JztcbiAgdmFyIENMT1NFX0NVUkxZID0gJ30nO1xuICB2YXIgQkxPQ0tfUExBQ0VIT0xERVIgPSAnJUJMT0NLJSc7XG4gIHZhciBDc3NSdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDc3NSdWxlO1xuICB9KCkpO1xuICBmdW5jdGlvbiBwcm9jZXNzUnVsZXMoaW5wdXQsIHJ1bGVDYWxsYmFjaykge1xuICAgICAgdmFyIGlucHV0V2l0aEVzY2FwZWRCbG9ja3MgPSBlc2NhcGVCbG9ja3MoaW5wdXQpO1xuICAgICAgdmFyIG5leHRCbG9ja0luZGV4ID0gMDtcbiAgICAgIHJldHVybiBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmVzY2FwZWRTdHJpbmcucmVwbGFjZShfcnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBtW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBtWzJdO1xuICAgICAgICAgIHZhciBjb250ZW50ID0gJyc7XG4gICAgICAgICAgdmFyIHN1ZmZpeCA9IG1bNF07XG4gICAgICAgICAgdmFyIGNvbnRlbnRQcmVmaXggPSAnJztcbiAgICAgICAgICBpZiAoc3VmZml4ICYmIHN1ZmZpeC5zdGFydHNXaXRoKCd7JyArIEJMT0NLX1BMQUNFSE9MREVSKSkge1xuICAgICAgICAgICAgICBjb250ZW50ID0gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5ibG9ja3NbbmV4dEJsb2NrSW5kZXgrK107XG4gICAgICAgICAgICAgIHN1ZmZpeCA9IHN1ZmZpeC5zdWJzdHJpbmcoQkxPQ0tfUExBQ0VIT0xERVIubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgIGNvbnRlbnRQcmVmaXggPSAneyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBydWxlID0gcnVsZUNhbGxiYWNrKG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSk7XG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyBtWzFdICsgcnVsZS5zZWxlY3RvciArIG1bM10gKyBjb250ZW50UHJlZml4ICsgcnVsZS5jb250ZW50ICsgc3VmZml4O1xuICAgICAgfSk7XG4gIH1cbiAgdmFyIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKGVzY2FwZWRTdHJpbmcsIGJsb2Nrcykge1xuICAgICAgICAgIHRoaXMuZXNjYXBlZFN0cmluZyA9IGVzY2FwZWRTdHJpbmc7XG4gICAgICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nV2l0aEVzY2FwZWRCbG9ja3M7XG4gIH0oKSk7XG4gIGZ1bmN0aW9uIGVzY2FwZUJsb2NrcyhpbnB1dCkge1xuICAgICAgdmFyIGlucHV0UGFydHMgPSBpbnB1dC5zcGxpdChfY3VybHlSZSk7XG4gICAgICB2YXIgcmVzdWx0UGFydHMgPSBbXTtcbiAgICAgIHZhciBlc2NhcGVkQmxvY2tzID0gW107XG4gICAgICB2YXIgYnJhY2tldENvdW50ID0gMDtcbiAgICAgIHZhciBjdXJyZW50QmxvY2tQYXJ0cyA9IFtdO1xuICAgICAgZm9yICh2YXIgcGFydEluZGV4ID0gMDsgcGFydEluZGV4IDwgaW5wdXRQYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBpbnB1dFBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgaWYgKHBhcnQgPT0gQ0xPU0VfQ1VSTFkpIHtcbiAgICAgICAgICAgICAgYnJhY2tldENvdW50LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChicmFja2V0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRCbG9ja1BhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFBhcnRzLnB1c2goQkxPQ0tfUExBQ0VIT0xERVIpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEJsb2NrUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydCA9PSBPUEVOX0NVUkxZKSB7XG4gICAgICAgICAgICAgIGJyYWNrZXRDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU3RyaW5nV2l0aEVzY2FwZWRCbG9ja3MocmVzdWx0UGFydHMuam9pbignJyksIGVzY2FwZWRCbG9ja3MpO1xuICB9XG5cbiAgdmFyIENPTVBPTkVOVF9WQVJJQUJMRSA9ICclQ09NUCUnO1xuICB2YXIgSE9TVF9BVFRSID0gXCJfbmdob3N0LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xuICB2YXIgQ09OVEVOVF9BVFRSID0gXCJfbmdjb250ZW50LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xuICB2YXIgU3R5bGVzQ29tcGlsZURlcGVuZGVuY3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3R5bGVzQ29tcGlsZURlcGVuZGVuY3kobW9kdWxlVXJsLCBpc1NoaW1tZWQsIHZhbHVlUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICB0aGlzLm1vZHVsZVVybCA9IG1vZHVsZVVybDtcbiAgICAgICAgICB0aGlzLmlzU2hpbW1lZCA9IGlzU2hpbW1lZDtcbiAgICAgICAgICB0aGlzLnZhbHVlUGxhY2Vob2xkZXIgPSB2YWx1ZVBsYWNlaG9sZGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5O1xuICB9KCkpO1xuICB2YXIgU3R5bGVzQ29tcGlsZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdHlsZXNDb21waWxlUmVzdWx0KGNvbXBvbmVudFN0eWxlc2hlZXQsIGV4dGVybmFsU3R5bGVzaGVldHMpIHtcbiAgICAgICAgICB0aGlzLmNvbXBvbmVudFN0eWxlc2hlZXQgPSBjb21wb25lbnRTdHlsZXNoZWV0O1xuICAgICAgICAgIHRoaXMuZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGV4dGVybmFsU3R5bGVzaGVldHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3R5bGVzQ29tcGlsZVJlc3VsdDtcbiAgfSgpKTtcbiAgdmFyIENvbXBpbGVkU3R5bGVzaGVldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlZFN0eWxlc2hlZXQoc3RhdGVtZW50cywgc3R5bGVzVmFyLCBkZXBlbmRlbmNpZXMsIGlzU2hpbW1lZCwgbWV0YSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgICAgdGhpcy5zdHlsZXNWYXIgPSBzdHlsZXNWYXI7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgICAgdGhpcy5pc1NoaW1tZWQgPSBpc1NoaW1tZWQ7XG4gICAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb21waWxlZFN0eWxlc2hlZXQ7XG4gIH0oKSk7XG4gIHZhciBTdHlsZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0eWxlQ29tcGlsZXIoX3VybFJlc29sdmVyKSB7XG4gICAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgICAgdGhpcy5fc2hhZG93Q3NzID0gbmV3IFNoYWRvd0NzcygpO1xuICAgICAgfVxuICAgICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IFtdO1xuICAgICAgICAgIHZhciBjb21wb25lbnRTdHlsZXNoZWV0ID0gdGhpcy5fY29tcGlsZVN0eWxlcyhjb21wLCBuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7XG4gICAgICAgICAgICAgIHN0eWxlczogY29tcC50ZW1wbGF0ZS5zdHlsZXMsXG4gICAgICAgICAgICAgIHN0eWxlVXJsczogY29tcC50ZW1wbGF0ZS5zdHlsZVVybHMsXG4gICAgICAgICAgICAgIG1vZHVsZVVybDogY29tcC50eXBlLm1vZHVsZVVybFxuICAgICAgICAgIH0pLCB0cnVlKTtcbiAgICAgICAgICBjb21wLnRlbXBsYXRlLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldE1ldGEpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBpbGVkU3R5bGVzaGVldCA9IF90aGlzLl9jb21waWxlU3R5bGVzKGNvbXAsIHN0eWxlc2hlZXRNZXRhLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHMucHVzaChjb21waWxlZFN0eWxlc2hlZXQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgU3R5bGVzQ29tcGlsZVJlc3VsdChjb21wb25lbnRTdHlsZXNoZWV0LCBleHRlcm5hbFN0eWxlc2hlZXRzKTtcbiAgICAgIH07XG4gICAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVN0eWxlcyA9IGZ1bmN0aW9uIChjb21wLCBzdHlsZXNoZWV0LCBpc0NvbXBvbmVudFN0eWxlc2hlZXQpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHZhciBzaGltID0gY29tcC50ZW1wbGF0ZS5lbmNhcHN1bGF0aW9uID09PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkO1xuICAgICAgICAgIHZhciBzdHlsZUV4cHJlc3Npb25zID0gc3R5bGVzaGVldC5zdHlsZXMubWFwKGZ1bmN0aW9uIChwbGFpblN0eWxlKSB7IHJldHVybiBsaXRlcmFsKF90aGlzLl9zaGltSWZOZWVkZWQocGxhaW5TdHlsZSwgc2hpbSkpOyB9KTtcbiAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0LnN0eWxlVXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IG5ldyBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhKHsgbmFtZTogZ2V0U3R5bGVzVmFyTmFtZShudWxsKSB9KTtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2gobmV3IFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5KHN0eWxlc2hlZXQuc3R5bGVVcmxzW2ldLCBzaGltLCBpZGVudGlmaWVyKSk7XG4gICAgICAgICAgICAgIHN0eWxlRXhwcmVzc2lvbnMucHVzaChuZXcgRXh0ZXJuYWxFeHByKGlkZW50aWZpZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc3R5bGVzIHZhcmlhYmxlIGNvbnRhaW5zIHBsYWluIHN0cmluZ3MgYW5kIGFycmF5cyBvZiBvdGhlciBzdHlsZXMgYXJyYXlzIChyZWN1cnNpdmUpLFxuICAgICAgICAgIC8vIHNvIHdlIHNldCBpdHMgdHlwZSB0byBkeW5hbWljLlxuICAgICAgICAgIHZhciBzdHlsZXNWYXIgPSBnZXRTdHlsZXNWYXJOYW1lKGlzQ29tcG9uZW50U3R5bGVzaGVldCA/IGNvbXAgOiBudWxsKTtcbiAgICAgICAgICB2YXIgc3RtdCA9IHZhcmlhYmxlKHN0eWxlc1ZhcilcbiAgICAgICAgICAgICAgLnNldChsaXRlcmFsQXJyKHN0eWxlRXhwcmVzc2lvbnMsIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgICAudG9EZWNsU3RtdChudWxsLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlZFN0eWxlc2hlZXQoW3N0bXRdLCBzdHlsZXNWYXIsIGRlcGVuZGVuY2llcywgc2hpbSwgc3R5bGVzaGVldCk7XG4gICAgICB9O1xuICAgICAgU3R5bGVDb21waWxlci5wcm90b3R5cGUuX3NoaW1JZk5lZWRlZCA9IGZ1bmN0aW9uIChzdHlsZSwgc2hpbSkge1xuICAgICAgICAgIHJldHVybiBzaGltID8gdGhpcy5fc2hhZG93Q3NzLnNoaW1Dc3NUZXh0KHN0eWxlLCBDT05URU5UX0FUVFIsIEhPU1RfQVRUUikgOiBzdHlsZTtcbiAgICAgIH07XG4gICAgICBTdHlsZUNvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIFN0eWxlQ29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBVcmxSZXNvbHZlciwgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gU3R5bGVDb21waWxlcjtcbiAgfSgpKTtcbiAgZnVuY3Rpb24gZ2V0U3R5bGVzVmFyTmFtZShjb21wb25lbnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBcInN0eWxlc1wiO1xuICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgIHJlc3VsdCArPSBcIl9cIiArIGNvbXBvbmVudC50eXBlLm5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGludGVybmFsIG1vZHVsZSBvZiB0aGUgQW5ndWxhciBjb21waWxlciB0aGF0IGJlZ2lucyB3aXRoIGNvbXBvbmVudCB0eXBlcyxcbiAgICogZXh0cmFjdHMgdGVtcGxhdGVzLCBhbmQgZXZlbnR1YWxseSBwcm9kdWNlcyBhIGNvbXBpbGVkIHZlcnNpb24gb2YgdGhlIGNvbXBvbmVudFxuICAgKiByZWFkeSBmb3IgbGlua2luZyBpbnRvIGFuIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBAc2VjdXJpdHkgIFdoZW4gY29tcGlsaW5nIHRlbXBsYXRlcyBhdCBydW50aW1lLCB5b3UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgZW50aXJlIHRlbXBsYXRlIGNvbWVzXG4gICAqIGZyb20gYSB0cnVzdGVkIHNvdXJjZS4gQXR0YWNrZXItY29udHJvbGxlZCBkYXRhIGludHJvZHVjZWQgYnkgYSB0ZW1wbGF0ZSBjb3VsZCBleHBvc2UgeW91clxuICAgKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuICBGb3IgbW9yZSBkZXRhaWwsIHNlZSB0aGUgW1NlY3VyaXR5IEd1aWRlXShodHRwOi8vZy5jby9uZy9zZWN1cml0eSkuXG4gICAqL1xuICB2YXIgUnVudGltZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFJ1bnRpbWVDb21waWxlcihfaW5qZWN0b3IsIF9tZXRhZGF0YVJlc29sdmVyLCBfdGVtcGxhdGVOb3JtYWxpemVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfbmdNb2R1bGVDb21waWxlciwgX2NvbXBpbGVyQ29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciA9IF9tZXRhZGF0YVJlc29sdmVyO1xuICAgICAgICAgIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplciA9IF90ZW1wbGF0ZU5vcm1hbGl6ZXI7XG4gICAgICAgICAgdGhpcy5fdGVtcGxhdGVQYXJzZXIgPSBfdGVtcGxhdGVQYXJzZXI7XG4gICAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlciA9IF9zdHlsZUNvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgICAgdGhpcy5fbmdNb2R1bGVDb21waWxlciA9IF9uZ01vZHVsZUNvbXBpbGVyO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVyQ29uZmlnID0gX2NvbXBpbGVyQ29uZmlnO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICB0aGlzLl9hbmltYXRpb25QYXJzZXIgPSBuZXcgQW5pbWF0aW9uUGFyc2VyKCk7XG4gICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ29tcGlsZXIgPSBuZXcgQW5pbWF0aW9uQ29tcGlsZXIoKTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZVN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQ29tcG9uZW50cyhtb2R1bGVUeXBlLCB0cnVlKS5zeW5jUmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMobW9kdWxlVHlwZSwgZmFsc2UpLmFzeW5jUmVzdWx0O1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNTeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHMobW9kdWxlVHlwZSwgdHJ1ZSkuc3luY1Jlc3VsdDtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBmYWxzZSkuYXN5bmNSZXN1bHQ7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgaXNTeW5jKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudFByb21pc2UgPSB0aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBpc1N5bmMpO1xuICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSB0aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KG5nTW9kdWxlRmFjdG9yeSwgY29tcG9uZW50UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5nTW9kdWxlRmFjdG9yeTsgfSkpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudFByb21pc2UgPSB0aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBpc1N5bmMpO1xuICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSB0aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHZhciBtb2R1bGVNZXRhID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUpO1xuICAgICAgICAgIHZhciBjb21wb25lbnRGYWN0b3JpZXMgPSBbXTtcbiAgICAgICAgICB2YXIgdGVtcGxhdGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIG1vZHVsZU1ldGEudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZU1ldGEpIHtcbiAgICAgICAgICAgICAgbW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyTWV0YSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGRpck1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBfdGhpcy5fY3JlYXRlQ29tcGlsZWRIb3N0VGVtcGxhdGUoZGlyTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZCh0ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yaWVzLnB1c2godGVtcGxhdGUucHJveHlDb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN5bmNSZXN1bHQgPSBuZXcgX2FuZ3VsYXJfY29yZS5Nb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzKG5nTW9kdWxlRmFjdG9yeSwgY29tcG9uZW50RmFjdG9yaWVzKTtcbiAgICAgICAgICAvLyBOb3RlOiBob3N0IGNvbXBvbmVudHMgdGhlbXNlbHZlcyBjYW4gYWx3YXlzIGJlIGNvbXBpbGVkIHN5bmNocm9ub3VzbHkgYXMgdGhleSBoYXZlIGFuXG4gICAgICAgICAgLy8gaW5saW5lIHRlbXBsYXRlLiBIb3dldmVyLCB3ZSBzdGlsbCBuZWVkIHRvIHdhaXQgZm9yIHRoZSBjb21wb25lbnRzIHRoYXQgdGhleVxuICAgICAgICAgIC8vIHJlZmVyZW5jZSB0byBiZSBsb2FkZWQgLyBjb21waWxlZC5cbiAgICAgICAgICB2YXIgY29tcGlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7IF90aGlzLl9jb21waWxlVGVtcGxhdGUodGVtcGxhdGUpOyB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYXN5bmNSZXN1bHQgPSBpc1N5bmMgPyBQcm9taXNlLnJlc29sdmUoY29tcGlsZSgpKSA6IGNvbXBvbmVudFByb21pc2UudGhlbihjb21waWxlKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChzeW5jUmVzdWx0LCBhc3luY1Jlc3VsdCk7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICB2YXIgbmdNb2R1bGVGYWN0b3J5ID0gdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmdldChtb2R1bGVUeXBlKTtcbiAgICAgICAgICBpZiAoIW5nTW9kdWxlRmFjdG9yeSkge1xuICAgICAgICAgICAgICB2YXIgbW9kdWxlTWV0YV8xID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAvLyBBbHdheXMgcHJvdmlkZSBhIGJvdW5kIENvbXBpbGVyXG4gICAgICAgICAgICAgIHZhciBleHRyYVByb3ZpZGVycyA9IFt0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFByb3ZpZGVyTWV0YWRhdGEobmV3IFByb3ZpZGVyTWV0YShfYW5ndWxhcl9jb3JlLkNvbXBpbGVyLCB7IHVzZUZhY3Rvcnk6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNb2R1bGVCb3VuZENvbXBpbGVyKF90aGlzLCBtb2R1bGVNZXRhXzEudHlwZS5yZWZlcmVuY2UpOyB9IH0pKV07XG4gICAgICAgICAgICAgIHZhciBjb21waWxlUmVzdWx0ID0gdGhpcy5fbmdNb2R1bGVDb21waWxlci5jb21waWxlKG1vZHVsZU1ldGFfMSwgZXh0cmFQcm92aWRlcnMpO1xuICAgICAgICAgICAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgICAgIGRlcC5wbGFjZWhvbGRlci5yZWZlcmVuY2UgPVxuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hc3NlcnRDb21wb25lbnRLbm93bihkZXAuY29tcC5yZWZlcmVuY2UsIHRydWUpLnByb3h5Q29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgIGRlcC5wbGFjZWhvbGRlci5uYW1lID0gXCJjb21wRmFjdG9yeV9cIiArIGRlcC5jb21wLm5hbWU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRTdGF0ZW1lbnRzKGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmdNb2R1bGVGYWN0b3J5ID0gaml0U3RhdGVtZW50cyhtb2R1bGVNZXRhXzEudHlwZS5uYW1lICsgXCIubmdmYWN0b3J5LmpzXCIsIGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5zZXQobW9kdWxlTWV0YV8xLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZUZhY3RvcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmdNb2R1bGVGYWN0b3J5O1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnRzID0gZnVuY3Rpb24gKG1haW5Nb2R1bGUsIGlzU3luYykge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdmFyIHRlbXBsYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB2YXIgbG9hZGluZ1Byb21pc2VzID0gW107XG4gICAgICAgICAgdmFyIG5nTW9kdWxlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1haW5Nb2R1bGUpO1xuICAgICAgICAgIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbE1vZHVsZU1ldGEpIHtcbiAgICAgICAgICAgICAgbG9jYWxNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJNZXRhKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5hZGQoX3RoaXMuX2NyZWF0ZUNvbXBpbGVkVGVtcGxhdGUoZGlyTWV0YSwgbG9jYWxNb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgZGlyTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5hZGQoX3RoaXMuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlKGVudHJ5Q29tcG9uZW50VHlwZS5yZWZlcmVuY2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGxvY2FsTW9kdWxlTWV0YS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnlDb21wb25lbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKF90aGlzLl9jcmVhdGVDb21waWxlZEhvc3RUZW1wbGF0ZShlbnRyeUNvbXBvbmVudFR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IGVudHJ5Q29tcG9uZW50cyBvZiBlbnRyeUNvbXBvbmVudHM/XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBpZiAodGVtcGxhdGUubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcih0ZW1wbGF0ZS5jb21wVHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1Byb21pc2VzLnB1c2godGVtcGxhdGUubG9hZGluZyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgY29tcGlsZSA9IGZ1bmN0aW9uICgpIHsgdGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKHRlbXBsYXRlKSB7IF90aGlzLl9jb21waWxlVGVtcGxhdGUodGVtcGxhdGUpOyB9KTsgfTtcbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICAgIGNvbXBpbGUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkaW5nUHJvbWlzZXMpLnRoZW4oY29tcGlsZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWROZ01vZHVsZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGVGb3IodHlwZSk7XG4gICAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICAgIGlmIChjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplci5jbGVhckNhY2hlRm9yKGNvbXBpbGVkVGVtcGxhdGUubm9ybWFsaXplZENvbXBNZXRhKTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICB0aGlzLl90ZW1wbGF0ZU5vcm1hbGl6ZXIuY2xlYXJDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlID0gZnVuY3Rpb24gKGNvbXBUeXBlKSB7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmdldChjb21wVHlwZSk7XG4gICAgICAgICAgaWYgKCFjb21waWxlZFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wTWV0YSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoY29tcFR5cGUpO1xuICAgICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgICB2YXIgaG9zdE1ldGEgPSBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShjb21wTWV0YSk7XG4gICAgICAgICAgICAgIGNvbXBpbGVkVGVtcGxhdGUgPSBuZXcgQ29tcGlsZWRUZW1wbGF0ZSh0cnVlLCBjb21wTWV0YS5zZWxlY3RvciwgY29tcE1ldGEudHlwZSwgW2NvbXBNZXRhXSwgW10sIFtdLCB0aGlzLl90ZW1wbGF0ZU5vcm1hbGl6ZXIubm9ybWFsaXplRGlyZWN0aXZlKGhvc3RNZXRhKSk7XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuc2V0KGNvbXBUeXBlLCBjb21waWxlZFRlbXBsYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlQ29tcGlsZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb21wTWV0YSwgbmdNb2R1bGUpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgICBjb21waWxlZFRlbXBsYXRlID0gbmV3IENvbXBpbGVkVGVtcGxhdGUoZmFsc2UsIGNvbXBNZXRhLnNlbGVjdG9yLCBjb21wTWV0YS50eXBlLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMsIG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUucGlwZXMsIG5nTW9kdWxlLnNjaGVtYXMsIHRoaXMuX3RlbXBsYXRlTm9ybWFsaXplci5ub3JtYWxpemVEaXJlY3RpdmUoY29tcE1ldGEpKTtcbiAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLnNldChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSwgY29tcGlsZWRUZW1wbGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21waWxlZFRlbXBsYXRlO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX2Fzc2VydENvbXBvbmVudEtub3duID0gZnVuY3Rpb24gKGNvbXBUeXBlLCBpc0hvc3QpIHtcbiAgICAgICAgICB2YXIgY29tcGlsZWRUZW1wbGF0ZSA9IGlzSG9zdCA/IHRoaXMuX2NvbXBpbGVkSG9zdFRlbXBsYXRlQ2FjaGUuZ2V0KGNvbXBUeXBlKSA6XG4gICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQoY29tcFR5cGUpO1xuICAgICAgICAgIGlmICghY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICBpZiAoaXNIb3N0KSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb21waWxlZCB2aWV3IGZvciBjb21wb25lbnQgXCIgKyBzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgZG9lcyBub3QgZXhpc3QhXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IFwiICsgc3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIGlzIG5vdCBwYXJ0IG9mIGFueSBOZ01vZHVsZSBvciB0aGUgbW9kdWxlIGhhcyBub3QgYmVlbiBpbXBvcnRlZCBpbnRvIHlvdXIgbW9kdWxlLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tcGlsZWRUZW1wbGF0ZTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9hc3NlcnRDb21wb25lbnRMb2FkZWQgPSBmdW5jdGlvbiAoY29tcFR5cGUsIGlzSG9zdCkge1xuICAgICAgICAgIHZhciBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fYXNzZXJ0Q29tcG9uZW50S25vd24oY29tcFR5cGUsIGlzSG9zdCk7XG4gICAgICAgICAgaWYgKGNvbXBpbGVkVGVtcGxhdGUubG9hZGluZykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb21waWxlZFRlbXBsYXRlIGZvciBcIiArIHN0cmluZ2lmeShjb21wVHlwZSkgKyBcIiAoaXNIb3N0OiBcIiArIGlzSG9zdCArIFwiKSBpcyBzdGlsbCBsb2FkaW5nIVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbXBpbGVkVGVtcGxhdGU7XG4gICAgICB9O1xuICAgICAgUnVudGltZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBpZiAodGVtcGxhdGUuaXNDb21waWxlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjb21wTWV0YSA9IHRlbXBsYXRlLm5vcm1hbGl6ZWRDb21wTWV0YTtcbiAgICAgICAgICB2YXIgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHZhciBzdHlsZXNDb21waWxlUmVzdWx0ID0gdGhpcy5fc3R5bGVDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICBzdHlsZXNDb21waWxlUmVzdWx0LmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAocikgeyBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwuc2V0KHIubWV0YS5tb2R1bGVVcmwsIHIpOyB9KTtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdChzdHlsZXNDb21waWxlUmVzdWx0LmNvbXBvbmVudFN0eWxlc2hlZXQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgICAgdmFyIHZpZXdDb21wTWV0YXMgPSB0ZW1wbGF0ZS52aWV3Q29tcG9uZW50VHlwZXMubWFwKGZ1bmN0aW9uIChjb21wVHlwZSkgeyByZXR1cm4gX3RoaXMuX2Fzc2VydENvbXBvbmVudExvYWRlZChjb21wVHlwZSwgZmFsc2UpLm5vcm1hbGl6ZWRDb21wTWV0YTsgfSk7XG4gICAgICAgICAgdmFyIHBhcnNlZEFuaW1hdGlvbnMgPSB0aGlzLl9hbmltYXRpb25QYXJzZXIucGFyc2VDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgIHZhciBwYXJzZWRUZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlUGFyc2VyLnBhcnNlKGNvbXBNZXRhLCBjb21wTWV0YS50ZW1wbGF0ZS50ZW1wbGF0ZSwgdGVtcGxhdGUudmlld0RpcmVjdGl2ZXMuY29uY2F0KHZpZXdDb21wTWV0YXMpLCB0ZW1wbGF0ZS52aWV3UGlwZXMsIHRlbXBsYXRlLnNjaGVtYXMsIGNvbXBNZXRhLnR5cGUubmFtZSk7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkQW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvbkNvbXBpbGVyLmNvbXBpbGUoY29tcE1ldGEudHlwZS5uYW1lLCBwYXJzZWRBbmltYXRpb25zKTtcbiAgICAgICAgICB2YXIgY29tcGlsZVJlc3VsdCA9IHRoaXMuX3ZpZXdDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhLCBwYXJzZWRUZW1wbGF0ZSwgdmFyaWFibGUoc3R5bGVzQ29tcGlsZVJlc3VsdC5jb21wb25lbnRTdHlsZXNoZWV0LnN0eWxlc1ZhciksIHRlbXBsYXRlLnZpZXdQaXBlcywgY29tcGlsZWRBbmltYXRpb25zKTtcbiAgICAgICAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgdmFyIGRlcFRlbXBsYXRlO1xuICAgICAgICAgICAgICBpZiAoZGVwIGluc3RhbmNlb2YgVmlld0ZhY3RvcnlEZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmZkID0gZGVwO1xuICAgICAgICAgICAgICAgICAgZGVwVGVtcGxhdGUgPSBfdGhpcy5fYXNzZXJ0Q29tcG9uZW50TG9hZGVkKHZmZC5jb21wLnJlZmVyZW5jZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgdmZkLnBsYWNlaG9sZGVyLnJlZmVyZW5jZSA9IGRlcFRlbXBsYXRlLnByb3h5Vmlld0ZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgICB2ZmQucGxhY2Vob2xkZXIubmFtZSA9IFwidmlld0ZhY3RvcnlfXCIgKyB2ZmQuY29tcC5uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRlcCBpbnN0YW5jZW9mIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2ZkID0gZGVwO1xuICAgICAgICAgICAgICAgICAgZGVwVGVtcGxhdGUgPSBfdGhpcy5fYXNzZXJ0Q29tcG9uZW50TG9hZGVkKGNmZC5jb21wLnJlZmVyZW5jZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICBjZmQucGxhY2Vob2xkZXIucmVmZXJlbmNlID0gZGVwVGVtcGxhdGUucHJveHlDb21wb25lbnRGYWN0b3J5O1xuICAgICAgICAgICAgICAgICAgY2ZkLnBsYWNlaG9sZGVyLm5hbWUgPSBcImNvbXBGYWN0b3J5X1wiICsgY2ZkLmNvbXAubmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzdGF0ZW1lbnRzID0gc3R5bGVzQ29tcGlsZVJlc3VsdC5jb21wb25lbnRTdHlsZXNoZWV0LnN0YXRlbWVudHMuY29uY2F0KGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cyk7XG4gICAgICAgICAgY29tcGlsZWRBbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IGVudHJ5LnN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGVtZW50KSB7IHN0YXRlbWVudHMucHVzaChzdGF0ZW1lbnQpOyB9KTsgfSk7XG4gICAgICAgICAgdmFyIGZhY3Rvcnk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgICAgZmFjdG9yeSA9IGludGVycHJldFN0YXRlbWVudHMoc3RhdGVtZW50cywgY29tcGlsZVJlc3VsdC52aWV3RmFjdG9yeVZhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmYWN0b3J5ID0gaml0U3RhdGVtZW50cyhcIlwiICsgdGVtcGxhdGUuY29tcFR5cGUubmFtZSArICh0ZW1wbGF0ZS5pc0hvc3QgPyAnX0hvc3QnIDogJycpICsgXCIubmdmYWN0b3J5LmpzXCIsIHN0YXRlbWVudHMsIGNvbXBpbGVSZXN1bHQudmlld0ZhY3RvcnlWYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ZW1wbGF0ZS5jb21waWxlZChmYWN0b3J5KTtcbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIucHJvdG90eXBlLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXAsIGkpIHtcbiAgICAgICAgICAgICAgdmFyIG5lc3RlZENvbXBpbGVSZXN1bHQgPSBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwuZ2V0KGRlcC5tb2R1bGVVcmwpO1xuICAgICAgICAgICAgICB2YXIgbmVzdGVkU3R5bGVzQXJyID0gX3RoaXMuX3Jlc29sdmVBbmRFdmFsU3R5bGVzQ29tcGlsZVJlc3VsdChuZXN0ZWRDb21waWxlUmVzdWx0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpO1xuICAgICAgICAgICAgICBkZXAudmFsdWVQbGFjZWhvbGRlci5yZWZlcmVuY2UgPSBuZXN0ZWRTdHlsZXNBcnI7XG4gICAgICAgICAgICAgIGRlcC52YWx1ZVBsYWNlaG9sZGVyLm5hbWUgPSBcImltcG9ydGVkU3R5bGVzXCIgKyBpO1xuICAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlci5wcm90b3R5cGUuX3Jlc29sdmVBbmRFdmFsU3R5bGVzQ29tcGlsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCkge1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0KHJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwcmV0U3RhdGVtZW50cyhyZXN1bHQuc3RhdGVtZW50cywgcmVzdWx0LnN0eWxlc1Zhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaml0U3RhdGVtZW50cyhyZXN1bHQubWV0YS5tb2R1bGVVcmwgKyBcIi5jc3MuanNcIiwgcmVzdWx0LnN0YXRlbWVudHMsIHJlc3VsdC5zdHlsZXNWYXIpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG4gICAgICBSdW50aW1lQ29tcGlsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgUnVudGltZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RvciwgfSxcbiAgICAgICAgICB7IHR5cGU6IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLCB9LFxuICAgICAgICAgIHsgdHlwZTogRGlyZWN0aXZlTm9ybWFsaXplciwgfSxcbiAgICAgICAgICB7IHR5cGU6IFRlbXBsYXRlUGFyc2VyLCB9LFxuICAgICAgICAgIHsgdHlwZTogU3R5bGVDb21waWxlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IFZpZXdDb21waWxlciwgfSxcbiAgICAgICAgICB7IHR5cGU6IE5nTW9kdWxlQ29tcGlsZXIsIH0sXG4gICAgICAgICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICAgIF07XG4gICAgICByZXR1cm4gUnVudGltZUNvbXBpbGVyO1xuICB9KCkpO1xuICB2YXIgQ29tcGlsZWRUZW1wbGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBDb21waWxlZFRlbXBsYXRlKGlzSG9zdCwgc2VsZWN0b3IsIGNvbXBUeXBlLCB2aWV3RGlyZWN0aXZlc0FuZENvbXBvbmVudHMsIHZpZXdQaXBlcywgc2NoZW1hcywgX25vcm1hbGl6ZVJlc3VsdCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgdGhpcy5pc0hvc3QgPSBpc0hvc3Q7XG4gICAgICAgICAgdGhpcy5jb21wVHlwZSA9IGNvbXBUeXBlO1xuICAgICAgICAgIHRoaXMudmlld1BpcGVzID0gdmlld1BpcGVzO1xuICAgICAgICAgIHRoaXMuc2NoZW1hcyA9IHNjaGVtYXM7XG4gICAgICAgICAgdGhpcy5fdmlld0ZhY3RvcnkgPSBudWxsO1xuICAgICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fbm9ybWFsaXplZENvbXBNZXRhID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlzQ29tcGlsZWRXaXRoRGVwcyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudmlld0NvbXBvbmVudFR5cGVzID0gW107XG4gICAgICAgICAgdGhpcy52aWV3RGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICAgIHZpZXdEaXJlY3RpdmVzQW5kQ29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJNZXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy52aWV3Q29tcG9uZW50VHlwZXMucHVzaChkaXJNZXRhLnR5cGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdEaXJlY3RpdmVzLnB1c2goZGlyTWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLnByb3h5Vmlld0ZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghX3RoaXMuX3ZpZXdGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBDb21waWxlZFRlbXBsYXRlIGZvciBcIiArIHN0cmluZ2lmeShfdGhpcy5jb21wVHlwZSkgKyBcIiBpcyBub3QgY29tcGlsZWQgeWV0IVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3ZpZXdGYWN0b3J5LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5wcm94eUNvbXBvbmVudEZhY3RvcnkgPSBpc0hvc3QgP1xuICAgICAgICAgICAgICBuZXcgX2FuZ3VsYXJfY29yZS5Db21wb25lbnRGYWN0b3J5KHNlbGVjdG9yLCB0aGlzLnByb3h5Vmlld0ZhY3RvcnksIGNvbXBUeXBlLnJlZmVyZW5jZSkgOlxuICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgIGlmIChfbm9ybWFsaXplUmVzdWx0LnN5bmNSZXN1bHQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplZENvbXBNZXRhID0gX25vcm1hbGl6ZVJlc3VsdC5zeW5jUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gX25vcm1hbGl6ZVJlc3VsdC5hc3luY1Jlc3VsdC50aGVuKGZ1bmN0aW9uIChub3JtYWxpemVkQ29tcE1ldGEpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLl9ub3JtYWxpemVkQ29tcE1ldGEgPSBub3JtYWxpemVkQ29tcE1ldGE7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5sb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBpbGVkVGVtcGxhdGUucHJvdG90eXBlLCBcIm5vcm1hbGl6ZWRDb21wTWV0YVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIGlzIHN0aWxsIGxvYWRpbmcgZm9yIFwiICsgdGhpcy5jb21wVHlwZS5uYW1lICsgXCIhXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkQ29tcE1ldGE7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBDb21waWxlZFRlbXBsYXRlLnByb3RvdHlwZS5jb21waWxlZCA9IGZ1bmN0aW9uICh2aWV3RmFjdG9yeSkge1xuICAgICAgICAgIHRoaXMuX3ZpZXdGYWN0b3J5ID0gdmlld0ZhY3Rvcnk7XG4gICAgICAgICAgdGhpcy5pc0NvbXBpbGVkID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBDb21waWxlZFRlbXBsYXRlLnByb3RvdHlwZS5kZXBzQ29tcGlsZWQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaXNDb21waWxlZFdpdGhEZXBzID0gdHJ1ZTsgfTtcbiAgICAgIHJldHVybiBDb21waWxlZFRlbXBsYXRlO1xuICB9KCkpO1xuICBmdW5jdGlvbiBhc3NlcnRDb21wb25lbnQobWV0YSkge1xuICAgICAgaWYgKCFtZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBpbGUgJ1wiICsgbWV0YS50eXBlLm5hbWUgKyBcIicgYmVjYXVzZSBpdCBpcyBub3QgYSBjb21wb25lbnQuXCIpO1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGBDb21waWxlcmAgYnkgZGVsZWdhdGluZyB0byB0aGUgUnVudGltZUNvbXBpbGVyIHVzaW5nIGEga25vd24gbW9kdWxlLlxuICAgKi9cbiAgdmFyIE1vZHVsZUJvdW5kQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gTW9kdWxlQm91bmRDb21waWxlcihfZGVsZWdhdGUsIF9uZ01vZHVsZSkge1xuICAgICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xuICAgICAgICAgIHRoaXMuX25nTW9kdWxlID0gX25nTW9kdWxlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLCBcIl9pbmplY3RvclwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pbmplY3RvcjsgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVTeW5jKG1vZHVsZVR5cGUpO1xuICAgICAgfTtcbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVBc3luYyhtb2R1bGVUeXBlKTtcbiAgICAgIH07XG4gICAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c1N5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c1N5bmMobW9kdWxlVHlwZSk7XG4gICAgICB9O1xuICAgICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMobW9kdWxlVHlwZSk7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBDbGVhcnMgYWxsIGNhY2hlc1xuICAgICAgICovXG4gICAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kZWxlZ2F0ZS5jbGVhckNhY2hlKCk7IH07XG4gICAgICAvKipcbiAgICAgICAqIENsZWFycyB0aGUgY2FjaGUgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQvbmdNb2R1bGUuXG4gICAgICAgKi9cbiAgICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAodHlwZSkgeyB0aGlzLl9kZWxlZ2F0ZS5jbGVhckNhY2hlRm9yKHR5cGUpOyB9O1xuICAgICAgcmV0dXJuIE1vZHVsZUJvdW5kQ29tcGlsZXI7XG4gIH0oKSk7XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09IFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgPT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vXG4gIC8vICAgICAgICBETyBOT1QgRURJVCBUSElTIExJU1QgT0YgU0VDVVJJVFkgU0VOU0lUSVZFIFBST1BFUlRJRVMgV0lUSE9VVCBBIFNFQ1VSSVRZIFJFVklFVyFcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY2ggb3V0IHRvIG1wcm9ic3QgZm9yIGRldGFpbHMuXG4gIC8vXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLyoqIE1hcCBmcm9tIHRhZ05hbWV8cHJvcGVydHlOYW1lIFNlY3VyaXR5Q29udGV4dC4gUHJvcGVydGllcyBhcHBseWluZyB0byBhbGwgdGFncyB1c2UgJyonLiAqL1xuICB2YXIgU0VDVVJJVFlfU0NIRU1BID0ge307XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyQ29udGV4dChjdHgsIHNwZWNzKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIHNwZWNzXzEgPSBzcGVjczsgX2kgPCBzcGVjc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBzcGVjID0gc3BlY3NfMVtfaV07XG4gICAgICAgICAgU0VDVVJJVFlfU0NIRU1BW3NwZWMudG9Mb3dlckNhc2UoKV0gPSBjdHg7XG4gICAgICB9XG4gIH1cbiAgLy8gQ2FzZSBpcyBpbnNpZ25pZmljYW50IGJlbG93LCBhbGwgZWxlbWVudCBhbmQgYXR0cmlidXRlIG5hbWVzIGFyZSBsb3dlci1jYXNlZCBmb3IgbG9va3VwLlxuICByZWdpc3RlckNvbnRleHQoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuSFRNTCwgW1xuICAgICAgJ2lmcmFtZXxzcmNkb2MnLFxuICAgICAgJyp8aW5uZXJIVE1MJyxcbiAgICAgICcqfG91dGVySFRNTCcsXG4gIF0pO1xuICByZWdpc3RlckNvbnRleHQoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuU1RZTEUsIFsnKnxzdHlsZSddKTtcbiAgLy8gTkI6IG5vIFNDUklQVCBjb250ZXh0cyBoZXJlLCB0aGV5IGFyZSBuZXZlciBhbGxvd2VkIGR1ZSB0byB0aGUgcGFyc2VyIHN0cmlwcGluZyB0aGVtLlxuICByZWdpc3RlckNvbnRleHQoX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuVVJMLCBbXG4gICAgICAnKnxmb3JtQWN0aW9uJywgJ2FyZWF8aHJlZicsICdhcmVhfHBpbmcnLCAnYXVkaW98c3JjJywgJ2F8aHJlZicsXG4gICAgICAnYXxwaW5nJywgJ2Jsb2NrcXVvdGV8Y2l0ZScsICdib2R5fGJhY2tncm91bmQnLCAnZGVsfGNpdGUnLCAnZm9ybXxhY3Rpb24nLFxuICAgICAgJ2ltZ3xzcmMnLCAnaW1nfHNyY3NldCcsICdpbnB1dHxzcmMnLCAnaW5zfGNpdGUnLCAncXxjaXRlJyxcbiAgICAgICdzb3VyY2V8c3JjJywgJ3NvdXJjZXxzcmNzZXQnLCAndHJhY2t8c3JjJywgJ3ZpZGVvfHBvc3RlcicsICd2aWRlb3xzcmMnLFxuICBdKTtcbiAgcmVnaXN0ZXJDb250ZXh0KF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCwgW1xuICAgICAgJ2FwcGxldHxjb2RlJyxcbiAgICAgICdhcHBsZXR8Y29kZWJhc2UnLFxuICAgICAgJ2Jhc2V8aHJlZicsXG4gICAgICAnZW1iZWR8c3JjJyxcbiAgICAgICdmcmFtZXxzcmMnLFxuICAgICAgJ2hlYWR8cHJvZmlsZScsXG4gICAgICAnaHRtbHxtYW5pZmVzdCcsXG4gICAgICAnaWZyYW1lfHNyYycsXG4gICAgICAnbGlua3xocmVmJyxcbiAgICAgICdtZWRpYXxzcmMnLFxuICAgICAgJ29iamVjdHxjb2RlYmFzZScsXG4gICAgICAnb2JqZWN0fGRhdGEnLFxuICAgICAgJ3NjcmlwdHxzcmMnLFxuICBdKTtcblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIHZhciBfX2V4dGVuZHMkMTkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG4gIHZhciBCT09MRUFOID0gJ2Jvb2xlYW4nO1xuICB2YXIgTlVNQkVSID0gJ251bWJlcic7XG4gIHZhciBTVFJJTkcgPSAnc3RyaW5nJztcbiAgdmFyIE9CSkVDVCA9ICdvYmplY3QnO1xuICAvKipcbiAgICogVGhpcyBhcnJheSByZXByZXNlbnRzIHRoZSBET00gc2NoZW1hLiBJdCBlbmNvZGVzIGluaGVyaXRhbmNlLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLlxuICAgKlxuICAgKiAjIyBPdmVydmlld1xuICAgKlxuICAgKiBFYWNoIGxpbmUgcmVwcmVzZW50cyBvbmUga2luZCBvZiBlbGVtZW50LiBUaGUgYGVsZW1lbnRfaW5oZXJpdGFuY2VgIGFuZCBwcm9wZXJ0aWVzIGFyZSBqb2luZWRcbiAgICogdXNpbmcgYGVsZW1lbnRfaW5oZXJpdGFuY2V8cHJvcGVydGllc2Agc3ludGF4LlxuICAgKlxuICAgKiAjIyBFbGVtZW50IEluaGVyaXRhbmNlXG4gICAqXG4gICAqIFRoZSBgZWxlbWVudF9pbmhlcml0YW5jZWAgY2FuIGJlIGZ1cnRoZXIgc3ViZGl2aWRlZCBhcyBgZWxlbWVudDEsZWxlbWVudDIsLi4uXnBhcmVudEVsZW1lbnRgLlxuICAgKiBIZXJlIHRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFdmVyeSBlbGVtZW50IGluIHRoZSBsaXN0XG4gICAqIGhhcyBpZGVudGljYWwgcHJvcGVydGllcy5cbiAgICpcbiAgICogQW4gYGVsZW1lbnRgIG1heSBpbmhlcml0IGFkZGl0aW9uYWwgcHJvcGVydGllcyBmcm9tIGBwYXJlbnRFbGVtZW50YCBJZiBubyBgXnBhcmVudEVsZW1lbnRgIGlzXG4gICAqIHNwZWNpZmllZCB0aGVuIGBcIlwiYCAoYmxhbmspIGVsZW1lbnQgaXMgYXNzdW1lZC5cbiAgICpcbiAgICogTk9URTogVGhlIGJsYW5rIGVsZW1lbnQgaW5oZXJpdHMgZnJvbSByb290IGBbRWxlbWVudF1gIGVsZW1lbnQsIHRoZSBzdXBlciBlbGVtZW50IG9mIGFsbFxuICAgKiBlbGVtZW50cy5cbiAgICpcbiAgICogTk9URSBhbiBlbGVtZW50IHByZWZpeCBzdWNoIGFzIGA6c3ZnOmAgaGFzIG5vIHNwZWNpYWwgbWVhbmluZyB0byB0aGUgc2NoZW1hLlxuICAgKlxuICAgKiAjIyBQcm9wZXJ0aWVzXG4gICAqXG4gICAqIEVhY2ggZWxlbWVudCBoYXMgYSBzZXQgb2YgcHJvcGVydGllcyBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFYWNoIHByb3BlcnR5IGNhbiBiZSBwcmVmaXhlZFxuICAgKiBieSBhIHNwZWNpYWwgY2hhcmFjdGVyIGRlc2lnbmF0aW5nIGl0cyB0eXBlOlxuICAgKlxuICAgKiAtIChubyBwcmVmaXgpOiBwcm9wZXJ0eSBpcyBhIHN0cmluZy5cbiAgICogLSBgKmA6IHByb3BlcnR5IHJlcHJlc2VudHMgYW4gZXZlbnQuXG4gICAqIC0gYCFgOiBwcm9wZXJ0eSBpcyBhIGJvb2xlYW4uXG4gICAqIC0gYCNgOiBwcm9wZXJ0eSBpcyBhIG51bWJlci5cbiAgICogLSBgJWA6IHByb3BlcnR5IGlzIGFuIG9iamVjdC5cbiAgICpcbiAgICogIyMgUXVlcnlcbiAgICpcbiAgICogVGhlIGNsYXNzIGNyZWF0ZXMgYW4gaW50ZXJuYWwgc3F1YXMgcmVwcmVzZW50YXRpb24gd2hpY2ggYWxsb3dzIHRvIGVhc2lseSBhbnN3ZXIgdGhlIHF1ZXJ5IG9mXG4gICAqIGlmIGEgZ2l2ZW4gcHJvcGVydHkgZXhpc3Qgb24gYSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBOT1RFOiBXZSBkb24ndCB5ZXQgc3VwcG9ydCBxdWVyeWluZyBmb3IgdHlwZXMgb3IgZXZlbnRzLlxuICAgKiBOT1RFOiBUaGlzIHNjaGVtYSBpcyBhdXRvIGV4dHJhY3RlZCBmcm9tIGBzY2hlbWFfZXh0cmFjdG9yLnRzYCBsb2NhdGVkIGluIHRoZSB0ZXN0IGZvbGRlcixcbiAgICogICAgICAgc2VlIGRvbV9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeV9zcGVjLnRzXG4gICAqL1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy9cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIERPIE5PVCBFRElUIFRISVMgRE9NIFNDSEVNQSBXSVRIT1VUIEEgU0VDVVJJVFkgUkVWSUVXIVxuICAvL1xuICAvLyBOZXdseSBhZGRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgc2VjdXJpdHkgcmV2aWV3ZWQgYW5kIGFzc2lnbmVkIGFuIGFwcHJvcHJpYXRlIFNlY3VyaXR5Q29udGV4dCBpblxuICAvLyBkb21fc2VjdXJpdHlfc2NoZW1hLnRzLiBSZWFjaCBvdXQgdG8gbXByb2JzdCAmIHJqYW1ldCBmb3IgZGV0YWlscy5cbiAgLy9cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICB2YXIgU0NIRU1BID0gW1xuICAgICAgJ1tFbGVtZW50XXx0ZXh0Q29udGVudCwlY2xhc3NMaXN0LGNsYXNzTmFtZSxpZCxpbm5lckhUTUwsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmNvcHksKmN1dCwqcGFzdGUsKnNlYXJjaCwqc2VsZWN0c3RhcnQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJIVE1MLCNzY3JvbGxMZWZ0LCNzY3JvbGxUb3AnLFxuICAgICAgJ1tIVE1MRWxlbWVudF1eW0VsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY29weSwqY3VlY2hhbmdlLCpjdXQsKmRibGNsaWNrLCpkcmFnLCpkcmFnZW5kLCpkcmFnZW50ZXIsKmRyYWdsZWF2ZSwqZHJhZ292ZXIsKmRyYWdzdGFydCwqZHJvcCwqZHVyYXRpb25jaGFuZ2UsKmVtcHRpZWQsKmVuZGVkLCplcnJvciwqZm9jdXMsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKm1lc3NhZ2UsKm1vdXNlZG93biwqbW91c2VlbnRlciwqbW91c2VsZWF2ZSwqbW91c2Vtb3ZlLCptb3VzZW91dCwqbW91c2VvdmVyLCptb3VzZXVwLCptb3VzZXdoZWVsLCptb3pmdWxsc2NyZWVuY2hhbmdlLCptb3pmdWxsc2NyZWVuZXJyb3IsKm1venBvaW50ZXJsb2NrY2hhbmdlLCptb3pwb2ludGVybG9ja2Vycm9yLCpwYXN0ZSwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlYXJjaCwqc2Vla2VkLCpzZWVraW5nLCpzZWxlY3QsKnNlbGVjdHN0YXJ0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCp3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yLCp3ZWJnbGNvbnRleHRsb3N0LCp3ZWJnbGNvbnRleHRyZXN0b3JlZCwqd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSwqd2Via2l0ZnVsbHNjcmVlbmVycm9yLCp3aGVlbCxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAgICdhYmJyLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiLGJkaSxiZG8sY2l0ZSxjb2RlLGRkLGRmbixkdCxlbSxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsaGVhZGVyLGksa2JkLG1haW4sbWFyayxuYXYsbm9zY3JpcHQscmIscnAscnQscnRjLHJ1YnkscyxzYW1wLHNlY3Rpb24sc21hbGwsc3Ryb25nLHN1YixzdXAsdSx2YXIsd2JyXltIVE1MRWxlbWVudF18YWNjZXNzS2V5LGNvbnRlbnRFZGl0YWJsZSxkaXIsIWRyYWdnYWJsZSwhaGlkZGVuLGlubmVyVGV4dCxsYW5nLCphYm9ydCwqYmVmb3JlY29weSwqYmVmb3JlY3V0LCpiZWZvcmVwYXN0ZSwqYmx1ciwqY2FuY2VsLCpjYW5wbGF5LCpjYW5wbGF5dGhyb3VnaCwqY2hhbmdlLCpjbGljaywqY2xvc2UsKmNvbnRleHRtZW51LCpjb3B5LCpjdWVjaGFuZ2UsKmN1dCwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbWVzc2FnZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKm1vemZ1bGxzY3JlZW5jaGFuZ2UsKm1vemZ1bGxzY3JlZW5lcnJvciwqbW96cG9pbnRlcmxvY2tjaGFuZ2UsKm1venBvaW50ZXJsb2NrZXJyb3IsKnBhc3RlLCpwYXVzZSwqcGxheSwqcGxheWluZywqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2VhcmNoLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2VsZWN0c3RhcnQsKnNob3csKnN0YWxsZWQsKnN1Ym1pdCwqc3VzcGVuZCwqdGltZXVwZGF0ZSwqdG9nZ2xlLCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsKndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IsKndlYmdsY29udGV4dGxvc3QsKndlYmdsY29udGV4dHJlc3RvcmVkLCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVyVGV4dCwhc3BlbGxjaGVjaywlc3R5bGUsI3RhYkluZGV4LHRpdGxlLCF0cmFuc2xhdGUnLFxuICAgICAgJ21lZGlhXltIVE1MRWxlbWVudF18IWF1dG9wbGF5LCFjb250cm9scywlY3Jvc3NPcmlnaW4sI2N1cnJlbnRUaW1lLCFkZWZhdWx0TXV0ZWQsI2RlZmF1bHRQbGF5YmFja1JhdGUsIWRpc2FibGVSZW1vdGVQbGF5YmFjaywhbG9vcCwhbXV0ZWQsKmVuY3J5cHRlZCwjcGxheWJhY2tSYXRlLHByZWxvYWQsc3JjLCVzcmNPYmplY3QsI3ZvbHVtZScsXG4gICAgICAnOnN2ZzpeW0hUTUxFbGVtZW50XXwqYWJvcnQsKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY3VlY2hhbmdlLCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCVzdHlsZSwjdGFiSW5kZXgnLFxuICAgICAgJzpzdmc6Z3JhcGhpY3NeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmFuaW1hdGlvbl46c3ZnOnwqYmVnaW4sKmVuZCwqcmVwZWF0JyxcbiAgICAgICc6c3ZnOmdlb21ldHJ5Xjpzdmc6fCcsXG4gICAgICAnOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9uXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpncmFkaWVudF46c3ZnOnwnLFxuICAgICAgJzpzdmc6dGV4dENvbnRlbnReOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6dGV4dFBvc2l0aW9uaW5nXjpzdmc6dGV4dENvbnRlbnR8JyxcbiAgICAgICdhXltIVE1MRWxlbWVudF18Y2hhcnNldCxjb29yZHMsZG93bmxvYWQsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsaHJlZmxhbmcsbmFtZSxwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3kscmVsLHJldixzZWFyY2gsc2hhcGUsdGFyZ2V0LHRleHQsdHlwZSx1c2VybmFtZScsXG4gICAgICAnYXJlYV5bSFRNTEVsZW1lbnRdfGFsdCxjb29yZHMsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsIW5vSHJlZixwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3ksc2VhcmNoLHNoYXBlLHRhcmdldCx1c2VybmFtZScsXG4gICAgICAnYXVkaW9ebWVkaWF8JyxcbiAgICAgICdicl5bSFRNTEVsZW1lbnRdfGNsZWFyJyxcbiAgICAgICdiYXNlXltIVE1MRWxlbWVudF18aHJlZix0YXJnZXQnLFxuICAgICAgJ2JvZHleW0hUTUxFbGVtZW50XXxhTGluayxiYWNrZ3JvdW5kLGJnQ29sb3IsbGluaywqYmVmb3JldW5sb2FkLCpibHVyLCplcnJvciwqZm9jdXMsKmhhc2hjaGFuZ2UsKmxhbmd1YWdlY2hhbmdlLCpsb2FkLCptZXNzYWdlLCpvZmZsaW5lLCpvbmxpbmUsKnBhZ2VoaWRlLCpwYWdlc2hvdywqcG9wc3RhdGUsKnJlamVjdGlvbmhhbmRsZWQsKnJlc2l6ZSwqc2Nyb2xsLCpzdG9yYWdlLCp1bmhhbmRsZWRyZWplY3Rpb24sKnVubG9hZCx0ZXh0LHZMaW5rJyxcbiAgICAgICdidXR0b25eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsbmFtZSx0eXBlLHZhbHVlJyxcbiAgICAgICdjYW52YXNeW0hUTUxFbGVtZW50XXwjaGVpZ2h0LCN3aWR0aCcsXG4gICAgICAnY29udGVudF5bSFRNTEVsZW1lbnRdfHNlbGVjdCcsXG4gICAgICAnZGxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgICAnZGF0YWxpc3ReW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ2RldGFpbHNeW0hUTUxFbGVtZW50XXwhb3BlbicsXG4gICAgICAnZGlhbG9nXltIVE1MRWxlbWVudF18IW9wZW4scmV0dXJuVmFsdWUnLFxuICAgICAgJ2Rpcl5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAgICdkaXZeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgICAnZW1iZWReW0hUTUxFbGVtZW50XXxhbGlnbixoZWlnaHQsbmFtZSxzcmMsdHlwZSx3aWR0aCcsXG4gICAgICAnZmllbGRzZXReW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbmFtZScsXG4gICAgICAnZm9udF5bSFRNTEVsZW1lbnRdfGNvbG9yLGZhY2Usc2l6ZScsXG4gICAgICAnZm9ybV5bSFRNTEVsZW1lbnRdfGFjY2VwdENoYXJzZXQsYWN0aW9uLGF1dG9jb21wbGV0ZSxlbmNvZGluZyxlbmN0eXBlLG1ldGhvZCxuYW1lLCFub1ZhbGlkYXRlLHRhcmdldCcsXG4gICAgICAnZnJhbWVeW0hUTUxFbGVtZW50XXxmcmFtZUJvcmRlcixsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSwhbm9SZXNpemUsc2Nyb2xsaW5nLHNyYycsXG4gICAgICAnZnJhbWVzZXReW0hUTUxFbGVtZW50XXxjb2xzLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHJvd3MnLFxuICAgICAgJ2hyXltIVE1MRWxlbWVudF18YWxpZ24sY29sb3IsIW5vU2hhZGUsc2l6ZSx3aWR0aCcsXG4gICAgICAnaGVhZF5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAnaDEsaDIsaDMsaDQsaDUsaDZeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgICAnaHRtbF5bSFRNTEVsZW1lbnRdfHZlcnNpb24nLFxuICAgICAgJ2lmcmFtZV5bSFRNTEVsZW1lbnRdfGFsaWduLCFhbGxvd0Z1bGxzY3JlZW4sZnJhbWVCb3JkZXIsaGVpZ2h0LGxvbmdEZXNjLG1hcmdpbkhlaWdodCxtYXJnaW5XaWR0aCxuYW1lLHJlZmVycmVyUG9saWN5LCVzYW5kYm94LHNjcm9sbGluZyxzcmMsc3JjZG9jLHdpZHRoJyxcbiAgICAgICdpbWdeW0hUTUxFbGVtZW50XXxhbGlnbixhbHQsYm9yZGVyLCVjcm9zc09yaWdpbiwjaGVpZ2h0LCNoc3BhY2UsIWlzTWFwLGxvbmdEZXNjLGxvd3NyYyxuYW1lLHJlZmVycmVyUG9saWN5LHNpemVzLHNyYyxzcmNzZXQsdXNlTWFwLCN2c3BhY2UsI3dpZHRoJyxcbiAgICAgICdpbnB1dF5bSFRNTEVsZW1lbnRdfGFjY2VwdCxhbGlnbixhbHQsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLCFhdXRvZm9jdXMsIWNoZWNrZWQsIWRlZmF1bHRDaGVja2VkLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwlZmlsZXMsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LCNoZWlnaHQsIWluY3JlbWVudGFsLCFpbmRldGVybWluYXRlLG1heCwjbWF4TGVuZ3RoLG1pbiwjbWluTGVuZ3RoLCFtdWx0aXBsZSxuYW1lLHBhdHRlcm4scGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsI3NpemUsc3JjLHN0ZXAsdHlwZSx1c2VNYXAsdmFsdWUsJXZhbHVlQXNEYXRlLCN2YWx1ZUFzTnVtYmVyLCN3aWR0aCcsXG4gICAgICAna2V5Z2VuXltIVE1MRWxlbWVudF18IWF1dG9mb2N1cyxjaGFsbGVuZ2UsIWRpc2FibGVkLGtleXR5cGUsbmFtZScsXG4gICAgICAnbGleW0hUTUxFbGVtZW50XXx0eXBlLCN2YWx1ZScsXG4gICAgICAnbGFiZWxeW0hUTUxFbGVtZW50XXxodG1sRm9yJyxcbiAgICAgICdsZWdlbmReW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgICAnbGlua15bSFRNTEVsZW1lbnRdfGFzLGNoYXJzZXQsJWNyb3NzT3JpZ2luLCFkaXNhYmxlZCxocmVmLGhyZWZsYW5nLGludGVncml0eSxtZWRpYSxyZWwsJXJlbExpc3QscmV2LCVzaXplcyx0YXJnZXQsdHlwZScsXG4gICAgICAnbWFwXltIVE1MRWxlbWVudF18bmFtZScsXG4gICAgICAnbWFycXVlZV5bSFRNTEVsZW1lbnRdfGJlaGF2aW9yLGJnQ29sb3IsZGlyZWN0aW9uLGhlaWdodCwjaHNwYWNlLCNsb29wLCNzY3JvbGxBbW91bnQsI3Njcm9sbERlbGF5LCF0cnVlU3BlZWQsI3ZzcGFjZSx3aWR0aCcsXG4gICAgICAnbWVudV5bSFRNTEVsZW1lbnRdfCFjb21wYWN0JyxcbiAgICAgICdtZXRhXltIVE1MRWxlbWVudF18Y29udGVudCxodHRwRXF1aXYsbmFtZSxzY2hlbWUnLFxuICAgICAgJ21ldGVyXltIVE1MRWxlbWVudF18I2hpZ2gsI2xvdywjbWF4LCNtaW4sI29wdGltdW0sI3ZhbHVlJyxcbiAgICAgICdpbnMsZGVsXltIVE1MRWxlbWVudF18Y2l0ZSxkYXRlVGltZScsXG4gICAgICAnb2xeW0hUTUxFbGVtZW50XXwhY29tcGFjdCwhcmV2ZXJzZWQsI3N0YXJ0LHR5cGUnLFxuICAgICAgJ29iamVjdF5bSFRNTEVsZW1lbnRdfGFsaWduLGFyY2hpdmUsYm9yZGVyLGNvZGUsY29kZUJhc2UsY29kZVR5cGUsZGF0YSwhZGVjbGFyZSxoZWlnaHQsI2hzcGFjZSxuYW1lLHN0YW5kYnksdHlwZSx1c2VNYXAsI3ZzcGFjZSx3aWR0aCcsXG4gICAgICAnb3B0Z3JvdXBeW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbGFiZWwnLFxuICAgICAgJ29wdGlvbl5bSFRNTEVsZW1lbnRdfCFkZWZhdWx0U2VsZWN0ZWQsIWRpc2FibGVkLGxhYmVsLCFzZWxlY3RlZCx0ZXh0LHZhbHVlJyxcbiAgICAgICdvdXRwdXReW0hUTUxFbGVtZW50XXxkZWZhdWx0VmFsdWUsJWh0bWxGb3IsbmFtZSx2YWx1ZScsXG4gICAgICAncF5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAgICdwYXJhbV5bSFRNTEVsZW1lbnRdfG5hbWUsdHlwZSx2YWx1ZSx2YWx1ZVR5cGUnLFxuICAgICAgJ3BpY3R1cmVeW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3ByZV5bSFRNTEVsZW1lbnRdfCN3aWR0aCcsXG4gICAgICAncHJvZ3Jlc3NeW0hUTUxFbGVtZW50XXwjbWF4LCN2YWx1ZScsXG4gICAgICAncSxibG9ja3F1b3RlLGNpdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3NjcmlwdF5bSFRNTEVsZW1lbnRdfCFhc3luYyxjaGFyc2V0LCVjcm9zc09yaWdpbiwhZGVmZXIsZXZlbnQsaHRtbEZvcixpbnRlZ3JpdHksc3JjLHRleHQsdHlwZScsXG4gICAgICAnc2VsZWN0XltIVE1MRWxlbWVudF18IWF1dG9mb2N1cywhZGlzYWJsZWQsI2xlbmd0aCwhbXVsdGlwbGUsbmFtZSwhcmVxdWlyZWQsI3NlbGVjdGVkSW5kZXgsI3NpemUsdmFsdWUnLFxuICAgICAgJ3NoYWRvd15bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAnc291cmNlXltIVE1MRWxlbWVudF18bWVkaWEsc2l6ZXMsc3JjLHNyY3NldCx0eXBlJyxcbiAgICAgICdzcGFuXltIVE1MRWxlbWVudF18JyxcbiAgICAgICdzdHlsZV5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxtZWRpYSx0eXBlJyxcbiAgICAgICdjYXB0aW9uXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICAgJ3RoLHRkXltIVE1MRWxlbWVudF18YWJicixhbGlnbixheGlzLGJnQ29sb3IsY2gsY2hPZmYsI2NvbFNwYW4saGVhZGVycyxoZWlnaHQsIW5vV3JhcCwjcm93U3BhbixzY29wZSx2QWxpZ24sd2lkdGgnLFxuICAgICAgJ2NvbCxjb2xncm91cF5bSFRNTEVsZW1lbnRdfGFsaWduLGNoLGNoT2ZmLCNzcGFuLHZBbGlnbix3aWR0aCcsXG4gICAgICAndGFibGVeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGJvcmRlciwlY2FwdGlvbixjZWxsUGFkZGluZyxjZWxsU3BhY2luZyxmcmFtZSxydWxlcyxzdW1tYXJ5LCV0Rm9vdCwldEhlYWQsd2lkdGgnLFxuICAgICAgJ3RyXltIVE1MRWxlbWVudF18YWxpZ24sYmdDb2xvcixjaCxjaE9mZix2QWxpZ24nLFxuICAgICAgJ3Rmb290LHRoZWFkLHRib2R5XltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsdkFsaWduJyxcbiAgICAgICd0ZW1wbGF0ZV5bSFRNTEVsZW1lbnRdfCcsXG4gICAgICAndGV4dGFyZWFeW0hUTUxFbGVtZW50XXxhdXRvY2FwaXRhbGl6ZSwhYXV0b2ZvY3VzLCNjb2xzLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwjbWF4TGVuZ3RoLCNtaW5MZW5ndGgsbmFtZSxwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLCNyb3dzLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCx2YWx1ZSx3cmFwJyxcbiAgICAgICd0aXRsZV5bSFRNTEVsZW1lbnRdfHRleHQnLFxuICAgICAgJ3RyYWNrXltIVE1MRWxlbWVudF18IWRlZmF1bHQsa2luZCxsYWJlbCxzcmMsc3JjbGFuZycsXG4gICAgICAndWxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCx0eXBlJyxcbiAgICAgICd1bmtub3duXltIVE1MRWxlbWVudF18JyxcbiAgICAgICd2aWRlb15tZWRpYXwjaGVpZ2h0LHBvc3Rlciwjd2lkdGgnLFxuICAgICAgJzpzdmc6YV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzphbmltYXRlXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgICAnOnN2ZzphbmltYXRlTW90aW9uXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgICAnOnN2ZzphbmltYXRlVHJhbnNmb3JtXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgICAnOnN2ZzpjaXJjbGVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6Y2xpcFBhdGheOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6Y3Vyc29yXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpkZWZzXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOmRlc2NeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmRpc2NhcmReOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmVsbGlwc2VeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6ZmVCbGVuZF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVDb2xvck1hdHJpeF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVDb21wb25lbnRUcmFuc2Zlcl46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVDb21wb3NpdGVeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlQ29udm9sdmVNYXRyaXheOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlRGlmZnVzZUxpZ2h0aW5nXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZURpc3BsYWNlbWVudE1hcF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVEaXN0YW50TGlnaHReOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlRHJvcFNoYWRvd146c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVGbG9vZF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVGdW5jQV46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAgICc6c3ZnOmZlRnVuY0JeOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgICAnOnN2ZzpmZUZ1bmNHXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICAgJzpzdmc6ZmVGdW5jUl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAgICc6c3ZnOmZlR2F1c3NpYW5CbHVyXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZUltYWdlXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZU1lcmdlXjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZU1lcmdlTm9kZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVNb3JwaG9sb2d5Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZU9mZnNldF46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmVQb2ludExpZ2h0Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZVNwZWN1bGFyTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlU3BvdExpZ2h0Xjpzdmc6fCcsXG4gICAgICAnOnN2ZzpmZVRpbGVeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOmZlVHVyYnVsZW5jZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6ZmlsdGVyXjpzdmc6fCcsXG4gICAgICAnOnN2Zzpmb3JlaWduT2JqZWN0Xjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOmdeOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6aW1hZ2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICAgJzpzdmc6bGluZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpsaW5lYXJHcmFkaWVudF46c3ZnOmdyYWRpZW50fCcsXG4gICAgICAnOnN2ZzptcGF0aF46c3ZnOnwnLFxuICAgICAgJzpzdmc6bWFya2VyXjpzdmc6fCcsXG4gICAgICAnOnN2ZzptYXNrXjpzdmc6fCcsXG4gICAgICAnOnN2ZzptZXRhZGF0YV46c3ZnOnwnLFxuICAgICAgJzpzdmc6cGF0aF46c3ZnOmdlb21ldHJ5fCcsXG4gICAgICAnOnN2ZzpwYXR0ZXJuXjpzdmc6fCcsXG4gICAgICAnOnN2Zzpwb2x5Z29uXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAgICc6c3ZnOnBvbHlsaW5lXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAgICc6c3ZnOnJhZGlhbEdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAgICc6c3ZnOnJlY3ReOnN2ZzpnZW9tZXRyeXwnLFxuICAgICAgJzpzdmc6c3ZnXjpzdmc6Z3JhcGhpY3N8I2N1cnJlbnRTY2FsZSwjem9vbUFuZFBhbicsXG4gICAgICAnOnN2ZzpzY3JpcHReOnN2Zzp8dHlwZScsXG4gICAgICAnOnN2ZzpzZXReOnN2ZzphbmltYXRpb258JyxcbiAgICAgICc6c3ZnOnN0b3BeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOnN0eWxlXjpzdmc6fCFkaXNhYmxlZCxtZWRpYSx0aXRsZSx0eXBlJyxcbiAgICAgICc6c3ZnOnN3aXRjaF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgICAnOnN2ZzpzeW1ib2xeOnN2Zzp8JyxcbiAgICAgICc6c3ZnOnRzcGFuXjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgICAnOnN2Zzp0ZXh0Xjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgICAnOnN2Zzp0ZXh0UGF0aF46c3ZnOnRleHRDb250ZW50fCcsXG4gICAgICAnOnN2Zzp0aXRsZV46c3ZnOnwnLFxuICAgICAgJzpzdmc6dXNlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAgICc6c3ZnOnZpZXdeOnN2Zzp8I3pvb21BbmRQYW4nLFxuICAgICAgJ2RhdGFeW0hUTUxFbGVtZW50XXx2YWx1ZScsXG4gICAgICAnbWVudWl0ZW1eW0hUTUxFbGVtZW50XXx0eXBlLGxhYmVsLGljb24sIWRpc2FibGVkLCFjaGVja2VkLHJhZGlvZ3JvdXAsIWRlZmF1bHQnLFxuICAgICAgJ3N1bW1hcnleW0hUTUxFbGVtZW50XXwnLFxuICAgICAgJ3RpbWVeW0hUTUxFbGVtZW50XXxkYXRlVGltZScsXG4gIF07XG4gIHZhciBfQVRUUl9UT19QUk9QID0ge1xuICAgICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICAgICAnZm9ybWFjdGlvbic6ICdmb3JtQWN0aW9uJyxcbiAgICAgICdpbm5lckh0bWwnOiAnaW5uZXJIVE1MJyxcbiAgICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxuICB9O1xuICB2YXIgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgIF9fZXh0ZW5kcyQxOShEb21FbGVtZW50U2NoZW1hUmVnaXN0cnksIF9zdXBlcik7XG4gICAgICBmdW5jdGlvbiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICB0aGlzLl9zY2hlbWEgPSB7fTtcbiAgICAgICAgICBTQ0hFTUEuZm9yRWFjaChmdW5jdGlvbiAoZW5jb2RlZFR5cGUpIHtcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSB7fTtcbiAgICAgICAgICAgICAgdmFyIF9hID0gZW5jb2RlZFR5cGUuc3BsaXQoJ3wnKSwgc3RyVHlwZSA9IF9hWzBdLCBzdHJQcm9wZXJ0aWVzID0gX2FbMV07XG4gICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gc3RyUHJvcGVydGllcy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICB2YXIgX2IgPSBzdHJUeXBlLnNwbGl0KCdeJyksIHR5cGVOYW1lcyA9IF9iWzBdLCBzdXBlck5hbWUgPSBfYlsxXTtcbiAgICAgICAgICAgICAgdHlwZU5hbWVzLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7IHJldHVybiBfdGhpcy5fc2NoZW1hW3RhZy50b0xvd2VyQ2FzZSgpXSA9IHR5cGU7IH0pO1xuICAgICAgICAgICAgICB2YXIgc3VwZXJUeXBlID0gc3VwZXJOYW1lICYmIF90aGlzLl9zY2hlbWFbc3VwZXJOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICBpZiAoc3VwZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdXBlclR5cGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgdHlwZVtwcm9wXSA9IHN1cGVyVHlwZVtwcm9wXTsgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgeWV0IHN1cHBvcnQgZXZlbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZXZlciBhbGxvd2luZyB0byBiaW5kIHRvIGV2ZW50cywgR08gVEhST1VHSCBBIFNFQ1VSSVRZIFJFVklFVywgYWxsb3dpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbG1vc3QgY2VydGFpbmx5IGludHJvZHVjZSBiYWQgWFNTIHZ1bG5lcmFiaWxpdGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IEVWRU5UO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gQk9PTEVBTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IE5VTUJFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IE9CSkVDVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eV0gPSBTVFJJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUsIHNjaGVtYU1ldGFzKSB7XG4gICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IF9hbmd1bGFyX2NvcmUuTk9fRVJST1JTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICduZy1jb250YWluZXInIHx8IHRhZ05hbWUgPT09ICduZy1jb250ZW50Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBfYW5ndWxhcl9jb3JlLkNVU1RPTV9FTEVNRU5UU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIENhbid0IHRlbGwgbm93IGFzIHdlIGRvbid0IGtub3cgd2hpY2ggcHJvcGVydGllcyBhIGN1c3RvbSBlbGVtZW50IHdpbGwgZ2V0XG4gICAgICAgICAgICAgICAgICAvLyBvbmNlIGl0IGlzIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnRQcm9wZXJ0aWVzID0gdGhpcy5fc2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgdGhpcy5fc2NoZW1hWyd1bmtub3duJ107XG4gICAgICAgICAgcmV0dXJuICEhZWxlbWVudFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgfTtcbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzRWxlbWVudCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBzY2hlbWFNZXRhcykge1xuICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBfYW5ndWxhcl9jb3JlLk5PX0VSUk9SU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnbmctY29udGFpbmVyJyB8fCB0YWdOYW1lID09PSAnbmctY29udGVudCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKGZ1bmN0aW9uIChzY2hlbWEpIHsgcmV0dXJuIHNjaGVtYS5uYW1lID09PSBfYW5ndWxhcl9jb3JlLkNVU1RPTV9FTEVNRU5UU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFueSBjdXN0b20gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhIXRoaXMuX3NjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogc2VjdXJpdHlDb250ZXh0IHJldHVybnMgdGhlIHNlY3VyaXR5IGNvbnRleHQgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gRE9NIHRhZy5cbiAgICAgICAqXG4gICAgICAgKiBUYWcgYW5kIHByb3BlcnR5IG5hbWUgYXJlIHN0YXRpY2FsbHkga25vd24gYW5kIGNhbm5vdCBjaGFuZ2UgYXQgcnVudGltZSwgaS5lLiBpdCBpcyBub3RcbiAgICAgICAqIHBvc3NpYmxlIHRvIGJpbmQgYSB2YWx1ZSBpbnRvIGEgY2hhbmdpbmcgYXR0cmlidXRlIG9yIHRhZyBuYW1lLlxuICAgICAgICpcbiAgICAgICAqIFRoZSBmaWx0ZXJpbmcgaXMgd2hpdGUgbGlzdCBiYXNlZC4gQWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHNjaGVtYSBhYm92ZSBhcmUgYXNzdW1lZCB0byBoYXZlIHRoZVxuICAgICAgICogJ05PTkUnIHNlY3VyaXR5IGNvbnRleHQsIGkuZS4gdGhhdCB0aGV5IGFyZSBzYWZlIGluZXJ0IHN0cmluZyB2YWx1ZXMuIE9ubHkgc3BlY2lmaWMgd2VsbCBrbm93blxuICAgICAgICogYXR0YWNrIHZlY3RvcnMgYXJlIGFzc2lnbmVkIHRoZWlyIGFwcHJvcHJpYXRlIGNvbnRleHQuXG4gICAgICAgKi9cbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuc2VjdXJpdHlDb250ZXh0ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BOYW1lKSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGNvbXBhcmlzb25zIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBzbyB0aGF0IGNhc2UgZGlmZmVyZW5jZXMgYmV0d2VlbiBhdHRyaWJ1dGUgYW5kXG4gICAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBwcm9wTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGN0eCA9IFNFQ1VSSVRZX1NDSEVNQVt0YWdOYW1lICsgJ3wnICsgcHJvcE5hbWVdO1xuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4ID0gU0VDVVJJVFlfU0NIRU1BWycqfCcgKyBwcm9wTmFtZV07XG4gICAgICAgICAgcmV0dXJuIGN0eCA/IGN0eCA6IF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkU7XG4gICAgICB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRNYXBwZWRQcm9wTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkgeyByZXR1cm4gX0FUVFJfVE9fUFJPUFtwcm9wTmFtZV0gfHwgcHJvcE5hbWU7IH07XG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICduZy1jb21wb25lbnQnOyB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS52YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgICAgdmFyIG1zZyA9IChcIkJpbmRpbmcgdG8gZXZlbnQgcHJvcGVydHkgJ1wiICsgbmFtZSArIFwiJyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLCBcIikgK1xuICAgICAgICAgICAgICAgICAgKFwicGxlYXNlIHVzZSAoXCIgKyBuYW1lLnNsaWNlKDIpICsgXCIpPS4uLlwiKSArXG4gICAgICAgICAgICAgICAgICAoXCJcXG5JZiAnXCIgKyBuYW1lICsgXCInIGlzIGEgZGlyZWN0aXZlIGlucHV0LCBtYWtlIHN1cmUgdGhlIGRpcmVjdGl2ZSBpcyBpbXBvcnRlZCBieSB0aGVcIikgK1xuICAgICAgICAgICAgICAgICAgXCIgY3VycmVudCBtb2R1bGUuXCI7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnb24nKSkge1xuICAgICAgICAgICAgICB2YXIgbXNnID0gKFwiQmluZGluZyB0byBldmVudCBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLCBcIikgK1xuICAgICAgICAgICAgICAgICAgKFwicGxlYXNlIHVzZSAoXCIgKyBuYW1lLnNsaWNlKDIpICsgXCIpPS4uLlwiKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIG1zZzogbXNnIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZmFsc2UgfTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuICAgICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgIF07XG4gICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgcmV0dXJuIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbiAgfShFbGVtZW50U2NoZW1hUmVnaXN0cnkpKTtcblxuICB2YXIgX05PX1JFU09VUkNFX0xPQURFUiA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlc291cmNlTG9hZGVyIGltcGxlbWVudGF0aW9uIGhhcyBiZWVuIHByb3ZpZGVkLiBDYW4ndCByZWFkIHRoZSB1cmwgXFxcIlwiICsgdXJsICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICB9O1xuICAvKipcbiAgICogQSBzZXQgb2YgcHJvdmlkZXJzIHRoYXQgcHJvdmlkZSBgUnVudGltZUNvbXBpbGVyYCBhbmQgaXRzIGRlcGVuZGVuY2llcyB0byB1c2UgZm9yXG4gICAqIHRlbXBsYXRlIGNvbXBpbGF0aW9uLlxuICAgKi9cbiAgdmFyIENPTVBJTEVSX1BST1ZJREVSUyA9IFtcbiAgICAgIHsgcHJvdmlkZTogUmVmbGVjdG9yLCB1c2VWYWx1ZTogcmVmbGVjdG9yIH0sXG4gICAgICB7IHByb3ZpZGU6IFJlZmxlY3RvclJlYWRlciwgdXNlRXhpc3Rpbmc6IFJlZmxlY3RvciB9LFxuICAgICAgeyBwcm92aWRlOiBSZXNvdXJjZUxvYWRlciwgdXNlVmFsdWU6IF9OT19SRVNPVVJDRV9MT0FERVIgfSxcbiAgICAgIENvbnNvbGUsXG4gICAgICBMZXhlcixcbiAgICAgIFBhcnNlcixcbiAgICAgIEh0bWxQYXJzZXIsXG4gICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogSTE4Tkh0bWxQYXJzZXIsXG4gICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKHBhcnNlciwgdHJhbnNsYXRpb25zLCBmb3JtYXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJMThOSHRtbFBhcnNlcihwYXJzZXIsIHRyYW5zbGF0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlcHM6IFtcbiAgICAgICAgICAgICAgSHRtbFBhcnNlcixcbiAgICAgICAgICAgICAgW25ldyBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCksIG5ldyBfYW5ndWxhcl9jb3JlLkluamVjdChfYW5ndWxhcl9jb3JlLlRSQU5TTEFUSU9OUyldLFxuICAgICAgICAgICAgICBbbmV3IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSwgbmV3IF9hbmd1bGFyX2NvcmUuSW5qZWN0KF9hbmd1bGFyX2NvcmUuVFJBTlNMQVRJT05TX0ZPUk1BVCldLFxuICAgICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBUZW1wbGF0ZVBhcnNlcixcbiAgICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIsXG4gICAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlcixcbiAgICAgIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIsXG4gICAgICBTdHlsZUNvbXBpbGVyLFxuICAgICAgVmlld0NvbXBpbGVyLFxuICAgICAgTmdNb2R1bGVDb21waWxlcixcbiAgICAgIHsgcHJvdmlkZTogQ29tcGlsZXJDb25maWcsIHVzZVZhbHVlOiBuZXcgQ29tcGlsZXJDb25maWcoKSB9LFxuICAgICAgUnVudGltZUNvbXBpbGVyLFxuICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLkNvbXBpbGVyLCB1c2VFeGlzdGluZzogUnVudGltZUNvbXBpbGVyIH0sXG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnksXG4gICAgICB7IHByb3ZpZGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgdXNlRXhpc3Rpbmc6IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSB9LFxuICAgICAgVXJsUmVzb2x2ZXIsXG4gICAgICBEaXJlY3RpdmVSZXNvbHZlcixcbiAgICAgIFBpcGVSZXNvbHZlcixcbiAgICAgIE5nTW9kdWxlUmVzb2x2ZXJcbiAgXTtcbiAgdmFyIFJ1bnRpbWVDb21waWxlckZhY3RvcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUnVudGltZUNvbXBpbGVyRmFjdG9yeShkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gW3tcbiAgICAgICAgICAgICAgICAgIHVzZURlYnVnOiBfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpLFxuICAgICAgICAgICAgICAgICAgdXNlSml0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWRcbiAgICAgICAgICAgICAgfV0uY29uY2F0KGRlZmF1bHRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIFJ1bnRpbWVDb21waWxlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUNvbXBpbGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBbXTsgfVxuICAgICAgICAgIHZhciBtZXJnZWRPcHRpb25zID0gX21lcmdlT3B0aW9ucyh0aGlzLl9kZWZhdWx0T3B0aW9ucy5jb25jYXQob3B0aW9ucykpO1xuICAgICAgICAgIHZhciBpbmplY3RvciA9IF9hbmd1bGFyX2NvcmUuUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAgICAgICAgICBDT01QSUxFUl9QUk9WSURFUlMsIHtcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IENvbXBpbGVyQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGlsZXJDb25maWcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgZXhwbGljaXQgdmFsdWVzIGZyb20gdGhlIGNvbXBpbGVyIG9wdGlvbnMgb3ZlcndyaXRlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgYXBwIHByb3ZpZGVycy4gRS5nLiBpbXBvcnRhbnQgZm9yIHRoZSB0ZXN0aW5nIHBsYXRmb3JtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5EZWJ1Z0luZm86IG1lcmdlZE9wdGlvbnMudXNlRGVidWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUppdDogbWVyZ2VkT3B0aW9ucy51c2VKaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcHAgcHJvdmlkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRFbmNhcHN1bGF0aW9uOiBtZXJnZWRPcHRpb25zLmRlZmF1bHRFbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dCaW5kaW5nVXBkYXRlOiBtZXJnZWRPcHRpb25zLnVzZURlYnVnXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZGVwczogW11cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5wcm92aWRlcnNcbiAgICAgICAgICBdKTtcbiAgICAgICAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KF9hbmd1bGFyX2NvcmUuQ29tcGlsZXIpO1xuICAgICAgfTtcbiAgICAgIFJ1bnRpbWVDb21waWxlckZhY3RvcnkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgXTtcbiAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgUnVudGltZUNvbXBpbGVyRmFjdG9yeS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW19hbmd1bGFyX2NvcmUuQ09NUElMRVJfT1BUSU9OUyxdIH0sXSB9LFxuICAgICAgXTtcbiAgICAgIHJldHVybiBSdW50aW1lQ29tcGlsZXJGYWN0b3J5O1xuICB9KCkpO1xuICBmdW5jdGlvbiBfaW5pdFJlZmxlY3RvcigpIHtcbiAgICAgIHJlZmxlY3Rvci5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzID0gbmV3IFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKTtcbiAgfVxuICAvKipcbiAgICogQSBwbGF0Zm9ybSB0aGF0IGluY2x1ZGVkIGNvcmVQbGF0Zm9ybSBhbmQgdGhlIGNvbXBpbGVyLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICB2YXIgcGxhdGZvcm1Db3JlRHluYW1pYyA9IF9hbmd1bGFyX2NvcmUuY3JlYXRlUGxhdGZvcm1GYWN0b3J5KF9hbmd1bGFyX2NvcmUucGxhdGZvcm1Db3JlLCAnY29yZUR5bmFtaWMnLCBbXG4gICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuQ09NUElMRVJfT1BUSU9OUywgdXNlVmFsdWU6IHt9LCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLkNvbXBpbGVyRmFjdG9yeSwgdXNlQ2xhc3M6IFJ1bnRpbWVDb21waWxlckZhY3RvcnkgfSxcbiAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5QTEFURk9STV9JTklUSUFMSVpFUiwgdXNlVmFsdWU6IF9pbml0UmVmbGVjdG9yLCBtdWx0aTogdHJ1ZSB9LFxuICBdKTtcbiAgZnVuY3Rpb24gX21lcmdlT3B0aW9ucyhvcHRpb25zQXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHVzZURlYnVnOiBfbGFzdERlZmluZWQob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMudXNlRGVidWc7IH0pKSxcbiAgICAgICAgICB1c2VKaXQ6IF9sYXN0RGVmaW5lZChvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy51c2VKaXQ7IH0pKSxcbiAgICAgICAgICBkZWZhdWx0RW5jYXBzdWxhdGlvbjogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLmRlZmF1bHRFbmNhcHN1bGF0aW9uOyB9KSksXG4gICAgICAgICAgcHJvdmlkZXJzOiBfbWVyZ2VBcnJheXMob3B0aW9uc0Fyci5tYXAoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIG9wdGlvbnMucHJvdmlkZXJzOyB9KSlcbiAgICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gX2xhc3REZWZpbmVkKGFyZ3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhcmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGFyZ3NbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIF9tZXJnZUFycmF5cyhwYXJ0cykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkgeyByZXR1cm4gcGFydCAmJiByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHBhcnQpOyB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQGxpY2Vuc2VcbiAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAqXG4gICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICovXG4gIC8vIGFzc2V0OjxwYWNrYWdlLW5hbWU+LzxyZWFsbT4vPHBhdGgtdG8tbW9kdWxlPlxuICB2YXIgX0FTU0VUX1VSTF9SRSA9IC9hc3NldDooW15cXC9dKylcXC8oW15cXC9dKylcXC8oLispLztcbiAgLyoqXG4gICAqIEludGVyZmFjZSB0aGF0IGRlZmluZXMgaG93IGltcG9ydCBzdGF0ZW1lbnRzIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG4gICAqL1xuICB2YXIgSW1wb3J0R2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIEltcG9ydEdlbmVyYXRvcigpIHtcbiAgICAgIH1cbiAgICAgIEltcG9ydEdlbmVyYXRvci5wYXJzZUFzc2V0VXJsID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gQXNzZXRVcmwucGFyc2UodXJsKTsgfTtcbiAgICAgIHJldHVybiBJbXBvcnRHZW5lcmF0b3I7XG4gIH0oKSk7XG4gIHZhciBBc3NldFVybCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBBc3NldFVybChwYWNrYWdlTmFtZSwgZmlyc3RMZXZlbERpciwgbW9kdWxlUGF0aCkge1xuICAgICAgICAgIHRoaXMucGFja2FnZU5hbWUgPSBwYWNrYWdlTmFtZTtcbiAgICAgICAgICB0aGlzLmZpcnN0TGV2ZWxEaXIgPSBmaXJzdExldmVsRGlyO1xuICAgICAgICAgIHRoaXMubW9kdWxlUGF0aCA9IG1vZHVsZVBhdGg7XG4gICAgICB9XG4gICAgICBBc3NldFVybC5wYXJzZSA9IGZ1bmN0aW9uICh1cmwsIGFsbG93Tm9uTWF0Y2hpbmcpIHtcbiAgICAgICAgICBpZiAoYWxsb3dOb25NYXRjaGluZyA9PT0gdm9pZCAwKSB7IGFsbG93Tm9uTWF0Y2hpbmcgPSB0cnVlOyB9XG4gICAgICAgICAgdmFyIG1hdGNoID0gdXJsLm1hdGNoKF9BU1NFVF9VUkxfUkUpO1xuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEFzc2V0VXJsKG1hdGNoWzFdLCBtYXRjaFsyXSwgbWF0Y2hbM10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWxsb3dOb25NYXRjaGluZykge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXJsIFwiICsgdXJsICsgXCIgaXMgbm90IGEgdmFsaWQgYXNzZXQ6IHVybFwiKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gQXNzZXRVcmw7XG4gIH0oKSk7XG5cbiAgdmFyIF9fY29tcGlsZXJfcHJpdmF0ZV9fID0ge1xuICAgICAgU2VsZWN0b3JNYXRjaGVyOiBTZWxlY3Rvck1hdGNoZXIsXG4gICAgICBDc3NTZWxlY3RvcjogQ3NzU2VsZWN0b3IsXG4gICAgICBBc3NldFVybDogQXNzZXRVcmwsXG4gICAgICBJbXBvcnRHZW5lcmF0b3I6IEltcG9ydEdlbmVyYXRvcixcbiAgICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyOiBDb21waWxlTWV0YWRhdGFSZXNvbHZlcixcbiAgICAgIEh0bWxQYXJzZXI6IEh0bWxQYXJzZXIsXG4gICAgICBJbnRlcnBvbGF0aW9uQ29uZmlnOiBJbnRlcnBvbGF0aW9uQ29uZmlnLFxuICAgICAgRGlyZWN0aXZlTm9ybWFsaXplcjogRGlyZWN0aXZlTm9ybWFsaXplcixcbiAgICAgIExleGVyOiBMZXhlcixcbiAgICAgIFBhcnNlcjogUGFyc2VyLFxuICAgICAgUGFyc2VMb2NhdGlvbjogUGFyc2VMb2NhdGlvbixcbiAgICAgIFBhcnNlRXJyb3I6IFBhcnNlRXJyb3IsXG4gICAgICBQYXJzZUVycm9yTGV2ZWw6IFBhcnNlRXJyb3JMZXZlbCxcbiAgICAgIFBhcnNlU291cmNlRmlsZTogUGFyc2VTb3VyY2VGaWxlLFxuICAgICAgUGFyc2VTb3VyY2VTcGFuOiBQYXJzZVNvdXJjZVNwYW4sXG4gICAgICBUZW1wbGF0ZVBhcnNlcjogVGVtcGxhdGVQYXJzZXIsXG4gICAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnk6IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSxcbiAgICAgIFN0eWxlQ29tcGlsZXI6IFN0eWxlQ29tcGlsZXIsXG4gICAgICBWaWV3Q29tcGlsZXI6IFZpZXdDb21waWxlcixcbiAgICAgIE5nTW9kdWxlQ29tcGlsZXI6IE5nTW9kdWxlQ29tcGlsZXIsXG4gICAgICBUeXBlU2NyaXB0RW1pdHRlcjogVHlwZVNjcmlwdEVtaXR0ZXJcbiAgfTtcblxuICBleHBvcnRzLkNPTVBJTEVSX1BST1ZJREVSUyA9IENPTVBJTEVSX1BST1ZJREVSUztcbiAgZXhwb3J0cy5Db21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGEgPSBDb21waWxlRGlEZXBlbmRlbmN5TWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSBDb21waWxlRmFjdG9yeU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVJZGVudGlmaWVyTWV0YWRhdGEgPSBDb21waWxlSWRlbnRpZmllck1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVNZXRhZGF0YVdpdGhJZGVudGlmaWVyID0gQ29tcGlsZU1ldGFkYXRhV2l0aElkZW50aWZpZXI7XG4gIGV4cG9ydHMuQ29tcGlsZVBpcGVNZXRhZGF0YSA9IENvbXBpbGVQaXBlTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZVByb3ZpZGVyTWV0YWRhdGEgPSBDb21waWxlUHJvdmlkZXJNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlUXVlcnlNZXRhZGF0YSA9IENvbXBpbGVRdWVyeU1ldGFkYXRhO1xuICBleHBvcnRzLkNvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhID0gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGE7XG4gIGV4cG9ydHMuQ29tcGlsZVRva2VuTWV0YWRhdGEgPSBDb21waWxlVG9rZW5NZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlVHlwZU1ldGFkYXRhID0gQ29tcGlsZVR5cGVNZXRhZGF0YTtcbiAgZXhwb3J0cy5Db21waWxlckNvbmZpZyA9IENvbXBpbGVyQ29uZmlnO1xuICBleHBvcnRzLkRFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIgPSBERUZBVUxUX1BBQ0tBR0VfVVJMX1BST1ZJREVSO1xuICBleHBvcnRzLkRpcmVjdGl2ZVJlc29sdmVyID0gRGlyZWN0aXZlUmVzb2x2ZXI7XG4gIGV4cG9ydHMuTmdNb2R1bGVSZXNvbHZlciA9IE5nTW9kdWxlUmVzb2x2ZXI7XG4gIGV4cG9ydHMuT2ZmbGluZUNvbXBpbGVyID0gT2ZmbGluZUNvbXBpbGVyO1xuICBleHBvcnRzLlBpcGVSZXNvbHZlciA9IFBpcGVSZXNvbHZlcjtcbiAgZXhwb3J0cy5SZW5kZXJUeXBlcyA9IFJlbmRlclR5cGVzO1xuICBleHBvcnRzLlJlc291cmNlTG9hZGVyID0gUmVzb3VyY2VMb2FkZXI7XG4gIGV4cG9ydHMuUnVudGltZUNvbXBpbGVyID0gUnVudGltZUNvbXBpbGVyO1xuICBleHBvcnRzLlNvdXJjZU1vZHVsZSA9IFNvdXJjZU1vZHVsZTtcbiAgZXhwb3J0cy5URU1QTEFURV9UUkFOU0ZPUk1TID0gVEVNUExBVEVfVFJBTlNGT1JNUztcbiAgZXhwb3J0cy5VcmxSZXNvbHZlciA9IFVybFJlc29sdmVyO1xuICBleHBvcnRzLmNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIgPSBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyO1xuICBleHBvcnRzLnBsYXRmb3JtQ29yZUR5bmFtaWMgPSBwbGF0Zm9ybUNvcmVEeW5hbWljO1xuICBleHBvcnRzLkRFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICBleHBvcnRzLkludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnO1xuICBleHBvcnRzLkVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbiAgZXhwb3J0cy5JMThOSHRtbFBhcnNlciA9IEkxOE5IdG1sUGFyc2VyO1xuICBleHBvcnRzLk1lc3NhZ2VCdW5kbGUgPSBNZXNzYWdlQnVuZGxlO1xuICBleHBvcnRzLlhsaWZmID0gWGxpZmY7XG4gIGV4cG9ydHMuWG1iID0gWG1iO1xuICBleHBvcnRzLlh0YiA9IFh0YjtcbiAgZXhwb3J0cy5UZXh0QXN0ID0gVGV4dEFzdDtcbiAgZXhwb3J0cy5Cb3VuZFRleHRBc3QgPSBCb3VuZFRleHRBc3Q7XG4gIGV4cG9ydHMuQXR0ckFzdCA9IEF0dHJBc3Q7XG4gIGV4cG9ydHMuQm91bmRFbGVtZW50UHJvcGVydHlBc3QgPSBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdDtcbiAgZXhwb3J0cy5Cb3VuZEV2ZW50QXN0ID0gQm91bmRFdmVudEFzdDtcbiAgZXhwb3J0cy5SZWZlcmVuY2VBc3QgPSBSZWZlcmVuY2VBc3Q7XG4gIGV4cG9ydHMuVmFyaWFibGVBc3QgPSBWYXJpYWJsZUFzdDtcbiAgZXhwb3J0cy5FbGVtZW50QXN0ID0gRWxlbWVudEFzdDtcbiAgZXhwb3J0cy5FbWJlZGRlZFRlbXBsYXRlQXN0ID0gRW1iZWRkZWRUZW1wbGF0ZUFzdDtcbiAgZXhwb3J0cy5Cb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0ID0gQm91bmREaXJlY3RpdmVQcm9wZXJ0eUFzdDtcbiAgZXhwb3J0cy5EaXJlY3RpdmVBc3QgPSBEaXJlY3RpdmVBc3Q7XG4gIGV4cG9ydHMuUHJvdmlkZXJBc3QgPSBQcm92aWRlckFzdDtcbiAgZXhwb3J0cy5OZ0NvbnRlbnRBc3QgPSBOZ0NvbnRlbnRBc3Q7XG4gIGV4cG9ydHMudGVtcGxhdGVWaXNpdEFsbCA9IHRlbXBsYXRlVmlzaXRBbGw7XG4gIGV4cG9ydHMuX19jb21waWxlcl9wcml2YXRlX18gPSBfX2NvbXBpbGVyX3ByaXZhdGVfXztcblxufSkpO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYyLjAuMlxuICogKGMpIDIwMTAtMjAxNiBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyeGpzL1N1YmplY3QnKSwgcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3J4anMvU3ViamVjdCcsICdyeGpzL09ic2VydmFibGUnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5jb3JlID0gZ2xvYmFsLm5nLmNvcmUgfHwge30pLGdsb2JhbC5SeCxnbG9iYWwuUngpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMscnhqc19TdWJqZWN0LHJ4anNfT2JzZXJ2YWJsZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIGdsb2JhbFNjb3BlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gZ2xvYmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVNaWNyb1Rhc2soZm4pIHtcbiAgICAgICAgWm9uZS5jdXJyZW50LnNjaGVkdWxlTWljcm9UYXNrKCdzY2hlZHVsZU1pY3JvdGFzaycsIGZuKTtcbiAgICB9XG4gICAgLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4gICAgLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbiAgICB2YXIgZ2xvYmFsJDEgPSBnbG9iYWxTY29wZTtcbiAgICBmdW5jdGlvbiBnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlWyduYW1lJ10gfHwgdHlwZW9mIHR5cGU7XG4gICAgfVxuICAgIC8vIFRPRE86IHJlbW92ZSBjYWxscyB0byBhc3NlcnQgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudFxuICAgIC8vIE5vdGU6IENhbid0IGp1c3QgZXhwb3J0IHRoaXMgYW5kIGltcG9ydCBpbiBpbiBvdGhlciBmaWxlc1xuICAgIC8vIGFzIGBhc3NlcnRgIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCBpbiBEYXJ0XG4gICAgZ2xvYmFsJDEuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xuICAgIH07XG4gICAgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQgfHwgdG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5vdmVycmlkZGVuTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLm92ZXJyaWRkZW5OYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVJbmRleCA9PT0gLTEgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG4gICAgfVxuICAgIHZhciBTdHJpbmdXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBTdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpOyB9O1xuICAgICAgICBTdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQgPSBmdW5jdGlvbiAocywgaW5kZXgpIHsgcmV0dXJuIHMuY2hhckNvZGVBdChpbmRleCk7IH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIuc3BsaXQgPSBmdW5jdGlvbiAocywgcmVnRXhwKSB7IHJldHVybiBzLnNwbGl0KHJlZ0V4cCk7IH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKHMsIHMyKSB7IHJldHVybiBzID09PSBzMjsgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5zdHJpcExlZnQgPSBmdW5jdGlvbiAocywgY2hhclZhbCkge1xuICAgICAgICAgICAgaWYgKHMgJiYgcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNbaV0gIT0gY2hhclZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5zdHJpcFJpZ2h0ID0gZnVuY3Rpb24gKHMsIGNoYXJWYWwpIHtcbiAgICAgICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzW2ldICE9IGNoYXJWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIucmVwbGFjZSA9IGZ1bmN0aW9uIChzLCBmcm9tLCByZXBsYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIHJlcGxhY2UpO1xuICAgICAgICB9O1xuICAgICAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAocywgZnJvbSwgcmVwbGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5zbGljZSA9IGZ1bmN0aW9uIChzLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gcy5zbGljZShmcm9tLCB0byA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkID0gZnVuY3Rpb24gKHMsIGZyb20sIGNiKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvZmZzZXQgJiBzdHJpbmcgZnJvbSB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5zcGxpY2UoLTIsIDIpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayByZWNlaXZlcyBtYXRjaCwgcDEsIC4uLiwgcG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobWF0Y2hlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChzLCBzdWJzdHIpIHsgcmV0dXJuIHMuaW5kZXhPZihzdWJzdHIpICE9IC0xOyB9O1xuICAgICAgICBTdHJpbmdXcmFwcGVyLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyaW5nV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIHZhciBOdW1iZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTnVtYmVyV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBOdW1iZXJXcmFwcGVyLnRvRml4ZWQgPSBmdW5jdGlvbiAobiwgZnJhY3Rpb25EaWdpdHMpIHsgcmV0dXJuIG4udG9GaXhlZChmcmFjdGlvbkRpZ2l0cyk7IH07XG4gICAgICAgIE51bWJlcldyYXBwZXIuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnQgPSBmdW5jdGlvbiAodGV4dCwgcmFkaXgpIHtcbiAgICAgICAgICAgIGlmIChyYWRpeCA9PSAxMCkge1xuICAgICAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT9bMC05XSskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmFkaXggPT0gMTYpIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOUFCQ0RFRmFiY2RlZl0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgJyArIHRleHQgKyAnIGluIGJhc2UgJyArIHJhZGl4KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIFwiTmFOXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmFOOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5pc051bWVyaWMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTsgfTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5pc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXNOYU4odmFsdWUpOyB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7IH07XG4gICAgICAgIHJldHVybiBOdW1iZXJXcmFwcGVyO1xuICAgIH0oKSk7XG4gICAgLy8gSlMgaGFzIE5hTiAhPT0gTmFOXG4gICAgZnVuY3Rpb24gbG9vc2VJZGVudGljYWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYiB8fCB0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInICYmIGlzTmFOKGEpICYmIGlzTmFOKGIpO1xuICAgIH1cbiAgICAvLyBKUyBjb25zaWRlcnMgTmFOIGlzIHRoZSBzYW1lIGFzIE5hTiBmb3IgbWFwIEtleSAod2hpbGUgTmFOICE9PSBOYU4gb3RoZXJ3aXNlKVxuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXBcbiAgICBmdW5jdGlvbiBnZXRNYXBLZXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0pzT2JqZWN0KG8pIHtcbiAgICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvID09PSAnb2JqZWN0Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByaW50KG9iaikge1xuICAgICAgICBjb25zb2xlLmxvZyhvYmopO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuKG9iaikge1xuICAgICAgICBjb25zb2xlLndhcm4ob2JqKTtcbiAgICB9XG4gICAgdmFyIF9zeW1ib2xJdGVyYXRvciA9IG51bGw7XG4gICAgZnVuY3Rpb24gZ2V0U3ltYm9sSXRlcmF0b3IoKSB7XG4gICAgICAgIGlmIChpc0JsYW5rKF9zeW1ib2xJdGVyYXRvcikpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZ2xvYmFsU2NvcGUuU3ltYm9sKSAmJiBpc1ByZXNlbnQoU3ltYm9sLml0ZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgIF9zeW1ib2xJdGVyYXRvciA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVzNi1zaGltIHNwZWNpZmljIGxvZ2ljXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXAucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtrZXldID09PSBNYXAucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zeW1ib2xJdGVyYXRvciA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N5bWJvbEl0ZXJhdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgICAgICAgcmV0dXJuICFpc0pzT2JqZWN0KG9iaik7XG4gICAgfVxuXG4gICAgdmFyIF9uZXh0Q2xhc3NJZCA9IDA7XG4gICAgZnVuY3Rpb24gZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbikge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihhbm5vdGF0aW9uKSAmJiBhbm5vdGF0aW9uLmhhc093blByb3BlcnR5KCdhbm5vdGF0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIGl0IGlzIGEgZGVjb3JhdG9yLCBleHRyYWN0IGFubm90YXRpb25cbiAgICAgICAgICAgIGFubm90YXRpb24gPSBhbm5vdGF0aW9uLmFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5UGFyYW1zKGZuT3JBcnJheSwga2V5KSB7XG4gICAgICAgIGlmIChmbk9yQXJyYXkgPT09IE9iamVjdCB8fCBmbk9yQXJyYXkgPT09IFN0cmluZyB8fCBmbk9yQXJyYXkgPT09IEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICBmbk9yQXJyYXkgPT09IE51bWJlciB8fCBmbk9yQXJyYXkgPT09IEFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHVzZSBuYXRpdmUgXCIgKyBzdHJpbmdpZnkoZm5PckFycmF5KSArIFwiIGFzIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZuT3JBcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmbk9yQXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm5PckFycmF5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9ucyA9IGZuT3JBcnJheTtcbiAgICAgICAgICAgIHZhciBhbm5vTGVuZ3RoID0gYW5ub3RhdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciBmbiA9IGZuT3JBcnJheVthbm5vTGVuZ3RoXTtcbiAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbihmbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXN0IHBvc2l0aW9uIG9mIENsYXNzIG1ldGhvZCBhcnJheSBtdXN0IGJlIEZ1bmN0aW9uIGluIGtleSBcIiArIGtleSArIFwiIHdhcyAnXCIgKyBzdHJpbmdpZnkoZm4pICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFubm9MZW5ndGggIT0gZm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIG9mIGFubm90YXRpb25zIChcIiArIGFubm9MZW5ndGggKyBcIikgZG9lcyBub3QgbWF0Y2ggbnVtYmVyIG9mIGFyZ3VtZW50cyAoXCIgKyBmbi5sZW5ndGggKyBcIikgaW4gdGhlIGZ1bmN0aW9uOiBcIiArIHN0cmluZ2lmeShmbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcmFtc0Fubm90YXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhbm5vdGF0aW9ucy5sZW5ndGggLSAxOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgcGFyYW1zQW5ub3RhdGlvbnMucHVzaChwYXJhbUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGFubm90YXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbm5vdGF0aW9uLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbUFubm90YXRpb25zLnB1c2goZXh0cmFjdEFubm90YXRpb24oYW5ub3RhdGlvbltqXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1Bbm5vdGF0aW9ucy5wdXNoKGV4dHJhY3RBbm5vdGF0aW9uKGFubm90YXRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtQW5ub3RhdGlvbnMucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgcGFyYW1zQW5ub3RhdGlvbnMsIGZuKTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgRnVuY3Rpb24gb3IgQXJyYXkgaXMgc3VwcG9ydGVkIGluIENsYXNzIGRlZmluaXRpb24gZm9yIGtleSAnXCIgKyBrZXkgKyBcIicgaXMgJ1wiICsgc3RyaW5naWZ5KGZuT3JBcnJheSkgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSB3YXkgZm9yIGV4cHJlc3NpbmcgRVM2IGNsYXNzZXMgd2l0aCBwYXJhbWV0ZXIgYW5ub3RhdGlvbnMgaW4gRVM1LlxuICAgICAqXG4gICAgICogIyMgQmFzaWMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmFyIEdyZWV0ZXIgPSBuZy5DbGFzcyh7XG4gICAgICogICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAqICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAqICAgfSxcbiAgICAgKlxuICAgICAqICAgZ3JlZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBhbGVydCgnSGVsbG8gJyArIHRoaXMubmFtZSArICchJyk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIEVTNjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNsYXNzIEdyZWV0ZXIge1xuICAgICAqICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAqICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogICBncmVldCgpIHtcbiAgICAgKiAgICAgYWxlcnQoJ0hlbGxvICcgKyB0aGlzLm5hbWUgKyAnIScpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIG9yIGVxdWl2YWxlbnQgdG8gRVM1OlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmFyIEdyZWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAqICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBHcmVldGVyLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgKiAgIGFsZXJ0KCdIZWxsbyAnICsgdGhpcy5uYW1lICsgJyEnKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSB3aXRoIHBhcmFtZXRlciBhbm5vdGF0aW9uc1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmFyIE15U2VydmljZSA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yOiBbU3RyaW5nLCBbbmV3IFF1ZXJ5KCksIFF1ZXJ5TGlzdF0sIGZ1bmN0aW9uKG5hbWUsIHF1ZXJ5TGlzdCkge1xuICAgICAqICAgICAuLi5cbiAgICAgKiAgIH1dXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIEVTNjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNsYXNzIE15U2VydmljZSB7XG4gICAgICogICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIEBRdWVyeSgpIHF1ZXJ5TGlzdDogUXVlcnlMaXN0KSB7XG4gICAgICogICAgIC4uLlxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIHdpdGggaW5oZXJpdGFuY2VcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZhciBTaGFwZSA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yOiAoY29sb3IpIHtcbiAgICAgKiAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIFNxdWFyZSA9IG5nLkNsYXNzKHtcbiAgICAgKiAgIGV4dGVuZHM6IFNoYXBlLFxuICAgICAqICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKGNvbG9yLCBzaXplKSB7XG4gICAgICogICAgIFNoYXBlLmNhbGwodGhpcywgY29sb3IpO1xuICAgICAqICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGFzcyhjbHNEZWYpIHtcbiAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gYXBwbHlQYXJhbXMoY2xzRGVmLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpID8gY2xzRGVmLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLCAnY29uc3RydWN0b3InKTtcbiAgICAgICAgdmFyIHByb3RvID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgICBpZiAoY2xzRGVmLmhhc093blByb3BlcnR5KCdleHRlbmRzJykpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNsc0RlZi5leHRlbmRzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHByb3RvID1cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShjbHNEZWYuZXh0ZW5kcy5wcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xhc3MgZGVmaW5pdGlvbiAnZXh0ZW5kcycgcHJvcGVydHkgbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHdhczogXCIgKyBzdHJpbmdpZnkoY2xzRGVmLmV4dGVuZHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2xzRGVmKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9ICdleHRlbmRzJyAmJiBrZXkgIT0gJ3Byb3RvdHlwZScgJiYgY2xzRGVmLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBwcm90b1trZXldID0gYXBwbHlQYXJhbXMoY2xzRGVmW2tleV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5hbm5vdGF0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIHRoaXMuYW5ub3RhdGlvbnMsIGNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gY29uc3RydWN0b3JbJ25hbWUnXTtcbiAgICAgICAgaWYgKCFjb25zdHJ1Y3Rvck5hbWUgfHwgY29uc3RydWN0b3JOYW1lID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvclsnb3ZlcnJpZGRlbk5hbWUnXSA9IFwiY2xhc3NcIiArIF9uZXh0Q2xhc3NJZCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgdmFyIFJlZmxlY3QgPSBnbG9iYWwkMS5SZWZsZWN0O1xuICAgIGZ1bmN0aW9uIG1ha2VEZWNvcmF0b3IobmFtZSwgcHJvcHMsIHBhcmVudENsYXNzLCBjaGFpbkZuKSB7XG4gICAgICAgIGlmIChjaGFpbkZuID09PSB2b2lkIDApIHsgY2hhaW5GbiA9IG51bGw7IH1cbiAgICAgICAgdmFyIG1ldGFDdG9yID0gbWFrZU1ldGFkYXRhQ3RvcihbcHJvcHNdKTtcbiAgICAgICAgZnVuY3Rpb24gRGVjb3JhdG9yRmFjdG9yeShvYmpPclR5cGUpIHtcbiAgICAgICAgICAgIGlmICghKFJlZmxlY3QgJiYgUmVmbGVjdC5nZXRNZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAncmVmbGVjdC1tZXRhZGF0YSBzaGltIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgY2xhc3MgZGVjb3JhdG9ycyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIERlY29yYXRvckZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBtZXRhQ3Rvci5jYWxsKHRoaXMsIG9iak9yVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkluc3RhbmNlXzEgPSBuZXcgRGVjb3JhdG9yRmFjdG9yeShvYmpPclR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciBjaGFpbkFubm90YXRpb24gPSBpc0Z1bmN0aW9uKHRoaXMpICYmIHRoaXMuYW5ub3RhdGlvbnMgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuYW5ub3RhdGlvbnMgOiBbXTtcbiAgICAgICAgICAgICAgICBjaGFpbkFubm90YXRpb24ucHVzaChhbm5vdGF0aW9uSW5zdGFuY2VfMSk7XG4gICAgICAgICAgICAgICAgdmFyIFR5cGVEZWNvcmF0b3IgPSBmdW5jdGlvbiBUeXBlRGVjb3JhdG9yKGNscykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIGNscykgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlXzEpO1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIGFubm90YXRpb25zLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgVHlwZURlY29yYXRvci5hbm5vdGF0aW9ucyA9IGNoYWluQW5ub3RhdGlvbjtcbiAgICAgICAgICAgICAgICBUeXBlRGVjb3JhdG9yLkNsYXNzID0gQ2xhc3M7XG4gICAgICAgICAgICAgICAgaWYgKGNoYWluRm4pXG4gICAgICAgICAgICAgICAgICAgIGNoYWluRm4oVHlwZURlY29yYXRvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVEZWNvcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudENsYXNzKSB7XG4gICAgICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIChcIkBcIiArIG5hbWUpOyB9O1xuICAgICAgICBEZWNvcmF0b3JGYWN0b3J5LmFubm90YXRpb25DbHMgPSBEZWNvcmF0b3JGYWN0b3J5O1xuICAgICAgICByZXR1cm4gRGVjb3JhdG9yRmFjdG9yeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZU1ldGFkYXRhQ3Rvcihwcm9wcykge1xuICAgICAgICBmdW5jdGlvbiBjdG9yKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ1ZhbCA9IGFyZ3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhaW4gcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSAhYXJnVmFsIHx8IGFyZ1ZhbCA9PT0gdW5kZWZpbmVkID8gcHJvcFsxXSA6IGFyZ1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNbcHJvcFswXV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gIWFyZ1ZhbCB8fCBhcmdWYWxbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgPyBwcm9wW3Byb3BOYW1lXSA6IGFyZ1ZhbFtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpc1twcm9wTmFtZV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3RvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVBhcmFtRGVjb3JhdG9yKG5hbWUsIHByb3BzLCBwYXJlbnRDbGFzcykge1xuICAgICAgICB2YXIgbWV0YUN0b3IgPSBtYWtlTWV0YWRhdGFDdG9yKHByb3BzKTtcbiAgICAgICAgZnVuY3Rpb24gUGFyYW1EZWNvcmF0b3JGYWN0b3J5KCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUGFyYW1EZWNvcmF0b3JGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgbWV0YUN0b3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkluc3RhbmNlID0gbmV3ICgoX2EgPSBQYXJhbURlY29yYXRvckZhY3RvcnkpLmJpbmQuYXBwbHkoX2EsIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICAgICAgICBQYXJhbURlY29yYXRvci5hbm5vdGF0aW9uID0gYW5ub3RhdGlvbkluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIFBhcmFtRGVjb3JhdG9yO1xuICAgICAgICAgICAgZnVuY3Rpb24gUGFyYW1EZWNvcmF0b3IoY2xzLCB1bnVzZWRLZXksIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBSZWZsZWN0LmdldE1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgY2xzKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBtaWdodCBiZSBnYXBzIGlmIHNvbWUgaW4gYmV0d2VlbiBwYXJhbWV0ZXJzIGRvIG5vdCBoYXZlIGFubm90YXRpb25zLlxuICAgICAgICAgICAgICAgIC8vIHdlIHBhZCB3aXRoIG51bGxzLlxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJhbWV0ZXJzLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbaW5kZXhdID0gcGFyYW1ldGVyc1tpbmRleF0gfHwgW107XG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25zRm9yUGFyYW0gPSBwYXJhbWV0ZXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uc0ZvclBhcmFtLnB1c2goYW5ub3RhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKCdwYXJhbWV0ZXJzJywgcGFyYW1ldGVycywgY2xzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRDbGFzcykge1xuICAgICAgICAgICAgUGFyYW1EZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBQYXJhbURlY29yYXRvckZhY3RvcnkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFwiQFwiICsgbmFtZSk7IH07XG4gICAgICAgIFBhcmFtRGVjb3JhdG9yRmFjdG9yeS5hbm5vdGF0aW9uQ2xzID0gUGFyYW1EZWNvcmF0b3JGYWN0b3J5O1xuICAgICAgICByZXR1cm4gUGFyYW1EZWNvcmF0b3JGYWN0b3J5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUHJvcERlY29yYXRvcihuYW1lLCBwcm9wcywgcGFyZW50Q2xhc3MpIHtcbiAgICAgICAgdmFyIG1ldGFDdG9yID0gbWFrZU1ldGFkYXRhQ3Rvcihwcm9wcyk7XG4gICAgICAgIGZ1bmN0aW9uIFByb3BEZWNvcmF0b3JGYWN0b3J5KCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUHJvcERlY29yYXRvckZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBtZXRhQ3Rvci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3JJbnN0YW5jZSA9IG5ldyAoKF9hID0gUHJvcERlY29yYXRvckZhY3RvcnkpLmJpbmQuYXBwbHkoX2EsIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIFByb3BEZWNvcmF0b3IodGFyZ2V0LCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRhID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdGFyZ2V0LmNvbnN0cnVjdG9yKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgbWV0YVtuYW1lXSA9IG1ldGFbbmFtZV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIG1ldGFbbmFtZV0udW5zaGlmdChkZWNvcmF0b3JJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoJ3Byb3BNZXRhZGF0YScsIG1ldGEsIHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50Q2xhc3MpIHtcbiAgICAgICAgICAgIFByb3BEZWNvcmF0b3JGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50Q2xhc3MucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBQcm9wRGVjb3JhdG9yRmFjdG9yeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoXCJAXCIgKyBuYW1lKTsgfTtcbiAgICAgICAgUHJvcERlY29yYXRvckZhY3RvcnkuYW5ub3RhdGlvbkNscyA9IFByb3BEZWNvcmF0b3JGYWN0b3J5O1xuICAgICAgICByZXR1cm4gUHJvcERlY29yYXRvckZhY3Rvcnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5qZWN0IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgSW5qZWN0ID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdJbmplY3QnLCBbWyd0b2tlbicsIHVuZGVmaW5lZF1dKTtcbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIE9wdGlvbmFsID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdPcHRpb25hbCcsIFtdKTtcbiAgICAvKipcbiAgICAgKiBJbmplY3RhYmxlIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgSW5qZWN0YWJsZSA9IG1ha2VQYXJhbURlY29yYXRvcignSW5qZWN0YWJsZScsIFtdKTtcbiAgICAvKipcbiAgICAgKiBTZWxmIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgU2VsZiA9IG1ha2VQYXJhbURlY29yYXRvcignU2VsZicsIFtdKTtcbiAgICAvKipcbiAgICAgKiBTa2lwU2VsZiBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIFNraXBTZWxmID0gbWFrZVBhcmFtRGVjb3JhdG9yKCdTa2lwU2VsZicsIFtdKTtcbiAgICAvKipcbiAgICAgKiBIb3N0IGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgSG9zdCA9IG1ha2VQYXJhbURlY29yYXRvcignSG9zdCcsIFtdKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIGluIGEgREkgUHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvWXM5ZXpYcGoyTW5veTNVYzhLQnA/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB2YXIgdCA9IG5ldyBPcGFxdWVUb2tlbihcInZhbHVlXCIpO1xuICAgICAqXG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICogICB7cHJvdmlkZTogdCwgdXNlVmFsdWU6IFwiYmluZGluZ1ZhbHVlXCJ9XG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoaW5qZWN0b3IuZ2V0KHQpKS50b0VxdWFsKFwiYmluZGluZ1ZhbHVlXCIpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVXNpbmcgYW4gYE9wYXF1ZVRva2VuYCBpcyBwcmVmZXJhYmxlIHRvIHVzaW5nIHN0cmluZ3MgYXMgdG9rZW5zIGJlY2F1c2Ugb2YgcG9zc2libGUgY29sbGlzaW9uc1xuICAgICAqIGNhdXNlZCBieSBtdWx0aXBsZSBwcm92aWRlcnMgdXNpbmcgdGhlIHNhbWUgc3RyaW5nIGFzIHR3byBkaWZmZXJlbnQgdG9rZW5zLlxuICAgICAqXG4gICAgICogVXNpbmcgYW4gYE9wYXF1ZVRva2VuYCBpcyBwcmVmZXJhYmxlIHRvIHVzaW5nIGFuIGBPYmplY3RgIGFzIHRva2VucyBiZWNhdXNlIGl0IHByb3ZpZGVzIGJldHRlclxuICAgICAqIGVycm9yIG1lc3NhZ2VzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICAvLyBzbyB0aGF0IG1ldGFkYXRhIGlzIGdhdGhlcmVkIGZvciB0aGlzIGNsYXNzXG4gICAgdmFyIE9wYXF1ZVRva2VuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT3BhcXVlVG9rZW4oX2Rlc2MpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2MgPSBfZGVzYztcbiAgICAgICAgfVxuICAgICAgICBPcGFxdWVUb2tlbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlRva2VuIFwiICsgdGhpcy5fZGVzYzsgfTtcbiAgICAgICAgT3BhcXVlVG9rZW4uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgT3BhcXVlVG9rZW4uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gT3BhcXVlVG9rZW47XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgdG9rZW4gY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgdmlydHVhbCBwcm92aWRlciB0aGF0IHdpbGwgcG9wdWxhdGUgdGhlXG4gICAgICogYGVudHJ5Q29tcG9uZW50c2AgZmllbGRzIG9mIGNvbXBvbmVudHMgYW5kIG5nIG1vZHVsZXMgYmFzZWQgb24gaXRzIGB1c2VWYWx1ZWAuXG4gICAgICogQWxsIGNvbXBvbmVudHMgdGhhdCBhcmUgcmVmZXJlbmNlZCBpbiB0aGUgYHVzZVZhbHVlYCB2YWx1ZSAoZWl0aGVyIGRpcmVjdGx5XG4gICAgICogb3IgaW4gYSBuZXN0ZWQgYXJyYXkgb3IgbWFwKSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBgZW50cnlDb21wb25lbnRzYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0aGUgcm91dGVyIGNhbiBwb3B1bGF0ZSB0aGUgYGVudHJ5Q29tcG9uZW50c2BcbiAgICAgKiBmaWVsZCBvZiBhbiBOZ01vZHVsZSBiYXNlZCBvbiB0aGUgcm91dGVyIGNvbmZpZ3VyYXRpb24gd2hpY2ggcmVmZXJzXG4gICAgICogdG8gY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBoZWxwZXIgZnVuY3Rpb24gaW5zaWRlIHRoZSByb3V0ZXJcbiAgICAgKiBmdW5jdGlvbiBwcm92aWRlUm91dGVzKHJvdXRlcykge1xuICAgICAqICAgcmV0dXJuIFtcbiAgICAgKiAgICAge3Byb3ZpZGU6IFJPVVRFUywgdXNlVmFsdWU6IHJvdXRlc30sXG4gICAgICogICAgIHtwcm92aWRlOiBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTLCB1c2VWYWx1ZTogcm91dGVzLCBtdWx0aTogdHJ1ZX1cbiAgICAgKiAgIF07XG4gICAgICogfVxuICAgICAqXG4gICAgICogLy8gdXNlciBjb2RlXG4gICAgICogbGV0IHJvdXRlcyA9IFtcbiAgICAgKiAgIHtwYXRoOiAnL3Jvb3QnLCBjb21wb25lbnQ6IFJvb3RDb21wfSxcbiAgICAgKiAgIHtwYXRoOiAnL3RlYW1zJywgY29tcG9uZW50OiBUZWFtc0NvbXB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBwcm92aWRlcnM6IFtwcm92aWRlUm91dGVzKHJvdXRlcyldXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNb2R1bGVXaXRoUm91dGVzIHt9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMgPSBuZXcgT3BhcXVlVG9rZW4oJ0FuYWx5emVGb3JFbnRyeUNvbXBvbmVudHMnKTtcbiAgICAvKipcbiAgICAgKiBBdHRyaWJ1dGUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBBdHRyaWJ1dGUgPSBtYWtlUGFyYW1EZWNvcmF0b3IoJ0F0dHJpYnV0ZScsIFtbJ2F0dHJpYnV0ZU5hbWUnLCB1bmRlZmluZWRdXSk7XG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgcXVlcnkgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIENvbnRlbnRDaGlsZHJlbn0sIHtAbGluayBDb250ZW50Q2hpbGR9LCB7QGxpbmsgVmlld0NoaWxkcmVufSwge0BsaW5rIFZpZXdDaGlsZH0gZm9yXG4gICAgICogbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUXVlcnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBRdWVyeSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUXVlcnk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBDb250ZW50Q2hpbGRyZW4gZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICogIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIENvbnRlbnRDaGlsZHJlbiA9IG1ha2VQcm9wRGVjb3JhdG9yKCdDb250ZW50Q2hpbGRyZW4nLCBbXG4gICAgICAgIFsnc2VsZWN0b3InLCB1bmRlZmluZWRdLCB7XG4gICAgICAgICAgICBmaXJzdDogZmFsc2UsXG4gICAgICAgICAgICBpc1ZpZXdRdWVyeTogZmFsc2UsXG4gICAgICAgICAgICBkZXNjZW5kYW50czogZmFsc2UsXG4gICAgICAgICAgICByZWFkOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICBdLCBRdWVyeSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ29uZmlndXJlcyBhIGNvbnRlbnQgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2RpL3RzL2NvbnRlbnRDaGlsZC9jb250ZW50X2NoaWxkX2hvd3RvLnRzIHJlZ2lvbj0nSG93VG8nfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSBDb250ZW50Q2hpbGQgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9yIHRoZSBkaXJlY3RpdmUgbWF0Y2hpbmcgdGhlIHNlbGVjdG9yIGZyb20gdGhlXG4gICAgICogY29udGVudCBET00uIElmIHRoZSBjb250ZW50IERPTSBjaGFuZ2VzLCBhbmQgYSBuZXcgY2hpbGQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IsXG4gICAgICogdGhlIHByb3BlcnR5IHdpbGwgYmUgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIENvbnRlbnQgcXVlcmllcyBhcmUgc2V0IGJlZm9yZSB0aGUgYG5nQWZ0ZXJDb250ZW50SW5pdGAgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogKipNZXRhZGF0YSBQcm9wZXJ0aWVzKio6XG4gICAgICpcbiAgICAgKiAqICoqc2VsZWN0b3IqKiAtIHRoZSBkaXJlY3RpdmUgdHlwZSBvciB0aGUgbmFtZSB1c2VkIGZvciBxdWVyeWluZy5cbiAgICAgKiAqICoqcmVhZCoqIC0gcmVhZCBhIGRpZmZlcmVudCB0b2tlbiBmcm9tIHRoZSBxdWVyaWVkIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBMZXQncyBsb29rIGF0IGFuIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy9jb250ZW50Q2hpbGQvY29udGVudF9jaGlsZF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2NvcmVgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgQ29udGVudENoaWxkID0gbWFrZVByb3BEZWNvcmF0b3IoJ0NvbnRlbnRDaGlsZCcsIFtcbiAgICAgICAgWydzZWxlY3RvcicsIHVuZGVmaW5lZF0sIHtcbiAgICAgICAgICAgIGZpcnN0OiB0cnVlLFxuICAgICAgICAgICAgaXNWaWV3UXVlcnk6IGZhbHNlLFxuICAgICAgICAgICAgZGVzY2VuZGFudHM6IHRydWUsXG4gICAgICAgICAgICByZWFkOiB1bmRlZmluZWQsXG4gICAgICAgIH1cbiAgICBdLCBRdWVyeSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ29uZmlndXJlcyBhIHZpZXcgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2RpL3RzL3ZpZXdDaGlsZHJlbi92aWV3X2NoaWxkcmVuX2hvd3RvLnRzIHJlZ2lvbj0nSG93VG8nfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSBWaWV3Q2hpbGRyZW4gdG8gZ2V0IHRoZSB7QGxpbmsgUXVlcnlMaXN0fSBvZiBlbGVtZW50cyBvciBkaXJlY3RpdmVzIGZyb20gdGhlXG4gICAgICogdmlldyBET00uIEFueSB0aW1lIGEgY2hpbGQgZWxlbWVudCBpcyBhZGRlZCwgcmVtb3ZlZCwgb3IgbW92ZWQsIHRoZSBxdWVyeSBsaXN0IHdpbGwgYmUgdXBkYXRlZCxcbiAgICAgKiBhbmQgdGhlIGNoYW5nZXMgb2JzZXJ2YWJsZSBvZiB0aGUgcXVlcnkgbGlzdCB3aWxsIGVtaXQgYSBuZXcgdmFsdWUuXG4gICAgICpcbiAgICAgKiBWaWV3IHF1ZXJpZXMgYXJlIHNldCBiZWZvcmUgdGhlIGBuZ0FmdGVyVmlld0luaXRgIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgICAgKlxuICAgICAqICoqTWV0YWRhdGEgUHJvcGVydGllcyoqOlxuICAgICAqXG4gICAgICogKiAqKnNlbGVjdG9yKiogLSB0aGUgZGlyZWN0aXZlIHR5cGUgb3IgdGhlIG5hbWUgdXNlZCBmb3IgcXVlcnlpbmcuXG4gICAgICogKiAqKnJlYWQqKiAtIHJlYWQgYSBkaWZmZXJlbnQgdG9rZW4gZnJvbSB0aGUgcXVlcmllZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIExldCdzIGxvb2sgYXQgYW4gZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2RpL3RzL3ZpZXdDaGlsZHJlbi92aWV3X2NoaWxkcmVuX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvY29yZWBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBWaWV3Q2hpbGRyZW4gPSBtYWtlUHJvcERlY29yYXRvcignVmlld0NoaWxkcmVuJywgW1xuICAgICAgICBbJ3NlbGVjdG9yJywgdW5kZWZpbmVkXSwge1xuICAgICAgICAgICAgZmlyc3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNWaWV3UXVlcnk6IHRydWUsXG4gICAgICAgICAgICBkZXNjZW5kYW50czogdHJ1ZSxcbiAgICAgICAgICAgIHJlYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfVxuICAgIF0sIFF1ZXJ5KTtcbiAgICAvKipcbiAgICAgKiBWaWV3Q2hpbGQgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBWaWV3Q2hpbGQgPSBtYWtlUHJvcERlY29yYXRvcignVmlld0NoaWxkJywgW1xuICAgICAgICBbJ3NlbGVjdG9yJywgdW5kZWZpbmVkXSwge1xuICAgICAgICAgICAgZmlyc3Q6IHRydWUsXG4gICAgICAgICAgICBpc1ZpZXdRdWVyeTogdHJ1ZSxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiB0cnVlLFxuICAgICAgICAgICAgcmVhZDogdW5kZWZpbmVkLFxuICAgICAgICB9XG4gICAgXSwgUXVlcnkpO1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIHdpdGhpbiB0aGUgY2hhbmdlIGRldGVjdG9yIHdoaWNoIHN0cmF0ZWd5IHdpbGwgYmUgdXNlZCB0aGUgbmV4dCB0aW1lIGNoYW5nZVxuICAgICAqIGRldGVjdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7XG4gICAgKGZ1bmN0aW9uIChDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogYE9uUHVzaGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yJ3MgbW9kZSB3aWxsIGJlIHNldCB0byBgQ2hlY2tPbmNlYCBkdXJpbmcgaHlkcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbXCJPblB1c2hcIl0gPSAwXSA9IFwiT25QdXNoXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgRGVmYXVsdGAgbWVhbnMgdGhhdCB0aGUgY2hhbmdlIGRldGVjdG9yJ3MgbW9kZSB3aWxsIGJlIHNldCB0byBgQ2hlY2tBbHdheXNgIGR1cmluZyBoeWRyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIkRlZmF1bHRcIl0gPSAxXSA9IFwiRGVmYXVsdFwiO1xuICAgIH0pKGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB0aGUgc3RhdHVzIG9mIHRoZSBkZXRlY3Rvci5cbiAgICAgKi9cbiAgICB2YXIgQ2hhbmdlRGV0ZWN0b3JTdGF0dXM7XG4gICAgKGZ1bmN0aW9uIChDaGFuZ2VEZXRlY3RvclN0YXR1cykge1xuICAgICAgICAvKipcbiAgICAgICAgICogYENoZWNrZWRPbmNlYCBtZWFucyB0aGF0IGFmdGVyIGNhbGxpbmcgZGV0ZWN0Q2hhbmdlcyB0aGUgbW9kZSBvZiB0aGUgY2hhbmdlIGRldGVjdG9yXG4gICAgICAgICAqIHdpbGwgYmVjb21lIGBDaGVja2VkYC5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzW1wiQ2hlY2tPbmNlXCJdID0gMF0gPSBcIkNoZWNrT25jZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYENoZWNrZWRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvciBzaG91bGQgYmUgc2tpcHBlZCB1bnRpbCBpdHMgbW9kZSBjaGFuZ2VzIHRvXG4gICAgICAgICAqIGBDaGVja09uY2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJDaGVja2VkXCJdID0gMV0gPSBcIkNoZWNrZWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBDaGVja0Fsd2F5c2AgbWVhbnMgdGhhdCBhZnRlciBjYWxsaW5nIGRldGVjdENoYW5nZXMgdGhlIG1vZGUgb2YgdGhlIGNoYW5nZSBkZXRlY3RvclxuICAgICAgICAgKiB3aWxsIHJlbWFpbiBgQ2hlY2tBbHdheXNgLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJDaGVja0Fsd2F5c1wiXSA9IDJdID0gXCJDaGVja0Fsd2F5c1wiO1xuICAgICAgICAvKipcbiAgICAgICAgICogYERldGFjaGVkYCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3Igc3ViIHRyZWUgaXMgbm90IGEgcGFydCBvZiB0aGUgbWFpbiB0cmVlIGFuZFxuICAgICAgICAgKiBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICAgICAgICovXG4gICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzW0NoYW5nZURldGVjdG9yU3RhdHVzW1wiRGV0YWNoZWRcIl0gPSAzXSA9IFwiRGV0YWNoZWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBFcnJvcmVkYCBtZWFucyB0aGF0IHRoZSBjaGFuZ2UgZGV0ZWN0b3IgZW5jb3VudGVyZWQgYW4gZXJyb3IgY2hlY2tpbmcgYSBiaW5kaW5nXG4gICAgICAgICAqIG9yIGNhbGxpbmcgYSBkaXJlY3RpdmUgbGlmZWN5Y2xlIG1ldGhvZCBhbmQgaXMgbm93IGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gQ2hhbmdlXG4gICAgICAgICAqIGRldGVjdG9ycyBpbiB0aGlzIHN0YXRlIHdpbGwgbm8gbG9uZ2VyIGRldGVjdCBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbQ2hhbmdlRGV0ZWN0b3JTdGF0dXNbXCJFcnJvcmVkXCJdID0gNF0gPSBcIkVycm9yZWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBEZXN0cm95ZWRgIG1lYW5zIHRoYXQgdGhlIGNoYW5nZSBkZXRlY3RvciBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBDaGFuZ2VEZXRlY3RvclN0YXR1c1tDaGFuZ2VEZXRlY3RvclN0YXR1c1tcIkRlc3Ryb3llZFwiXSA9IDVdID0gXCJEZXN0cm95ZWRcIjtcbiAgICB9KShDaGFuZ2VEZXRlY3RvclN0YXR1cyB8fCAoQ2hhbmdlRGV0ZWN0b3JTdGF0dXMgPSB7fSkpO1xuICAgIGZ1bmN0aW9uIGlzRGVmYXVsdENoYW5nZURldGVjdGlvblN0cmF0ZWd5KGNoYW5nZURldGVjdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgIHJldHVybiBpc0JsYW5rKGNoYW5nZURldGVjdGlvblN0cmF0ZWd5KSB8fFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPT09IGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXJlY3RpdmUgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBEaXJlY3RpdmUgPSBtYWtlRGVjb3JhdG9yKCdEaXJlY3RpdmUnLCB7XG4gICAgICAgIHNlbGVjdG9yOiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0czogdW5kZWZpbmVkLFxuICAgICAgICBvdXRwdXRzOiB1bmRlZmluZWQsXG4gICAgICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJvdmlkZXJzOiB1bmRlZmluZWQsXG4gICAgICAgIGV4cG9ydEFzOiB1bmRlZmluZWQsXG4gICAgICAgIHF1ZXJpZXM6IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENvbXBvbmVudCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIENvbXBvbmVudCA9IG1ha2VEZWNvcmF0b3IoJ0NvbXBvbmVudCcsIHtcbiAgICAgICAgc2VsZWN0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXRzOiB1bmRlZmluZWQsXG4gICAgICAgIG91dHB1dHM6IHVuZGVmaW5lZCxcbiAgICAgICAgaG9zdDogdW5kZWZpbmVkLFxuICAgICAgICBleHBvcnRBczogdW5kZWZpbmVkLFxuICAgICAgICBtb2R1bGVJZDogdW5kZWZpbmVkLFxuICAgICAgICBwcm92aWRlcnM6IHVuZGVmaW5lZCxcbiAgICAgICAgdmlld1Byb3ZpZGVyczogdW5kZWZpbmVkLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcbiAgICAgICAgcXVlcmllczogdW5kZWZpbmVkLFxuICAgICAgICB0ZW1wbGF0ZVVybDogdW5kZWZpbmVkLFxuICAgICAgICB0ZW1wbGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBzdHlsZVVybHM6IHVuZGVmaW5lZCxcbiAgICAgICAgc3R5bGVzOiB1bmRlZmluZWQsXG4gICAgICAgIGFuaW1hdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAgICAgZW5jYXBzdWxhdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICBpbnRlcnBvbGF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGVudHJ5Q29tcG9uZW50czogdW5kZWZpbmVkXG4gICAgfSwgRGlyZWN0aXZlKTtcbiAgICAvKipcbiAgICAgKiBQaXBlIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgUGlwZSA9IG1ha2VEZWNvcmF0b3IoJ1BpcGUnLCB7XG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcHVyZTogdHJ1ZSxcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBJbnB1dCBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIElucHV0ID0gbWFrZVByb3BEZWNvcmF0b3IoJ0lucHV0JywgW1snYmluZGluZ1Byb3BlcnR5TmFtZScsIHVuZGVmaW5lZF1dKTtcbiAgICAvKipcbiAgICAgKiBPdXRwdXQgZGVjb3JhdG9yIGFuZCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKiBAQW5ub3RhdGlvblxuICAgICAqL1xuICAgIHZhciBPdXRwdXQgPSBtYWtlUHJvcERlY29yYXRvcignT3V0cHV0JywgW1snYmluZGluZ1Byb3BlcnR5TmFtZScsIHVuZGVmaW5lZF1dKTtcbiAgICAvKipcbiAgICAgKiBIb3N0QmluZGluZyBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIEhvc3RCaW5kaW5nID0gbWFrZVByb3BEZWNvcmF0b3IoJ0hvc3RCaW5kaW5nJywgW1snaG9zdFByb3BlcnR5TmFtZScsIHVuZGVmaW5lZF1dKTtcbiAgICAvKipcbiAgICAgKiBIb3N0QmluZGluZyBkZWNvcmF0b3IgYW5kIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqIEBBbm5vdGF0aW9uXG4gICAgICovXG4gICAgdmFyIEhvc3RMaXN0ZW5lciA9IG1ha2VQcm9wRGVjb3JhdG9yKCdIb3N0TGlzdGVuZXInLCBbWydldmVudE5hbWUnLCB1bmRlZmluZWRdLCBbJ2FyZ3MnLCBbXV1dKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIExpZmVjeWNsZUhvb2tzO1xuICAgIChmdW5jdGlvbiAoTGlmZWN5Y2xlSG9va3MpIHtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJPbkluaXRcIl0gPSAwXSA9IFwiT25Jbml0XCI7XG4gICAgICAgIExpZmVjeWNsZUhvb2tzW0xpZmVjeWNsZUhvb2tzW1wiT25EZXN0cm95XCJdID0gMV0gPSBcIk9uRGVzdHJveVwiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIkRvQ2hlY2tcIl0gPSAyXSA9IFwiRG9DaGVja1wiO1xuICAgICAgICBMaWZlY3ljbGVIb29rc1tMaWZlY3ljbGVIb29rc1tcIk9uQ2hhbmdlc1wiXSA9IDNdID0gXCJPbkNoYW5nZXNcIjtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJBZnRlckNvbnRlbnRJbml0XCJdID0gNF0gPSBcIkFmdGVyQ29udGVudEluaXRcIjtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJBZnRlckNvbnRlbnRDaGVja2VkXCJdID0gNV0gPSBcIkFmdGVyQ29udGVudENoZWNrZWRcIjtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJBZnRlclZpZXdJbml0XCJdID0gNl0gPSBcIkFmdGVyVmlld0luaXRcIjtcbiAgICAgICAgTGlmZWN5Y2xlSG9va3NbTGlmZWN5Y2xlSG9va3NbXCJBZnRlclZpZXdDaGVja2VkXCJdID0gN10gPSBcIkFmdGVyVmlld0NoZWNrZWRcIjtcbiAgICB9KShMaWZlY3ljbGVIb29rcyB8fCAoTGlmZWN5Y2xlSG9va3MgPSB7fSkpO1xuICAgIHZhciBMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTID0gW1xuICAgICAgICBMaWZlY3ljbGVIb29rcy5PbkluaXQsIExpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSwgTGlmZWN5Y2xlSG9va3MuRG9DaGVjaywgTGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzLFxuICAgICAgICBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0LCBMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRDaGVja2VkLCBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0LFxuICAgICAgICBMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkXG4gICAgXTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCB3aGVuIGFueSBkYXRhLWJvdW5kIHByb3BlcnR5IG9mIGEgZGlyZWN0aXZlIGNoYW5nZXMuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdPbkNoYW5nZXMnfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogYG5nT25DaGFuZ2VzYCBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgdGhlIGRhdGEtYm91bmQgcHJvcGVydGllcyBoYXZlIGJlZW4gY2hlY2tlZCBhbmQgYmVmb3JlIHZpZXdcbiAgICAgKiBhbmQgY29udGVudCBjaGlsZHJlbiBhcmUgY2hlY2tlZCBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlbSBoYXMgY2hhbmdlZC5cbiAgICAgKiBUaGUgYGNoYW5nZXNgIHBhcmFtZXRlciBjb250YWlucyB0aGUgY2hhbmdlZCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzI29uY2hhbmdlcyBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgT25DaGFuZ2VzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gT25DaGFuZ2VzKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPbkNoYW5nZXM7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCBhZnRlciBkYXRhLWJvdW5kIHByb3BlcnRpZXMgb2YgYSBkaXJlY3RpdmUgYXJlXG4gICAgICogaW5pdGlhbGl6ZWQuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdPbkluaXQnfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogYG5nT25Jbml0YCBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgdGhlIGRpcmVjdGl2ZSdzIGRhdGEtYm91bmQgcHJvcGVydGllcyBoYXZlIGJlZW4gY2hlY2tlZCBmb3IgdGhlXG4gICAgICogZmlyc3QgdGltZSwgYW5kIGJlZm9yZSBhbnkgb2YgaXRzIGNoaWxkcmVuIGhhdmUgYmVlbiBjaGVja2VkLiBJdCBpcyBpbnZva2VkIG9ubHkgb25jZSB3aGVuIHRoZVxuICAgICAqIGRpcmVjdGl2ZSBpcyBpbnN0YW50aWF0ZWQuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE9uSW5pdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE9uSW5pdCgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT25Jbml0O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBBbmd1bGFyIGRpcnR5IGNoZWNrcyBhIGRpcmVjdGl2ZS5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J0RvQ2hlY2snfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogYG5nRG9DaGVja2AgZ2V0cyBjYWxsZWQgdG8gY2hlY2sgdGhlIGNoYW5nZXMgaW4gdGhlIGRpcmVjdGl2ZXMgaW4gYWRkaXRpb24gdG8gdGhlIGRlZmF1bHRcbiAgICAgKiBhbGdvcml0aG0uIFRoZSBkZWZhdWx0IGNoYW5nZSBkZXRlY3Rpb24gYWxnb3JpdGhtIGxvb2tzIGZvciBkaWZmZXJlbmNlcyBieSBjb21wYXJpbmdcbiAgICAgKiBib3VuZC1wcm9wZXJ0eSB2YWx1ZXMgYnkgcmVmZXJlbmNlIGFjcm9zcyBjaGFuZ2UgZGV0ZWN0aW9uIHJ1bnMuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgYSBkaXJlY3RpdmUgdHlwaWNhbGx5IHNob3VsZCBub3QgdXNlIGJvdGggYERvQ2hlY2tgIGFuZCB7QGxpbmsgT25DaGFuZ2VzfSB0byByZXNwb25kIHRvXG4gICAgICogY2hhbmdlcyBvbiB0aGUgc2FtZSBpbnB1dCwgYXMgYG5nT25DaGFuZ2VzYCB3aWxsIGNvbnRpbnVlIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBkZWZhdWx0IGNoYW5nZVxuICAgICAqIGRldGVjdG9yIGRldGVjdHMgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBhbmQge0BsaW5rIEl0ZXJhYmxlRGlmZmVyc30gZm9yIGltcGxlbWVudGluZyBjdXN0b20gZGlydHkgY2hlY2tpbmdcbiAgICAgKiBmb3IgY29sbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MjZG9jaGVjayBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRG9DaGVjayA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERvQ2hlY2soKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERvQ2hlY2s7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBMaWZlY3ljbGUgaG9vayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgZGlyZWN0aXZlIG9yIHBpcGUgaXMgZGVzdHJveWVkLlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nT25EZXN0cm95J31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIGBuZ09uRGVzdHJveWAgY2FsbGJhY2sgaXMgdHlwaWNhbGx5IHVzZWQgZm9yIGFueSBjdXN0b20gY2xlYW51cCB0aGF0IG5lZWRzIHRvIG9jY3VyIHdoZW4gdGhlXG4gICAgICogaW5zdGFuY2UgaXMgZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogU2VlIHtAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzIFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBPbkRlc3Ryb3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBPbkRlc3Ryb3koKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9uRGVzdHJveTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgYSBkaXJlY3RpdmUncyBjb250ZW50IGhhcyBiZWVuIGZ1bGx5XG4gICAgICogaW5pdGlhbGl6ZWQuXG4gICAgICogQGhvd1RvVXNlXG4gICAgICoge0BleGFtcGxlIGNvcmUvdHMvbWV0YWRhdGEvbGlmZWN5Y2xlX2hvb2tzX3NwZWMudHMgcmVnaW9uPSdBZnRlckNvbnRlbnRJbml0J31cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNlZSB7QGxpbmtEb2NzIGd1aWRlL2xpZmVjeWNsZS1ob29rcyNhZnRlcmNvbnRlbnQgXCJMaWZlY3ljbGUgSG9va3MgR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFmdGVyQ29udGVudEluaXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBZnRlckNvbnRlbnRJbml0O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgTGlmZWN5Y2xlIGhvb2sgdGhhdCBpcyBjYWxsZWQgYWZ0ZXIgZXZlcnkgY2hlY2sgb2YgYSBkaXJlY3RpdmUncyBjb250ZW50LlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nQWZ0ZXJDb250ZW50Q2hlY2tlZCd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MjYWZ0ZXJjb250ZW50IFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBZnRlckNvbnRlbnRDaGVja2VkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWZ0ZXJDb250ZW50Q2hlY2tlZDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGEgY29tcG9uZW50J3MgdmlldyBoYXMgYmVlbiBmdWxseVxuICAgICAqIGluaXRpYWxpemVkLlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqIHtAZXhhbXBsZSBjb3JlL3RzL21ldGFkYXRhL2xpZmVjeWNsZV9ob29rc19zcGVjLnRzIHJlZ2lvbj0nQWZ0ZXJWaWV3SW5pdCd9XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZWUge0BsaW5rRG9jcyBndWlkZS9saWZlY3ljbGUtaG9va3MjYWZ0ZXJ2aWV3IFwiTGlmZWN5Y2xlIEhvb2tzIEd1aWRlXCJ9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBZnRlclZpZXdJbml0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWZ0ZXJWaWV3SW5pdDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIExpZmVjeWNsZSBob29rIHRoYXQgaXMgY2FsbGVkIGFmdGVyIGV2ZXJ5IGNoZWNrIG9mIGEgY29tcG9uZW50J3Mgdmlldy5cbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKiB7QGV4YW1wbGUgY29yZS90cy9tZXRhZGF0YS9saWZlY3ljbGVfaG9va3Nfc3BlYy50cyByZWdpb249J0FmdGVyVmlld0NoZWNrZWQnfVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2VlIHtAbGlua0RvY3MgZ3VpZGUvbGlmZWN5Y2xlLWhvb2tzI2FmdGVydmlldyBcIkxpZmVjeWNsZSBIb29rcyBHdWlkZVwifS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWZ0ZXJWaWV3Q2hlY2tlZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFmdGVyVmlld0NoZWNrZWQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgYSBzY2hlbWEgdGhhdCB3aWxsIGFsbG93OlxuICAgICAqIC0gYW55IG5vbi1Bbmd1bGFyIGVsZW1lbnRzIHdpdGggYSBgLWAgaW4gdGhlaXIgbmFtZSxcbiAgICAgKiAtIGFueSBwcm9wZXJ0aWVzIG9uIGVsZW1lbnRzIHdpdGggYSBgLWAgaW4gdGhlaXIgbmFtZSB3aGljaCBpcyB0aGUgY29tbW9uIHJ1bGUgZm9yIGN1c3RvbVxuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDVVNUT01fRUxFTUVOVFNfU0NIRU1BID0ge1xuICAgICAgICBuYW1lOiAnY3VzdG9tLWVsZW1lbnRzJ1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIHNjaGVtYSB0aGF0IHdpbGwgYWxsb3cgYW55IHByb3BlcnR5IG9uIGFueSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOT19FUlJPUlNfU0NIRU1BID0ge1xuICAgICAgICBuYW1lOiAnbm8tZXJyb3JzLXNjaGVtYSdcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5nTW9kdWxlIGRlY29yYXRvciBhbmQgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICogQEFubm90YXRpb25cbiAgICAgKi9cbiAgICB2YXIgTmdNb2R1bGUgPSBtYWtlRGVjb3JhdG9yKCdOZ01vZHVsZScsIHtcbiAgICAgICAgcHJvdmlkZXJzOiB1bmRlZmluZWQsXG4gICAgICAgIGRlY2xhcmF0aW9uczogdW5kZWZpbmVkLFxuICAgICAgICBpbXBvcnRzOiB1bmRlZmluZWQsXG4gICAgICAgIGV4cG9ydHM6IHVuZGVmaW5lZCxcbiAgICAgICAgZW50cnlDb21wb25lbnRzOiB1bmRlZmluZWQsXG4gICAgICAgIGJvb3RzdHJhcDogdW5kZWZpbmVkLFxuICAgICAgICBzY2hlbWFzOiB1bmRlZmluZWQsXG4gICAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB0ZW1wbGF0ZSBhbmQgc3R5bGUgZW5jYXBzdWxhdGlvbiBvcHRpb25zIGF2YWlsYWJsZSBmb3IgQ29tcG9uZW50J3Mge0BsaW5rIENvbXBvbmVudH0uXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIFZpZXdNZXRhZGF0YSNlbmNhcHN1bGF0aW9ufS5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbjtcbiAgICAoZnVuY3Rpb24gKFZpZXdFbmNhcHN1bGF0aW9uKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbXVsYXRlIGBOYXRpdmVgIHNjb3Bpbmcgb2Ygc3R5bGVzIGJ5IGFkZGluZyBhbiBhdHRyaWJ1dGUgY29udGFpbmluZyBzdXJyb2dhdGUgaWQgdG8gdGhlIEhvc3RcbiAgICAgICAgICogRWxlbWVudCBhbmQgcHJlLXByb2Nlc3NpbmcgdGhlIHN0eWxlIHJ1bGVzIHByb3ZpZGVkIHZpYVxuICAgICAgICAgKiB7QGxpbmsgVmlld01ldGFkYXRhI3N0eWxlc30gb3Ige0BsaW5rIFZpZXdNZXRhZGF0YSNzdHlsZXNVcmxzfSwgYW5kIGFkZGluZyB0aGUgbmV3IEhvc3QgRWxlbWVudFxuICAgICAgICAgKiBhdHRyaWJ1dGUgdG8gYWxsIHNlbGVjdG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCBvcHRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIkVtdWxhdGVkXCJdID0gMF0gPSBcIkVtdWxhdGVkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgdGhlIG5hdGl2ZSBlbmNhcHN1bGF0aW9uIG1lY2hhbmlzbSBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgRE9NIHRoaXMgbWVhbnMgdXNpbmcgW1NoYWRvdyBET01dKGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvc2hhZG93LykgYW5kXG4gICAgICAgICAqIGNyZWF0aW5nIGEgU2hhZG93Um9vdCBmb3IgQ29tcG9uZW50J3MgSG9zdCBFbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJOYXRpdmVcIl0gPSAxXSA9IFwiTmF0aXZlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb24ndCBwcm92aWRlIGFueSB0ZW1wbGF0ZSBvciBzdHlsZSBlbmNhcHN1bGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJOb25lXCJdID0gMl0gPSBcIk5vbmVcIjtcbiAgICB9KShleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uIHx8IChleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSBwcm9wZXJ0aWVzIGF2YWlsYWJsZSBmb3IgY29uZmlndXJpbmcgVmlld3MuXG4gICAgICpcbiAgICAgKiBGb3IgZGV0YWlscyBvbiB0aGUgYEBDb21wb25lbnRgIGFubm90YXRpb24sIHNlZSB7QGxpbmsgQ29tcG9uZW50fS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIHNlbGVjdG9yOiAnZ3JlZXQnLFxuICAgICAqICAgdGVtcGxhdGU6ICdIZWxsbyB7e25hbWV9fSEnLFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgR3JlZXQge1xuICAgICAqICAgbmFtZTogc3RyaW5nO1xuICAgICAqXG4gICAgICogICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgKiAgICAgdGhpcy5uYW1lID0gJ1dvcmxkJztcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgQ29tcG9uZW50IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50fVxuICAgICAqL1xuICAgIHZhciBWaWV3TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaWV3TWV0YWRhdGEoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0ZW1wbGF0ZVVybCA9IF9iLnRlbXBsYXRlVXJsLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlLCBlbmNhcHN1bGF0aW9uID0gX2IuZW5jYXBzdWxhdGlvbiwgc3R5bGVzID0gX2Iuc3R5bGVzLCBzdHlsZVVybHMgPSBfYi5zdHlsZVVybHMsIGFuaW1hdGlvbnMgPSBfYi5hbmltYXRpb25zLCBpbnRlcnBvbGF0aW9uID0gX2IuaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVVcmwgPSB0ZW1wbGF0ZVVybDtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVVcmxzID0gc3R5bGVVcmxzO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgICAgICB0aGlzLmVuY2Fwc3VsYXRpb24gPSBlbmNhcHN1bGF0aW9uO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucztcbiAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFZpZXdNZXRhZGF0YTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIHJlZmVyIHRvIHJlZmVyZW5jZXMgd2hpY2ggYXJlIG5vdCB5ZXQgZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSwgYGZvcndhcmRSZWZgIGlzIHVzZWQgd2hlbiB0aGUgYHRva2VuYCB3aGljaCB3ZSBuZWVkIHRvIHJlZmVyIHRvIGZvciB0aGUgcHVycG9zZXMgb2ZcbiAgICAgKiBESSBpcyBkZWNsYXJlZCxcbiAgICAgKiBidXQgbm90IHlldCBkZWZpbmVkLiBJdCBpcyBhbHNvIHVzZWQgd2hlbiB0aGUgYHRva2VuYCB3aGljaCB3ZSB1c2Ugd2hlbiBjcmVhdGluZyBhIHF1ZXJ5IGlzIG5vdFxuICAgICAqIHlldCBkZWZpbmVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9kaS90cy9mb3J3YXJkX3JlZi9mb3J3YXJkX3JlZl9zcGVjLnRzIHJlZ2lvbj0nZm9yd2FyZF9yZWYnfVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3J3YXJkUmVmKGZvcndhcmRSZWZGbikge1xuICAgICAgICBmb3J3YXJkUmVmRm4uX19mb3J3YXJkX3JlZl9fID0gZm9yd2FyZFJlZjtcbiAgICAgICAgZm9yd2FyZFJlZkZuLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5KHRoaXMoKSk7IH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkUmVmRm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExhemlseSByZXRyaWV2ZXMgdGhlIHJlZmVyZW5jZSB2YWx1ZSBmcm9tIGEgZm9yd2FyZFJlZi5cbiAgICAgKlxuICAgICAqIEFjdHMgYXMgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIHdoZW4gZ2l2ZW4gYSBub24tZm9yd2FyZC1yZWYgdmFsdWUuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvR1U3Mm1KcmsxZmlvZENoY21pRFI/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2RpL3RzL2ZvcndhcmRfcmVmL2ZvcndhcmRfcmVmX3NwZWMudHMgcmVnaW9uPSdyZXNvbHZlX2ZvcndhcmRfcmVmJ31cbiAgICAgKlxuICAgICAqIFNlZToge0BsaW5rIGZvcndhcmRSZWZ9XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odHlwZSkgJiYgdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX19mb3J3YXJkX3JlZl9fJykgJiZcbiAgICAgICAgICAgIHR5cGUuX19mb3J3YXJkX3JlZl9fID09PSBmb3J3YXJkUmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEJhc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhCYXNlRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEJhc2VFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBFcnJvcnMgZG9uJ3QgdXNlIGN1cnJlbnQgdGhpcywgaW5zdGVhZCB0aGV5IGNyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gZG8gZm9yd2FyZCBhbGwgb2Ygb3VyIGFwaSB0byB0aGUgbmF0aXZlSW5zdGFuY2UuXG4gICAgICAgICAgICB2YXIgbmF0aXZlRXJyb3IgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLm1lc3NhZ2U7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHRoaXMuX25hdGl2ZUVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VFcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLm5hbWU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUVycm9yLnByb3RvdHlwZSwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX25hdGl2ZUVycm9yLnN0YWNrOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy5fbmF0aXZlRXJyb3Iuc3RhY2sgPSB2YWx1ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEJhc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9uYXRpdmVFcnJvci50b1N0cmluZygpOyB9O1xuICAgICAgICByZXR1cm4gQmFzZUVycm9yO1xuICAgIH0oRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFdyYXBwZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhXcmFwcGVkRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFdyYXBwZWRFcnJvcihtZXNzYWdlLCBlcnJvcikge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSArIFwiIGNhdXNlZCBieTogXCIgKyAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcikpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFcnJvci5wcm90b3R5cGUsIFwic3RhY2tcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm9yaWdpbmFsRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHRoaXMub3JpZ2luYWxFcnJvciA6IHRoaXMuX25hdGl2ZUVycm9yKVxuICAgICAgICAgICAgICAgICAgICAuc3RhY2s7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFdyYXBwZWRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuXG4gICAgdmFyIF9USFJPV19JRl9OT1RfRk9VTkQgPSBuZXcgT2JqZWN0KCk7XG4gICAgdmFyIFRIUk9XX0lGX05PVF9GT1VORCA9IF9USFJPV19JRl9OT1RfRk9VTkQ7XG4gICAgdmFyIF9OdWxsSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTnVsbEluamVjdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIF9OdWxsSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gX1RIUk9XX0lGX05PVF9GT1VORDsgfVxuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IF9USFJPV19JRl9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm92aWRlciBmb3IgXCIgKyBzdHJpbmdpZnkodG9rZW4pICsgXCIhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vdEZvdW5kVmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfTnVsbEluamVjdG9yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgSW5qZWN0b3IgaW50ZXJmYWNlXG4gICAgICogQGhvd1RvVXNlXG4gICAgICogYGBgXG4gICAgICogY29uc3QgaW5qZWN0b3I6IEluamVjdG9yID0gLi4uO1xuICAgICAqIGluamVjdG9yLmdldCguLi4pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSB7QGxpbmtEb2NzIGd1aWRlL2RlcGVuZGVuY3ktaW5qZWN0aW9uIFwiRGVwZW5kZW5jeSBJbmplY3Rpb24gR3VpZGVcIn0uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J0luamVjdG9yJ31cbiAgICAgKlxuICAgICAqIGBJbmplY3RvcmAgcmV0dXJucyBpdHNlbGYgd2hlbiBnaXZlbiBgSW5qZWN0b3JgIGFzIGEgdG9rZW46XG4gICAgICoge0BleGFtcGxlIGNvcmUvZGkvdHMvaW5qZWN0b3Jfc3BlYy50cyByZWdpb249J2luamVjdEluamVjdG9yJ31cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbmplY3RvcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGFuIGluc3RhbmNlIGZyb20gdGhlIGluamVjdG9yIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0b2tlbi5cbiAgICAgICAgICogSWYgbm90IGZvdW5kOlxuICAgICAgICAgKiAtIFRocm93cyB7QGxpbmsgTm9Qcm92aWRlckVycm9yfSBpZiBubyBgbm90Rm91bmRWYWx1ZWAgdGhhdCBpcyBub3QgZXF1YWwgdG9cbiAgICAgICAgICogSW5qZWN0b3IuVEhST1dfSUZfTk9UX0ZPVU5EIGlzIGdpdmVuXG4gICAgICAgICAqIC0gUmV0dXJucyB0aGUgYG5vdEZvdW5kVmFsdWVgIG90aGVyd2lzZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9O1xuICAgICAgICBJbmplY3Rvci5USFJPV19JRl9OT1RfRk9VTkQgPSBfVEhST1dfSUZfTk9UX0ZPVU5EO1xuICAgICAgICBJbmplY3Rvci5OVUxMID0gbmV3IF9OdWxsSW5qZWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIEluamVjdG9yO1xuICAgIH0oKSk7XG5cbiAgICAvLyBTYWZhcmkgYW5kIEludGVybmV0IEV4cGxvcmVyIGRvIG5vdCBzdXBwb3J0IHRoZSBpdGVyYWJsZSBwYXJhbWV0ZXIgdG8gdGhlXG4gICAgLy8gTWFwIGNvbnN0cnVjdG9yLiAgV2Ugd29yayBhcm91bmQgdGhhdCBieSBtYW51YWxseSBhZGRpbmcgdGhlIGl0ZW1zLlxuICAgIHZhciBjcmVhdGVNYXBGcm9tUGFpcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG5ldyBNYXAoW1sxLCAyXV0pLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWFwRnJvbVBhaXJzKHBhaXJzKSB7IHJldHVybiBuZXcgTWFwKHBhaXJzKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXBBbmRQb3B1bGF0ZUZyb21QYWlycyhwYWlycykge1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgICAgIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgdmFyIF9jbGVhclZhbHVlcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgobmV3IE1hcCgpKS5rZXlzKCkubmV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jbGVhclZhbHVlcyhtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleUl0ZXJhdG9yID0gbS5rZXlzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCEoKGsgPSBrZXlJdGVyYXRvci5uZXh0KCkpLmRvbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG0uc2V0KGsudmFsdWUsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2NsZWFyVmFsdWVzV2l0aEZvcmVFYWNoKG0pIHtcbiAgICAgICAgICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHsgbS5zZXQoaywgbnVsbCk7IH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgLy8gU2FmYXJpIGRvZXNuJ3QgaW1wbGVtZW50IE1hcEl0ZXJhdG9yLm5leHQoKSwgd2hpY2ggaXMgdXNlZCBpcyBUcmFjZXVyJ3MgcG9seWZpbGwgb2YgQXJyYXkuZnJvbVxuICAgIC8vIFRPRE8obWxhdmFsKTogcmVtb3ZlIHRoZSB3b3JrIGFyb3VuZCBvbmNlIHdlIGhhdmUgYSB3b3JraW5nIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgICB2YXIgX2FycmF5RnJvbU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKG5ldyBNYXAoKSkudmFsdWVzKCkubmV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXAobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZXMgPyBBcnJheS5mcm9tKG0udmFsdWVzKCkpIDogQXJyYXkuZnJvbShtLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXBXaXRoRm9yZWFjaChtLCBnZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkobS5zaXplKSwgaSA9IDA7XG4gICAgICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBnZXRWYWx1ZXMgPyB2IDogaztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICB2YXIgTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1hcFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTWFwV3JhcHBlci5jcmVhdGVGcm9tU3RyaW5nTWFwID0gZnVuY3Rpb24gKHN0cmluZ01hcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3RyaW5nTWFwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChwcm9wLCBzdHJpbmdNYXBbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgTWFwV3JhcHBlci50b1N0cmluZ01hcCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICB2YXIgciA9IHt9O1xuICAgICAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiByW2tdID0gdjsgfSk7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfTtcbiAgICAgICAgTWFwV3JhcHBlci5jcmVhdGVGcm9tUGFpcnMgPSBmdW5jdGlvbiAocGFpcnMpIHsgcmV0dXJuIGNyZWF0ZU1hcEZyb21QYWlycyhwYWlycyk7IH07XG4gICAgICAgIE1hcFdyYXBwZXIuaXRlcmFibGUgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gbTsgfTtcbiAgICAgICAgTWFwV3JhcHBlci5rZXlzID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIF9hcnJheUZyb21NYXAobSwgZmFsc2UpOyB9O1xuICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBfYXJyYXlGcm9tTWFwKG0sIHRydWUpOyB9O1xuICAgICAgICByZXR1cm4gTWFwV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFdyYXBzIEphdmFzY3JpcHQgT2JqZWN0c1xuICAgICAqL1xuICAgIHZhciBTdHJpbmdNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nTWFwV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIG0gPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0xW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IE9iamVjdC5rZXlzKG0yKTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTJba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgICB2YXIgazEgPSBPYmplY3Qua2V5cyhtMSk7XG4gICAgICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gazFbaV07XG4gICAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIHZhciBMaXN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTIGhhcyBubyB3YXkgdG8gZXhwcmVzcyBhIHN0YXRpY2FsbHkgZml4ZWQgc2l6ZSBsaXN0LCBidXQgZGFydCBkb2VzIHNvIHdlXG4gICAgICAgIC8vIGtlZXAgYm90aCBtZXRob2RzLlxuICAgICAgICBMaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jcmVhdGVHcm93YWJsZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jbG9uZSA9IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm4oYXJyYXlbaV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5maXJzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFhcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIubGFzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSB2b2lkIDApIHsgc3RhcnRJbmRleCA9IDA7IH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlLCBzdGFydEluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY29udGFpbnMgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHsgcmV0dXJuIGxpc3QuaW5kZXhPZihlbCkgIT09IC0xOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZXZlcnNlZCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgdmFyIGEgPSBMaXN0V3JhcHBlci5jbG9uZShhcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYS5yZXZlcnNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmNvbmNhdCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0ID0gZnVuY3Rpb24gKGxpc3QsIGluZGV4LCB2YWx1ZSkgeyBsaXN0LnNwbGljZShpbmRleCwgMCwgdmFsdWUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jbGVhciA9IGZ1bmN0aW9uIChsaXN0KSB7IGxpc3QubGVuZ3RoID0gMDsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaXNFbXB0eSA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0Lmxlbmd0aCA9PSAwOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5maWxsID0gZnVuY3Rpb24gKGxpc3QsIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBudWxsOyB9XG4gICAgICAgICAgICBsaXN0LmZpbGwodmFsdWUsIHN0YXJ0LCBlbmQgPT09IG51bGwgPyBsaXN0Lmxlbmd0aCA6IGVuZCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5zbGljZSA9IGZ1bmN0aW9uIChsLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gbC5zbGljZShmcm9tLCB0byA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc3BsaWNlID0gZnVuY3Rpb24gKGwsIGZyb20sIGxlbmd0aCkgeyByZXR1cm4gbC5zcGxpY2UoZnJvbSwgbGVuZ3RoKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc29ydCA9IGZ1bmN0aW9uIChsLCBjb21wYXJlRm4pIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29tcGFyZUZuKSkge1xuICAgICAgICAgICAgICAgIGwuc29ydChjb21wYXJlRm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbC5zb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwudG9TdHJpbmcoKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIudG9KU09OID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGwpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5tYXhpbXVtID0gZnVuY3Rpb24gKGxpc3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbWF4VmFsdWUgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZVZhbHVlID0gcHJlZGljYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gY2FuZGlkYXRlVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkobGlzdCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbCA9IGZ1bmN0aW9uIChsaXN0LCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaXN0V3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9mbGF0dGVuQXJyYXkoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkoaXRlbSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpc3RMaWtlSXRlcmFibGUob2JqKSB7XG4gICAgICAgIGlmICghaXNKc09iamVjdChvYmopKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gaXNBcnJheShvYmopIHx8XG4gICAgICAgICAgICAoIShvYmogaW5zdGFuY2VvZiBNYXApICYmXG4gICAgICAgICAgICAgICAgZ2V0U3ltYm9sSXRlcmF0b3IoKSBpbiBvYmopOyAvLyBKUyBJdGVyYWJsZSBoYXZlIGEgU3ltYm9sLml0ZXJhdG9yIHByb3BcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlSXRlcmFibGVzRXF1YWwoYSwgYiwgY29tcGFyYXRvcikge1xuICAgICAgICB2YXIgaXRlcmF0b3IxID0gYVtnZXRTeW1ib2xJdGVyYXRvcigpXSgpO1xuICAgICAgICB2YXIgaXRlcmF0b3IyID0gYltnZXRTeW1ib2xJdGVyYXRvcigpXSgpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0xID0gaXRlcmF0b3IxLm5leHQoKTtcbiAgICAgICAgICAgIHZhciBpdGVtMiA9IGl0ZXJhdG9yMi5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXRlbTEuZG9uZSAmJiBpdGVtMi5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGl0ZW0xLmRvbmUgfHwgaXRlbTIuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWNvbXBhcmF0b3IoaXRlbTEudmFsdWUsIGl0ZW0yLnZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXRlcmF0ZUxpc3RMaWtlKG9iaiwgZm4pIHtcbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmbihvYmpbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gb2JqW2dldFN5bWJvbEl0ZXJhdG9yKCldKCk7XG4gICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgIHdoaWxlICghKChpdGVtID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSkge1xuICAgICAgICAgICAgICAgIGZuKGl0ZW0udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZpbmRGaXJzdENsb3NlZEN5Y2xlKGtleXMpIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChMaXN0V3JhcHBlci5jb250YWlucyhyZXMsIGtleXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKGtleXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnN0cnVjdFJlc29sdmluZ1BhdGgoa2V5cykge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZWQgPSBmaW5kRmlyc3RDbG9zZWRDeWNsZShMaXN0V3JhcHBlci5yZXZlcnNlZChrZXlzKSk7XG4gICAgICAgICAgICB2YXIgdG9rZW5TdHJzID0gcmV2ZXJzZWQubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBzdHJpbmdpZnkoay50b2tlbik7IH0pO1xuICAgICAgICAgICAgcmV0dXJuICcgKCcgKyB0b2tlblN0cnMuam9pbignIC0+ICcpICsgJyknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzZSBjbGFzcyBmb3IgYWxsIGVycm9ycyBhcmlzaW5nIGZyb20gbWlzY29uZmlndXJlZCBwcm92aWRlcnMuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBYnN0cmFjdFByb3ZpZGVyRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShBYnN0cmFjdFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0UHJvdmlkZXJFcnJvcihpbmplY3Rvciwga2V5LCBjb25zdHJ1Y3RSZXNvbHZpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnREkgRXJyb3InKTtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtrZXldO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RvcnMgPSBbaW5qZWN0b3JdO1xuICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3RSZXNvbHZpbmdNZXNzYWdlID0gY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSh0aGlzLmtleXMpO1xuICAgICAgICB9XG4gICAgICAgIEFic3RyYWN0UHJvdmlkZXJFcnJvci5wcm90b3R5cGUuYWRkS2V5ID0gZnVuY3Rpb24gKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzLnB1c2goaW5qZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuY29uc3RydWN0UmVzb2x2aW5nTWVzc2FnZSh0aGlzLmtleXMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RQcm92aWRlckVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gdHJ5aW5nIHRvIHJldHJpZXZlIGEgZGVwZW5kZW5jeSBieSBrZXkgZnJvbSB7QGxpbmsgSW5qZWN0b3J9LCBidXQgdGhlXG4gICAgICoge0BsaW5rIEluamVjdG9yfSBkb2VzIG5vdCBoYXZlIGEge0BsaW5rIFByb3ZpZGVyfSBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC92cThEM0ZSQjlhR2JuV0pxdEVQRT9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIEEge1xuICAgICAqICAgY29uc3RydWN0b3IoYjpCKSB7fVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSkpLnRvVGhyb3dFcnJvcigpO1xuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTm9Qcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoTm9Qcm92aWRlckVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOb1Byb3ZpZGVyRXJyb3IoaW5qZWN0b3IsIGtleSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaW5qZWN0b3IsIGtleSwgZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBzdHJpbmdpZnkoTGlzdFdyYXBwZXIuZmlyc3Qoa2V5cykudG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIHByb3ZpZGVyIGZvciBcIiArIGZpcnN0ICsgXCIhXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vUHJvdmlkZXJFcnJvcjtcbiAgICB9KEFic3RyYWN0UHJvdmlkZXJFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGRlcGVuZGVuY2llcyBmb3JtIGEgY3ljbGUuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvd1lRZE5vczBUenFsM2VpMUVWOWo/cD1pbmZvKSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIHtwcm92aWRlOiBcIm9uZVwiLCB1c2VGYWN0b3J5OiAodHdvKSA9PiBcInR3b1wiLCBkZXBzOiBbW25ldyBJbmplY3QoXCJ0d29cIildXX0sXG4gICAgICogICB7cHJvdmlkZTogXCJ0d29cIiwgdXNlRmFjdG9yeTogKG9uZSkgPT4gXCJvbmVcIiwgZGVwczogW1tuZXcgSW5qZWN0KFwib25lXCIpXV19XG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gaW5qZWN0b3IuZ2V0KFwib25lXCIpKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFJldHJpZXZpbmcgYEFgIG9yIGBCYCB0aHJvd3MgYSBgQ3ljbGljRGVwZW5kZW5jeUVycm9yYCBhcyB0aGUgZ3JhcGggYWJvdmUgY2Fubm90IGJlIGNvbnN0cnVjdGVkLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ3ljbGljRGVwZW5kZW5jeUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQ3ljbGljRGVwZW5kZW5jeUVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDeWNsaWNEZXBlbmRlbmN5RXJyb3IoaW5qZWN0b3IsIGtleSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgaW5qZWN0b3IsIGtleSwgZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJDYW5ub3QgaW5zdGFudGlhdGUgY3ljbGljIGRlcGVuZGVuY3khXCIgKyBjb25zdHJ1Y3RSZXNvbHZpbmdQYXRoKGtleXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEN5Y2xpY0RlcGVuZGVuY3lFcnJvcjtcbiAgICB9KEFic3RyYWN0UHJvdmlkZXJFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGEgY29uc3RydWN0aW5nIHR5cGUgcmV0dXJucyB3aXRoIGFuIEVycm9yLlxuICAgICAqXG4gICAgICogVGhlIGBJbnN0YW50aWF0aW9uRXJyb3JgIGNsYXNzIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCBlcnJvciBwbHVzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIHdoaWNoIGNhdXNlZFxuICAgICAqIHRoaXMgb2JqZWN0IHRvIGJlIGluc3RhbnRpYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC83YVdZZGNxVFFzUDBlTnFFZFVBZj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNsYXNzIEEge1xuICAgICAqICAgY29uc3RydWN0b3IoKSB7XG4gICAgICogICAgIHRocm93IG5ldyBFcnJvcignbWVzc2FnZScpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBpbmplY3RvciA9IEluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0FdKTtcblxuICAgICAqIHRyeSB7XG4gICAgICogICBpbmplY3Rvci5nZXQoQSk7XG4gICAgICogfSBjYXRjaCAoZSkge1xuICAgICAqICAgZXhwZWN0KGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0aW9uRXJyb3IpLnRvQmUodHJ1ZSk7XG4gICAgICogICBleHBlY3QoZS5vcmlnaW5hbEV4Y2VwdGlvbi5tZXNzYWdlKS50b0VxdWFsKFwibWVzc2FnZVwiKTtcbiAgICAgKiAgIGV4cGVjdChlLm9yaWdpbmFsU3RhY2spLnRvQmVEZWZpbmVkKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSW5zdGFudGlhdGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoSW5zdGFudGlhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBJbnN0YW50aWF0aW9uRXJyb3IoaW5qZWN0b3IsIG9yaWdpbmFsRXhjZXB0aW9uLCBvcmlnaW5hbFN0YWNrLCBrZXkpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdESSBFcnJvcicsIG9yaWdpbmFsRXhjZXB0aW9uKTtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtrZXldO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RvcnMgPSBbaW5qZWN0b3JdO1xuICAgICAgICB9XG4gICAgICAgIEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUuYWRkS2V5ID0gZnVuY3Rpb24gKGluamVjdG9yLCBrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3JzLnB1c2goaW5qZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluc3RhbnRpYXRpb25FcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBzdHJpbmdpZnkoTGlzdFdyYXBwZXIuZmlyc3QodGhpcy5rZXlzKS50b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFcnJvci5tZXNzYWdlICsgXCI6IEVycm9yIGR1cmluZyBpbnN0YW50aWF0aW9uIG9mIFwiICsgZmlyc3QgKyBcIiFcIiArIGNvbnN0cnVjdFJlc29sdmluZ1BhdGgodGhpcy5rZXlzKSArIFwiLlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN0YW50aWF0aW9uRXJyb3IucHJvdG90eXBlLCBcImNhdXNlS2V5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlzWzBdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEluc3RhbnRpYXRpb25FcnJvcjtcbiAgICB9KFdyYXBwZWRFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGFuIG9iamVjdCBvdGhlciB0aGVuIHtAbGluayBQcm92aWRlcn0gKG9yIGBUeXBlYCkgaXMgcGFzc2VkIHRvIHtAbGluayBJbmplY3Rvcn1cbiAgICAgKiBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9ZYXRDRmJQQU1DTDBKU1NRNG12SD9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcIm5vdCBhIHR5cGVcIl0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEludmFsaWRQcm92aWRlckVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoSW52YWxpZFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEludmFsaWRQcm92aWRlckVycm9yKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIkludmFsaWQgcHJvdmlkZXIgLSBvbmx5IGluc3RhbmNlcyBvZiBQcm92aWRlciBhbmQgVHlwZSBhcmUgYWxsb3dlZCwgZ290OiBcIiArIHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSW52YWxpZFByb3ZpZGVyRXJyb3I7XG4gICAgfShCYXNlRXJyb3IpKTtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiB0aGUgY2xhc3MgaGFzIG5vIGFubm90YXRpb24gaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBMYWNrIG9mIGFubm90YXRpb24gaW5mb3JtYXRpb24gcHJldmVudHMgdGhlIHtAbGluayBJbmplY3Rvcn0gZnJvbSBkZXRlcm1pbmluZyB3aGljaCBkZXBlbmRlbmNpZXNcbiAgICAgKiBuZWVkIHRvIGJlIGluamVjdGVkIGludG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3JIblp0bE5TN3ZKT1BRNnBjVmttP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY2xhc3MgQSB7XG4gICAgICogICBjb25zdHJ1Y3RvcihiKSB7fVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGV4cGVjdCgoKSA9PiBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtBXSkpLnRvVGhyb3dFcnJvcigpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhpcyBlcnJvciBpcyBhbHNvIHRocm93biB3aGVuIHRoZSBjbGFzcyBub3QgbWFya2VkIHdpdGgge0BsaW5rIEluamVjdGFibGV9IGhhcyBwYXJhbWV0ZXIgdHlwZXMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY2xhc3MgQiB7fVxuICAgICAqXG4gICAgICogY2xhc3MgQSB7XG4gICAgICogICBjb25zdHJ1Y3RvcihiOkIpIHt9IC8vIG5vIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwYXJhbWV0ZXIgdHlwZXMgb2YgQSBpcyBhdmFpbGFibGUgYXQgcnVudGltZS5cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQSxCXSkpLnRvVGhyb3dFcnJvcigpO1xuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTm9Bbm5vdGF0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShOb0Fubm90YXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTm9Bbm5vdGF0aW9uRXJyb3IodHlwZU9yRnVuYywgcGFyYW1zKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBOb0Fubm90YXRpb25FcnJvci5fZ2VuTWVzc2FnZSh0eXBlT3JGdW5jLCBwYXJhbXMpKTtcbiAgICAgICAgfVxuICAgICAgICBOb0Fubm90YXRpb25FcnJvci5fZ2VuTWVzc2FnZSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcmFtcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtZXRlciA9IHBhcmFtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFtZXRlciB8fCBwYXJhbWV0ZXIubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLnB1c2goJz8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5wdXNoKHBhcmFtZXRlci5tYXAoc3RyaW5naWZ5KS5qb2luKCcgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnQ2Fubm90IHJlc29sdmUgYWxsIHBhcmFtZXRlcnMgZm9yIFxcJycgKyBzdHJpbmdpZnkodHlwZU9yRnVuYykgKyAnXFwnKCcgK1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZS5qb2luKCcsICcpICsgJykuICcgK1xuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhhdCBhbGwgdGhlIHBhcmFtZXRlcnMgYXJlIGRlY29yYXRlZCB3aXRoIEluamVjdCBvciBoYXZlIHZhbGlkIHR5cGUgYW5ub3RhdGlvbnMgYW5kIHRoYXQgXFwnJyArXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHR5cGVPckZ1bmMpICsgJ1xcJyBpcyBkZWNvcmF0ZWQgd2l0aCBJbmplY3RhYmxlLic7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBOb0Fubm90YXRpb25FcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGdldHRpbmcgYW4gb2JqZWN0IGJ5IGluZGV4LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2JSczBTWDJPVFFpSnpxdmpnbDhQP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY2xhc3MgQSB7fVxuICAgICAqXG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQV0pO1xuICAgICAqXG4gICAgICogZXhwZWN0KCgpID0+IGluamVjdG9yLmdldEF0KDEwMCkpLnRvVGhyb3dFcnJvcigpO1xuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgT3V0T2ZCb3VuZHNFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKE91dE9mQm91bmRzRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE91dE9mQm91bmRzRXJyb3IoaW5kZXgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW5kZXggXCIgKyBpbmRleCArIFwiIGlzIG91dC1vZi1ib3VuZHMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPdXRPZkJvdW5kc0Vycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLy8gVE9ETzogYWRkIGEgd29ya2luZyBleGFtcGxlIGFmdGVyIGFscGhhMzggaXMgcmVsZWFzZWRcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBhIG11bHRpIHByb3ZpZGVyIGFuZCBhIHJlZ3VsYXIgcHJvdmlkZXIgYXJlIGJvdW5kIHRvIHRoZSBzYW1lIHRva2VuLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBleHBlY3QoKCkgPT4gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbXG4gICAgICogICB7IHByb3ZpZGU6IFwiU3RyaW5nc1wiLCB1c2VWYWx1ZTogXCJzdHJpbmcxXCIsIG11bHRpOiB0cnVlfSxcbiAgICAgKiAgIHsgcHJvdmlkZTogXCJTdHJpbmdzXCIsIHVzZVZhbHVlOiBcInN0cmluZzJcIiwgbXVsdGk6IGZhbHNlfVxuICAgICAqIF0pKS50b1Rocm93RXJyb3IoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoTWl4aW5nTXVsdGlQcm92aWRlcnNXaXRoUmVndWxhclByb3ZpZGVyc0Vycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBNaXhpbmdNdWx0aVByb3ZpZGVyc1dpdGhSZWd1bGFyUHJvdmlkZXJzRXJyb3IocHJvdmlkZXIxLCBwcm92aWRlcjIpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdDYW5ub3QgbWl4IG11bHRpIHByb3ZpZGVycyBhbmQgcmVndWxhciBwcm92aWRlcnMsIGdvdDogJyArIHByb3ZpZGVyMS50b1N0cmluZygpICsgJyAnICtcbiAgICAgICAgICAgICAgICBwcm92aWRlcjIudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgb2JqZWN0IHVzZWQgZm9yIHJldHJpZXZpbmcgaXRlbXMgZnJvbSB0aGUge0BsaW5rIFJlZmxlY3RpdmVJbmplY3Rvcn0uXG4gICAgICpcbiAgICAgKiBLZXlzIGhhdmU6XG4gICAgICogLSBhIHN5c3RlbS13aWRlIHVuaXF1ZSBgaWRgLlxuICAgICAqIC0gYSBgdG9rZW5gLlxuICAgICAqXG4gICAgICogYEtleWAgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHtAbGluayBSZWZsZWN0aXZlSW5qZWN0b3J9IGJlY2F1c2UgaXRzIHN5c3RlbS13aWRlIHVuaXF1ZSBgaWRgIGFsbG93c1xuICAgICAqIHRoZVxuICAgICAqIGluamVjdG9yIHRvIHN0b3JlIGNyZWF0ZWQgb2JqZWN0cyBpbiBhIG1vcmUgZWZmaWNpZW50IHdheS5cbiAgICAgKlxuICAgICAqIGBLZXlgIHNob3VsZCBub3QgYmUgY3JlYXRlZCBkaXJlY3RseS4ge0BsaW5rIFJlZmxlY3RpdmVJbmplY3Rvcn0gY3JlYXRlcyBrZXlzIGF1dG9tYXRpY2FsbHkgd2hlblxuICAgICAqIHJlc29sdmluZ1xuICAgICAqIHByb3ZpZGVycy5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJlZmxlY3RpdmVLZXkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUtleSh0b2tlbiwgaWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIG11c3QgYmUgZGVmaW5lZCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUtleS5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5naWZpZWQgdG9rZW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RyaW5naWZ5KHRoaXMudG9rZW4pOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyBhIGBLZXlgIGZvciBhIHRva2VuLlxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUtleS5nZXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2xvYmFsS2V5UmVnaXN0cnkuZ2V0KHJlc29sdmVGb3J3YXJkUmVmKHRva2VuKSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlS2V5LCBcIm51bWJlck9mS2V5c1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5cyByZWdpc3RlcmVkIGluIHRoZSBzeXN0ZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2dsb2JhbEtleVJlZ2lzdHJ5Lm51bWJlck9mS2V5czsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlS2V5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdmFyIEtleVJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gS2V5UmVnaXN0cnkoKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxLZXlzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIEtleVJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFJlZmxlY3RpdmVLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FsbEtleXMuaGFzKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbGxLZXlzLmdldCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3S2V5ID0gbmV3IFJlZmxlY3RpdmVLZXkodG9rZW4sIFJlZmxlY3RpdmVLZXkubnVtYmVyT2ZLZXlzKTtcbiAgICAgICAgICAgIHRoaXMuX2FsbEtleXMuc2V0KHRva2VuLCBuZXdLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0tleTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtleVJlZ2lzdHJ5LnByb3RvdHlwZSwgXCJudW1iZXJPZktleXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9hbGxLZXlzLnNpemU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gS2V5UmVnaXN0cnk7XG4gICAgfSgpKTtcbiAgICB2YXIgX2dsb2JhbEtleVJlZ2lzdHJ5ID0gbmV3IEtleVJlZ2lzdHJ5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgUmVwcmVzZW50cyBhIHR5cGUgdGhhdCBhIENvbXBvbmVudCBvciBvdGhlciBvYmplY3QgaXMgaW5zdGFuY2VzIG9mLlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBBbiBleGFtcGxlIG9mIGEgYFR5cGVgIGlzIGBNeUN1c3RvbUNvbXBvbmVudGAgY2xhc3MsIHdoaWNoIGluIEphdmFTY3JpcHQgaXMgYmUgcmVwcmVzZW50ZWQgYnlcbiAgICAgKiB0aGUgYE15Q3VzdG9tQ29tcG9uZW50YCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVHlwZSA9IEZ1bmN0aW9uO1xuXG4gICAgdmFyIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKHJlZmxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlZmxlY3QgPSByZWZsZWN0IHx8IGdsb2JhbCQxLlJlZmxlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaXNSZWZsZWN0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmZhY3RvcnkgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IHQucHJvdG90eXBlO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB0LmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLl96aXBUeXBlc0FuZEFubm90YXRpb25zID0gZnVuY3Rpb24gKHBhcmFtVHlwZXMgLyoqIFRPRE8gIzkxMDAgKi8sIHBhcmFtQW5ub3RhdGlvbnMgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtVHlwZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHBhcmFtQW5ub3RhdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShwYXJhbVR5cGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFRTIG91dHB1dHMgT2JqZWN0IGZvciBwYXJhbWV0ZXJzIHdpdGhvdXQgdHlwZXMsIHdoaWxlIFRyYWNldXIgb21pdHNcbiAgICAgICAgICAgICAgICAvLyB0aGUgYW5ub3RhdGlvbnMuIEZvciBub3cgd2UgcHJlc2VydmUgdGhlIFRyYWNldXIgYmVoYXZpb3IgdG8gYWlkXG4gICAgICAgICAgICAgICAgLy8gbWlncmF0aW9uLCBidXQgdGhpcyBjYW4gYmUgcmV2aXNpdGVkLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1UeXBlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtVHlwZXNbaV0gIT0gT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtwYXJhbVR5cGVzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmFtQW5ub3RhdGlvbnMpICYmIGlzUHJlc2VudChwYXJhbUFubm90YXRpb25zW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbaV0uY29uY2F0KHBhcmFtQW5ub3RhdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgLy8gUHJlZmVyIHRoZSBkaXJlY3QgQVBJLlxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0eXBlT3JGdW5jLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVPckZ1bmMucGFyYW1ldGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQSSBvZiB0c2lja2xlIGZvciBsb3dlcmluZyBkZWNvcmF0b3JzIHRvIHByb3BlcnRpZXMgb24gdGhlIGNsYXNzLlxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0eXBlT3JGdW5jLmN0b3JQYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgICAgIHZhciBjdG9yUGFyYW1ldGVycyA9IHR5cGVPckZ1bmMuY3RvclBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtVHlwZXNfMSA9IGN0b3JQYXJhbWV0ZXJzLm1hcChmdW5jdGlvbiAoY3RvclBhcmFtIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBjdG9yUGFyYW0gJiYgY3RvclBhcmFtLnR5cGU7IH0pO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zXzEgPSBjdG9yUGFyYW1ldGVycy5tYXAoZnVuY3Rpb24gKGN0b3JQYXJhbSAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3RvclBhcmFtICYmIGNvbnZlcnRUc2lja2xlRGVjb3JhdG9ySW50b01ldGFkYXRhKGN0b3JQYXJhbS5kZWNvcmF0b3JzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5femlwVHlwZXNBbmRBbm5vdGF0aW9ucyhwYXJhbVR5cGVzXzEsIHBhcmFtQW5ub3RhdGlvbnNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgZm9yIG1ldGFkYXRhIGNyZWF0ZWQgYnkgaW52b2tpbmcgdGhlIGRlY29yYXRvcnMuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3JlZmxlY3QpICYmIGlzUHJlc2VudCh0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbUFubm90YXRpb25zID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgncGFyYW1ldGVycycsIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbVR5cGVzID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmFtVHlwZXMpIHx8IGlzUHJlc2VudChwYXJhbUFubm90YXRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5femlwVHlwZXNBbmRBbm5vdGF0aW9ucyhwYXJhbVR5cGVzLCBwYXJhbUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgYXJyYXkgaGFzIHRvIGJlIGZpbGxlZCB3aXRoIGB1bmRlZmluZWRgIGJlY2F1c2UgaG9sZXMgd291bGQgYmUgc2tpcHBlZCBieSBgc29tZWBcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gbmV3IEFycmF5KHR5cGVPckZ1bmMubGVuZ3RoKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmFubm90YXRpb25zID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICAgIC8vIFByZWZlciB0aGUgZGlyZWN0IEFQSS5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodHlwZU9yRnVuYy5hbm5vdGF0aW9ucykpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0eXBlT3JGdW5jLmFubm90YXRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGFubm90YXRpb25zKSAmJiBhbm5vdGF0aW9ucy5hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmFubm90YXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBUEkgb2YgdHNpY2tsZSBmb3IgbG93ZXJpbmcgZGVjb3JhdG9ycyB0byBwcm9wZXJ0aWVzIG9uIHRoZSBjbGFzcy5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodHlwZU9yRnVuYy5kZWNvcmF0b3JzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0VHNpY2tsZURlY29yYXRvckludG9NZXRhZGF0YSh0eXBlT3JGdW5jLmRlY29yYXRvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIGZvciBtZXRhZGF0YSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZSBkZWNvcmF0b3JzLlxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9yZWZsZWN0KSAmJiBpc1ByZXNlbnQodGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSB0aGlzLl9yZWZsZWN0LmdldE1ldGFkYXRhKCdhbm5vdGF0aW9ucycsIHR5cGVPckZ1bmMpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYW5ub3RhdGlvbnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXIgdGhlIGRpcmVjdCBBUEkuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHR5cGVPckZ1bmMucHJvcE1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTWV0YWRhdGEgPSB0eXBlT3JGdW5jLnByb3BNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wTWV0YWRhdGEpICYmIHByb3BNZXRhZGF0YS5wcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhID0gcHJvcE1ldGFkYXRhLnByb3BNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFQSSBvZiB0c2lja2xlIGZvciBsb3dlcmluZyBkZWNvcmF0b3JzIHRvIHByb3BlcnRpZXMgb24gdGhlIGNsYXNzLlxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0eXBlT3JGdW5jLnByb3BEZWNvcmF0b3JzKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wRGVjb3JhdG9yc18xID0gdHlwZU9yRnVuYy5wcm9wRGVjb3JhdG9ycztcbiAgICAgICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhXzEgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwcm9wRGVjb3JhdG9yc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BNZXRhZGF0YV8xW3Byb3BdID0gY29udmVydFRzaWNrbGVEZWNvcmF0b3JJbnRvTWV0YWRhdGEocHJvcERlY29yYXRvcnNfMVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BNZXRhZGF0YV8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQVBJIGZvciBtZXRhZGF0YSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZSBkZWNvcmF0b3JzLlxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9yZWZsZWN0KSAmJiBpc1ByZXNlbnQodGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcE1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdC5nZXRNZXRhZGF0YSgncHJvcE1ldGFkYXRhJywgdHlwZU9yRnVuYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwcm9wTWV0YWRhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9O1xuICAgICAgICAvLyBOb3RlOiBKYXZhU2NyaXB0IGRvZXMgbm90IHN1cHBvcnQgdG8gcXVlcnkgZm9yIGludGVyZmFjZXMgZHVyaW5nIHJ1bnRpbWUuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHdlIGNhbid0IHRocm93IGhlcmUgYXMgdGhlIHJlZmxlY3RvciB3aWxsIGFsd2F5cyBjYWxsIHRoaXMgbWV0aG9kXG4gICAgICAgIC8vIHdoZW4gYXNrZWQgZm9yIGEgbGlmZWN5Y2xlIGludGVyZmFjZSBhcyB0aGlzIGlzIHdoYXQgd2UgY2hlY2sgaW4gRGFydC5cbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaW50ZXJmYWNlcyA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBbXTsgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaGFzTGlmZWN5Y2xlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBsY0ludGVyZmFjZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwcm90byA9IHR5cGUucHJvdG90eXBlO1xuICAgICAgICAgICAgcmV0dXJuICEhcHJvdG9bbGNQcm9wZXJ0eV07XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmdldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBuZXcgRnVuY3Rpb24oJ28nLCAncmV0dXJuIG8uJyArIG5hbWUgKyAnOycpOyB9O1xuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsICd2JywgJ3JldHVybiBvLicgKyBuYW1lICsgJyA9IHY7Jyk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25Cb2R5ID0gXCJpZiAoIW8uXCIgKyBuYW1lICsgXCIpIHRocm93IG5ldyBFcnJvcignXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyB1bmRlZmluZWQnKTtcXG4gICAgICAgIHJldHVybiBvLlwiICsgbmFtZSArIFwiLmFwcGx5KG8sIGFyZ3MpO1wiO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbignbycsICdhcmdzJywgZnVuY3Rpb25Cb2R5KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm90IGEgY29uY2VwdCBvZiBpbXBvcnQgdXJpIGluIEpzLCBidXQgdGhpcyBpcyB1c2VmdWwgaW4gZGV2ZWxvcGluZyBEYXJ0IGFwcGxpY2F0aW9ucy5cbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaW1wb3J0VXJpID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFN0YXRpY1N5bWJvbFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlWydmaWxlUGF0aCddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVbJ2ZpbGVQYXRoJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSdW50aW1lIHR5cGVcbiAgICAgICAgICAgIHJldHVybiBcIi4vXCIgKyBzdHJpbmdpZnkodHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUsIG1vZHVsZVVybCwgcnVudGltZSkgeyByZXR1cm4gcnVudGltZTsgfTtcbiAgICAgICAgUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucmVzb2x2ZUVudW0gPSBmdW5jdGlvbiAoZW51bUlkZW50aWZpZXIsIG5hbWUpIHsgcmV0dXJuIGVudW1JZGVudGlmaWVyW25hbWVdOyB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGlvbkNhcGFiaWxpdGllcztcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRUc2lja2xlRGVjb3JhdG9ySW50b01ldGFkYXRhKGRlY29yYXRvckludm9jYXRpb25zKSB7XG4gICAgICAgIGlmICghZGVjb3JhdG9ySW52b2NhdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb3JhdG9ySW52b2NhdGlvbnMubWFwKGZ1bmN0aW9uIChkZWNvcmF0b3JJbnZvY2F0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZGVjb3JhdG9yVHlwZSA9IGRlY29yYXRvckludm9jYXRpb24udHlwZTtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uQ2xzID0gZGVjb3JhdG9yVHlwZS5hbm5vdGF0aW9uQ2xzO1xuICAgICAgICAgICAgdmFyIGFubm90YXRpb25BcmdzID0gZGVjb3JhdG9ySW52b2NhdGlvbi5hcmdzID8gZGVjb3JhdG9ySW52b2NhdGlvbi5hcmdzIDogW107XG4gICAgICAgICAgICByZXR1cm4gbmV3IChhbm5vdGF0aW9uQ2xzLmJpbmQuYXBwbHkoYW5ub3RhdGlvbkNscywgW3ZvaWQgMF0uY29uY2F0KGFubm90YXRpb25BcmdzKSkpKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgYWNjZXNzIHRvIHJlZmxlY3Rpb24gZGF0YSBhYm91dCBzeW1ib2xzLiBVc2VkIGludGVybmFsbHkgYnkgQW5ndWxhclxuICAgICAqIHRvIHBvd2VyIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGFuZCBjb21waWxhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgUmVmbGVjdG9yUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdG9yUmVhZGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZsZWN0b3JSZWFkZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gcmVmbGVjdGlvbiBkYXRhIGFib3V0IHN5bWJvbHMuIFVzZWQgaW50ZXJuYWxseSBieSBBbmd1bGFyXG4gICAgICogdG8gcG93ZXIgZGVwZW5kZW5jeSBpbmplY3Rpb24gYW5kIGNvbXBpbGF0aW9uLlxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMihSZWZsZWN0b3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RvcihyZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IHJlZmxlY3Rpb25DYXBhYmlsaXRpZXM7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9pbmplY3RhYmxlSW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2dldHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9zZXR0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbWV0aG9kcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3VzZWRLZXlzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnVwZGF0ZUNhcGFiaWxpdGllcyA9IGZ1bmN0aW9uIChjYXBzKSB7IHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IGNhcHM7IH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuaXNSZWZsZWN0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5pc1JlZmxlY3Rpb25FbmFibGVkKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXVzZXMgYHRoaXNgIHJlZmxlY3RvciB0byB0cmFjayBrZXlzIHVzZWQgdG8gYWNjZXNzXG4gICAgICAgICAqIHtAbGluayBSZWZsZWN0aW9uSW5mb30gb2JqZWN0cy5cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUudHJhY2tVc2FnZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdXNlZEtleXMgPSBuZXcgU2V0KCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyB0eXBlcyBmb3Igd2hpY2ggcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgbm90IHJlcXVlc3RlZCBzaW5jZVxuICAgICAgICAgKiB7QGxpbmsgI3RyYWNrVXNhZ2V9IHdhcyBjYWxsZWQuIFRoaXMgbGlzdCBjb3VsZCBsYXRlciBiZSBhdWRpdGVkIGFzXG4gICAgICAgICAqIHBvdGVudGlhbCBkZWFkIGNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmxpc3RVbnVzZWRLZXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VkS2V5cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2FnZSB0cmFja2luZyBpcyBkaXNhYmxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFsbFR5cGVzID0gTWFwV3JhcHBlci5rZXlzKHRoaXMuX2luamVjdGFibGVJbmZvKTtcbiAgICAgICAgICAgIHJldHVybiBhbGxUeXBlcy5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIV90aGlzLl91c2VkS2V5cy5oYXMoa2V5KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVnaXN0ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jLCBmdW5jSW5mbykge1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0YWJsZUluZm8uc2V0KGZ1bmMsIGZ1bmNJbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5yZWdpc3RlclR5cGUgPSBmdW5jdGlvbiAodHlwZSwgdHlwZUluZm8pIHtcbiAgICAgICAgICAgIHRoaXMuX2luamVjdGFibGVJbmZvLnNldCh0eXBlLCB0eXBlSW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucmVnaXN0ZXJHZXR0ZXJzID0gZnVuY3Rpb24gKGdldHRlcnMpIHsgX21lcmdlTWFwcyh0aGlzLl9nZXR0ZXJzLCBnZXR0ZXJzKTsgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5yZWdpc3RlclNldHRlcnMgPSBmdW5jdGlvbiAoc2V0dGVycykgeyBfbWVyZ2VNYXBzKHRoaXMuX3NldHRlcnMsIHNldHRlcnMpOyB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlZ2lzdGVyTWV0aG9kcyA9IGZ1bmN0aW9uIChtZXRob2RzKSB7IF9tZXJnZU1hcHModGhpcy5fbWV0aG9kcywgbWV0aG9kcyk7IH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZWZsZWN0aW9uSW5mbyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLl9nZXRSZWZsZWN0aW9uSW5mbyh0eXBlKS5mYWN0b3J5O1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQocmVzKSA/IHJlcyA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmZhY3RvcnkodHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucGFyYW1ldGVycyA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5qZWN0YWJsZUluZm8uaGFzKHR5cGVPckZ1bmMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldFJlZmxlY3Rpb25JbmZvKHR5cGVPckZ1bmMpLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChyZXMpID8gcmVzIDogW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luamVjdGFibGVJbmZvLmhhcyh0eXBlT3JGdW5jKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLl9nZXRSZWZsZWN0aW9uSW5mbyh0eXBlT3JGdW5jKS5hbm5vdGF0aW9ucztcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHJlcykgPyByZXMgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuYW5ub3RhdGlvbnModHlwZU9yRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmplY3RhYmxlSW5mby5oYXModHlwZU9yRnVuYykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5fZ2V0UmVmbGVjdGlvbkluZm8odHlwZU9yRnVuYykucHJvcE1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQocmVzKSA/IHJlcyA6IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm9wTWV0YWRhdGEodHlwZU9yRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuaW50ZXJmYWNlcyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5qZWN0YWJsZUluZm8uaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuX2dldFJlZmxlY3Rpb25JbmZvKHR5cGUpLmludGVyZmFjZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChyZXMpID8gcmVzIDogW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmludGVyZmFjZXModHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuaGFzTGlmZWN5Y2xlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBsY0ludGVyZmFjZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdmFyIGludGVyZmFjZXMgPSB0aGlzLmludGVyZmFjZXModHlwZSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJmYWNlcy5pbmRleE9mKGxjSW50ZXJmYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaGFzTGlmZWN5Y2xlSG9vayh0eXBlLCBsY0ludGVyZmFjZSwgbGNQcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuZ2V0dGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXR0ZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXR0ZXJzLmdldChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuZ2V0dGVyKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGVycy5nZXQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnNldHRlcihuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21ldGhvZHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5tZXRob2QobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmVmbGVjdG9yLnByb3RvdHlwZS5fZ2V0UmVmbGVjdGlvbkluZm8gPSBmdW5jdGlvbiAodHlwZU9yRnVuYykge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl91c2VkS2V5cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VkS2V5cy5hZGQodHlwZU9yRnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5qZWN0YWJsZUluZm8uZ2V0KHR5cGVPckZ1bmMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJlZmxlY3Rvci5wcm90b3R5cGUuX2NvbnRhaW5zUmVmbGVjdGlvbkluZm8gPSBmdW5jdGlvbiAodHlwZU9yRnVuYykgeyByZXR1cm4gdGhpcy5faW5qZWN0YWJsZUluZm8uaGFzKHR5cGVPckZ1bmMpOyB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLmltcG9ydFVyaSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMuaW1wb3J0VXJpKHR5cGUpOyB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlc29sdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUsIG1vZHVsZVVybCwgcnVudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmbGVjdGlvbkNhcGFiaWxpdGllcy5yZXNvbHZlSWRlbnRpZmllcihuYW1lLCBtb2R1bGVVcmwsIHJ1bnRpbWUpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0b3IucHJvdG90eXBlLnJlc29sdmVFbnVtID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmxlY3Rpb25DYXBhYmlsaXRpZXMucmVzb2x2ZUVudW0oaWRlbnRpZmllciwgbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0b3I7XG4gICAgfShSZWZsZWN0b3JSZWFkZXIpKTtcbiAgICBmdW5jdGlvbiBfbWVyZ2VNYXBzKHRhcmdldCwgY29uZmlnKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbmZpZykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyB0YXJnZXQuc2V0KGssIGNvbmZpZ1trXSk7IH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgUmVmbGVjdG9yfSB1c2VkIGludGVybmFsbHkgaW4gQW5ndWxhciB0byBhY2Nlc3MgbWV0YWRhdGFcbiAgICAgKiBhYm91dCBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciByZWZsZWN0b3IgPSBuZXcgUmVmbGVjdG9yKG5ldyBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKCkpO1xuXG4gICAgLyoqXG4gICAgICogYERlcGVuZGVuY3lgIGlzIHVzZWQgYnkgdGhlIGZyYW1ld29yayB0byBleHRlbmQgREkuXG4gICAgICogVGhpcyBpcyBpbnRlcm5hbCB0byBBbmd1bGFyIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHkuXG4gICAgICovXG4gICAgdmFyIFJlZmxlY3RpdmVEZXBlbmRlbmN5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZURlcGVuZGVuY3koa2V5LCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZFZpc2liaWxpdHkgPSBsb3dlckJvdW5kVmlzaWJpbGl0eTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZFZpc2liaWxpdHkgPSB1cHBlckJvdW5kVmlzaWJpbGl0eTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZURlcGVuZGVuY3kuZnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZURlcGVuZGVuY3koa2V5LCBmYWxzZSwgbnVsbCwgbnVsbCwgW10pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZURlcGVuZGVuY3k7XG4gICAgfSgpKTtcbiAgICB2YXIgX0VNUFRZX0xJU1QgPSBbXTtcbiAgICB2YXIgUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfKGtleSwgcmVzb2x2ZWRGYWN0b3JpZXMsIG11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZEZhY3RvcmllcyA9IHJlc29sdmVkRmFjdG9yaWVzO1xuICAgICAgICAgICAgdGhpcy5tdWx0aVByb3ZpZGVyID0gbXVsdGlQcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJfLnByb3RvdHlwZSwgXCJyZXNvbHZlZEZhY3RvcnlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlc29sdmVkRmFjdG9yaWVzWzBdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyXztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEFuIGludGVybmFsIHJlc29sdmVkIHJlcHJlc2VudGF0aW9uIG9mIGEgZmFjdG9yeSBmdW5jdGlvbiBjcmVhdGVkIGJ5IHJlc29sdmluZyB7QGxpbmtcbiAgICAgKiBQcm92aWRlcn0uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeShcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmFjdG9yeSBmdW5jdGlvbiB3aGljaCBjYW4gcmV0dXJuIGFuIGluc3RhbmNlIG9mIGFuIG9iamVjdCByZXByZXNlbnRlZCBieSBhIGtleS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZmFjdG9yeSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXJndW1lbnRzIChkZXBlbmRlbmNpZXMpIHRvIHRoZSBgZmFjdG9yeWAgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBhIHNpbmdsZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlUmVmbGVjdGl2ZUZhY3RvcnkocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIGZhY3RvcnlGbjtcbiAgICAgICAgdmFyIHJlc29sdmVkRGVwcztcbiAgICAgICAgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VDbGFzcykpIHtcbiAgICAgICAgICAgIHZhciB1c2VDbGFzcyA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyLnVzZUNsYXNzKTtcbiAgICAgICAgICAgIGZhY3RvcnlGbiA9IHJlZmxlY3Rvci5mYWN0b3J5KHVzZUNsYXNzKTtcbiAgICAgICAgICAgIHJlc29sdmVkRGVwcyA9IF9kZXBlbmRlbmNpZXNGb3IodXNlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudChwcm92aWRlci51c2VFeGlzdGluZykpIHtcbiAgICAgICAgICAgIGZhY3RvcnlGbiA9IGZ1bmN0aW9uIChhbGlhc0luc3RhbmNlKSB7IHJldHVybiBhbGlhc0luc3RhbmNlOyB9O1xuICAgICAgICAgICAgcmVzb2x2ZWREZXBzID0gW1JlZmxlY3RpdmVEZXBlbmRlbmN5LmZyb21LZXkoUmVmbGVjdGl2ZUtleS5nZXQocHJvdmlkZXIudXNlRXhpc3RpbmcpKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQcmVzZW50KHByb3ZpZGVyLnVzZUZhY3RvcnkpKSB7XG4gICAgICAgICAgICBmYWN0b3J5Rm4gPSBwcm92aWRlci51c2VGYWN0b3J5O1xuICAgICAgICAgICAgcmVzb2x2ZWREZXBzID0gY29uc3RydWN0RGVwZW5kZW5jaWVzKHByb3ZpZGVyLnVzZUZhY3RvcnksIHByb3ZpZGVyLmRlcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFjdG9yeUZuID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdmlkZXIudXNlVmFsdWU7IH07XG4gICAgICAgICAgICByZXNvbHZlZERlcHMgPSBfRU1QVFlfTElTVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkoZmFjdG9yeUZuLCByZXNvbHZlZERlcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUge0BsaW5rIFByb3ZpZGVyfSBpbnRvIHtAbGluayBSZXNvbHZlZFByb3ZpZGVyfS5cbiAgICAgKlxuICAgICAqIHtAbGluayBJbmplY3Rvcn0gaW50ZXJuYWxseSBvbmx5IHVzZXMge0BsaW5rIFJlc29sdmVkUHJvdmlkZXJ9LCB7QGxpbmsgUHJvdmlkZXJ9IGNvbnRhaW5zXG4gICAgICogY29udmVuaWVuY2UgcHJvdmlkZXIgc3ludGF4LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8oUmVmbGVjdGl2ZUtleS5nZXQocHJvdmlkZXIucHJvdmlkZSksIFtyZXNvbHZlUmVmbGVjdGl2ZUZhY3RvcnkocHJvdmlkZXIpXSwgcHJvdmlkZXIubXVsdGkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGEgbGlzdCBvZiBQcm92aWRlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcnMocHJvdmlkZXJzKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkID0gX25vcm1hbGl6ZVByb3ZpZGVycyhwcm92aWRlcnMsIFtdKTtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gbm9ybWFsaXplZC5tYXAocmVzb2x2ZVJlZmxlY3RpdmVQcm92aWRlcik7XG4gICAgICAgIHJldHVybiBNYXBXcmFwcGVyLnZhbHVlcyhtZXJnZVJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycyhyZXNvbHZlZCwgbmV3IE1hcCgpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhIGxpc3Qgb2YgUmVzb2x2ZWRQcm92aWRlcnMgaW50byBhIGxpc3Qgd2hlcmVcbiAgICAgKiBlYWNoIGtleSBpcyBjb250YWluZWQgZXhhY3RseSBvbmNlIGFuZCBtdWx0aSBwcm92aWRlcnNcbiAgICAgKiBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzKHByb3ZpZGVycywgbm9ybWFsaXplZFByb3ZpZGVyc01hcCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3ZpZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gcHJvdmlkZXJzW2ldO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gbm9ybWFsaXplZFByb3ZpZGVyc01hcC5nZXQocHJvdmlkZXIua2V5LmlkKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIgIT09IGV4aXN0aW5nLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1peGluZ011bHRpUHJvdmlkZXJzV2l0aFJlZ3VsYXJQcm92aWRlcnNFcnJvcihleGlzdGluZywgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubXVsdGlQcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5yZXNvbHZlZEZhY3Rvcmllcy5wdXNoKHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3ZpZGVyc01hcC5zZXQocHJvdmlkZXIua2V5LmlkLCBwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkUHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IG5ldyBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcl8ocHJvdmlkZXIua2V5LCBMaXN0V3JhcHBlci5jbG9uZShwcm92aWRlci5yZXNvbHZlZEZhY3RvcmllcyksIHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvdmlkZXJzTWFwLnNldChwcm92aWRlci5rZXkuaWQsIHJlc29sdmVkUHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkUHJvdmlkZXJzTWFwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbm9ybWFsaXplUHJvdmlkZXJzKHByb3ZpZGVycywgcmVzKSB7XG4gICAgICAgIHByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBpZiAoYiBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaCh7IHByb3ZpZGU6IGIsIHVzZUNsYXNzOiBiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0JyAmJiBiLnByb3ZpZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgX25vcm1hbGl6ZVByb3ZpZGVycyhiLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm92aWRlckVycm9yKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc3RydWN0RGVwZW5kZW5jaWVzKHR5cGVPckZ1bmMsIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgcmV0dXJuIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gW3RdOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uICh0KSB7IHJldHVybiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMsIHQsIHBhcmFtcyk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9kZXBlbmRlbmNpZXNGb3IodHlwZU9yRnVuYykge1xuICAgICAgICB2YXIgcGFyYW1zID0gcmVmbGVjdG9yLnBhcmFtZXRlcnModHlwZU9yRnVuYyk7XG4gICAgICAgIGlmICghcGFyYW1zKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBpZiAocGFyYW1zLnNvbWUoaXNCbGFuaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb0Fubm90YXRpb25FcnJvcih0eXBlT3JGdW5jLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMsIHAsIHBhcmFtcyk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZXh0cmFjdFRva2VuKHR5cGVPckZ1bmMgLyoqIFRPRE8gIzkxMDAgKi8sIG1ldGFkYXRhIC8qKiBUT0RPICM5MTAwICovIC8qYW55W10gfCBhbnkqLywgcGFyYW1zKSB7XG4gICAgICAgIHZhciBkZXBQcm9wcyA9IFtdO1xuICAgICAgICB2YXIgdG9rZW4gPSBudWxsO1xuICAgICAgICB2YXIgb3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFpc0FycmF5KG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhIGluc3RhbmNlb2YgSW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBlbmRlbmN5KG1ldGFkYXRhLnRva2VuLCBvcHRpb25hbCwgbnVsbCwgbnVsbCwgZGVwUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVEZXBlbmRlbmN5KG1ldGFkYXRhLCBvcHRpb25hbCwgbnVsbCwgbnVsbCwgZGVwUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsb3dlckJvdW5kVmlzaWJpbGl0eSA9IG51bGw7XG4gICAgICAgIHZhciB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YWRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbU1ldGFkYXRhID0gbWV0YWRhdGFbaV07XG4gICAgICAgICAgICBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgSW5qZWN0KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbU1ldGFkYXRhLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1NZXRhZGF0YSBpbnN0YW5jZW9mIFNlbGYpIHtcbiAgICAgICAgICAgICAgICB1cHBlckJvdW5kVmlzaWJpbGl0eSA9IHBhcmFtTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbU1ldGFkYXRhIGluc3RhbmNlb2YgSG9zdCkge1xuICAgICAgICAgICAgICAgIHVwcGVyQm91bmRWaXNpYmlsaXR5ID0gcGFyYW1NZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtTWV0YWRhdGEgaW5zdGFuY2VvZiBTa2lwU2VsZikge1xuICAgICAgICAgICAgICAgIGxvd2VyQm91bmRWaXNpYmlsaXR5ID0gcGFyYW1NZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKHRva2VuKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlRGVwZW5kZW5jeSh0b2tlbiwgb3B0aW9uYWwsIGxvd2VyQm91bmRWaXNpYmlsaXR5LCB1cHBlckJvdW5kVmlzaWJpbGl0eSwgZGVwUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQW5ub3RhdGlvbkVycm9yKHR5cGVPckZ1bmMsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2NyZWF0ZURlcGVuZGVuY3kodG9rZW4gLyoqIFRPRE8gIzkxMDAgKi8sIG9wdGlvbmFsIC8qKiBUT0RPICM5MTAwICovLCBsb3dlckJvdW5kVmlzaWJpbGl0eSAvKiogVE9ETyAjOTEwMCAqLywgdXBwZXJCb3VuZFZpc2liaWxpdHkgLyoqIFRPRE8gIzkxMDAgKi8sIGRlcFByb3BzIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVmbGVjdGl2ZURlcGVuZGVuY3koUmVmbGVjdGl2ZUtleS5nZXQodG9rZW4pLCBvcHRpb25hbCwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBkZXBQcm9wcyk7XG4gICAgfVxuXG4gICAgLy8gYXZvaWQgdW51c2VkIGltcG9ydCB3aGVuIFR5cGUgdW5pb24gdHlwZXMgYXJlIGVyYXNlZFxuICAgIC8vIFRocmVzaG9sZCBmb3IgdGhlIGR5bmFtaWMgdmVyc2lvblxuICAgIHZhciBfTUFYX0NPTlNUUlVDVElPTl9DT1VOVEVSID0gMTA7XG4gICAgdmFyIFVOREVGSU5FRCA9IG5ldyBPYmplY3QoKTtcbiAgICB2YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JJbmxpbmVTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kocHJvdG9FSSwgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyMyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyNyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyOCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyOSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkMyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkNyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkOCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmtleUlkOSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gcHJvdmlkZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjAgPSBwcm92aWRlcnNbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDAgPSBwcm92aWRlcnNbMF0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyMSA9IHByb3ZpZGVyc1sxXTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkMSA9IHByb3ZpZGVyc1sxXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIyID0gcHJvdmlkZXJzWzJdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQyID0gcHJvdmlkZXJzWzJdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjMgPSBwcm92aWRlcnNbM107XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDMgPSBwcm92aWRlcnNbM10ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyNCA9IHByb3ZpZGVyc1s0XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkNCA9IHByb3ZpZGVyc1s0XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gNSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI1ID0gcHJvdmlkZXJzWzVdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ1ID0gcHJvdmlkZXJzWzVdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjYgPSBwcm92aWRlcnNbNl07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDYgPSBwcm92aWRlcnNbNl0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IDcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyNyA9IHByb3ZpZGVyc1s3XTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkNyA9IHByb3ZpZGVyc1s3XS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gOCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXI4ID0gcHJvdmlkZXJzWzhdO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5SWQ4ID0gcHJvdmlkZXJzWzhdLmtleS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiA5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlcjkgPSBwcm92aWRlcnNbOV07XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlJZDkgPSBwcm92aWRlcnNbOV0ua2V5LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIwO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIxO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIyO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIzO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI0O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI1O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI2O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI3O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI4O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI5O1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5ID0gZnVuY3Rpb24gKGluamVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5KGluamVjdG9yLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9ySW5saW5lU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneShwcm90b0luaiwgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgICAgIHZhciBsZW4gPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5rZXlJZHMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkc1tpXSA9IHByb3ZpZGVyc1tpXS5rZXkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldFByb3ZpZGVyQXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnByb3ZpZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnNbaW5kZXhdO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3RvckR5bmFtaWNTdHJhdGVneS5wcm90b3R5cGUuY3JlYXRlSW5qZWN0b3JTdHJhdGVneSA9IGZ1bmN0aW9uIChlaSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kodGhpcywgZWkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3k7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZQcm92aWRlcnMgPSBwcm92aWRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBwcm92aWRlcnMubGVuZ3RoID4gX01BWF9DT05TVFJVQ1RJT05fQ09VTlRFUiA/XG4gICAgICAgICAgICAgICAgbmV3IFJlZmxlY3RpdmVQcm90b0luamVjdG9yRHluYW1pY1N0cmF0ZWd5KHRoaXMsIHByb3ZpZGVycykgOlxuICAgICAgICAgICAgICAgIG5ldyBSZWZsZWN0aXZlUHJvdG9JbmplY3RvcklubGluZVN0cmF0ZWd5KHRoaXMsIHByb3ZpZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvcihwcm92aWRlcnMpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlUHJvdG9JbmplY3Rvci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuZ2V0UHJvdmlkZXJBdEluZGV4KGluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVQcm90b0luamVjdG9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3koaW5qZWN0b3IsIHByb3RvU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMucHJvdG9TdHJhdGVneSA9IHByb3RvU3RyYXRlZ3k7XG4gICAgICAgICAgICB0aGlzLm9iajAgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajEgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajIgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajMgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajQgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajUgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajYgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajcgPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajggPSBVTkRFRklORUQ7XG4gICAgICAgICAgICB0aGlzLm9iajkgPSBVTkRFRklORUQ7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0Q29uc3RydWN0aW9uQ291bnRlciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmplY3Rvci5fY29uc3RydWN0aW9uQ291bnRlciA9IDA7IH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5pbnN0YW50aWF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3Rvci5fbmV3KHByb3ZpZGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9ySW5saW5lU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wcm90b1N0cmF0ZWd5O1xuICAgICAgICAgICAgdmFyIGluaiA9IHRoaXMuaW5qZWN0b3I7XG4gICAgICAgICAgICBpZiAocC5rZXlJZDAgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqMCA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqMCA9IGluai5fbmV3KHAucHJvdmlkZXIwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkMSA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmoxID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmoxID0gaW5qLl9uZXcocC5wcm92aWRlcjEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmoxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQyID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajIgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajIgPSBpbmouX25ldyhwLnByb3ZpZGVyMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDMgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqMyA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqMyA9IGluai5fbmV3KHAucHJvdmlkZXIzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkNCA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo0ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo0ID0gaW5qLl9uZXcocC5wcm92aWRlcjQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ1ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajUgPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajUgPSBpbmouX25ldyhwLnByb3ZpZGVyNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDYgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqNiA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqNiA9IGluai5fbmV3KHAucHJvdmlkZXI2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLmtleUlkNyA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vYmo3ID09PSBVTkRFRklORUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmo3ID0gaW5qLl9uZXcocC5wcm92aWRlcjcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAua2V5SWQ4ID09PSBrZXlJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iajggPT09IFVOREVGSU5FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9iajggPSBpbmouX25ldyhwLnByb3ZpZGVyOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocC5rZXlJZDkgPT09IGtleUlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub2JqOSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JqOSA9IGluai5fbmV3KHAucHJvdmlkZXI5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBVTkRFRklORUQ7XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXRPYmpBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmowO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqMTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAyKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajI7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gMylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmozO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNDtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA1KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajU7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gNilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo2O1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IDcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqNztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSA4KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iajg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gOSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vYmo5O1xuICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mQm91bmRzRXJyb3IoaW5kZXgpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JJbmxpbmVTdHJhdGVneS5wcm90b3R5cGUuZ2V0TWF4TnVtYmVyT2ZPYmplY3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX01BWF9DT05TVFJVQ1RJT05fQ09VTlRFUjsgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3RpdmVJbmplY3RvcklubGluZVN0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgdmFyIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlZmxlY3RpdmVJbmplY3RvckR5bmFtaWNTdHJhdGVneShwcm90b1N0cmF0ZWd5LCBpbmplY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5wcm90b1N0cmF0ZWd5ID0gcHJvdG9TdHJhdGVneTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0b3IgPSBpbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMub2JqcyA9IG5ldyBBcnJheShwcm90b1N0cmF0ZWd5LnByb3ZpZGVycy5sZW5ndGgpO1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIuZmlsbCh0aGlzLm9ianMsIFVOREVGSU5FRCk7XG4gICAgICAgIH1cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5yZXNldENvbnN0cnVjdGlvbkNvdW50ZXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuaW5qZWN0b3IuX2NvbnN0cnVjdGlvbkNvdW50ZXIgPSAwOyB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmluc3RhbnRpYXRlUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yLl9uZXcocHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JEeW5hbWljU3RyYXRlZ3kucHJvdG90eXBlLmdldE9iakJ5S2V5SWQgPSBmdW5jdGlvbiAoa2V5SWQpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wcm90b1N0cmF0ZWd5O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmtleUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwLmtleUlkc1tpXSA9PT0ga2V5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub2Jqc1tpXSA9PT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9ianNbaV0gPSB0aGlzLmluamVjdG9yLl9uZXcocC5wcm92aWRlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9ianNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFVOREVGSU5FRDtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5nZXRPYmpBdEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMub2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZCb3VuZHNFcnJvcihpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmpzW2luZGV4XTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5LnByb3RvdHlwZS5nZXRNYXhOdW1iZXJPZk9iamVjdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm9ianMubGVuZ3RoOyB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yRHluYW1pY1N0cmF0ZWd5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQSBSZWZsZWN0aXZlRGVwZW5kZW5jeSBpbmplY3Rpb24gY29udGFpbmVyIHVzZWQgZm9yIGluc3RhbnRpYXRpbmcgb2JqZWN0cyBhbmQgcmVzb2x2aW5nXG4gICAgICogZGVwZW5kZW5jaWVzLlxuICAgICAqXG4gICAgICogQW4gYEluamVjdG9yYCBpcyBhIHJlcGxhY2VtZW50IGZvciBhIGBuZXdgIG9wZXJhdG9yLCB3aGljaCBjYW4gYXV0b21hdGljYWxseSByZXNvbHZlIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEluIHR5cGljYWwgdXNlLCBhcHBsaWNhdGlvbiBjb2RlIGFza3MgZm9yIHRoZSBkZXBlbmRlbmNpZXMgaW4gdGhlIGNvbnN0cnVjdG9yIGFuZCB0aGV5IGFyZVxuICAgICAqIHJlc29sdmVkIGJ5IHRoZSBgSW5qZWN0b3JgLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L2p6amVjMD9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGNyZWF0ZXMgYW4gYEluamVjdG9yYCBjb25maWd1cmVkIHRvIGNyZWF0ZSBgRW5naW5lYCBhbmQgYENhcmAuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIEVuZ2luZSB7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQEluamVjdGFibGUoKVxuICAgICAqIGNsYXNzIENhciB7XG4gICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyLCBFbmdpbmVdKTtcbiAgICAgKiB2YXIgY2FyID0gaW5qZWN0b3IuZ2V0KENhcik7XG4gICAgICogZXhwZWN0KGNhciBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcbiAgICAgKiBleHBlY3QoY2FyLmVuZ2luZSBpbnN0YW5jZW9mIEVuZ2luZSkudG9CZSh0cnVlKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5vdGljZSwgd2UgZG9uJ3QgdXNlIHRoZSBgbmV3YCBvcGVyYXRvciBiZWNhdXNlIHdlIGV4cGxpY2l0bHkgd2FudCB0byBoYXZlIHRoZSBgSW5qZWN0b3JgXG4gICAgICogcmVzb2x2ZSBhbGwgb2YgdGhlIG9iamVjdCdzIGRlcGVuZGVuY2llcyBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBSZWZsZWN0aXZlSW5qZWN0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR1cm5zIGFuIGFycmF5IG9mIHByb3ZpZGVyIGRlZmluaXRpb25zIGludG8gYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHJlc29sdXRpb24gaXMgYSBwcm9jZXNzIG9mIGZsYXR0ZW5pbmcgbXVsdGlwbGUgbmVzdGVkIGFycmF5cyBhbmQgY29udmVydGluZyBpbmRpdmlkdWFsXG4gICAgICAgICAqIHByb3ZpZGVycyBpbnRvIGFuIGFycmF5IG9mIHtAbGluayBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcn1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvQWlYVEhpP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgcHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW0NhciwgW1tFbmdpbmVdXV0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzLmxlbmd0aCkudG9FcXVhbCgyKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVyc1swXSBpbnN0YW5jZW9mIFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmtleS5kaXNwbGF5TmFtZSkudG9CZShcIkNhclwiKTtcbiAgICAgICAgICogZXhwZWN0KHByb3ZpZGVyc1swXS5kZXBlbmRlbmNpZXMubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgKiBleHBlY3QocHJvdmlkZXJzWzBdLmZhY3RvcnkpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChwcm92aWRlcnNbMV0ua2V5LmRpc3BsYXlOYW1lKS50b0JlKFwiRW5naW5lXCIpO1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSB7QGxpbmsgUmVmbGVjdGl2ZUluamVjdG9yI2Zyb21SZXNvbHZlZFByb3ZpZGVyc30gZm9yIG1vcmUgaW5mby5cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlID0gZnVuY3Rpb24gKHByb3ZpZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVSZWZsZWN0aXZlUHJvdmlkZXJzKHByb3ZpZGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlcyBhbiBhcnJheSBvZiBwcm92aWRlcnMgYW5kIGNyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSB0aG9zZSBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBwYXNzZWQtaW4gcHJvdmlkZXJzIGNhbiBiZSBhbiBhcnJheSBvZiBgVHlwZWAsIHtAbGluayBQcm92aWRlcn0sXG4gICAgICAgICAqIG9yIGEgcmVjdXJzaXZlIGFycmF5IG9mIG1vcmUgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZVBPY2NBP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbQ2FyLCBFbmdpbmVdKTtcbiAgICAgICAgICogZXhwZWN0KGluamVjdG9yLmdldChDYXIpIGluc3RhbmNlb2YgQ2FyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBzbG93ZXIgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBgZnJvbVJlc29sdmVkUHJvdmlkZXJzYFxuICAgICAgICAgKiBiZWNhdXNlIGl0IG5lZWRzIHRvIHJlc29sdmUgdGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgZmlyc3QuXG4gICAgICAgICAqIFNlZSB7QGxpbmsgSW5qZWN0b3IjcmVzb2x2ZX0gYW5kIHtAbGluayBJbmplY3RvciNmcm9tUmVzb2x2ZWRQcm92aWRlcnN9LlxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUocHJvdmlkZXJzKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKFJlc29sdmVkUmVmbGVjdGl2ZVByb3ZpZGVycywgcGFyZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5qZWN0b3IgZnJvbSBwcmV2aW91c2x5IHJlc29sdmVkIHByb3ZpZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBBUEkgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byBjb25zdHJ1Y3QgaW5qZWN0b3JzIGluIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZSBwYXJ0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tyU01jaT9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIENhciB7XG4gICAgICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIHByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDYXIsIEVuZ2luZV0pO1xuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHByb3ZpZGVycyk7XG4gICAgICAgICAqIGV4cGVjdChpbmplY3Rvci5nZXQoQ2FyKSBpbnN0YW5jZW9mIENhcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5mcm9tUmVzb2x2ZWRQcm92aWRlcnMgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZmxlY3RpdmVJbmplY3Rvcl8oUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHByb3ZpZGVycyksIHBhcmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlSW5qZWN0b3IucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcmVudCBvZiB0aGlzIGluamVjdG9yLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byB0aGUgc2VjdGlvbiBvZiB0aGUgdXNlciBndWlkZSB0YWxraW5nIGFib3V0IGhpZXJhcmNoaWNhbCBpbmplY3Rpb24uXG4gICAgICAgICAgICAgKiAtLT5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvZW9zTUdvP3A9cHJldmlldykpXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgICAgICogdmFyIHBhcmVudCA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtdKTtcbiAgICAgICAgICAgICAqIHZhciBjaGlsZCA9IHBhcmVudC5yZXNvbHZlQW5kQ3JlYXRlQ2hpbGQoW10pO1xuICAgICAgICAgICAgICogZXhwZWN0KGNoaWxkLnBhcmVudCkudG9CZShwYXJlbnQpO1xuICAgICAgICAgICAgICogYGBgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmVzIGFuIGFycmF5IG9mIHByb3ZpZGVycyBhbmQgY3JlYXRlcyBhIGNoaWxkIGluamVjdG9yIGZyb20gdGhvc2UgcHJvdmlkZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgdG8gdGhlIHNlY3Rpb24gb2YgdGhlIHVzZXIgZ3VpZGUgdGFsa2luZyBhYm91dCBoaWVyYXJjaGljYWwgaW5qZWN0aW9uLlxuICAgICAgICAgKiAtLT5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHBhc3NlZC1pbiBwcm92aWRlcnMgY2FuIGJlIGFuIGFycmF5IG9mIGBUeXBlYCwge0BsaW5rIFByb3ZpZGVyfSxcbiAgICAgICAgICogb3IgYSByZWN1cnNpdmUgYXJyYXkgb2YgbW9yZSBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9vcEIzVDQ/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBjbGFzcyBQYXJlbnRQcm92aWRlciB7fVxuICAgICAgICAgKiBjbGFzcyBDaGlsZFByb3ZpZGVyIHt9XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBwYXJlbnQgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbUGFyZW50UHJvdmlkZXJdKTtcbiAgICAgICAgICogdmFyIGNoaWxkID0gcGFyZW50LnJlc29sdmVBbmRDcmVhdGVDaGlsZChbQ2hpbGRQcm92aWRlcl0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSBpbnN0YW5jZW9mIFBhcmVudFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KENoaWxkUHJvdmlkZXIpIGluc3RhbmNlb2YgQ2hpbGRQcm92aWRlcikudG9CZSh0cnVlKTtcbiAgICAgICAgICogZXhwZWN0KGNoaWxkLmdldChQYXJlbnRQcm92aWRlcikpLnRvQmUocGFyZW50LmdldChQYXJlbnRQcm92aWRlcikpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBzbG93ZXIgdGhhbiB0aGUgY29ycmVzcG9uZGluZyBgY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWRgXG4gICAgICAgICAqIGJlY2F1c2UgaXQgbmVlZHMgdG8gcmVzb2x2ZSB0aGUgcGFzc2VkLWluIHByb3ZpZGVycyBmaXJzdC5cbiAgICAgICAgICogU2VlIHtAbGluayBJbmplY3RvciNyZXNvbHZlfSBhbmQge0BsaW5rIEluamVjdG9yI2NyZWF0ZUNoaWxkRnJvbVJlc29sdmVkfS5cbiAgICAgICAgICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvci5wcm90b3R5cGUucmVzb2x2ZUFuZENyZWF0ZUNoaWxkID0gZnVuY3Rpb24gKHByb3ZpZGVycykgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGNoaWxkIGluamVjdG9yIGZyb20gcHJldmlvdXNseSByZXNvbHZlZCBwcm92aWRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIDwhLS0gVE9ETzogQWRkIGEgbGluayB0byB0aGUgc2VjdGlvbiBvZiB0aGUgdXNlciBndWlkZSB0YWxraW5nIGFib3V0IGhpZXJhcmNoaWNhbCBpbmplY3Rpb24uXG4gICAgICAgICAqIC0tPlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIEFQSSBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIGNvbnN0cnVjdCBpbmplY3RvcnMgaW4gcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIHBhcnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvVmh5ZmpOP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogY2xhc3MgUGFyZW50UHJvdmlkZXIge31cbiAgICAgICAgICogY2xhc3MgQ2hpbGRQcm92aWRlciB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgcGFyZW50UHJvdmlkZXJzID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW1BhcmVudFByb3ZpZGVyXSk7XG4gICAgICAgICAqIHZhciBjaGlsZFByb3ZpZGVycyA9IFJlZmxlY3RpdmVJbmplY3Rvci5yZXNvbHZlKFtDaGlsZFByb3ZpZGVyXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBwYXJlbnQgPSBSZWZsZWN0aXZlSW5qZWN0b3IuZnJvbVJlc29sdmVkUHJvdmlkZXJzKHBhcmVudFByb3ZpZGVycyk7XG4gICAgICAgICAqIHZhciBjaGlsZCA9IHBhcmVudC5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZChjaGlsZFByb3ZpZGVycyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoUGFyZW50UHJvdmlkZXIpIGluc3RhbmNlb2YgUGFyZW50UHJvdmlkZXIpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAqIGV4cGVjdChjaGlsZC5nZXQoQ2hpbGRQcm92aWRlcikgaW5zdGFuY2VvZiBDaGlsZFByb3ZpZGVyKS50b0JlKHRydWUpO1xuICAgICAgICAgKiBleHBlY3QoY2hpbGQuZ2V0KFBhcmVudFByb3ZpZGVyKSkudG9CZShwYXJlbnQuZ2V0KFBhcmVudFByb3ZpZGVyKSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5jcmVhdGVDaGlsZEZyb21SZXNvbHZlZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHZlcyBhIHByb3ZpZGVyIGFuZCBpbnN0YW50aWF0ZXMgYW4gb2JqZWN0IGluIHRoZSBjb250ZXh0IG9mIHRoZSBpbmplY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNyZWF0ZWQgb2JqZWN0IGRvZXMgbm90IGdldCBjYWNoZWQgYnkgdGhlIGluamVjdG9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQveXZWWG9CP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQEluamVjdGFibGUoKVxuICAgICAgICAgKiBjbGFzcyBFbmdpbmUge1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgQ2FyIHtcbiAgICAgICAgICogICBjb25zdHJ1Y3RvcihwdWJsaWMgZW5naW5lOkVuZ2luZSkge31cbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgaW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbRW5naW5lXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHZhciBjYXIgPSBpbmplY3Rvci5yZXNvbHZlQW5kSW5zdGFudGlhdGUoQ2FyKTtcbiAgICAgICAgICogZXhwZWN0KGNhci5lbmdpbmUpLnRvQmUoaW5qZWN0b3IuZ2V0KEVuZ2luZSkpO1xuICAgICAgICAgKiBleHBlY3QoY2FyKS5ub3QudG9CZShpbmplY3Rvci5yZXNvbHZlQW5kSW5zdGFudGlhdGUoQ2FyKSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5yZXNvbHZlQW5kSW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhbiBvYmplY3QgdXNpbmcgYSByZXNvbHZlZCBwcm92aWRlciBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5qZWN0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjcmVhdGVkIG9iamVjdCBkb2VzIG5vdCBnZXQgY2FjaGVkIGJ5IHRoZSBpbmplY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L3B0Q0ltUT9wPXByZXZpZXcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgICAgICogY2xhc3MgRW5naW5lIHtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICAgICAqIGNsYXNzIENhciB7XG4gICAgICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGVuZ2luZTpFbmdpbmUpIHt9XG4gICAgICAgICAqIH1cbiAgICAgICAgICpcbiAgICAgICAgICogdmFyIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW0VuZ2luZV0pO1xuICAgICAgICAgKiB2YXIgY2FyUHJvdmlkZXIgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShbQ2FyXSlbMF07XG4gICAgICAgICAqIHZhciBjYXIgPSBpbmplY3Rvci5pbnN0YW50aWF0ZVJlc29sdmVkKGNhclByb3ZpZGVyKTtcbiAgICAgICAgICogZXhwZWN0KGNhci5lbmdpbmUpLnRvQmUoaW5qZWN0b3IuZ2V0KEVuZ2luZSkpO1xuICAgICAgICAgKiBleHBlY3QoY2FyKS5ub3QudG9CZShpbmplY3Rvci5pbnN0YW50aWF0ZVJlc29sdmVkKGNhclByb3ZpZGVyKSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yLnByb3RvdHlwZS5pbnN0YW50aWF0ZVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0aXZlSW5qZWN0b3I7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVmbGVjdGl2ZUluamVjdG9yXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSZWZsZWN0aXZlSW5qZWN0b3JfKF9wcm90byAvKiBQcm90b0luamVjdG9yICovLCBfcGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoX3BhcmVudCA9PT0gdm9pZCAwKSB7IF9wYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jb25zdHJ1Y3Rpb25Db3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvID0gX3Byb3RvO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gX3Byb3RvLl9zdHJhdGVneS5jcmVhdGVJbmplY3RvclN0cmF0ZWd5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXkoUmVmbGVjdGl2ZUtleS5nZXQodG9rZW4pLCBudWxsLCBudWxsLCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuZ2V0QXQgPSBmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5LmdldE9iakF0SW5kZXgoaW5kZXgpOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLCBcImludGVybmFsU3RyYXRlZ3lcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICAgICAqIEludGVybmFsLiBEbyBub3QgdXNlLlxuICAgICAgICAgICAgICogV2UgcmV0dXJuIGBhbnlgIG5vdCB0byBleHBvcnQgdGhlIEluamVjdG9yU3RyYXRlZ3kgdHlwZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdHJhdGVneTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLnJlc29sdmVBbmRDcmVhdGVDaGlsZCA9IGZ1bmN0aW9uIChwcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBSZXNvbHZlZFJlZmxlY3RpdmVQcm92aWRlcnMgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZShwcm92aWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWQoUmVzb2x2ZWRSZWZsZWN0aXZlUHJvdmlkZXJzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuY3JlYXRlQ2hpbGRGcm9tUmVzb2x2ZWQgPSBmdW5jdGlvbiAocHJvdmlkZXJzKSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBuZXcgUmVmbGVjdGl2ZVByb3RvSW5qZWN0b3IocHJvdmlkZXJzKTtcbiAgICAgICAgICAgIHZhciBpbmogPSBuZXcgUmVmbGVjdGl2ZUluamVjdG9yXyhwcm90byk7XG4gICAgICAgICAgICBpbmouX3BhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gaW5qO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5yZXNvbHZlQW5kSW5zdGFudGlhdGUgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbnRpYXRlUmVzb2x2ZWQoUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmUoW3Byb3ZpZGVyXSlbMF0pO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5pbnN0YW50aWF0ZVJlc29sdmVkID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFudGlhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX25ldyA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnN0cnVjdGlvbkNvdW50ZXIrKyA+IHRoaXMuX3N0cmF0ZWd5LmdldE1heE51bWJlck9mT2JqZWN0cygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEN5Y2xpY0RlcGVuZGVuY3lFcnJvcih0aGlzLCBwcm92aWRlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICB9O1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5faW5zdGFudGlhdGVQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm11bHRpUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KHByb3ZpZGVyLnJlc29sdmVkRmFjdG9yaWVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbaV0gPSB0aGlzLl9pbnN0YW50aWF0ZShwcm92aWRlciwgcHJvdmlkZXIucmVzb2x2ZWRGYWN0b3JpZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnRpYXRlKHByb3ZpZGVyLCBwcm92aWRlci5yZXNvbHZlZEZhY3Rvcmllc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl9pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uIChwcm92aWRlciwgUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIGZhY3RvcnkgPSBSZXNvbHZlZFJlZmxlY3RpdmVGYWN0b3J5LmZhY3Rvcnk7XG4gICAgICAgICAgICB2YXIgZGVwcyA9IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3RvcnkuZGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGRlcHMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGQwO1xuICAgICAgICAgICAgdmFyIGQxO1xuICAgICAgICAgICAgdmFyIGQyO1xuICAgICAgICAgICAgdmFyIGQzO1xuICAgICAgICAgICAgdmFyIGQ0O1xuICAgICAgICAgICAgdmFyIGQ1O1xuICAgICAgICAgICAgdmFyIGQ2O1xuICAgICAgICAgICAgdmFyIGQ3O1xuICAgICAgICAgICAgdmFyIGQ4O1xuICAgICAgICAgICAgdmFyIGQ5O1xuICAgICAgICAgICAgdmFyIGQxMDtcbiAgICAgICAgICAgIHZhciBkMTE7XG4gICAgICAgICAgICB2YXIgZDEyO1xuICAgICAgICAgICAgdmFyIGQxMztcbiAgICAgICAgICAgIHZhciBkMTQ7XG4gICAgICAgICAgICB2YXIgZDE1O1xuICAgICAgICAgICAgdmFyIGQxNjtcbiAgICAgICAgICAgIHZhciBkMTc7XG4gICAgICAgICAgICB2YXIgZDE4O1xuICAgICAgICAgICAgdmFyIGQxOTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZDAgPSBsZW5ndGggPiAwID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1swXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxID0gbGVuZ3RoID4gMSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMV0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMiA9IGxlbmd0aCA+IDIgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzJdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDMgPSBsZW5ndGggPiAzID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1szXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ0ID0gbGVuZ3RoID4gNCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbNF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkNSA9IGxlbmd0aCA+IDUgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzVdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDYgPSBsZW5ndGggPiA2ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s2XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQ3ID0gbGVuZ3RoID4gNyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbN10pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkOCA9IGxlbmd0aCA+IDggPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzhdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDkgPSBsZW5ndGggPiA5ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1s5XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxMCA9IGxlbmd0aCA+IDEwID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxMF0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTEgPSBsZW5ndGggPiAxMSA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTFdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDEyID0gbGVuZ3RoID4gMTIgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzEyXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxMyA9IGxlbmd0aCA+IDEzID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxM10pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTQgPSBsZW5ndGggPiAxNCA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTRdKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE1ID0gbGVuZ3RoID4gMTUgPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE1XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxNiA9IGxlbmd0aCA+IDE2ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxNl0pIDogbnVsbDtcbiAgICAgICAgICAgICAgICBkMTcgPSBsZW5ndGggPiAxNyA/IHRoaXMuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kocHJvdmlkZXIsIGRlcHNbMTddKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgZDE4ID0gbGVuZ3RoID4gMTggPyB0aGlzLl9nZXRCeVJlZmxlY3RpdmVEZXBlbmRlbmN5KHByb3ZpZGVyLCBkZXBzWzE4XSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGQxOSA9IGxlbmd0aCA+IDE5ID8gdGhpcy5fZ2V0QnlSZWZsZWN0aXZlRGVwZW5kZW5jeShwcm92aWRlciwgZGVwc1sxOV0pIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBYnN0cmFjdFByb3ZpZGVyRXJyb3IgfHwgZSBpbnN0YW5jZW9mIEluc3RhbnRpYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlLmFkZEtleSh0aGlzLCBwcm92aWRlci5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9iajtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IGZhY3RvcnkoZDAsIGQxLCBkMiwgZDMsIGQ0LCBkNSwgZDYsIGQ3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBmYWN0b3J5KGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5LCBkMTAsIGQxMSwgZDEyLCBkMTMsIGQxNCwgZDE1LCBkMTYsIGQxNywgZDE4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gZmFjdG9yeShkMCwgZDEsIGQyLCBkMywgZDQsIGQ1LCBkNiwgZDcsIGQ4LCBkOSwgZDEwLCBkMTEsIGQxMiwgZDEzLCBkMTQsIGQxNSwgZDE2LCBkMTcsIGQxOCwgZDE5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlICdcIiArIHByb3ZpZGVyLmtleS5kaXNwbGF5TmFtZSArIFwiJyBiZWNhdXNlIGl0IGhhcyBtb3JlIHRoYW4gMjAgZGVwZW5kZW5jaWVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3RhbnRpYXRpb25FcnJvcih0aGlzLCBlLCBlLnN0YWNrLCBwcm92aWRlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5UmVmbGVjdGl2ZURlcGVuZGVuY3kgPSBmdW5jdGlvbiAocHJvdmlkZXIsIGRlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5S2V5KGRlcC5rZXksIGRlcC5sb3dlckJvdW5kVmlzaWJpbGl0eSwgZGVwLnVwcGVyQm91bmRWaXNpYmlsaXR5LCBkZXAub3B0aW9uYWwgPyBudWxsIDogVEhST1dfSUZfTk9UX0ZPVU5EKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUuX2dldEJ5S2V5ID0gZnVuY3Rpb24gKGtleSwgbG93ZXJCb3VuZFZpc2liaWxpdHksIHVwcGVyQm91bmRWaXNpYmlsaXR5LCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBJTkpFQ1RPUl9LRVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cHBlckJvdW5kVmlzaWJpbGl0eSBpbnN0YW5jZW9mIFNlbGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXlTZWxmKGtleSwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QnlLZXlEZWZhdWx0KGtleSwgbm90Rm91bmRWYWx1ZSwgbG93ZXJCb3VuZFZpc2liaWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFJlZmxlY3RpdmVJbmplY3Rvcl8ucHJvdG90eXBlLl90aHJvd09yTnVsbCA9IGZ1bmN0aW9uIChrZXksIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChub3RGb3VuZFZhbHVlICE9PSBUSFJPV19JRl9OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90Rm91bmRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb1Byb3ZpZGVyRXJyb3IodGhpcywga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlLZXlTZWxmID0gZnVuY3Rpb24gKGtleSwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuX3N0cmF0ZWd5LmdldE9iakJ5S2V5SWQoa2V5LmlkKTtcbiAgICAgICAgICAgIHJldHVybiAob2JqICE9PSBVTkRFRklORUQpID8gb2JqIDogdGhpcy5fdGhyb3dPck51bGwoa2V5LCBub3RGb3VuZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZS5fZ2V0QnlLZXlEZWZhdWx0ID0gZnVuY3Rpb24gKGtleSwgbm90Rm91bmRWYWx1ZSwgbG93ZXJCb3VuZFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHZhciBpbmo7XG4gICAgICAgICAgICBpZiAobG93ZXJCb3VuZFZpc2liaWxpdHkgaW5zdGFuY2VvZiBTa2lwU2VsZikge1xuICAgICAgICAgICAgICAgIGluaiA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluaiA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaW5qIGluc3RhbmNlb2YgUmVmbGVjdGl2ZUluamVjdG9yXykge1xuICAgICAgICAgICAgICAgIHZhciBpbmpfID0gaW5qO1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBpbmpfLl9zdHJhdGVneS5nZXRPYmpCeUtleUlkKGtleS5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAhPT0gVU5ERUZJTkVEKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIGluaiA9IGlual8uX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmogIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5qLmdldChrZXkudG9rZW4sIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93T3JOdWxsKGtleSwgbm90Rm91bmRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZsZWN0aXZlSW5qZWN0b3JfLnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJzID0gX21hcFByb3ZpZGVycyh0aGlzLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gJyBcIicgKyBiLmtleS5kaXNwbGF5TmFtZSArICdcIiAnOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSZWZsZWN0aXZlSW5qZWN0b3IocHJvdmlkZXJzOiBbXCIgKyBwcm92aWRlcnMgKyBcIl0pXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUmVmbGVjdGl2ZUluamVjdG9yXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpc3BsYXlOYW1lOyB9O1xuICAgICAgICByZXR1cm4gUmVmbGVjdGl2ZUluamVjdG9yXztcbiAgICB9KCkpO1xuICAgIHZhciBJTkpFQ1RPUl9LRVkgPSBSZWZsZWN0aXZlS2V5LmdldChJbmplY3Rvcik7XG4gICAgZnVuY3Rpb24gX21hcFByb3ZpZGVycyhpbmplY3RvciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShpbmplY3Rvci5fcHJvdG8ubnVtYmVyT2ZQcm92aWRlcnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluamVjdG9yLl9wcm90by5udW1iZXJPZlByb3ZpZGVyczsgKytpKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBmbihpbmplY3Rvci5fcHJvdG8uZ2V0UHJvdmlkZXJBdEluZGV4KGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBQcm92aWRlcyBhIGhvb2sgZm9yIGNlbnRyYWxpemVkIGV4Y2VwdGlvbiBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYEVycm9ySGFuZGxlcmAgcHJpbnRzIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSBgY29uc29sZWAuIFRvXG4gICAgICogaW50ZXJjZXB0IGVycm9yIGhhbmRsaW5nLCB3cml0ZSBhIGN1c3RvbSBleGNlcHRpb24gaGFuZGxlciB0aGF0IHJlcGxhY2VzIHRoaXMgZGVmYXVsdCBhc1xuICAgICAqIGFwcHJvcHJpYXRlIGZvciB5b3VyIGFwcC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjbGFzcyBNeUVycm9ySGFuZGxlciBpbXBsZW1lbnRzIEVycm9ySGFuZGxlciB7XG4gICAgICogICBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgICAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZXhjZXB0aW9uXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBFcnJvckhhbmRsZXIsIHVzZUNsYXNzOiBNeUVycm9ySGFuZGxlcn1dXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeU1vZHVsZSB7fVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFcnJvckhhbmRsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFcnJvckhhbmRsZXIocmV0aHJvd0Vycm9yKSB7XG4gICAgICAgICAgICBpZiAocmV0aHJvd0Vycm9yID09PSB2b2lkIDApIHsgcmV0aHJvd0Vycm9yID0gdHJ1ZTsgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fY29uc29sZSA9IGNvbnNvbGU7XG4gICAgICAgICAgICB0aGlzLnJldGhyb3dFcnJvciA9IHJldGhyb3dFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxFcnJvciA9IHRoaXMuX2ZpbmRPcmlnaW5hbEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFN0YWNrID0gdGhpcy5fZmluZE9yaWdpbmFsU3RhY2soZXJyb3IpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9maW5kQ29udGV4dChlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKFwiRVhDRVBUSU9OOiBcIiArIHRoaXMuX2V4dHJhY3RNZXNzYWdlKGVycm9yKSk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3IoXCJPUklHSU5BTCBFWENFUFRJT046IFwiICsgdGhpcy5fZXh0cmFjdE1lc3NhZ2Uob3JpZ2luYWxFcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsU3RhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmVycm9yKCdPUklHSU5BTCBTVEFDS1RSQUNFOicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3Iob3JpZ2luYWxTdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUuZXJyb3IoJ0VSUk9SIENPTlRFWFQ6Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS5lcnJvcihjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHJldGhyb3cgZXhjZXB0aW9ucywgc28gb3BlcmF0aW9ucyBsaWtlICdib290c3RyYXAnIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yXG4gICAgICAgICAgICAvLyB3aGVuIGFuIGVycm9yIGhhcHBlbnMuIElmIHdlIGRvIG5vdCByZXRocm93LCBib290c3RyYXAgd2lsbCBhbHdheXMgc3VjY2VlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLnJldGhyb3dFcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLl9leHRyYWN0TWVzc2FnZSA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLl9maW5kQ29udGV4dCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yLmNvbnRleHQgPyBlcnJvci5jb250ZXh0IDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmluZENvbnRleHQoZXJyb3Iub3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBFcnJvckhhbmRsZXIucHJvdG90eXBlLl9maW5kT3JpZ2luYWxFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIGUgPSBlcnJvci5vcmlnaW5hbEVycm9yO1xuICAgICAgICAgICAgd2hpbGUgKGUgJiYgZS5vcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZSA9IGUub3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEVycm9ySGFuZGxlci5wcm90b3R5cGUuX2ZpbmRPcmlnaW5hbFN0YWNrID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3I7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBlLnN0YWNrO1xuICAgICAgICAgICAgd2hpbGUgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlID0gZS5vcmlnaW5hbEVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5zdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBzdGFjayA9IGUuc3RhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXJyb3JIYW5kbGVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICAgICAgICAvLyBhbGxvdyBhbnkgUHJvbWlzZS9BKyBjb21wbGlhbnQgdGhlbmFibGUuXG4gICAgICAgIC8vIEl0J3MgdXAgdG8gdGhlIGNhbGxlciB0byBlbnN1cmUgdGhhdCBvYmoudGhlbiBjb25mb3JtcyB0byB0aGUgc3BlY1xuICAgICAgICByZXR1cm4gISFvYmogJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYW4gYXBwbGljYXRpb24gaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBUFBfSU5JVElBTElaRVIgPSBuZXcgT3BhcXVlVG9rZW4oJ0FwcGxpY2F0aW9uIEluaXRpYWxpemVyJyk7XG4gICAgLyoqXG4gICAgICogQSBjbGFzcyB0aGF0IHJlZmxlY3RzIHRoZSBzdGF0ZSBvZiBydW5uaW5nIHtAbGluayBBUFBfSU5JVElBTElaRVJ9cy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQXBwbGljYXRpb25Jbml0U3RhdHVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbGljYXRpb25Jbml0U3RhdHVzKGFwcEluaXRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFzeW5jSW5pdFByb21pc2VzID0gW107XG4gICAgICAgICAgICBpZiAoYXBwSW5pdHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFwcEluaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0UmVzdWx0ID0gYXBwSW5pdHNbaV0oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShpbml0UmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNJbml0UHJvbWlzZXMucHVzaChpbml0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RvbmVQcm9taXNlID0gUHJvbWlzZS5hbGwoYXN5bmNJbml0UHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkgeyBfdGhpcy5fZG9uZSA9IHRydWU7IH0pO1xuICAgICAgICAgICAgaWYgKGFzeW5jSW5pdFByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvbkluaXRTdGF0dXMucHJvdG90eXBlLCBcImRvbmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kb25lOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uSW5pdFN0YXR1cy5wcm90b3R5cGUsIFwiZG9uZVByb21pc2VcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kb25lUHJvbWlzZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEFwcGxpY2F0aW9uSW5pdFN0YXR1cy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBBcHBsaWNhdGlvbkluaXRTdGF0dXMuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtBUFBfSU5JVElBTElaRVIsXSB9LCB7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25Jbml0U3RhdHVzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIERJIFRva2VuIHJlcHJlc2VudGluZyBhIHVuaXF1ZSBzdHJpbmcgaWQgYXNzaWduZWQgdG8gdGhlIGFwcGxpY2F0aW9uIGJ5IEFuZ3VsYXIgYW5kIHVzZWRcbiAgICAgKiBwcmltYXJpbHkgZm9yIHByZWZpeGluZyBhcHBsaWNhdGlvbiBhdHRyaWJ1dGVzIGFuZCBDU1Mgc3R5bGVzIHdoZW5cbiAgICAgKiB7QGxpbmsgVmlld0VuY2Fwc3VsYXRpb24jRW11bGF0ZWR9IGlzIGJlaW5nIHVzZWQuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBhdm9pZCByYW5kb21seSBnZW5lcmF0ZWQgdmFsdWUgdG8gYmUgdXNlZCBhcyBhbiBhcHBsaWNhdGlvbiBpZCwgeW91IGNhbiBwcm92aWRlXG4gICAgICogYSBjdXN0b20gdmFsdWUgdmlhIGEgREkgcHJvdmlkZXIgPCEtLSBUT0RPOiBwcm92aWRlciAtLT4gY29uZmlndXJpbmcgdGhlIHJvb3Qge0BsaW5rIEluamVjdG9yfVxuICAgICAqIHVzaW5nIHRoaXMgdG9rZW4uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBUFBfSUQgPSBuZXcgT3BhcXVlVG9rZW4oJ0FwcElkJyk7XG4gICAgZnVuY3Rpb24gX2FwcElkUmFuZG9tUHJvdmlkZXJGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIF9yYW5kb21DaGFyKCkgKyBfcmFuZG9tQ2hhcigpICsgX3JhbmRvbUNoYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXJzIHRoYXQgd2lsbCBnZW5lcmF0ZSBhIHJhbmRvbSBBUFBfSURfVE9LRU4uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBBUFBfSURfUkFORE9NX1BST1ZJREVSID0ge1xuICAgICAgICBwcm92aWRlOiBBUFBfSUQsXG4gICAgICAgIHVzZUZhY3Rvcnk6IF9hcHBJZFJhbmRvbVByb3ZpZGVyRmFjdG9yeSxcbiAgICAgICAgZGVwczogW10sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBfcmFuZG9tQ2hhcigpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZ1dyYXBwZXIuZnJvbUNoYXJDb2RlKDk3ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhIHBsYXRmb3JtIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUExBVEZPUk1fSU5JVElBTElaRVIgPSBuZXcgT3BhcXVlVG9rZW4oJ1BsYXRmb3JtIEluaXRpYWxpemVyJyk7XG4gICAgLyoqXG4gICAgICogQWxsIGNhbGxiYWNrcyBwcm92aWRlZCB2aWEgdGhpcyB0b2tlbiB3aWxsIGJlIGNhbGxlZCBmb3IgZXZlcnkgY29tcG9uZW50IHRoYXQgaXMgYm9vdHN0cmFwcGVkLlxuICAgICAqIFNpZ25hdHVyZSBvZiB0aGUgY2FsbGJhY2s6XG4gICAgICpcbiAgICAgKiBgKGNvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmKSA9PiB2b2lkYC5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQVBQX0JPT1RTVFJBUF9MSVNURU5FUiA9IG5ldyBPcGFxdWVUb2tlbignYXBwQm9vdHN0cmFwTGlzdGVuZXInKTtcbiAgICAvKipcbiAgICAgKiBBIHRva2VuIHdoaWNoIGluZGljYXRlcyB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBQQUNLQUdFX1JPT1RfVVJMID0gbmV3IE9wYXF1ZVRva2VuKCdBcHBsaWNhdGlvbiBQYWNrYWdlcyBSb290IFVSTCcpO1xuXG4gICAgdmFyIENvbnNvbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb25zb2xlKCkge1xuICAgICAgICB9XG4gICAgICAgIENvbnNvbGUucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHByaW50KG1lc3NhZ2UpOyB9O1xuICAgICAgICAvLyBOb3RlOiBmb3IgcmVwb3J0aW5nIGVycm9ycyB1c2UgYERPTS5sb2dFcnJvcigpYCBhcyBpdCBpcyBwbGF0Zm9ybSBzcGVjaWZpY1xuICAgICAgICBDb25zb2xlLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgd2FybihtZXNzYWdlKTsgfTtcbiAgICAgICAgQ29uc29sZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBDb25zb2xlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBDb25zb2xlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBjb21wb25lbnQgaXMgc3RpbGwgYmVpbmcgbG9hZGVkIGluIGEgc3luY2hyb25vdXMgY29tcGlsZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNChDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IoY29tcFR5cGUpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQ2FuJ3QgY29tcGlsZSBzeW5jaHJvbm91c2x5IGFzIFwiICsgc3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIGlzIHN0aWxsIGJlaW5nIGxvYWRlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmNvbXBUeXBlID0gY29tcFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG4gICAgLyoqXG4gICAgICogQ29tYmluYXRpb24gb2YgTmdNb2R1bGVGYWN0b3J5IGFuZCBDb21wb25lbnRGYWN0b3J5cy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTW9kdWxlV2l0aENvbXBvbmVudEZhY3RvcmllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMobmdNb2R1bGVGYWN0b3J5LCBjb21wb25lbnRGYWN0b3JpZXMpIHtcbiAgICAgICAgICAgIHRoaXMubmdNb2R1bGVGYWN0b3J5ID0gbmdNb2R1bGVGYWN0b3J5O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3JpZXMgPSBjb21wb25lbnRGYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXM7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfdGhyb3dFcnJvcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVudGltZSBjb21waWxlciBpcyBub3QgbG9hZGVkXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb3ctbGV2ZWwgc2VydmljZSBmb3IgcnVubmluZyB0aGUgYW5ndWxhciBjb21waWxlciBkdXJpbmcgcnVudGltZVxuICAgICAqIHRvIGNyZWF0ZSB7QGxpbmsgQ29tcG9uZW50RmFjdG9yeX1zLCB3aGljaFxuICAgICAqIGNhbiBsYXRlciBiZSB1c2VkIHRvIGNyZWF0ZSBhbmQgcmVuZGVyIGEgQ29tcG9uZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogRWFjaCBgQE5nTW9kdWxlYCBwcm92aWRlcyBhbiBvd24gYENvbXBpbGVyYCB0byBpdHMgaW5qZWN0b3IsXG4gICAgICogdGhhdCB3aWxsIHVzZSB0aGUgZGlyZWN0aXZlcy9waXBlcyBvZiB0aGUgbmcgbW9kdWxlIGZvciBjb21waWxhdGlvblxuICAgICAqIG9mIGNvbXBvbmVudHMuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBpbGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21waWxlcyB0aGUgZ2l2ZW4gTmdNb2R1bGUgYW5kIGFsbCBvZiBpdHMgY29tcG9uZW50cy4gQWxsIHRlbXBsYXRlcyBvZiB0aGUgY29tcG9uZW50cyBsaXN0ZWRcbiAgICAgICAgICogaW4gYGVudHJ5Q29tcG9uZW50c2BcbiAgICAgICAgICogaGF2ZSB0byBiZSBpbmxpbmVkLiBPdGhlcndpc2UgdGhyb3dzIGEge0BsaW5rIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yfS5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7IHRocm93IF90aHJvd0Vycm9yKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21waWxlcyB0aGUgZ2l2ZW4gTmdNb2R1bGUgYW5kIGFsbCBvZiBpdHMgY29tcG9uZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7IHRocm93IF90aHJvd0Vycm9yKCk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1lIGFzIHtAbGluayBjb21waWxlTW9kdWxlU3luY30gYnV0IGFsc28gY3JlYXRlcyBDb21wb25lbnRGYWN0b3JpZXMgZm9yIGFsbCBjb21wb25lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBfdGhyb3dFcnJvcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyB7QGxpbmsgY29tcGlsZU1vZHVsZUFzeW5jfSBidXQgYWxzbyBjcmVhdGVzIENvbXBvbmVudEZhY3RvcmllcyBmb3IgYWxsIGNvbXBvbmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBfdGhyb3dFcnJvcigpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBjYWNoZXMuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyB0aGUgY2FjaGUgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQvbmdNb2R1bGUuXG4gICAgICAgICAqL1xuICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7IH07XG4gICAgICAgIHJldHVybiBDb21waWxlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRva2VuIHRvIHByb3ZpZGUgQ29tcGlsZXJPcHRpb25zIGluIHRoZSBwbGF0Zm9ybSBpbmplY3Rvci5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQ09NUElMRVJfT1BUSU9OUyA9IG5ldyBPcGFxdWVUb2tlbignY29tcGlsZXJPcHRpb25zJyk7XG4gICAgLyoqXG4gICAgICogQSBmYWN0b3J5IGZvciBjcmVhdGluZyBhIENvbXBpbGVyXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIENvbXBpbGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBpbGVyRmFjdG9yeSgpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29tcGlsZXJGYWN0b3J5O1xuICAgIH0oKSk7XG5cbiAgICB2YXIgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRJdGVyYWJsZURpZmZlckZhY3RvcnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBpc0xpc3RMaWtlSXRlcmFibGUob2JqKTsgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNkUmVmLCB0cmFja0J5Rm4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyKHRyYWNrQnlGbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0SXRlcmFibGVEaWZmZXJGYWN0b3J5O1xuICAgIH0oKSk7XG4gICAgdmFyIHRyYWNrQnlJZGVudGl0eSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkgeyByZXR1cm4gaXRlbTsgfTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIERlZmF1bHRJdGVyYWJsZURpZmZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRJdGVyYWJsZURpZmZlcihfdHJhY2tCeUZuKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFja0J5Rm4gPSBfdHJhY2tCeUZuO1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHVzZWQgcmVjb3JkcyBhdCBhbnkgcG9pbnQgaW4gdGltZSAoZHVyaW5nICYgYWNyb3NzIGBfY2hlY2soKWAgY2FsbHMpXG4gICAgICAgICAgICB0aGlzLl9saW5rZWRSZWNvcmRzID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSByZW1vdmVkIHJlY29yZHMgYXQgYW55IHBvaW50IGluIHRpbWUgZHVyaW5nIGBfY2hlY2soKWAgY2FsbHMuXG4gICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNJdEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faXRIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2l0VGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9hZGRpdGlvbnNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbW92ZXNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHJlY29yZHMgd2hlcmUgY3VzdG9tIHRyYWNrIGJ5IGlzIHRoZSBzYW1lLCBidXQgaXRlbSBpZGVudGl0eSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrQnlGbiA9IGlzUHJlc2VudCh0aGlzLl90cmFja0J5Rm4pID8gdGhpcy5fdHJhY2tCeUZuIDogdHJhY2tCeUlkZW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLCBcImNvbGxlY3Rpb25cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb2xsZWN0aW9uOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGVuZ3RoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5faXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIG5leHRJdCA9IHRoaXMuX2l0SGVhZDtcbiAgICAgICAgICAgIHZhciBuZXh0UmVtb3ZlID0gdGhpcy5fcmVtb3ZhbHNIZWFkO1xuICAgICAgICAgICAgdmFyIGFkZFJlbW92ZU9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgbW92ZU9mZnNldHMgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKG5leHRJdCB8fCBuZXh0UmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBpcyB0aGUgbmV4dCByZWNvcmQgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgIC8vIE9yZGVyOiByZW1vdmUsIGFkZCwgbW92ZVxuICAgICAgICAgICAgICAgIHZhciByZWNvcmQgPSAhbmV4dFJlbW92ZSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXh0SXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJdC5jdXJyZW50SW5kZXggPCBnZXRQcmV2aW91c0luZGV4KG5leHRSZW1vdmUsIGFkZFJlbW92ZU9mZnNldCwgbW92ZU9mZnNldHMpID9cbiAgICAgICAgICAgICAgICAgICAgbmV4dEl0IDpcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlbW92ZTtcbiAgICAgICAgICAgICAgICB2YXIgYWRqUHJldmlvdXNJbmRleCA9IGdldFByZXZpb3VzSW5kZXgocmVjb3JkLCBhZGRSZW1vdmVPZmZzZXQsIG1vdmVPZmZzZXRzKTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gcmVjb3JkLmN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBjb25zdW1lIHRoZSBpdGVtLCBhbmQgYWRqdXN0IHRoZSBhZGRSZW1vdmVPZmZzZXQgYW5kIHVwZGF0ZSBtb3ZlRGlzdGFuY2UgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gbmV4dFJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVPZmZzZXQtLTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlbW92ZSA9IG5leHRSZW1vdmUuX25leHRSZW1vdmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEl0ID0gbmV4dEl0Ll9uZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnByZXZpb3VzSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlT2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJTlZBUklBTlQ6ICBjdXJyZW50SW5kZXggPCBwcmV2aW91c0luZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdmVPZmZzZXRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxNb3ZlUHJldmlvdXNJbmRleCA9IGFkalByZXZpb3VzSW5kZXggLSBhZGRSZW1vdmVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxDdXJyZW50SW5kZXggPSBjdXJyZW50SW5kZXggLSBhZGRSZW1vdmVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxNb3ZlUHJldmlvdXNJbmRleCAhPSBsb2NhbEN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWxNb3ZlUHJldmlvdXNJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpIDwgbW92ZU9mZnNldHMubGVuZ3RoID8gbW92ZU9mZnNldHNbaV0gOiAobW92ZU9mZnNldHNbaV0gPSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0ICsgaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsQ3VycmVudEluZGV4IDw9IGluZGV4ICYmIGluZGV4IDwgbG9jYWxNb3ZlUHJldmlvdXNJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldHNbaV0gPSBvZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0luZGV4ID0gcmVjb3JkLnByZXZpb3VzSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldHNbcHJldmlvdXNJbmRleF0gPSBsb2NhbEN1cnJlbnRJbmRleCAtIGxvY2FsTW92ZVByZXZpb3VzSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkalByZXZpb3VzSW5kZXggIT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBmbihyZWNvcmQsIGFkalByZXZpb3VzSW5kZXgsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hQcmV2aW91c0l0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzSXRIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoQWRkZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9hZGRpdGlvbnNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dEFkZGVkKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoTW92ZWRJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tb3Zlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0TW92ZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hSZW1vdmVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hJZGVudGl0eUNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRJZGVudGl0eUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayhjb2xsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gW107XG4gICAgICAgICAgICBpZiAoIWlzTGlzdExpa2VJdGVyYWJsZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHRyeWluZyB0byBkaWZmICdcIiArIGNvbGxlY3Rpb24gKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVjayhjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvLyB0b2RvKHZpY2IpOiBvcHRpbSBmb3IgVW5tb2RpZmlhYmxlTGlzdFZpZXcgKGZyb3plbiBhcnJheXMpXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICB2YXIgcmVjb3JkID0gdGhpcy5faXRIZWFkO1xuICAgICAgICAgICAgdmFyIG1heUJlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICAgIHZhciBpdGVtO1xuICAgICAgICAgICAgdmFyIGl0ZW1UcmFja0J5O1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IGNvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVRyYWNrQnkgPSB0aGlzLl90cmFja0J5Rm4oaW5kZXgsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkID09PSBudWxsIHx8ICFsb29zZUlkZW50aWNhbChyZWNvcmQudHJhY2tCeUlkLCBpdGVtVHJhY2tCeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX21pc21hdGNoKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heUJlRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heUJlRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKG1pc2tvKTogY2FuIHdlIGxpbWl0IHRoaXMgdG8gZHVwbGljYXRlcyBvbmx5P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX3ZlcmlmeVJlaW5zZXJ0aW9uKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZElkZW50aXR5Q2hhbmdlKHJlY29yZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpdGVyYXRlTGlzdExpa2UoY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0gLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVRyYWNrQnkgPSBfdGhpcy5fdHJhY2tCeUZuKGluZGV4LCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZCA9PT0gbnVsbCB8fCAhbG9vc2VJZGVudGljYWwocmVjb3JkLnRyYWNrQnlJZCwgaXRlbVRyYWNrQnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBfdGhpcy5fbWlzbWF0Y2gocmVjb3JkLCBpdGVtLCBpdGVtVHJhY2tCeSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5QmVEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF5QmVEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obWlza28pOiBjYW4gd2UgbGltaXQgdGhpcyB0byBkdXBsaWNhdGVzIG9ubHk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gX3RoaXMuX3ZlcmlmeVJlaW5zZXJ0aW9uKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwocmVjb3JkLml0ZW0sIGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRJZGVudGl0eUNoYW5nZShyZWNvcmQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RydW5jYXRlKHJlY29yZCk7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRGlydHk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLCBcImlzRGlydHlcIiwge1xuICAgICAgICAgICAgLyogQ29sbGVjdGlvbkNoYW5nZXMgaXMgY29uc2lkZXJlZCBkaXJ0eSBpZiBpdCBoYXMgYW55IGFkZGl0aW9ucywgbW92ZXMsIHJlbW92YWxzLCBvciBpZGVudGl0eVxuICAgICAgICAgICAgICogY2hhbmdlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZGl0aW9uc0hlYWQgIT09IG51bGwgfHwgdGhpcy5fbW92ZXNIZWFkICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCAhPT0gbnVsbCB8fCB0aGlzLl9pZGVudGl0eUNoYW5nZXNIZWFkICE9PSBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldCB0aGUgc3RhdGUgb2YgdGhlIGNoYW5nZSBvYmplY3RzIHRvIHNob3cgbm8gY2hhbmdlcy4gVGhpcyBtZWFucyBzZXQgcHJldmlvdXNLZXkgdG9cbiAgICAgICAgICogY3VycmVudEtleSwgYW5kIGNsZWFyIGFsbCBvZiB0aGUgcXVldWVzIChhZGRpdGlvbnMsIG1vdmVzLCByZW1vdmFscykuXG4gICAgICAgICAqIFNldCB0aGUgcHJldmlvdXNJbmRleGVzIG9mIG1vdmVkIGFuZCBhZGRlZCBpdGVtcyB0byB0aGVpciBjdXJyZW50SW5kZXhlc1xuICAgICAgICAgKiBSZXNldCB0aGUgbGlzdCBvZiBhZGRpdGlvbnMsIG1vdmVzIGFuZCByZW1vdmFsc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRSZWNvcmQ7XG4gICAgICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c0l0SGVhZCA9IHRoaXMuX2l0SGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLl9uZXh0UHJldmlvdXMgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fYWRkaXRpb25zSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNJbmRleCA9IHJlY29yZC5jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX21vdmVzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSBuZXh0UmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5wcmV2aW91c0luZGV4ID0gcmVjb3JkLmN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFJlY29yZCA9IHJlY29yZC5fbmV4dE1vdmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tb3Zlc0hlYWQgPSB0aGlzLl9tb3Zlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IHRoaXMuX3JlbW92YWxzVGFpbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzSGVhZCA9IHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgY29yZSBmdW5jdGlvbiB3aGljaCBoYW5kbGVzIGRpZmZlcmVuY2VzIGJldHdlZW4gY29sbGVjdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIC0gYHJlY29yZGAgaXMgdGhlIHJlY29yZCB3aGljaCB3ZSBzYXcgYXQgdGhpcyBwb3NpdGlvbiBsYXN0IHRpbWUuIElmIG51bGwgdGhlbiBpdCBpcyBhIG5ld1xuICAgICAgICAgKiAgIGl0ZW0uXG4gICAgICAgICAqIC0gYGl0ZW1gIGlzIHRoZSBjdXJyZW50IGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgICogLSBgaW5kZXhgIGlzIHRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX21pc21hdGNoID0gZnVuY3Rpb24gKHJlY29yZCwgaXRlbSwgaXRlbVRyYWNrQnksIGluZGV4KSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJldmlvdXMgcmVjb3JkIGFmdGVyIHdoaWNoIHdlIHdpbGwgYXBwZW5kIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgICAgIHZhciBwcmV2aW91c1JlY29yZDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1JlY29yZCA9IHRoaXMuX2l0VGFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUmVjb3JkID0gcmVjb3JkLl9wcmV2O1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcmVjb3JkIGZyb20gdGhlIGNvbGxlY3Rpb24gc2luY2Ugd2Uga25vdyBpdCBkb2VzIG5vdCBtYXRjaCB0aGUgaXRlbS5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmUocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gc2VlIGlmIHdlIGhhdmUgc2VlbiB0aGUgaXRlbSBiZWZvcmUuXG4gICAgICAgICAgICByZWNvcmQgPSB0aGlzLl9saW5rZWRSZWNvcmRzID09PSBudWxsID8gbnVsbCA6IHRoaXMuX2xpbmtlZFJlY29yZHMuZ2V0KGl0ZW1UcmFja0J5LCBpbmRleCk7XG4gICAgICAgICAgICBpZiAocmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBzZWVuIHRoaXMgYmVmb3JlLCB3ZSBuZWVkIHRvIG1vdmUgaXQgZm9yd2FyZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBCdXQgZmlyc3Qgd2UgbmVlZCB0byBjaGVjayBpZiBpZGVudGl0eSBjaGFuZ2VkLCBzbyB3ZSBjYW4gdXBkYXRlIGluIHZpZXcgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbChyZWNvcmQuaXRlbSwgaXRlbSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZElkZW50aXR5Q2hhbmdlKHJlY29yZCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZUFmdGVyKHJlY29yZCwgcHJldmlvdXNSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5ldmVyIHNlZW4gaXQsIGNoZWNrIGV2aWN0ZWQgbGlzdC5cbiAgICAgICAgICAgICAgICByZWNvcmQgPSB0aGlzLl91bmxpbmtlZFJlY29yZHMgPT09IG51bGwgPyBudWxsIDogdGhpcy5fdW5saW5rZWRSZWNvcmRzLmdldChpdGVtVHJhY2tCeSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBpcyBhbiBpdGVtIHdoaWNoIHdlIGhhdmUgZXZpY3RlZCBlYXJsaWVyOiByZWluc2VydCBpdCBiYWNrIGludG8gdGhlIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBmaXJzdCB3ZSBuZWVkIHRvIGNoZWNrIGlmIGlkZW50aXR5IGNoYW5nZWQsIHNvIHdlIGNhbiB1cGRhdGUgaW4gdmlldyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbChyZWNvcmQuaXRlbSwgaXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJZGVudGl0eUNoYW5nZShyZWNvcmQsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWluc2VydEFmdGVyKHJlY29yZCwgcHJldmlvdXNSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IGlzIGEgbmV3IGl0ZW06IGFkZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEFmdGVyKG5ldyBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkKGl0ZW0sIGl0ZW1UcmFja0J5KSwgcHJldmlvdXNSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBjaGVjayBpcyBvbmx5IG5lZWRlZCBpZiBhbiBhcnJheSBjb250YWlucyBkdXBsaWNhdGVzLiAoU2hvcnQgY2lyY3VpdCBvZiBub3RoaW5nIGRpcnR5KVxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2UgY2FzZTogYFthLCBhXWAgPT4gYFtiLCBhLCBhXWBcbiAgICAgICAgICpcbiAgICAgICAgICogSWYgd2UgZGlkIG5vdCBoYXZlIHRoaXMgY2hlY2sgdGhlbiB0aGUgaW5zZXJ0aW9uIG9mIGBiYCB3b3VsZDpcbiAgICAgICAgICogICAxKSBldmljdCBmaXJzdCBgYWBcbiAgICAgICAgICogICAyKSBpbnNlcnQgYGJgIGF0IGAwYCBpbmRleC5cbiAgICAgICAgICogICAzKSBsZWF2ZSBgYWAgYXQgaW5kZXggYDFgIGFzIGlzLiA8LS0gdGhpcyBpcyB3cm9uZyFcbiAgICAgICAgICogICAzKSByZWluc2VydCBgYWAgYXQgaW5kZXggMi4gPC0tIHRoaXMgaXMgd3JvbmchXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBjb3JyZWN0IGJlaGF2aW9yIGlzOlxuICAgICAgICAgKiAgIDEpIGV2aWN0IGZpcnN0IGBhYFxuICAgICAgICAgKiAgIDIpIGluc2VydCBgYmAgYXQgYDBgIGluZGV4LlxuICAgICAgICAgKiAgIDMpIHJlaW5zZXJ0IGBhYCBhdCBpbmRleCAxLlxuICAgICAgICAgKiAgIDMpIG1vdmUgYGFgIGF0IGZyb20gYDFgIHRvIGAyYC5cbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogRG91YmxlIGNoZWNrIHRoYXQgd2UgaGF2ZSBub3QgZXZpY3RlZCBhIGR1cGxpY2F0ZSBpdGVtLiBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBpdGVtIHR5cGUgbWF5XG4gICAgICAgICAqIGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQ6XG4gICAgICAgICAqIFRoZSBpbnNlcnRpb24gb2YgYiB3aWxsIGV2aWN0IHRoZSBmaXJzdCAnYScuIElmIHdlIGRvbid0IHJlaW5zZXJ0IGl0IG5vdyBpdCB3aWxsIGJlIHJlaW5zZXJ0ZWRcbiAgICAgICAgICogYXQgdGhlIGVuZC4gV2hpY2ggd2lsbCBzaG93IHVwIGFzIHRoZSB0d28gJ2EncyBzd2l0Y2hpbmcgcG9zaXRpb24uIFRoaXMgaXMgaW5jb3JyZWN0LCBzaW5jZSBhXG4gICAgICAgICAqIGJldHRlciB3YXkgdG8gdGhpbmsgb2YgaXQgaXMgYXMgaW5zZXJ0IG9mICdiJyByYXRoZXIgdGhlbiBzd2l0Y2ggJ2EnIHdpdGggJ2InIGFuZCB0aGVuIGFkZCAnYSdcbiAgICAgICAgICogYXQgdGhlIGVuZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl92ZXJpZnlSZWluc2VydGlvbiA9IGZ1bmN0aW9uIChyZWNvcmQsIGl0ZW0sIGl0ZW1UcmFja0J5LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHJlaW5zZXJ0UmVjb3JkID0gdGhpcy5fdW5saW5rZWRSZWNvcmRzID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3VubGlua2VkUmVjb3Jkcy5nZXQoaXRlbVRyYWNrQnkpO1xuICAgICAgICAgICAgaWYgKHJlaW5zZXJ0UmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fcmVpbnNlcnRBZnRlcihyZWluc2VydFJlY29yZCwgcmVjb3JkLl9wcmV2LCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWNvcmQuY3VycmVudEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvTW92ZXMocmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHJpZCBvZiBhbnkgZXhjZXNzIHtAbGluayBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkfXMgZnJvbSB0aGUgcHJldmlvdXMgY29sbGVjdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiAtIGByZWNvcmRgIFRoZSBmaXJzdCBleGNlc3Mge0BsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3RydW5jYXRlID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgLy8gQW55dGhpbmcgYWZ0ZXIgdGhhdCBuZWVkcyB0byBiZSByZW1vdmVkO1xuICAgICAgICAgICAgd2hpbGUgKHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvUmVtb3ZhbHModGhpcy5fdW5saW5rKHJlY29yZCkpO1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IG5leHRSZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdW5saW5rZWRSZWNvcmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwuX25leHRBZGRlZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbW92ZXNUYWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsLl9uZXh0TW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2l0VGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0VGFpbC5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtb3ZhbHNUYWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwuX25leHRJZGVudGl0eUNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fcmVpbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdW5saW5rZWRSZWNvcmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5saW5rZWRSZWNvcmRzLnJlbW92ZShyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXYgPSByZWNvcmQuX3ByZXZSZW1vdmVkO1xuICAgICAgICAgICAgdmFyIG5leHQgPSByZWNvcmQuX25leHRSZW1vdmVkO1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldi5fbmV4dFJlbW92ZWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dC5fcHJldlJlbW92ZWQgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0QWZ0ZXIocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb01vdmVzKHJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9tb3ZlQWZ0ZXIgPSBmdW5jdGlvbiAocmVjb3JkLCBwcmV2UmVjb3JkLCBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5fdW5saW5rKHJlY29yZCk7XG4gICAgICAgICAgICB0aGlzLl9pbnNlcnRBZnRlcihyZWNvcmQsIHByZXZSZWNvcmQsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvTW92ZXMocmVjb3JkLCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2FkZEFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydEFmdGVyKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FkZGl0aW9uc1RhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuX2FkZGl0aW9uc0hlYWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSB0aGlzLl9hZGRpdGlvbnNIZWFkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydChfYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID09PSBudWxsKTtcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0QWRkZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSB0aGlzLl9hZGRpdGlvbnNUYWlsLl9uZXh0QWRkZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX2luc2VydEFmdGVyID0gZnVuY3Rpb24gKHJlY29yZCwgcHJldlJlY29yZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQgIT0gcHJldlJlY29yZCk7XG4gICAgICAgICAgICAvLyBhc3NlcnQocmVjb3JkLl9uZXh0ID09PSBudWxsKTtcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX3ByZXYgPT09IG51bGwpO1xuICAgICAgICAgICAgdmFyIG5leHQgPSBwcmV2UmVjb3JkID09PSBudWxsID8gdGhpcy5faXRIZWFkIDogcHJldlJlY29yZC5fbmV4dDtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydChuZXh0ICE9IHJlY29yZCk7XG4gICAgICAgICAgICAvLyBhc3NlcnQocHJldlJlY29yZCAhPSByZWNvcmQpO1xuICAgICAgICAgICAgcmVjb3JkLl9uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIHJlY29yZC5fcHJldiA9IHByZXZSZWNvcmQ7XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0VGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQuX3ByZXYgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldlJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0SGVhZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZSZWNvcmQuX25leHQgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlua2VkUmVjb3JkcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmtlZFJlY29yZHMgPSBuZXcgX0R1cGxpY2F0ZU1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGlua2VkUmVjb3Jkcy5wdXQocmVjb3JkKTtcbiAgICAgICAgICAgIHJlY29yZC5jdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZFRvUmVtb3ZhbHModGhpcy5fdW5saW5rKHJlY29yZCkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUuX3VubGluayA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5rZWRSZWNvcmRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlua2VkUmVjb3Jkcy5yZW1vdmUocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2ID0gcmVjb3JkLl9wcmV2O1xuICAgICAgICAgICAgdmFyIG5leHQgPSByZWNvcmQuX25leHQ7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAvLyBhc3NlcnQoKHJlY29yZC5fcHJldiA9IG51bGwpID09PSBudWxsKTtcbiAgICAgICAgICAgIC8vIGFzc2VydCgocmVjb3JkLl9uZXh0ID0gbnVsbCkgPT09IG51bGwpO1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdEhlYWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0VGFpbCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9Nb3ZlcyA9IGZ1bmN0aW9uIChyZWNvcmQsIHRvSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgIC8vIGFzc2VydChyZWNvcmQuX25leHRNb3ZlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAocmVjb3JkLnByZXZpb3VzSW5kZXggPT09IHRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vdmVzVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX21vdmVzSGVhZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW92ZXNUYWlsID0gdGhpcy5fbW92ZXNIZWFkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydChfbW92ZXNUYWlsLl9uZXh0TW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVzVGFpbCA9IHRoaXMuX21vdmVzVGFpbC5fbmV4dE1vdmVkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0SXRlcmFibGVEaWZmZXIucHJvdG90eXBlLl9hZGRUb1JlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VubGlua2VkUmVjb3JkcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubGlua2VkUmVjb3JkcyA9IG5ldyBfRHVwbGljYXRlTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bmxpbmtlZFJlY29yZHMucHV0KHJlY29yZCk7XG4gICAgICAgICAgICByZWNvcmQuY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIHJlY29yZC5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG8odmljYilcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQoX3JlbW92YWxzSGVhZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gdGhpcy5fcmVtb3ZhbHNIZWFkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgICAgIC8vIGFzc2VydChfcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9PT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5fbmV4dFJlbW92ZWQgPT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldlJlbW92ZWQgPSB0aGlzLl9yZW1vdmFsc1RhaWw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gdGhpcy5fcmVtb3ZhbHNUYWlsLl9uZXh0UmVtb3ZlZCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyLnByb3RvdHlwZS5fYWRkSWRlbnRpdHlDaGFuZ2UgPSBmdW5jdGlvbiAocmVjb3JkLCBpdGVtKSB7XG4gICAgICAgICAgICByZWNvcmQuaXRlbSA9IGl0ZW07XG4gICAgICAgICAgICBpZiAodGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwgPSB0aGlzLl9pZGVudGl0eUNoYW5nZXNIZWFkID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDaGFuZ2VzVGFpbCA9IHRoaXMuX2lkZW50aXR5Q2hhbmdlc1RhaWwuX25leHRJZGVudGl0eUNoYW5nZSA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRJdGVyYWJsZURpZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoSXRlbShmdW5jdGlvbiAocmVjb3JkIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBsaXN0LnB1c2gocmVjb3JkKTsgfSk7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaFByZXZpb3VzSXRlbShmdW5jdGlvbiAocmVjb3JkIC8qKiBUT0RPICM5MTAwICovKSB7IHJldHVybiBwcmV2aW91cy5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoQWRkZWRJdGVtKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIGFkZGl0aW9ucy5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgdmFyIG1vdmVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hNb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gbW92ZXMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHZhciByZW1vdmFscyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oZnVuY3Rpb24gKHJlY29yZCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gcmVtb3ZhbHMucHVzaChyZWNvcmQpOyB9KTtcbiAgICAgICAgICAgIHZhciBpZGVudGl0eUNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaElkZW50aXR5Q2hhbmdlKGZ1bmN0aW9uIChyZWNvcmQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIGlkZW50aXR5Q2hhbmdlcy5wdXNoKHJlY29yZCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuICdjb2xsZWN0aW9uOiAnICsgbGlzdC5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdwcmV2aW91czogJyArIHByZXZpb3VzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ2FkZGl0aW9uczogJyArIGFkZGl0aW9ucy5qb2luKCcsICcpICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICdtb3ZlczogJyArIG1vdmVzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3JlbW92YWxzOiAnICsgcmVtb3ZhbHMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnaWRlbnRpdHlDaGFuZ2VzOiAnICsgaWRlbnRpdHlDaGFuZ2VzLmpvaW4oJywgJykgKyAnXFxuJztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRJdGVyYWJsZURpZmZlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29sbGVjdGlvbkNoYW5nZVJlY29yZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQoaXRlbSwgdHJhY2tCeUlkKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy50cmFja0J5SWQgPSB0cmFja0J5SWQ7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzSW5kZXggPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dFByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9wcmV2RHVwID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHREdXAgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dEFkZGVkID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX25leHRNb3ZlZCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0SWRlbnRpdHlDaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNJbmRleCA9PT0gdGhpcy5jdXJyZW50SW5kZXggPyBzdHJpbmdpZnkodGhpcy5pdGVtKSA6XG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMuaXRlbSkgKyAnWycgK1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkodGhpcy5wcmV2aW91c0luZGV4KSArICctPicgKyBzdHJpbmdpZnkodGhpcy5jdXJyZW50SW5kZXgpICsgJ10nO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29sbGVjdGlvbkNoYW5nZVJlY29yZDtcbiAgICB9KCkpO1xuICAgIC8vIEEgbGlua2VkIGxpc3Qgb2YgQ29sbGVjdGlvbkNoYW5nZVJlY29yZHMgd2l0aCB0aGUgc2FtZSBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLml0ZW1cbiAgICB2YXIgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0KCkge1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl90YWlsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIHRoZSByZWNvcmQgdG8gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZTogYnkgZGVzaWduIGFsbCByZWNvcmRzIGluIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZXMgaG9sZCB0aGUgc2FtZSB2YWx1ZSBpbiByZWNvcmQuaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkID0gdGhpcy5fdGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX25leHREdXAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlY29yZC5fcHJldkR1cCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvKHZpY2IpXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHJlY29yZC5pdGVtID09ICBfaGVhZC5pdGVtIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgcmVjb3JkLml0ZW0gaXMgbnVtICYmIHJlY29yZC5pdGVtLmlzTmFOICYmIF9oZWFkLml0ZW0gaXMgbnVtICYmIF9oZWFkLml0ZW0uaXNOYU4pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwuX25leHREdXAgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2RHVwID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgICAgICByZWNvcmQuX25leHREdXAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJldHVybnMgYSBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkIGhhdmluZyBDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkLnRyYWNrQnlJZCA9PSB0cmFja0J5SWQgYW5kXG4gICAgICAgIC8vIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmQuY3VycmVudEluZGV4ID49IGFmdGVySW5kZXhcbiAgICAgICAgX0R1cGxpY2F0ZUl0ZW1SZWNvcmRMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodHJhY2tCeUlkLCBhZnRlckluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9oZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dER1cCkge1xuICAgICAgICAgICAgICAgIGlmICgoYWZ0ZXJJbmRleCA9PT0gbnVsbCB8fCBhZnRlckluZGV4IDwgcmVjb3JkLmN1cnJlbnRJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbG9vc2VJZGVudGljYWwocmVjb3JkLnRyYWNrQnlJZCwgdHJhY2tCeUlkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIG9uZSB7QGxpbmsgQ29sbGVjdGlvbkNoYW5nZVJlY29yZH0gZnJvbSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGxpc3Qgb2YgZHVwbGljYXRlcyBpcyBlbXB0eS5cbiAgICAgICAgICovXG4gICAgICAgIF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KCgpIHtcbiAgICAgICAgICAgIC8vICAvLyB2ZXJpZnkgdGhhdCB0aGUgcmVjb3JkIGJlaW5nIHJlbW92ZWQgaXMgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAvLyAgZm9yIChDb2xsZWN0aW9uQ2hhbmdlUmVjb3JkIGN1cnNvciA9IF9oZWFkOyBjdXJzb3IgIT0gbnVsbDsgY3Vyc29yID0gY3Vyc29yLl9uZXh0RHVwKSB7XG4gICAgICAgICAgICAvLyAgICBpZiAoaWRlbnRpY2FsKGN1cnNvciwgcmVjb3JkKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyAgfVxuICAgICAgICAgICAgLy8gIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vfSk7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldkR1cDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0RHVwO1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHREdXAgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQuX3ByZXZEdXAgPSBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWQgPT09IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfRHVwbGljYXRlSXRlbVJlY29yZExpc3Q7XG4gICAgfSgpKTtcbiAgICB2YXIgX0R1cGxpY2F0ZU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9EdXBsaWNhdGVNYXAoKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAvLyB0b2RvKHZpY2IpIGhhbmRsZSBjb3JuZXIgY2FzZXNcbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRNYXBLZXkocmVjb3JkLnRyYWNrQnlJZCk7XG4gICAgICAgICAgICB2YXIgZHVwbGljYXRlcyA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoZHVwbGljYXRlcykpIHtcbiAgICAgICAgICAgICAgICBkdXBsaWNhdGVzID0gbmV3IF9EdXBsaWNhdGVJdGVtUmVjb3JkTGlzdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldChrZXksIGR1cGxpY2F0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVwbGljYXRlcy5hZGQocmVjb3JkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlIHRoZSBgdmFsdWVgIHVzaW5nIGtleS4gQmVjYXVzZSB0aGUgQ29sbGVjdGlvbkNoYW5nZVJlY29yZCB2YWx1ZSBtYXkgYmUgb25lIHdoaWNoIHdlXG4gICAgICAgICAqIGhhdmUgYWxyZWFkeSBpdGVyYXRlZCBvdmVyLCB3ZSB1c2UgdGhlIGFmdGVySW5kZXggdG8gcHJldGVuZCBpdCBpcyBub3QgdGhlcmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSBjYXNlOiBgW2EsIGIsIGMsIGEsIGFdYCBpZiB3ZSBhcmUgYXQgaW5kZXggYDNgIHdoaWNoIGlzIHRoZSBzZWNvbmQgYGFgIHRoZW4gYXNraW5nIGlmIHdlXG4gICAgICAgICAqIGhhdmUgYW55IG1vcmUgYGFgcyBuZWVkcyB0byByZXR1cm4gdGhlIGxhc3QgYGFgIG5vdCB0aGUgZmlyc3Qgb3Igc2Vjb25kLlxuICAgICAgICAgKi9cbiAgICAgICAgX0R1cGxpY2F0ZU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRyYWNrQnlJZCwgYWZ0ZXJJbmRleCkge1xuICAgICAgICAgICAgaWYgKGFmdGVySW5kZXggPT09IHZvaWQgMCkgeyBhZnRlckluZGV4ID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIGtleSA9IGdldE1hcEtleSh0cmFja0J5SWQpO1xuICAgICAgICAgICAgdmFyIHJlY29yZExpc3QgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmRMaXN0ID8gcmVjb3JkTGlzdC5nZXQodHJhY2tCeUlkLCBhZnRlckluZGV4KSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEge0BsaW5rIENvbGxlY3Rpb25DaGFuZ2VSZWNvcmR9IGZyb20gdGhlIGxpc3Qgb2YgZHVwbGljYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGxpc3Qgb2YgZHVwbGljYXRlcyBhbHNvIGlzIHJlbW92ZWQgZnJvbSB0aGUgbWFwIGlmIGl0IGdldHMgZW1wdHkuXG4gICAgICAgICAqL1xuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0TWFwS2V5KHJlY29yZC50cmFja0J5SWQpO1xuICAgICAgICAgICAgLy8gdG9kbyh2aWNiKVxuICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMubWFwLmNvbnRhaW5zS2V5KGtleSkpO1xuICAgICAgICAgICAgdmFyIHJlY29yZExpc3QgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBvZiBkdXBsaWNhdGVzIHdoZW4gaXQgZ2V0cyBlbXB0eVxuICAgICAgICAgICAgaWYgKHJlY29yZExpc3QucmVtb3ZlKHJlY29yZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfRHVwbGljYXRlTWFwLnByb3RvdHlwZSwgXCJpc0VtcHR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5tYXAuc2l6ZSA9PT0gMDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIF9EdXBsaWNhdGVNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkgeyB0aGlzLm1hcC5jbGVhcigpOyB9O1xuICAgICAgICBfRHVwbGljYXRlTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdfRHVwbGljYXRlTWFwKCcgKyBzdHJpbmdpZnkodGhpcy5tYXApICsgJyknOyB9O1xuICAgICAgICByZXR1cm4gX0R1cGxpY2F0ZU1hcDtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIGdldFByZXZpb3VzSW5kZXgoaXRlbSwgYWRkUmVtb3ZlT2Zmc2V0LCBtb3ZlT2Zmc2V0cykge1xuICAgICAgICB2YXIgcHJldmlvdXNJbmRleCA9IGl0ZW0ucHJldmlvdXNJbmRleDtcbiAgICAgICAgaWYgKHByZXZpb3VzSW5kZXggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNJbmRleDtcbiAgICAgICAgdmFyIG1vdmVPZmZzZXQgPSAwO1xuICAgICAgICBpZiAobW92ZU9mZnNldHMgJiYgcHJldmlvdXNJbmRleCA8IG1vdmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbW92ZU9mZnNldCA9IG1vdmVPZmZzZXRzW3ByZXZpb3VzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c0luZGV4ICsgYWRkUmVtb3ZlT2Zmc2V0ICsgbW92ZU9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyRmFjdG9yeS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogaW5zdGFuY2VvZiBNYXAgfHwgaXNKc09iamVjdChvYmopOyB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY2RSZWYpIHsgcmV0dXJuIG5ldyBEZWZhdWx0S2V5VmFsdWVEaWZmZXIoKTsgfTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3Rvcnk7XG4gICAgfSgpKTtcbiAgICB2YXIgRGVmYXVsdEtleVZhbHVlRGlmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdEtleVZhbHVlRGlmZmVyKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNNYXBIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZhbHNUYWlsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZSwgXCJpc0RpcnR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRpdGlvbnNIZWFkICE9PSBudWxsIHx8IHRoaXMuX2NoYW5nZXNIZWFkICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCAhPT0gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hJdGVtID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIGZuKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuZm9yRWFjaFByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcHJldmlvdXNNYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgZm4ocmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5mb3JFYWNoQ2hhbmdlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hBZGRlZEl0ZW0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQ7XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmZvckVhY2hSZW1vdmVkSXRlbSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHJlY29yZDtcbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fcmVtb3ZhbHNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dFJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEobWFwIGluc3RhbmNlb2YgTWFwIHx8IGlzSnNPYmplY3QobWFwKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0cnlpbmcgdG8gZGlmZiAnXCIgKyBtYXAgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVjayhtYXApID8gdGhpcyA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUub25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICB2YXIgcmVjb3JkcyA9IHRoaXMuX3JlY29yZHM7XG4gICAgICAgICAgICB2YXIgb2xkU2VxUmVjb3JkID0gdGhpcy5fbWFwSGVhZDtcbiAgICAgICAgICAgIHZhciBsYXN0T2xkU2VxUmVjb3JkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBsYXN0TmV3U2VxUmVjb3JkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBzZXFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoKG1hcCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgIGlmIChvbGRTZXFSZWNvcmQgJiYga2V5ID09PSBvbGRTZXFSZWNvcmQua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NlcVJlY29yZCA9IG9sZFNlcVJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21heWJlQWRkVG9DaGFuZ2VzKG5ld1NlcVJlY29yZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTZXFSZWNvcmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVGcm9tU2VxKGxhc3RPbGRTZXFSZWNvcmQsIG9sZFNlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9SZW1vdmFscyhvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQgPSByZWNvcmRzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21heWJlQWRkVG9DaGFuZ2VzKG5ld1NlcVJlY29yZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VxUmVjb3JkID0gbmV3IEtleVZhbHVlQ2hhbmdlUmVjb3JkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChrZXksIG5ld1NlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZXFSZWNvcmQuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVG9BZGRpdGlvbnMobmV3U2VxUmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VxQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzSW5SZW1vdmFscyhuZXdTZXFSZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlRnJvbVJlbW92YWxzKG5ld1NlcVJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3ROZXdTZXFSZWNvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21hcEhlYWQgPSBuZXdTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TmV3U2VxUmVjb3JkLl9uZXh0ID0gbmV3U2VxUmVjb3JkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RPbGRTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQ7XG4gICAgICAgICAgICAgICAgbGFzdE5ld1NlcVJlY29yZCA9IG5ld1NlcVJlY29yZDtcbiAgICAgICAgICAgICAgICBvbGRTZXFSZWNvcmQgPSBvbGRTZXFSZWNvcmQgJiYgb2xkU2VxUmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl90cnVuY2F0ZShsYXN0T2xkU2VxUmVjb3JkLCBvbGRTZXFSZWNvcmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNEaXJ0eTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgc3RhdGUgb2YgdGhlIG1hcHBpbmdcbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3ByZXZpb3VzTWFwSGVhZCA9IHRoaXMuX21hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5fbmV4dFByZXZpb3VzID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2NoYW5nZXNIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnByZXZpb3VzVmFsdWUgPSByZWNvcmQuY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRBZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNIZWFkID0gdGhpcy5fY2hhbmdlc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc0hlYWQgPSB0aGlzLl9yZW1vdmFsc1RhaWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX3RydW5jYXRlID0gZnVuY3Rpb24gKGxhc3RSZWNvcmQsIHJlY29yZCkge1xuICAgICAgICAgICAgd2hpbGUgKHJlY29yZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UmVjb3JkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcEhlYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJlY29yZC5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXh0UmVjb3JkID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvUmVtb3ZhbHMocmVjb3JkKTtcbiAgICAgICAgICAgICAgICBsYXN0UmVjb3JkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IG5leHRSZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciByZWMgPSB0aGlzLl9yZW1vdmFsc0hlYWQ7IHJlYyAhPT0gbnVsbDsgcmVjID0gcmVjLl9uZXh0UmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgIHJlYy5wcmV2aW91c1ZhbHVlID0gcmVjLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZWMuY3VycmVudFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNvcmRzLmRlbGV0ZShyZWMua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fbWF5YmVBZGRUb0NoYW5nZXMgPSBmdW5jdGlvbiAocmVjb3JkLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbChuZXdWYWx1ZSwgcmVjb3JkLmN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZWNvcmQucHJldmlvdXNWYWx1ZSA9IHJlY29yZC5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgcmVjb3JkLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ2hhbmdlcyhyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2lzSW5SZW1vdmFscyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQgPT09IHRoaXMuX3JlbW92YWxzSGVhZCB8fCByZWNvcmQuX25leHRSZW1vdmVkICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCAhPT0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9hZGRUb1JlbW92YWxzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbW92YWxzSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IHRoaXMuX3JlbW92YWxzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbC5fbmV4dFJlbW92ZWQgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgcmVjb3JkLl9wcmV2UmVtb3ZlZCA9IHRoaXMuX3JlbW92YWxzVGFpbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmFsc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVNlcSA9IGZ1bmN0aW9uIChwcmV2LCByZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gcmVjb3JkLl9uZXh0O1xuICAgICAgICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXBIZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXYuX25leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3JkLl9uZXh0ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEZWZhdWx0S2V5VmFsdWVEaWZmZXIucHJvdG90eXBlLl9yZW1vdmVGcm9tUmVtb3ZhbHMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHJlY29yZC5fcHJldlJlbW92ZWQ7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJlY29yZC5fbmV4dFJlbW92ZWQ7XG4gICAgICAgICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzSGVhZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmV2Ll9uZXh0UmVtb3ZlZCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92YWxzVGFpbCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0Ll9wcmV2UmVtb3ZlZCA9IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmQuX3ByZXZSZW1vdmVkID0gcmVjb3JkLl9uZXh0UmVtb3ZlZCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9BZGRpdGlvbnMgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWRkaXRpb25zSGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc0hlYWQgPSB0aGlzLl9hZGRpdGlvbnNUYWlsID0gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkaXRpb25zVGFpbC5fbmV4dEFkZGVkID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZGl0aW9uc1RhaWwgPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS5fYWRkVG9DaGFuZ2VzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZXNIZWFkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlc0hlYWQgPSB0aGlzLl9jaGFuZ2VzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXNUYWlsLl9uZXh0Q2hhbmdlZCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VzVGFpbCA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdEtleVZhbHVlRGlmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gW107XG4gICAgICAgICAgICB2YXIgY2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJlbW92YWxzID0gW107XG4gICAgICAgICAgICB2YXIgcmVjb3JkO1xuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9tYXBIZWFkOyByZWNvcmQgIT09IG51bGw7IHJlY29yZCA9IHJlY29yZC5fbmV4dCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChyZWNvcmQgPSB0aGlzLl9wcmV2aW91c01hcEhlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0UHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5wdXNoKHN0cmluZ2lmeShyZWNvcmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAocmVjb3JkID0gdGhpcy5fY2hhbmdlc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX2FkZGl0aW9uc0hlYWQ7IHJlY29yZCAhPT0gbnVsbDsgcmVjb3JkID0gcmVjb3JkLl9uZXh0QWRkZWQpIHtcbiAgICAgICAgICAgICAgICBhZGRpdGlvbnMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHJlY29yZCA9IHRoaXMuX3JlbW92YWxzSGVhZDsgcmVjb3JkICE9PSBudWxsOyByZWNvcmQgPSByZWNvcmQuX25leHRSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZhbHMucHVzaChzdHJpbmdpZnkocmVjb3JkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ21hcDogJyArIGl0ZW1zLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzOiAnICsgcHJldmlvdXMuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25zOiAnICsgYWRkaXRpb25zLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ2NoYW5nZXM6ICcgKyBjaGFuZ2VzLmpvaW4oJywgJykgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgJ3JlbW92YWxzOiAnICsgcmVtb3ZhbHMuam9pbignLCAnKSArICdcXG4nO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIERlZmF1bHRLZXlWYWx1ZURpZmZlci5wcm90b3R5cGUuX2ZvckVhY2ggPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIG9iai5mb3JFYWNoKGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gZm4ob2JqW2tdLCBrKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWZhdWx0S2V5VmFsdWVEaWZmZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEtleVZhbHVlQ2hhbmdlUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gS2V5VmFsdWVDaGFuZ2VSZWNvcmQoa2V5KSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0UHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXh0QWRkZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dFJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcHJldlJlbW92ZWQgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fbmV4dENoYW5nZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIEtleVZhbHVlQ2hhbmdlUmVjb3JkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb29zZUlkZW50aWNhbCh0aGlzLnByZXZpb3VzVmFsdWUsIHRoaXMuY3VycmVudFZhbHVlKSA/XG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMua2V5KSA6XG4gICAgICAgICAgICAgICAgKHN0cmluZ2lmeSh0aGlzLmtleSkgKyAnWycgKyBzdHJpbmdpZnkodGhpcy5wcmV2aW91c1ZhbHVlKSArICctPicgK1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZnkodGhpcy5jdXJyZW50VmFsdWUpICsgJ10nKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEtleVZhbHVlQ2hhbmdlUmVjb3JkO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlcG9zaXRvcnkgb2YgZGlmZmVyZW50IGl0ZXJhYmxlIGRpZmZpbmcgc3RyYXRlZ2llcyB1c2VkIGJ5IE5nRm9yLCBOZ0NsYXNzLCBhbmQgb3RoZXJzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgSXRlcmFibGVEaWZmZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSXRlcmFibGVEaWZmZXJzKGZhY3Rvcmllcykge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLmNyZWF0ZSA9IGZ1bmN0aW9uIChmYWN0b3JpZXMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcGllZCA9IExpc3RXcmFwcGVyLmNsb25lKHBhcmVudC5mYWN0b3JpZXMpO1xuICAgICAgICAgICAgICAgIGZhY3RvcmllcyA9IGZhY3Rvcmllcy5jb25jYXQoY29waWVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVyYWJsZURpZmZlcnMoZmFjdG9yaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGFuIGFycmF5IG9mIHtAbGluayBJdGVyYWJsZURpZmZlckZhY3Rvcnl9IGFuZCByZXR1cm5zIGEgcHJvdmlkZXIgdXNlZCB0byBleHRlbmQgdGhlXG4gICAgICAgICAqIGluaGVyaXRlZCB7QGxpbmsgSXRlcmFibGVEaWZmZXJzfSBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBmYWN0b3JpZXMgYW5kIHJldHVybiBhIG5ld1xuICAgICAgICAgKiB7QGxpbmsgSXRlcmFibGVEaWZmZXJzfSBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBleHRlbmQgYW4gZXhpc3RpbmcgbGlzdCBvZiBmYWN0b3JpZXMsXG4gICAgICAgICAgICAgICAqIHdoaWNoIHdpbGwgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBpbmplY3RvciBmb3IgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICogVGhpcyBzdGVwIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWQgdG8gbWFrZSBhIG5ldyB7QGxpbmsgSXRlcmFibGVEaWZmZXJ9IGF2YWlsYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBDb21wb25lbnQoe1xuICAgICAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgICAgICogICAgIEl0ZXJhYmxlRGlmZmVycy5leHRlbmQoW25ldyBJbW11dGFibGVMaXN0RGlmZmVyKCldKVxuICAgICAgICAgKiAgIF1cbiAgICAgICAgICogfSlcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBJdGVyYWJsZURpZmZlcnMuZXh0ZW5kID0gZnVuY3Rpb24gKGZhY3Rvcmllcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwaWNhbGx5IHdvdWxkIG9jY3VyIHdoZW4gY2FsbGluZyBJdGVyYWJsZURpZmZlcnMuZXh0ZW5kIGluc2lkZSBvZiBkZXBlbmRlbmNpZXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm9vdHN0cmFwKCksIHdoaWNoIHdvdWxkIG92ZXJyaWRlIGRlZmF1bHQgcGlwZXMgaW5zdGVhZCBvZiBleHRlbmRpbmcgdGhlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGV4dGVuZCBJdGVyYWJsZURpZmZlcnMgd2l0aG91dCBhIHBhcmVudCBpbmplY3RvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJdGVyYWJsZURpZmZlcnMuY3JlYXRlKGZhY3RvcmllcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIERlcGVuZGVuY3kgdGVjaG5pY2FsbHkgaXNuJ3Qgb3B0aW9uYWwsIGJ1dCB3ZSBjYW4gcHJvdmlkZSBhIGJldHRlciBlcnJvciBtZXNzYWdlIHRoaXMgd2F5LlxuICAgICAgICAgICAgICAgIGRlcHM6IFtbSXRlcmFibGVEaWZmZXJzLCBuZXcgU2tpcFNlbGYoKSwgbmV3IE9wdGlvbmFsKCldXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuZmFjdG9yaWVzLmZpbmQoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuc3VwcG9ydHMoaXRlcmFibGUpOyB9KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZmFjdG9yeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0ICdcIiArIGl0ZXJhYmxlICsgXCInIG9mIHR5cGUgJ1wiICsgZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcoaXRlcmFibGUpICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSXRlcmFibGVEaWZmZXJzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlcG9zaXRvcnkgb2YgZGlmZmVyZW50IE1hcCBkaWZmaW5nIHN0cmF0ZWdpZXMgdXNlZCBieSBOZ0NsYXNzLCBOZ1N0eWxlLCBhbmQgb3RoZXJzLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgS2V5VmFsdWVEaWZmZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gS2V5VmFsdWVEaWZmZXJzKGZhY3Rvcmllcykge1xuICAgICAgICAgICAgdGhpcy5mYWN0b3JpZXMgPSBmYWN0b3JpZXM7XG4gICAgICAgIH1cbiAgICAgICAgS2V5VmFsdWVEaWZmZXJzLmNyZWF0ZSA9IGZ1bmN0aW9uIChmYWN0b3JpZXMsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcGllZCA9IExpc3RXcmFwcGVyLmNsb25lKHBhcmVudC5mYWN0b3JpZXMpO1xuICAgICAgICAgICAgICAgIGZhY3RvcmllcyA9IGZhY3Rvcmllcy5jb25jYXQoY29waWVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEtleVZhbHVlRGlmZmVycyhmYWN0b3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXlWYWx1ZURpZmZlcnMoZmFjdG9yaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGFuIGFycmF5IG9mIHtAbGluayBLZXlWYWx1ZURpZmZlckZhY3Rvcnl9IGFuZCByZXR1cm5zIGEgcHJvdmlkZXIgdXNlZCB0byBleHRlbmQgdGhlXG4gICAgICAgICAqIGluaGVyaXRlZCB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBmYWN0b3JpZXMgYW5kIHJldHVybiBhIG5ld1xuICAgICAgICAgKiB7QGxpbmsgS2V5VmFsdWVEaWZmZXJzfSBpbnN0YW5jZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBleHRlbmQgYW4gZXhpc3RpbmcgbGlzdCBvZiBmYWN0b3JpZXMsXG4gICAgICAgICAgICAgICAqIHdoaWNoIHdpbGwgb25seSBiZSBhcHBsaWVkIHRvIHRoZSBpbmplY3RvciBmb3IgdGhpcyBjb21wb25lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICogVGhpcyBzdGVwIGlzIGFsbCB0aGF0J3MgcmVxdWlyZWQgdG8gbWFrZSBhIG5ldyB7QGxpbmsgS2V5VmFsdWVEaWZmZXJ9IGF2YWlsYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBDb21wb25lbnQoe1xuICAgICAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgICAgICogICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQoW25ldyBJbW11dGFibGVNYXBEaWZmZXIoKV0pXG4gICAgICAgICAqICAgXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEtleVZhbHVlRGlmZmVycy5leHRlbmQgPSBmdW5jdGlvbiAoZmFjdG9yaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEtleVZhbHVlRGlmZmVycyxcbiAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBpY2FsbHkgd291bGQgb2NjdXIgd2hlbiBjYWxsaW5nIEtleVZhbHVlRGlmZmVycy5leHRlbmQgaW5zaWRlIG9mIGRlcGVuZGVuY2llcyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBib290c3RyYXAoKSwgd2hpY2ggd291bGQgb3ZlcnJpZGUgZGVmYXVsdCBwaXBlcyBpbnN0ZWFkIG9mIGV4dGVuZGluZyB0aGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZXh0ZW5kIEtleVZhbHVlRGlmZmVycyB3aXRob3V0IGEgcGFyZW50IGluamVjdG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEtleVZhbHVlRGlmZmVycy5jcmVhdGUoZmFjdG9yaWVzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gRGVwZW5kZW5jeSB0ZWNobmljYWxseSBpc24ndCBvcHRpb25hbCwgYnV0IHdlIGNhbiBwcm92aWRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgdGhpcyB3YXkuXG4gICAgICAgICAgICAgICAgZGVwczogW1tLZXlWYWx1ZURpZmZlcnMsIG5ldyBTa2lwU2VsZigpLCBuZXcgT3B0aW9uYWwoKV1dXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBLZXlWYWx1ZURpZmZlcnMucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa3YpIHtcbiAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy5mYWN0b3JpZXMuZmluZChmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5zdXBwb3J0cyhrdik7IH0pO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChmYWN0b3J5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgJ1wiICsga3YgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBLZXlWYWx1ZURpZmZlcnM7XG4gICAgfSgpKTtcblxuICAgIHZhciBVTklOSVRJQUxJWkVEID0ge1xuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0NEX0lOSVRfVkFMVUUnOyB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkZXZNb2RlRXF1YWwoYSwgYikge1xuICAgICAgICBpZiAoaXNMaXN0TGlrZUl0ZXJhYmxlKGEpICYmIGlzTGlzdExpa2VJdGVyYWJsZShiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUl0ZXJhYmxlc0VxdWFsKGEsIGIsIGRldk1vZGVFcXVhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzTGlzdExpa2VJdGVyYWJsZShhKSAmJiAhaXNQcmltaXRpdmUoYSkgJiYgIWlzTGlzdExpa2VJdGVyYWJsZShiKSAmJiAhaXNQcmltaXRpdmUoYikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlSWRlbnRpY2FsKGEsIGIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSByZXN1bHQgb2YgYSB7QGxpbmsgUGlwZX0gdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQgZXZlbiB0aG91Z2ggdGhlXG4gICAgICogcmVmZXJlbmNlXG4gICAgICogaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZWQgdmFsdWUgd2lsbCBiZSB1bndyYXBwZWQgYnkgY2hhbmdlIGRldGVjdGlvbiwgYW5kIHRoZSB1bndyYXBwZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaWYgKHRoaXMuX2xhdGVzdFZhbHVlID09PSB0aGlzLl9sYXRlc3RSZXR1cm5lZFZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIHRoaXMuX2xhdGVzdFJldHVybmVkVmFsdWU7XG4gICAgICogIH0gZWxzZSB7XG4gICAgICogICAgdGhpcy5fbGF0ZXN0UmV0dXJuZWRWYWx1ZSA9IHRoaXMuX2xhdGVzdFZhbHVlO1xuICAgICAqICAgIHJldHVybiBXcmFwcGVkVmFsdWUud3JhcCh0aGlzLl9sYXRlc3RWYWx1ZSk7IC8vIHRoaXMgd2lsbCBmb3JjZSB1cGRhdGVcbiAgICAgKiAgfVxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgV3JhcHBlZFZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gV3JhcHBlZFZhbHVlKHdyYXBwZWQpIHtcbiAgICAgICAgICAgIHRoaXMud3JhcHBlZCA9IHdyYXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgV3JhcHBlZFZhbHVlLndyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG5ldyBXcmFwcGVkVmFsdWUodmFsdWUpOyB9O1xuICAgICAgICByZXR1cm4gV3JhcHBlZFZhbHVlO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGNsYXNzIGZvciB1bndyYXBwaW5nIFdyYXBwZWRWYWx1ZSBzXG4gICAgICovXG4gICAgdmFyIFZhbHVlVW53cmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmFsdWVVbndyYXBwZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1dyYXBwZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFZhbHVlVW53cmFwcGVyLnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFdyYXBwZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzV3JhcHBlZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUud3JhcHBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgVmFsdWVVbndyYXBwZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmhhc1dyYXBwZWRWYWx1ZSA9IGZhbHNlOyB9O1xuICAgICAgICByZXR1cm4gVmFsdWVVbndyYXBwZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgYmFzaWMgY2hhbmdlIGZyb20gYSBwcmV2aW91cyB0byBhIG5ldyB2YWx1ZS5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNpbXBsZUNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNpbXBsZUNoYW5nZShwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzVmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGUgbmV3IHZhbHVlIGlzIHRoZSBmaXJzdCB2YWx1ZSBhc3NpZ25lZC5cbiAgICAgICAgICovXG4gICAgICAgIFNpbXBsZUNoYW5nZS5wcm90b3R5cGUuaXNGaXJzdENoYW5nZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucHJldmlvdXNWYWx1ZSA9PT0gVU5JTklUSUFMSVpFRDsgfTtcbiAgICAgICAgcmV0dXJuIFNpbXBsZUNoYW5nZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ2hhbmdlRGV0ZWN0b3JSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGFuZ2VEZXRlY3RvclJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFN0cnVjdHVyYWwgZGlmZmluZyBmb3IgYE9iamVjdGBzIGFuZCBgTWFwYHMuXG4gICAgICovXG4gICAgdmFyIGtleVZhbERpZmYgPSBbbmV3IERlZmF1bHRLZXlWYWx1ZURpZmZlckZhY3RvcnkoKV07XG4gICAgLyoqXG4gICAgICogU3RydWN0dXJhbCBkaWZmaW5nIGZvciBgSXRlcmFibGVgIHR5cGVzIHN1Y2ggYXMgYEFycmF5YHMuXG4gICAgICovXG4gICAgdmFyIGl0ZXJhYmxlRGlmZiA9IFtuZXcgRGVmYXVsdEl0ZXJhYmxlRGlmZmVyRmFjdG9yeSgpXTtcbiAgICB2YXIgZGVmYXVsdEl0ZXJhYmxlRGlmZmVycyA9IG5ldyBJdGVyYWJsZURpZmZlcnMoaXRlcmFibGVEaWZmKTtcbiAgICB2YXIgZGVmYXVsdEtleVZhbHVlRGlmZmVycyA9IG5ldyBLZXlWYWx1ZURpZmZlcnMoa2V5VmFsRGlmZik7XG5cbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgLy8gVE9ETyAobWF0c2tvKTogYWRkIHR5cGluZyBmb3IgdGhlIGFuaW1hdGlvbiBmdW5jdGlvblxuICAgIHZhciBSZW5kZXJDb21wb25lbnRUeXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyQ29tcG9uZW50VHlwZShpZCwgdGVtcGxhdGVVcmwsIHNsb3RDb3VudCwgZW5jYXBzdWxhdGlvbiwgc3R5bGVzLCBhbmltYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gdGVtcGxhdGVVcmw7XG4gICAgICAgICAgICB0aGlzLnNsb3RDb3VudCA9IHNsb3RDb3VudDtcbiAgICAgICAgICAgIHRoaXMuZW5jYXBzdWxhdGlvbiA9IGVuY2Fwc3VsYXRpb247XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlbmRlckNvbXBvbmVudFR5cGU7XG4gICAgfSgpKTtcbiAgICB2YXIgUmVuZGVyRGVidWdJbmZvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyRGVidWdJbmZvKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwiY29tcG9uZW50XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwicHJvdmlkZXJUb2tlbnNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVuZGVyRGVidWdJbmZvLnByb3RvdHlwZSwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlbmRlckRlYnVnSW5mby5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZW5kZXJEZWJ1Z0luZm8ucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBSZW5kZXJEZWJ1Z0luZm87XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlbmRlcmVyO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogSW5qZWN0YWJsZSBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgYSBsb3ctbGV2ZWwgaW50ZXJmYWNlIGZvciBtb2RpZnlpbmcgdGhlIFVJLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgc2VydmljZSB0byBieXBhc3MgQW5ndWxhcidzIHRlbXBsYXRpbmcgYW5kIG1ha2UgY3VzdG9tIFVJIGNoYW5nZXMgdGhhdCBjYW4ndCBiZVxuICAgICAqIGV4cHJlc3NlZCBkZWNsYXJhdGl2ZWx5LiBGb3IgZXhhbXBsZSBpZiB5b3UgbmVlZCB0byBzZXQgYSBwcm9wZXJ0eSBvciBhbiBhdHRyaWJ1dGUgd2hvc2UgbmFtZSBpc1xuICAgICAqIG5vdCBzdGF0aWNhbGx5IGtub3duLCB1c2Uge0BsaW5rICNzZXRFbGVtZW50UHJvcGVydHl9IG9yIHtAbGluayAjc2V0RWxlbWVudEF0dHJpYnV0ZX1cbiAgICAgKiByZXNwZWN0aXZlbHkuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgYXJlIGltcGxlbWVudGluZyBhIGN1c3RvbSByZW5kZXJlciwgeW91IG11c3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgUmVuZGVyZXIgaW1wbGVtZW50YXRpb24gaXMgYERvbVJlbmRlcmVyYC4gQWxzbyBhdmFpbGFibGUgaXMgYFdlYldvcmtlclJlbmRlcmVyYC5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJvb3RSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJvb3RSZW5kZXJlcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUm9vdFJlbmRlcmVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQSBTZWN1cml0eUNvbnRleHQgbWFya3MgYSBsb2NhdGlvbiB0aGF0IGhhcyBkYW5nZXJvdXMgc2VjdXJpdHkgaW1wbGljYXRpb25zLCBlLmcuIGEgRE9NIHByb3BlcnR5XG4gICAgICogbGlrZSBgaW5uZXJIVE1MYCB0aGF0IGNvdWxkIGNhdXNlIENyb3NzIFNpdGUgU2NyaXB0aW5nIChYU1MpIHNlY3VyaXR5IGJ1Z3Mgd2hlbiBpbXByb3Blcmx5XG4gICAgICogaGFuZGxlZC5cbiAgICAgKlxuICAgICAqIFNlZSBEb21TYW5pdGl6ZXIgZm9yIG1vcmUgZGV0YWlscyBvbiBzZWN1cml0eSBpbiBBbmd1bGFyIGFwcGxpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBleHBvcnRzLlNlY3VyaXR5Q29udGV4dDtcbiAgICAoZnVuY3Rpb24gKFNlY3VyaXR5Q29udGV4dCkge1xuICAgICAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJIVE1MXCJdID0gMV0gPSBcIkhUTUxcIjtcbiAgICAgICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlNUWUxFXCJdID0gMl0gPSBcIlNUWUxFXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJTQ1JJUFRcIl0gPSAzXSA9IFwiU0NSSVBUXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJVUkxcIl0gPSA0XSA9IFwiVVJMXCI7XG4gICAgICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJSRVNPVVJDRV9VUkxcIl0gPSA1XSA9IFwiUkVTT1VSQ0VfVVJMXCI7XG4gICAgfSkoZXhwb3J0cy5TZWN1cml0eUNvbnRleHQgfHwgKGV4cG9ydHMuU2VjdXJpdHlDb250ZXh0ID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBTYW5pdGl6ZXIgaXMgdXNlZCBieSB0aGUgdmlld3MgdG8gc2FuaXRpemUgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2FuaXRpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2FuaXRpemVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTYW5pdGl6ZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgYXJvdW5kIGEgbmF0aXZlIGVsZW1lbnQgaW5zaWRlIG9mIGEgVmlldy5cbiAgICAgKlxuICAgICAqIEFuIGBFbGVtZW50UmVmYCBpcyBiYWNrZWQgYnkgYSByZW5kZXItc3BlY2lmaWMgZWxlbWVudC4gSW4gdGhlIGJyb3dzZXIsIHRoaXMgaXMgdXN1YWxseSBhIERPTVxuICAgICAqIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgUGVybWl0dGluZyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBET00gY2FuIG1ha2UgeW91ciBhcHBsaWNhdGlvbiBtb3JlIHZ1bG5lcmFibGUgdG9cbiAgICAgKiBYU1MgYXR0YWNrcy4gQ2FyZWZ1bGx5IHJldmlldyBhbnkgdXNlIG9mIGBFbGVtZW50UmVmYCBpbiB5b3VyIGNvZGUuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZVxuICAgICAqIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIC8vIE5vdGU6IFdlIGRvbid0IGV4cG9zZSB0aGluZ3MgbGlrZSBgSW5qZWN0b3JgLCBgVmlld0NvbnRhaW5lcmAsIC4uLiBoZXJlLFxuICAgIC8vIGkuZS4gdXNlcnMgaGF2ZSB0byBhc2sgZm9yIHdoYXQgdGhleSBuZWVkLiBXaXRoIHRoYXQsIHdlIGNhbiBidWlsZCBiZXR0ZXIgYW5hbHlzaXMgdG9vbHNcbiAgICAvLyBhbmQgY291bGQgZG8gYmV0dGVyIGNvZGVnZW4gaW4gdGhlIGZ1dHVyZS5cbiAgICB2YXIgRWxlbWVudFJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEVsZW1lbnRSZWYobmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50ID0gbmF0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWxlbWVudFJlZjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIHRyYWNlO1xuICAgIHZhciBldmVudHM7XG4gICAgZnVuY3Rpb24gZGV0ZWN0V1RGKCkge1xuICAgICAgICB2YXIgd3RmID0gZ2xvYmFsJDFbJ3d0ZiddO1xuICAgICAgICBpZiAod3RmKSB7XG4gICAgICAgICAgICB0cmFjZSA9IHd0ZlsndHJhY2UnXTtcbiAgICAgICAgICAgIGlmICh0cmFjZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IHRyYWNlWydldmVudHMnXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNjb3BlKHNpZ25hdHVyZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdzID09PSB2b2lkIDApIHsgZmxhZ3MgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBldmVudHMuY3JlYXRlU2NvcGUoc2lnbmF0dXJlLCBmbGFncyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlYXZlKHNjb3BlLCByZXR1cm5WYWx1ZSkge1xuICAgICAgICB0cmFjZS5sZWF2ZVNjb3BlKHNjb3BlLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRUaW1lUmFuZ2UocmFuZ2VUeXBlLCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRyYWNlLmJlZ2luVGltZVJhbmdlKHJhbmdlVHlwZSwgYWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kVGltZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHRyYWNlLmVuZFRpbWVSYW5nZShyYW5nZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBXVEYgaXMgZW5hYmxlZC5cbiAgICAgKi9cbiAgICB2YXIgd3RmRW5hYmxlZCA9IGRldGVjdFdURigpO1xuICAgIGZ1bmN0aW9uIG5vb3BTY29wZShhcmcwLCBhcmcxKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdHJhY2Ugc2NvcGUuXG4gICAgICpcbiAgICAgKiBTY29wZXMgbXVzdCBiZSBzdHJpY3RseSBuZXN0ZWQgYW5kIGFyZSBhbmFsb2dvdXMgdG8gc3RhY2sgZnJhbWVzLCBidXRcbiAgICAgKiBkbyBub3QgaGF2ZSB0byBmb2xsb3cgdGhlIHN0YWNrIGZyYW1lcy4gSW5zdGVhZCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHRoZXkgZm9sbG93IGxvZ2ljYWxcbiAgICAgKiBuZXN0aW5nLiBZb3UgbWF5IHdhbnQgdG8gdXNlXG4gICAgICogW0V2ZW50XG4gICAgICogU2lnbmF0dXJlc10oaHR0cDovL2dvb2dsZS5naXRodWIuaW8vdHJhY2luZy1mcmFtZXdvcmsvaW5zdHJ1bWVudGluZy1jb2RlLmh0bWwjY3VzdG9tLWV2ZW50cylcbiAgICAgKiBhcyB0aGV5IGFyZSBkZWZpbmVkIGluIFdURi5cbiAgICAgKlxuICAgICAqIFVzZWQgdG8gbWFyayBzY29wZSBlbnRyeS4gVGhlIHJldHVybiB2YWx1ZSBpcyB1c2VkIHRvIGxlYXZlIHRoZSBzY29wZS5cbiAgICAgKlxuICAgICAqICAgICB2YXIgbXlTY29wZSA9IHd0ZkNyZWF0ZVNjb3BlKCdNeUNsYXNzI215TWV0aG9kKGFzY2lpIHNvbWVWYWwpJyk7XG4gICAgICpcbiAgICAgKiAgICAgc29tZU1ldGhvZCgpIHtcbiAgICAgKiAgICAgICAgdmFyIHMgPSBteVNjb3BlKCdGb28nKTsgLy8gJ0ZvbycgZ2V0cyBzdG9yZWQgaW4gdHJhY2luZyBVSVxuICAgICAqICAgICAgICAvLyBETyBTT01FIFdPUksgSEVSRVxuICAgICAqICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgMTIzKTsgLy8gUmV0dXJuIHZhbHVlIDEyM1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBOb3RlLCBhZGRpbmcgdHJ5LWZpbmFsbHkgYmxvY2sgYXJvdW5kIHRoZSB3b3JrIHRvIGVuc3VyZSB0aGF0IGB3dGZMZWF2ZWAgZ2V0cyBjYWxsZWQgY2FuXG4gICAgICogbmVnYXRpdmVseSBpbXBhY3QgdGhlIHBlcmZvcm1hbmNlIG9mIHlvdXIgYXBwbGljYXRpb24uIEZvciB0aGlzIHJlYXNvbiB3ZSByZWNvbW1lbmQgdGhhdFxuICAgICAqIHlvdSBkb24ndCBhZGQgdGhlbSB0byBlbnN1cmUgdGhhdCBgd3RmTGVhdmVgIGdldHMgY2FsbGVkLiBJbiBwcm9kdWN0aW9uIGB3dGZMZWF2ZWAgaXMgYSBub29wIGFuZFxuICAgICAqIHNvIHRyeS1maW5hbGx5IGJsb2NrIGhhcyBubyB2YWx1ZS4gV2hlbiBkZWJ1Z2dpbmcgcGVyZiBpc3N1ZXMsIHNraXBwaW5nIGB3dGZMZWF2ZWAsIGRvIHRvXG4gICAgICogZXhjZXB0aW9uLCB3aWxsIHByb2R1Y2UgaW5jb3JyZWN0IHRyYWNlLCBidXQgcHJlc2VuY2Ugb2YgZXhjZXB0aW9uIHNpZ25pZmllcyBsb2dpYyBlcnJvciB3aGljaFxuICAgICAqIG5lZWRzIHRvIGJlIGZpeGVkIGJlZm9yZSB0aGUgYXBwIHNob3VsZCBiZSBwcm9maWxlZC4gQWRkIHRyeS1maW5hbGx5IG9ubHkgd2hlbiB5b3UgZXhwZWN0IHRoYXRcbiAgICAgKiBhbiBleGNlcHRpb24gaXMgZXhwZWN0ZWQgZHVyaW5nIG5vcm1hbCBleGVjdXRpb24gd2hpbGUgcHJvZmlsaW5nLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciB3dGZDcmVhdGVTY29wZSA9IHd0ZkVuYWJsZWQgPyBjcmVhdGVTY29wZSA6IGZ1bmN0aW9uIChzaWduYXR1cmUsIGZsYWdzKSB7IHJldHVybiBub29wU2NvcGU7IH07XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBtYXJrIGVuZCBvZiBTY29wZS5cbiAgICAgKlxuICAgICAqIC0gYHNjb3BlYCB0byBlbmQuXG4gICAgICogLSBgcmV0dXJuVmFsdWVgIChvcHRpb25hbCkgdG8gYmUgcGFzc2VkIHRvIHRoZSBXVEYuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBgcmV0dXJuVmFsdWUgZm9yIGVhc3kgY2hhaW5pbmcuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciB3dGZMZWF2ZSA9IHd0ZkVuYWJsZWQgPyBsZWF2ZSA6IGZ1bmN0aW9uIChzLCByKSB7IHJldHVybiByOyB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gbWFyayBBc3luYyBzdGFydC4gQXN5bmMgYXJlIHNpbWlsYXIgdG8gc2NvcGUgYnV0IHRoZXkgZG9uJ3QgaGF2ZSB0byBiZSBzdHJpY3RseSBuZXN0ZWQuXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSBpcyB1c2VkIGluIHRoZSBjYWxsIHRvIFtlbmRBc3luY10uIEFzeW5jIHJhbmdlcyBvbmx5IHdvcmsgaWYgV1RGIGhhcyBiZWVuXG4gICAgICogZW5hYmxlZC5cbiAgICAgKlxuICAgICAqICAgICBzb21lTWV0aG9kKCkge1xuICAgICAqICAgICAgICB2YXIgcyA9IHd0ZlN0YXJ0VGltZVJhbmdlKCdIVFRQOkdFVCcsICdzb21lLnVybCcpO1xuICAgICAqICAgICAgICB2YXIgZnV0dXJlID0gbmV3IEZ1dHVyZS5kZWxheSg1KS50aGVuKChfKSB7XG4gICAgICogICAgICAgICAgd3RmRW5kVGltZVJhbmdlKHMpO1xuICAgICAqICAgICAgICB9KTtcbiAgICAgKiAgICAgfVxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgd3RmU3RhcnRUaW1lUmFuZ2UgPSB3dGZFbmFibGVkID8gc3RhcnRUaW1lUmFuZ2UgOiBmdW5jdGlvbiAocmFuZ2VUeXBlLCBhY3Rpb24pIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogRW5kcyBhIGFzeW5jIHRpbWUgcmFuZ2Ugb3BlcmF0aW9uLlxuICAgICAqIFtyYW5nZV0gaXMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIFt3dGZTdGFydFRpbWVSYW5nZV0gQXN5bmMgcmFuZ2VzIG9ubHkgd29yayBpZiBXVEYgaGFzIGJlZW5cbiAgICAgKiBlbmFibGVkLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgd3RmRW5kVGltZVJhbmdlID0gd3RmRW5hYmxlZCA/IGVuZFRpbWVSYW5nZSA6IGZ1bmN0aW9uIChyKSB7IHJldHVybiBudWxsOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGNvbnRhaW5lciB3aGVyZSBvbmUgb3IgbW9yZSBWaWV3cyBjYW4gYmUgYXR0YWNoZWQuXG4gICAgICpcbiAgICAgKiBUaGUgY29udGFpbmVyIGNhbiBjb250YWluIHR3byBraW5kcyBvZiBWaWV3cy4gSG9zdCBWaWV3cywgY3JlYXRlZCBieSBpbnN0YW50aWF0aW5nIGFcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50fSB2aWEge0BsaW5rICNjcmVhdGVDb21wb25lbnR9LCBhbmQgRW1iZWRkZWQgVmlld3MsIGNyZWF0ZWQgYnkgaW5zdGFudGlhdGluZyBhblxuICAgICAqIHtAbGluayBUZW1wbGF0ZVJlZiBFbWJlZGRlZCBUZW1wbGF0ZX0gdmlhIHtAbGluayAjY3JlYXRlRW1iZWRkZWRWaWV3fS5cbiAgICAgKlxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgVmlldyBDb250YWluZXIgd2l0aGluIHRoZSBjb250YWluaW5nIFZpZXcgaXMgc3BlY2lmaWVkIGJ5IHRoZSBBbmNob3JcbiAgICAgKiBgZWxlbWVudGAuIEVhY2ggVmlldyBDb250YWluZXIgY2FuIGhhdmUgb25seSBvbmUgQW5jaG9yIEVsZW1lbnQgYW5kIGVhY2ggQW5jaG9yIEVsZW1lbnQgY2FuIG9ubHlcbiAgICAgKiBoYXZlIGEgc2luZ2xlIFZpZXcgQ29udGFpbmVyLlxuICAgICAqXG4gICAgICogUm9vdCBlbGVtZW50cyBvZiBWaWV3cyBhdHRhY2hlZCB0byB0aGlzIGNvbnRhaW5lciBiZWNvbWUgc2libGluZ3Mgb2YgdGhlIEFuY2hvciBFbGVtZW50IGluXG4gICAgICogdGhlIFJlbmRlcmVkIFZpZXcuXG4gICAgICpcbiAgICAgKiBUbyBhY2Nlc3MgYSBgVmlld0NvbnRhaW5lclJlZmAgb2YgYW4gRWxlbWVudCwgeW91IGNhbiBlaXRoZXIgcGxhY2UgYSB7QGxpbmsgRGlyZWN0aXZlfSBpbmplY3RlZFxuICAgICAqIHdpdGggYFZpZXdDb250YWluZXJSZWZgIG9uIHRoZSBFbGVtZW50LCBvciB5b3Ugb2J0YWluIGl0IHZpYSBhIHtAbGluayBWaWV3Q2hpbGR9IHF1ZXJ5LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmlld0NvbnRhaW5lclJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImVsZW1lbnRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbmNob3IgZWxlbWVudCB0aGF0IHNwZWNpZmllcyB0aGUgbG9jYXRpb24gb2YgdGhpcyBjb250YWluZXIgaW4gdGhlIGNvbnRhaW5pbmcgVmlldy5cbiAgICAgICAgICAgICAqIDwhLS0gVE9ETzogcmVuYW1lIHRvIGFuY2hvckVsZW1lbnQgLS0+XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcInBhcmVudEluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWYucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBWaWV3cyBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gVmlld0NvbnRhaW5lclJlZjtcbiAgICB9KCkpO1xuICAgIHZhciBWaWV3Q29udGFpbmVyUmVmXyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXJSZWZfKF9lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDb21wb25lbnRJbkNvbnRhaW5lclNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjY3JlYXRlQ29tcG9uZW50KCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2luc2VydFNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjaW5zZXJ0KCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjcmVtb3ZlKCknKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2RldGFjaFNjb3BlID0gd3RmQ3JlYXRlU2NvcGUoJ1ZpZXdDb250YWluZXJSZWYjZGV0YWNoKCknKTtcbiAgICAgICAgfVxuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLl9lbGVtZW50Lm5lc3RlZFZpZXdzW2luZGV4XS5yZWY7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3cyA9IHRoaXMuX2VsZW1lbnQubmVzdGVkVmlld3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh2aWV3cykgPyB2aWV3cy5sZW5ndGggOiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiZWxlbWVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZWxlbWVudFJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbGVtZW50LmluamVjdG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZSwgXCJwYXJlbnRJbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2VsZW1lbnQucGFyZW50SW5qZWN0b3I7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPKHJhZG8pOiBwcm9maWxlIGFuZCBkZWNpZGUgd2hldGhlciBib3VuZHMgY2hlY2tzIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAvLyB0byB0aGUgbWV0aG9kcyBiZWxvdy5cbiAgICAgICAgVmlld0NvbnRhaW5lclJlZl8ucHJvdG90eXBlLmNyZWF0ZUVtYmVkZGVkVmlldyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVJlZiwgY29udGV4dCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciB2aWV3UmVmID0gdGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KGNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnQodmlld1JlZiwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdSZWY7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSwgaW5kZXgsIGluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IC0xOyB9XG4gICAgICAgICAgICBpZiAoaW5qZWN0b3IgPT09IHZvaWQgMCkgeyBpbmplY3RvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChwcm9qZWN0YWJsZU5vZGVzID09PSB2b2lkIDApIHsgcHJvamVjdGFibGVOb2RlcyA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fY3JlYXRlQ29tcG9uZW50SW5Db250YWluZXJTY29wZSgpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHRJbmplY3RvciA9IGlzUHJlc2VudChpbmplY3RvcikgPyBpbmplY3RvciA6IHRoaXMuX2VsZW1lbnQucGFyZW50SW5qZWN0b3I7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUoY29udGV4dEluamVjdG9yLCBwcm9qZWN0YWJsZU5vZGVzKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGNvbXBvbmVudFJlZi5ob3N0VmlldywgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHd0ZkxlYXZlKHMsIGNvbXBvbmVudFJlZik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGluc2VydCtyZW1vdmUgaW50byBtb3ZlXG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAodmlld1JlZiwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5faW5zZXJ0U2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHZpZXdSZWZfID0gdmlld1JlZjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYXR0YWNoVmlldyh2aWV3UmVmXy5pbnRlcm5hbFZpZXcsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB3dGZMZWF2ZShzLCB2aWV3UmVmXyk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHZpZXdSZWYsIGN1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLl9pbnNlcnRTY29wZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdmlld1JlZl8gPSB2aWV3UmVmO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5tb3ZlVmlldyh2aWV3UmVmXy5pbnRlcm5hbFZpZXcsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gd3RmTGVhdmUocywgdmlld1JlZl8pO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3Q29udGFpbmVyUmVmXy5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uICh2aWV3UmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXIuaW5kZXhPZih0aGlzLl9lbGVtZW50Lm5lc3RlZFZpZXdzLCB2aWV3UmVmLmludGVybmFsVmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE8oaSk6IHJlbmFtZSB0byBkZXN0cm95XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fcmVtb3ZlU2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZWxlbWVudC5kZXRhY2hWaWV3KGluZGV4KTtcbiAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgLy8gdmlldyBpcyBpbnRlbnRpb25hbGx5IG5vdCByZXR1cm5lZCB0byB0aGUgY2xpZW50LlxuICAgICAgICAgICAgd3RmTGVhdmUocyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE8oaSk6IHJlZmFjdG9yIGluc2VydCtyZW1vdmUgaW50byBtb3ZlXG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gLTE7IH1cbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5fZGV0YWNoU2NvcGUoKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSAtMSlcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZWxlbWVudC5kZXRhY2hWaWV3KGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB3dGZMZWF2ZShzLCB2aWV3LnJlZik7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdDb250YWluZXJSZWZfLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWaWV3Q29udGFpbmVyUmVmXztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBWaWV3VHlwZTtcbiAgICAoZnVuY3Rpb24gKFZpZXdUeXBlKSB7XG4gICAgICAgIC8vIEEgdmlldyB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGVsZW1lbnQgd2l0aCBib3VuZCBjb21wb25lbnQgZGlyZWN0aXZlLlxuICAgICAgICAvLyBDb250YWlucyBhIENPTVBPTkVOVCB2aWV3XG4gICAgICAgIFZpZXdUeXBlW1ZpZXdUeXBlW1wiSE9TVFwiXSA9IDBdID0gXCJIT1NUXCI7XG4gICAgICAgIC8vIFRoZSB2aWV3IG9mIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gQ2FuIGNvbnRhaW4gMCB0byBuIEVNQkVEREVEIHZpZXdzXG4gICAgICAgIFZpZXdUeXBlW1ZpZXdUeXBlW1wiQ09NUE9ORU5UXCJdID0gMV0gPSBcIkNPTVBPTkVOVFwiO1xuICAgICAgICAvLyBBIHZpZXcgdGhhdCBpcyBlbWJlZGRlZCBpbnRvIGFub3RoZXIgVmlldyB2aWEgYSA8dGVtcGxhdGU+IGVsZW1lbnRcbiAgICAgICAgLy8gaW5zaWRlIG9mIGEgQ09NUE9ORU5UIHZpZXdcbiAgICAgICAgVmlld1R5cGVbVmlld1R5cGVbXCJFTUJFRERFRFwiXSA9IDJdID0gXCJFTUJFRERFRFwiO1xuICAgIH0pKFZpZXdUeXBlIHx8IChWaWV3VHlwZSA9IHt9KSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBBcHBFbGVtZW50IGlzIGNyZWF0ZWQgZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIFZpZXdDb250YWluZXJSZWYsXG4gICAgICogYSBuZXN0ZWQgY29tcG9uZW50IG9yIGEgPHRlbXBsYXRlPiBlbGVtZW50IHRvIGtlZXAgZGF0YSBhcm91bmRcbiAgICAgKiB0aGF0IGlzIG5lZWRlZCBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvbnMuXG4gICAgICovXG4gICAgdmFyIEFwcEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBcHBFbGVtZW50KGluZGV4LCBwYXJlbnRJbmRleCwgcGFyZW50VmlldywgbmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRJbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRWaWV3ID0gcGFyZW50VmlldztcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IG5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZFZpZXdzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VmlldyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcEVsZW1lbnQucHJvdG90eXBlLCBcImVsZW1lbnRSZWZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRWxlbWVudFJlZih0aGlzLm5hdGl2ZUVsZW1lbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcEVsZW1lbnQucHJvdG90eXBlLCBcInZjUmVmXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFZpZXdDb250YWluZXJSZWZfKHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQXBwRWxlbWVudC5wcm90b3R5cGUuaW5pdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGNvbXBvbmVudENvbnN0cnVjdG9yVmlld1F1ZXJpZXMsIHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRDb25zdHJ1Y3RvclZpZXdRdWVyaWVzID0gY29tcG9uZW50Q29uc3RydWN0b3JWaWV3UXVlcmllcztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50VmlldyA9IHZpZXc7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBFbGVtZW50LnByb3RvdHlwZSwgXCJwYXJlbnRJbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyZW50Vmlldy5pbmplY3Rvcih0aGlzLnBhcmVudEluZGV4KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBFbGVtZW50LnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucGFyZW50Vmlldy5pbmplY3Rvcih0aGlzLmluZGV4KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEFwcEVsZW1lbnQucHJvdG90eXBlLm1hcE5lc3RlZFZpZXdzID0gZnVuY3Rpb24gKG5lc3RlZFZpZXdDbGFzcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5uZXN0ZWRWaWV3cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZFZpZXdzLmZvckVhY2goZnVuY3Rpb24gKG5lc3RlZFZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZFZpZXcuY2xhenogPT09IG5lc3RlZFZpZXdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2sobmVzdGVkVmlldykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBBcHBFbGVtZW50LnByb3RvdHlwZS5tb3ZlVmlldyA9IGZ1bmN0aW9uICh2aWV3LCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0luZGV4ID0gdGhpcy5uZXN0ZWRWaWV3cy5pbmRleE9mKHZpZXcpO1xuICAgICAgICAgICAgaWYgKHZpZXcudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXN0ZWRWaWV3cyA9IHRoaXMubmVzdGVkVmlld3M7XG4gICAgICAgICAgICBpZiAobmVzdGVkVmlld3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5lc3RlZFZpZXdzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3cyA9IG5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQXQobmVzdGVkVmlld3MsIHByZXZpb3VzSW5kZXgpO1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0KG5lc3RlZFZpZXdzLCBjdXJyZW50SW5kZXgsIHZpZXcpO1xuICAgICAgICAgICAgdmFyIHJlZlJlbmRlck5vZGU7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VmlldyA9IG5lc3RlZFZpZXdzW2N1cnJlbnRJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHJlZlJlbmRlck5vZGUgPSBwcmV2Vmlldy5sYXN0Um9vdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZSZW5kZXJOb2RlID0gdGhpcy5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyZWZSZW5kZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgIHZpZXcucmVuZGVyZXIuYXR0YWNoVmlld0FmdGVyKHJlZlJlbmRlck5vZGUsIHZpZXcuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3Lm1hcmtDb250ZW50Q2hpbGRBc01vdmVkKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXcsIHZpZXdJbmRleCkge1xuICAgICAgICAgICAgaWYgKHZpZXcudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXN0ZWRWaWV3cyA9IHRoaXMubmVzdGVkVmlld3M7XG4gICAgICAgICAgICBpZiAobmVzdGVkVmlld3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5lc3RlZFZpZXdzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWRWaWV3cyA9IG5lc3RlZFZpZXdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0KG5lc3RlZFZpZXdzLCB2aWV3SW5kZXgsIHZpZXcpO1xuICAgICAgICAgICAgdmFyIHJlZlJlbmRlck5vZGU7XG4gICAgICAgICAgICBpZiAodmlld0luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2VmlldyA9IG5lc3RlZFZpZXdzW3ZpZXdJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHJlZlJlbmRlck5vZGUgPSBwcmV2Vmlldy5sYXN0Um9vdE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWZSZW5kZXJOb2RlID0gdGhpcy5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChyZWZSZW5kZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgIHZpZXcucmVuZGVyZXIuYXR0YWNoVmlld0FmdGVyKHJlZlJlbmRlck5vZGUsIHZpZXcuZmxhdFJvb3ROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3LmFkZFRvQ29udGVudENoaWxkcmVuKHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBBcHBFbGVtZW50LnByb3RvdHlwZS5kZXRhY2hWaWV3ID0gZnVuY3Rpb24gKHZpZXdJbmRleCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBMaXN0V3JhcHBlci5yZW1vdmVBdCh0aGlzLm5lc3RlZFZpZXdzLCB2aWV3SW5kZXgpO1xuICAgICAgICAgICAgaWYgKHZpZXcudHlwZSA9PT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IHZpZXdzIGNhbid0IGJlIG1vdmVkIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcuZGV0YWNoKCk7XG4gICAgICAgICAgICB2aWV3LnJlbW92ZUZyb21Db250ZW50Q2hpbGRyZW4odGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdmlldztcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFwcEVsZW1lbnQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDYgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBlcnJvciB0aHJvd24gaWYgYXBwbGljYXRpb24gY2hhbmdlcyBtb2RlbCBicmVha2luZyB0aGUgdG9wLWRvd24gZGF0YSBmbG93LlxuICAgICAqXG4gICAgICogVGhpcyBleGNlcHRpb24gaXMgb25seSB0aHJvd24gaW4gZGV2IG1vZGUuXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IEFkZCBhIGxpbmsgb25jZSB0aGUgZGV2IG1vZGUgb3B0aW9uIGlzIGNvbmZpZ3VyYWJsZSAtLT5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ3BhcmVudCcsXG4gICAgICogICB0ZW1wbGF0ZTogJzxjaGlsZCBbcHJvcF09XCJwYXJlbnRQcm9wXCI+PC9jaGlsZD4nLFxuICAgICAqIH0pXG4gICAgICogY2xhc3MgUGFyZW50IHtcbiAgICAgKiAgIHBhcmVudFByb3AgPSAnaW5pdCc7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdjaGlsZCcsIGlucHV0czogWydwcm9wJ119KVxuICAgICAqIGNsYXNzIENoaWxkIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBwYXJlbnQ6IFBhcmVudCkge31cbiAgICAgKlxuICAgICAqICAgc2V0IHByb3Aodikge1xuICAgICAqICAgICAvLyB0aGlzIHVwZGF0ZXMgdGhlIHBhcmVudCBwcm9wZXJ0eSwgd2hpY2ggaXMgZGlzYWxsb3dlZCBkdXJpbmcgY2hhbmdlIGRldGVjdGlvblxuICAgICAqICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3JcbiAgICAgKiAgICAgdGhpcy5wYXJlbnQucGFyZW50UHJvcCA9ICd1cGRhdGVkJztcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcihvbGRWYWx1ZSwgY3VyclZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gXCJFeHByZXNzaW9uIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkLiBQcmV2aW91cyB2YWx1ZTogJ1wiICsgb2xkVmFsdWUgKyBcIicuIEN1cnJlbnQgdmFsdWU6ICdcIiArIGN1cnJWYWx1ZSArIFwiJy5cIjtcbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PT0gVU5JTklUSUFMSVpFRCkge1xuICAgICAgICAgICAgICAgIG1zZyArPVxuICAgICAgICAgICAgICAgICAgICBcIiBJdCBzZWVtcyBsaWtlIHRoZSB2aWV3IGhhcyBiZWVuIGNyZWF0ZWQgYWZ0ZXIgaXRzIHBhcmVudCBhbmQgaXRzIGNoaWxkcmVuIGhhdmUgYmVlbiBkaXJ0eSBjaGVja2VkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIEhhcyBpdCBiZWVuIGNyZWF0ZWQgaW4gYSBjaGFuZ2UgZGV0ZWN0aW9uIGhvb2sgP1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGFuIGV4Y2VwdGlvbiB3YXMgcmFpc2VkIGR1cmluZyB2aWV3IGNyZWF0aW9uLCBjaGFuZ2UgZGV0ZWN0aW9uIG9yIGRlc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBlcnJvciB3cmFwcyB0aGUgb3JpZ2luYWwgZXhjZXB0aW9uIHRvIGF0dGFjaCBhZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gdGhhdCBjYW5cbiAgICAgKiBiZSB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZpZXdXcmFwcGVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihWaWV3V3JhcHBlZEVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBWaWV3V3JhcHBlZEVycm9yKG9yaWdpbmFsRXJyb3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiRXJyb3IgaW4gXCIgKyBjb250ZXh0LnNvdXJjZSwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWaWV3V3JhcHBlZEVycm9yO1xuICAgIH0oV3JhcHBlZEVycm9yKSk7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYSBkZXN0cm95ZWQgdmlldyBpcyB1c2VkLlxuICAgICAqXG4gICAgICogVGhpcyBlcnJvciBpbmRpY2F0ZXMgYSBidWcgaW4gdGhlIGZyYW1ld29yay5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJuYWwgQW5ndWxhciBlcnJvci5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZpZXdEZXN0cm95ZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KFZpZXdEZXN0cm95ZWRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVmlld0Rlc3Ryb3llZEVycm9yKGRldGFpbHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQXR0ZW1wdCB0byB1c2UgYSBkZXN0cm95ZWQgdmlldzogXCIgKyBkZXRhaWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVmlld0Rlc3Ryb3llZEVycm9yO1xuICAgIH0oQmFzZUVycm9yKSk7XG5cbiAgICB2YXIgVmlld1V0aWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld1V0aWxzKF9yZW5kZXJlciwgX2FwcElkLCBzYW5pdGl6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fYXBwSWQgPSBfYXBwSWQ7XG4gICAgICAgICAgICB0aGlzLl9uZXh0Q29tcFR5cGVJZCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBieSB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgICAgICovXG4gICAgICAgIC8vIFRPRE8gKG1hdHNrbyk6IGFkZCB0eXBpbmcgZm9yIHRoZSBhbmltYXRpb24gZnVuY3Rpb25cbiAgICAgICAgVmlld1V0aWxzLnByb3RvdHlwZS5jcmVhdGVSZW5kZXJDb21wb25lbnRUeXBlID0gZnVuY3Rpb24gKHRlbXBsYXRlVXJsLCBzbG90Q291bnQsIGVuY2Fwc3VsYXRpb24sIHN0eWxlcywgYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJDb21wb25lbnRUeXBlKHRoaXMuX2FwcElkICsgXCItXCIgKyB0aGlzLl9uZXh0Q29tcFR5cGVJZCsrLCB0ZW1wbGF0ZVVybCwgc2xvdENvdW50LCBlbmNhcHN1bGF0aW9uLCBzdHlsZXMsIGFuaW1hdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFZpZXdVdGlscy5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKHJlbmRlckNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5yZW5kZXJDb21wb25lbnQocmVuZGVyQ29tcG9uZW50VHlwZSk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdVdGlscy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBWaWV3VXRpbHMuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IFJvb3RSZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBJbmplY3QsIGFyZ3M6IFtBUFBfSUQsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogU2FuaXRpemVyLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gVmlld1V0aWxzO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gZmxhdHRlbk5lc3RlZFZpZXdSZW5kZXJOb2Rlcyhub2Rlcykge1xuICAgICAgICByZXR1cm4gX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMobm9kZXMsIFtdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMobm9kZXMsIHJlbmRlck5vZGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFwcEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwRWwgPSBub2RlO1xuICAgICAgICAgICAgICAgIHJlbmRlck5vZGVzLnB1c2goYXBwRWwubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhcHBFbC5uZXN0ZWRWaWV3cykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBFbC5uZXN0ZWRWaWV3cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMoYXBwRWwubmVzdGVkVmlld3Nba10ucm9vdE5vZGVzT3JBcHBFbGVtZW50cywgcmVuZGVyTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyTm9kZXM7XG4gICAgfVxuICAgIHZhciBFTVBUWV9BUlIgPSBbXTtcbiAgICBmdW5jdGlvbiBlbnN1cmVTbG90Q291bnQocHJvamVjdGFibGVOb2RlcywgZXhwZWN0ZWRTbG90Q291bnQpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCFwcm9qZWN0YWJsZU5vZGVzKSB7XG4gICAgICAgICAgICByZXMgPSBFTVBUWV9BUlI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdGFibGVOb2Rlcy5sZW5ndGggPCBleHBlY3RlZFNsb3RDb3VudCkge1xuICAgICAgICAgICAgdmFyIGdpdmVuU2xvdENvdW50ID0gcHJvamVjdGFibGVOb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICByZXMgPSBuZXcgQXJyYXkoZXhwZWN0ZWRTbG90Q291bnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFNsb3RDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2ldID0gKGkgPCBnaXZlblNsb3RDb3VudCkgPyBwcm9qZWN0YWJsZU5vZGVzW2ldIDogRU1QVFlfQVJSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcHJvamVjdGFibGVOb2RlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICB2YXIgTUFYX0lOVEVSUE9MQVRJT05fVkFMVUVTID0gOTtcbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh2YWx1ZUNvdW50LCBjMCwgYTEsIGMxLCBhMiwgYzIsIGEzLCBjMywgYTQsIGM0LCBhNSwgYzUsIGE2LCBjNiwgYTcsIGM3LCBhOCwgYzgsIGE5LCBjOSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlQ291bnQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNDtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1O1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgKyBjNjtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1ICsgX3RvU3RyaW5nV2l0aE51bGwoYTYpICtcbiAgICAgICAgICAgICAgICAgICAgYzYgKyBfdG9TdHJpbmdXaXRoTnVsbChhNykgKyBjNztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gYzAgKyBfdG9TdHJpbmdXaXRoTnVsbChhMSkgKyBjMSArIF90b1N0cmluZ1dpdGhOdWxsKGEyKSArIGMyICsgX3RvU3RyaW5nV2l0aE51bGwoYTMpICtcbiAgICAgICAgICAgICAgICAgICAgYzMgKyBfdG9TdHJpbmdXaXRoTnVsbChhNCkgKyBjNCArIF90b1N0cmluZ1dpdGhOdWxsKGE1KSArIGM1ICsgX3RvU3RyaW5nV2l0aE51bGwoYTYpICtcbiAgICAgICAgICAgICAgICAgICAgYzYgKyBfdG9TdHJpbmdXaXRoTnVsbChhNykgKyBjNyArIF90b1N0cmluZ1dpdGhOdWxsKGE4KSArIGM4O1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIHJldHVybiBjMCArIF90b1N0cmluZ1dpdGhOdWxsKGExKSArIGMxICsgX3RvU3RyaW5nV2l0aE51bGwoYTIpICsgYzIgKyBfdG9TdHJpbmdXaXRoTnVsbChhMykgK1xuICAgICAgICAgICAgICAgICAgICBjMyArIF90b1N0cmluZ1dpdGhOdWxsKGE0KSArIGM0ICsgX3RvU3RyaW5nV2l0aE51bGwoYTUpICsgYzUgKyBfdG9TdHJpbmdXaXRoTnVsbChhNikgK1xuICAgICAgICAgICAgICAgICAgICBjNiArIF90b1N0cmluZ1dpdGhOdWxsKGE3KSArIGM3ICsgX3RvU3RyaW5nV2l0aE51bGwoYTgpICsgYzggKyBfdG9TdHJpbmdXaXRoTnVsbChhOSkgKyBjOTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9lcyBub3Qgc3VwcG9ydCBtb3JlIHRoYW4gOSBleHByZXNzaW9uc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfdG9TdHJpbmdXaXRoTnVsbCh2KSB7XG4gICAgICAgIHJldHVybiB2ICE9IG51bGwgPyB2LnRvU3RyaW5nKCkgOiAnJztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tCaW5kaW5nKHRocm93T25DaGFuZ2UsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBpZiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKCFkZXZNb2RlRXF1YWwob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gIWxvb3NlSWRlbnRpY2FsKG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2FzdEJ5VmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgdmFyIEVNUFRZX0FSUkFZID0gW107XG4gICAgdmFyIEVNUFRZX01BUCA9IHt9O1xuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTEoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXJlUHJveHkyKGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHZhciB2MSA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxKSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTMoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgdmFyIHYxID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgdmFyIHYyID0gVU5JTklUSUFMSVpFRDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwMCwgcDEsIHAyKSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTQoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzO1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICAgICAgdjMgPSBwMztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXJlUHJveHk1KGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQ7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4ocDAsIHAxLCBwMiwgcDMsIHA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTYoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjU7XG4gICAgICAgIHYwID0gdjEgPSB2MiA9IHYzID0gdjQgPSB2NSA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSkge1xuICAgICAgICAgICAgaWYgKCFsb29zZUlkZW50aWNhbCh2MCwgcDApIHx8ICFsb29zZUlkZW50aWNhbCh2MSwgcDEpIHx8ICFsb29zZUlkZW50aWNhbCh2MiwgcDIpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHYzLCBwMykgfHwgIWxvb3NlSWRlbnRpY2FsKHY0LCBwNCkgfHwgIWxvb3NlSWRlbnRpY2FsKHY1LCBwNSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTcoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gdjUgPSB2NiA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsb29zZUlkZW50aWNhbCh2NSwgcDUpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY2LCBwNikpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTgoZm4pIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NztcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gdjYgPSB2NyA9IFVOSU5JVElBTElaRUQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYsIHA3KSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSB8fCAhbG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbG9vc2VJZGVudGljYWwodjUsIHA1KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2NiwgcDYpIHx8ICFsb29zZUlkZW50aWNhbCh2NywgcDcpKSB7XG4gICAgICAgICAgICAgICAgdjAgPSBwMDtcbiAgICAgICAgICAgICAgICB2MSA9IHAxO1xuICAgICAgICAgICAgICAgIHYyID0gcDI7XG4gICAgICAgICAgICAgICAgdjMgPSBwMztcbiAgICAgICAgICAgICAgICB2NCA9IHA0O1xuICAgICAgICAgICAgICAgIHY1ID0gcDU7XG4gICAgICAgICAgICAgICAgdjYgPSBwNjtcbiAgICAgICAgICAgICAgICB2NyA9IHA3O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXJlUHJveHk5KGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4O1xuICAgICAgICB2MCA9IHYxID0gdjIgPSB2MyA9IHY0ID0gdjUgPSB2NiA9IHY3ID0gdjggPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgpIHtcbiAgICAgICAgICAgIGlmICghbG9vc2VJZGVudGljYWwodjAsIHAwKSB8fCAhbG9vc2VJZGVudGljYWwodjEsIHAxKSB8fCAhbG9vc2VJZGVudGljYWwodjIsIHAyKSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2MywgcDMpIHx8ICFsb29zZUlkZW50aWNhbCh2NCwgcDQpIHx8ICFsb29zZUlkZW50aWNhbCh2NSwgcDUpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY2LCBwNikgfHwgIWxvb3NlSWRlbnRpY2FsKHY3LCBwNykgfHwgIWxvb3NlSWRlbnRpY2FsKHY4LCBwOCkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHY3ID0gcDc7XG4gICAgICAgICAgICAgICAgdjggPSBwODtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmbihwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNiwgcDcsIHA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1cmVQcm94eTEwKGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OTtcbiAgICAgICAgdjAgPSB2MSA9IHYyID0gdjMgPSB2NCA9IHY1ID0gdjYgPSB2NyA9IHY4ID0gdjkgPSBVTklOSVRJQUxJWkVEO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgsIHA5KSB7XG4gICAgICAgICAgICBpZiAoIWxvb3NlSWRlbnRpY2FsKHYwLCBwMCkgfHwgIWxvb3NlSWRlbnRpY2FsKHYxLCBwMSkgfHwgIWxvb3NlSWRlbnRpY2FsKHYyLCBwMikgfHxcbiAgICAgICAgICAgICAgICAhbG9vc2VJZGVudGljYWwodjMsIHAzKSB8fCAhbG9vc2VJZGVudGljYWwodjQsIHA0KSB8fCAhbG9vc2VJZGVudGljYWwodjUsIHA1KSB8fFxuICAgICAgICAgICAgICAgICFsb29zZUlkZW50aWNhbCh2NiwgcDYpIHx8ICFsb29zZUlkZW50aWNhbCh2NywgcDcpIHx8ICFsb29zZUlkZW50aWNhbCh2OCwgcDgpIHx8XG4gICAgICAgICAgICAgICAgIWxvb3NlSWRlbnRpY2FsKHY5LCBwOSkpIHtcbiAgICAgICAgICAgICAgICB2MCA9IHAwO1xuICAgICAgICAgICAgICAgIHYxID0gcDE7XG4gICAgICAgICAgICAgICAgdjIgPSBwMjtcbiAgICAgICAgICAgICAgICB2MyA9IHAzO1xuICAgICAgICAgICAgICAgIHY0ID0gcDQ7XG4gICAgICAgICAgICAgICAgdjUgPSBwNTtcbiAgICAgICAgICAgICAgICB2NiA9IHA2O1xuICAgICAgICAgICAgICAgIHY3ID0gcDc7XG4gICAgICAgICAgICAgICAgdjggPSBwODtcbiAgICAgICAgICAgICAgICB2OSA9IHA5O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2LCBwNywgcDgsIHA5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gaW5zdGFuY2Ugb2YgYSBDb21wb25lbnQgY3JlYXRlZCB2aWEgYSB7QGxpbmsgQ29tcG9uZW50RmFjdG9yeX0uXG4gICAgICpcbiAgICAgKiBgQ29tcG9uZW50UmVmYCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIENvbXBvbmVudCBJbnN0YW5jZSBhcyB3ZWxsIG90aGVyIG9iamVjdHMgcmVsYXRlZCB0byB0aGlzXG4gICAgICogQ29tcG9uZW50IEluc3RhbmNlIGFuZCBhbGxvd3MgeW91IHRvIGRlc3Ryb3kgdGhlIENvbXBvbmVudCBJbnN0YW5jZSB2aWEgdGhlIHtAbGluayAjZGVzdHJveX1cbiAgICAgKiBtZXRob2QuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnRSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb21wb25lbnRSZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZi5wcm90b3R5cGUsIFwibG9jYXRpb25cIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMb2NhdGlvbiBvZiB0aGUgSG9zdCBFbGVtZW50IG9mIHRoaXMgQ29tcG9uZW50IEluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluamVjdG9yIG9uIHdoaWNoIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgZXhpc3RzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImluc3RhbmNlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluc3RhbmNlIG9mIHRoZSBDb21wb25lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJob3N0Vmlld1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB7QGxpbmsgVmlld1JlZn0gb2YgdGhlIEhvc3QgVmlldyBvZiB0aGlzIENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWYucHJvdG90eXBlLCBcImNoYW5nZURldGVjdG9yUmVmXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHtAbGluayBDaGFuZ2VEZXRlY3RvclJlZn0gb2YgdGhlIENvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmLnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGNvbXBvbmVudCB0eXBlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRSZWY7XG4gICAgfSgpKTtcbiAgICB2YXIgQ29tcG9uZW50UmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ1KENvbXBvbmVudFJlZl8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudFJlZl8oX2hvc3RFbGVtZW50LCBfY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9ob3N0RWxlbWVudCA9IF9ob3N0RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudFR5cGUgPSBfY29tcG9uZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwibG9jYXRpb25cIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ob3N0RWxlbWVudC5lbGVtZW50UmVmOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faG9zdEVsZW1lbnQuaW5qZWN0b3I7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiaW5zdGFuY2VcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ob3N0RWxlbWVudC5jb21wb25lbnQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRSZWZfLnByb3RvdHlwZSwgXCJob3N0Vmlld1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hvc3RFbGVtZW50LnBhcmVudFZpZXcucmVmOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50UmVmXy5wcm90b3R5cGUsIFwiY2hhbmdlRGV0ZWN0b3JSZWZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ob3N0RWxlbWVudC5wYXJlbnRWaWV3LnJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudFJlZl8ucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb21wb25lbnRUeXBlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQ29tcG9uZW50UmVmXy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5faG9zdEVsZW1lbnQucGFyZW50Vmlldy5kZXN0cm95KCk7IH07XG4gICAgICAgIENvbXBvbmVudFJlZl8ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLmhvc3RWaWV3Lm9uRGVzdHJveShjYWxsYmFjayk7IH07XG4gICAgICAgIHJldHVybiBDb21wb25lbnRSZWZfO1xuICAgIH0oQ29tcG9uZW50UmVmKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBFTVBUWV9DT05URVhUID0gbmV3IE9iamVjdCgpO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQ29tcG9uZW50RmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIF92aWV3RmFjdG9yeSwgX2NvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdGYWN0b3J5ID0gX3ZpZXdGYWN0b3J5O1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50VHlwZSA9IF9jb21wb25lbnRUeXBlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnRGYWN0b3J5LnByb3RvdHlwZSwgXCJjb21wb25lbnRUeXBlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29tcG9uZW50VHlwZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbmplY3RvciwgcHJvamVjdGFibGVOb2Rlcywgcm9vdFNlbGVjdG9yT3JOb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvamVjdGFibGVOb2RlcyA9PT0gdm9pZCAwKSB7IHByb2plY3RhYmxlTm9kZXMgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAocm9vdFNlbGVjdG9yT3JOb2RlID09PSB2b2lkIDApIHsgcm9vdFNlbGVjdG9yT3JOb2RlID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIHZ1ID0gaW5qZWN0b3IuZ2V0KFZpZXdVdGlscyk7XG4gICAgICAgICAgICBpZiAoIXByb2plY3RhYmxlTm9kZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0YWJsZU5vZGVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlOiBIb3N0IHZpZXdzIGRvbid0IG5lZWQgYSBkZWNsYXJhdGlvbkFwcEVsZW1lbnQhXG4gICAgICAgICAgICB2YXIgaG9zdFZpZXcgPSB0aGlzLl92aWV3RmFjdG9yeSh2dSwgaW5qZWN0b3IsIG51bGwpO1xuICAgICAgICAgICAgdmFyIGhvc3RFbGVtZW50ID0gaG9zdFZpZXcuY3JlYXRlKEVNUFRZX0NPTlRFWFQsIHByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudFJlZl8oaG9zdEVsZW1lbnQsIHRoaXMuX2NvbXBvbmVudFR5cGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50RmFjdG9yeTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTm9Db21wb25lbnRGYWN0b3J5RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNyhOb0NvbXBvbmVudEZhY3RvcnlFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTm9Db21wb25lbnRGYWN0b3J5RXJyb3IoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIk5vIGNvbXBvbmVudCBmYWN0b3J5IGZvdW5kIGZvciBcIiArIHN0cmluZ2lmeShjb21wb25lbnQpKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb0NvbXBvbmVudEZhY3RvcnlFcnJvcjtcbiAgICB9KEJhc2VFcnJvcikpO1xuICAgIHZhciBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9OdWxsQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIF9OdWxsQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBOb0NvbXBvbmVudEZhY3RvcnlFcnJvcihjb21wb25lbnQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX051bGxDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIuTlVMTCA9IG5ldyBfTnVsbENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcigpO1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgIH0oKSk7XG4gICAgdmFyIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKGZhY3RvcmllcywgX3BhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX2ZhY3RvcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmFjdG9yaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvcnkgPSBmYWN0b3JpZXNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fZmFjdG9yaWVzLnNldChmYWN0b3J5LmNvbXBvbmVudFR5cGUsIGZhY3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVDb21wb25lbnRGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2ZhY3Rvcmllcy5nZXQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fcGFyZW50LnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZSBieSBkaXJlY3RpdmVzIGFuZCBjb21wb25lbnRzIHRvIGVtaXQgY3VzdG9tIEV2ZW50cy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlc1xuICAgICAqXG4gICAgICogSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCBgWmlwcHlgIGFsdGVybmF0aXZlbHkgZW1pdHMgYG9wZW5gIGFuZCBgY2xvc2VgIGV2ZW50cyB3aGVuIGl0c1xuICAgICAqIHRpdGxlIGdldHMgY2xpY2tlZDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICd6aXBweScsXG4gICAgICogICB0ZW1wbGF0ZTogYFxuICAgICAqICAgPGRpdiBjbGFzcz1cInppcHB5XCI+XG4gICAgICogICAgIDxkaXYgKGNsaWNrKT1cInRvZ2dsZSgpXCI+VG9nZ2xlPC9kaXY+XG4gICAgICogICAgIDxkaXYgW2hpZGRlbl09XCIhdmlzaWJsZVwiPlxuICAgICAqICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgKiAgICAgPC9kaXY+XG4gICAgICogIDwvZGl2PmB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBaaXBweSB7XG4gICAgICogICB2aXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICAgKiAgIEBPdXRwdXQoKSBvcGVuOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgKiAgIEBPdXRwdXQoKSBjbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICpcbiAgICAgKiAgIHRvZ2dsZSgpIHtcbiAgICAgKiAgICAgdGhpcy52aXNpYmxlID0gIXRoaXMudmlzaWJsZTtcbiAgICAgKiAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAqICAgICAgIHRoaXMub3Blbi5lbWl0KG51bGwpO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgIHRoaXMuY2xvc2UuZW1pdChudWxsKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSBldmVudHMgcGF5bG9hZCBjYW4gYmUgYWNjZXNzZWQgYnkgdGhlIHBhcmFtZXRlciBgJGV2ZW50YCBvbiB0aGUgY29tcG9uZW50cyBvdXRwdXQgZXZlbnRcbiAgICAgKiBoYW5kbGVyOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPHppcHB5IChvcGVuKT1cIm9uT3BlbigkZXZlbnQpXCIgKGNsb3NlKT1cIm9uQ2xvc2UoJGV2ZW50KVwiPjwvemlwcHk+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBVc2VzIFJ4Lk9ic2VydmFibGUgYnV0IHByb3ZpZGVzIGFuIGFkYXB0ZXIgdG8gbWFrZSBpdCB3b3JrIGFzIHNwZWNpZmllZCBoZXJlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qaHVzYWluL29ic2VydmFibGUtc3BlY1xuICAgICAqXG4gICAgICogT25jZSBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3BlYyBpcyBhdmFpbGFibGUsIHN3aXRjaCB0byBpdC5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEV2ZW50RW1pdHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ4KEV2ZW50RW1pdHRlciwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgW0V2ZW50RW1pdHRlcl0sIHdoaWNoIGRlcGVuZGluZyBvbiBbaXNBc3luY10sXG4gICAgICAgICAqIGRlbGl2ZXJzIGV2ZW50cyBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm91c2x5LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKGlzQXN5bmMpIHtcbiAgICAgICAgICAgIGlmIChpc0FzeW5jID09PSB2b2lkIDApIHsgaXNBc3luYyA9IGZhbHNlOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID0gaXNBc3luYztcbiAgICAgICAgfVxuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodmFsdWUpIHsgX3N1cGVyLnByb3RvdHlwZS5uZXh0LmNhbGwodGhpcywgdmFsdWUpOyB9O1xuICAgICAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChnZW5lcmF0b3JPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICAgICAgdmFyIHNjaGVkdWxlckZuO1xuICAgICAgICAgICAgdmFyIGVycm9yRm4gPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlRm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dCAmJiB0eXBlb2YgZ2VuZXJhdG9yT3JOZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAodmFsdWUgLyoqIFRPRE8gIzkxMDAgKi8pIHsgZ2VuZXJhdG9yT3JOZXh0Lm5leHQodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKGVycikgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5lcnJvcihlcnIpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7IGdlbmVyYXRvck9yTmV4dC5lcnJvcihlcnIpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0LmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQuY29tcGxldGUoKTsgfSk7IH0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyBnZW5lcmF0b3JPck5leHQuY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXJGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKHZhbHVlIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0KHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh2YWx1ZSAvKiogVE9ETyAjOTEwMCAqLykgeyBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKGVycikgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yKGVycik7IH0pOyB9IDogZnVuY3Rpb24gKGVycikgeyBlcnJvcihlcnIpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wbGV0ZSgpOyB9KTsgfSA6IGZ1bmN0aW9uICgpIHsgY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zdWJzY3JpYmUuY2FsbCh0aGlzLCBzY2hlZHVsZXJGbiwgZXJyb3JGbiwgY29tcGxldGVGbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfShyeGpzX1N1YmplY3QuU3ViamVjdCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBOZ1pvbmVJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdab25lSW1wbChfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciB0cmFjZSA9IF9hLnRyYWNlLCBvbkVudGVyID0gX2Eub25FbnRlciwgb25MZWF2ZSA9IF9hLm9uTGVhdmUsIHNldE1pY3JvdGFzayA9IF9hLnNldE1pY3JvdGFzaywgc2V0TWFjcm90YXNrID0gX2Euc2V0TWFjcm90YXNrLCBvbkVycm9yID0gX2Eub25FcnJvcjtcbiAgICAgICAgICAgIHRoaXMub25FbnRlciA9IG9uRW50ZXI7XG4gICAgICAgICAgICB0aGlzLm9uTGVhdmUgPSBvbkxlYXZlO1xuICAgICAgICAgICAgdGhpcy5zZXRNaWNyb3Rhc2sgPSBzZXRNaWNyb3Rhc2s7XG4gICAgICAgICAgICB0aGlzLnNldE1hY3JvdGFzayA9IHNldE1hY3JvdGFzaztcbiAgICAgICAgICAgIHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFpvbmUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuZ3VsYXIgcmVxdWlyZXMgWm9uZS5qcyBwcm9seWZpbGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBab25lLmFzc2VydFpvbmVQYXRjaGVkKCk7XG4gICAgICAgICAgICB0aGlzLm91dGVyID0gdGhpcy5pbm5lciA9IFpvbmUuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChab25lWyd3dGZab25lU3BlYyddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lciA9IHRoaXMuaW5uZXIuZm9yayhab25lWyd3dGZab25lU3BlYyddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjZSAmJiBab25lWydsb25nU3RhY2tUcmFjZVpvbmVTcGVjJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyID0gdGhpcy5pbm5lci5mb3JrKFpvbmVbJ2xvbmdTdGFja1RyYWNlWm9uZVNwZWMnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gdGhpcy5pbm5lci5mb3JrKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnYW5ndWxhcicsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogeyAnaXNBbmd1bGFyWm9uZSc6IHRydWUgfSxcbiAgICAgICAgICAgICAgICBvbkludm9rZVRhc2s6IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgY3VycmVudCwgdGFyZ2V0LCB0YXNrLCBhcHBseVRoaXMsIGFwcGx5QXJncykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25FbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmludm9rZVRhc2sodGFyZ2V0LCB0YXNrLCBhcHBseVRoaXMsIGFwcGx5QXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkxlYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uSW52b2tlOiBmdW5jdGlvbiAoZGVsZWdhdGUsIGN1cnJlbnQsIHRhcmdldCwgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRW50ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5pbnZva2UodGFyZ2V0LCBjYWxsYmFjaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkxlYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uSGFzVGFzazogZnVuY3Rpb24gKGRlbGVnYXRlLCBjdXJyZW50LCB0YXJnZXQsIGhhc1Rhc2tTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5oYXNUYXNrKHRhcmdldCwgaGFzVGFza1N0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiBoYXNUYXNrIGV2ZW50cyB3aGljaCBvcmlnaW5hdGUgZnJvbSBvdXIgem9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKEEgY2hpbGQgaGFzVGFzayBldmVudCBpcyBub3QgaW50ZXJlc3RpbmcgdG8gdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzVGFza1N0YXRlLmNoYW5nZSA9PSAnbWljcm9UYXNrJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE1pY3JvdGFzayhoYXNUYXNrU3RhdGUubWljcm9UYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc1Rhc2tTdGF0ZS5jaGFuZ2UgPT0gJ21hY3JvVGFzaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRNYWNyb3Rhc2soaGFzVGFza1N0YXRlLm1hY3JvVGFzayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uSGFuZGxlRXJyb3I6IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgY3VycmVudCwgdGFyZ2V0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5oYW5kbGVFcnJvcih0YXJnZXQsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBOZ1pvbmVJbXBsLmlzSW5Bbmd1bGFyWm9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFpvbmUuY3VycmVudC5nZXQoJ2lzQW5ndWxhclpvbmUnKSA9PT0gdHJ1ZTsgfTtcbiAgICAgICAgTmdab25lSW1wbC5wcm90b3R5cGUucnVuSW5uZXIgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMuaW5uZXIucnVuKGZuKTsgfTtcbiAgICAgICAgO1xuICAgICAgICBOZ1pvbmVJbXBsLnByb3RvdHlwZS5ydW5Jbm5lckd1YXJkZWQgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMuaW5uZXIucnVuR3VhcmRlZChmbik7IH07XG4gICAgICAgIDtcbiAgICAgICAgTmdab25lSW1wbC5wcm90b3R5cGUucnVuT3V0ZXIgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMub3V0ZXIucnVuKGZuKTsgfTtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gTmdab25lSW1wbDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQW4gaW5qZWN0YWJsZSBzZXJ2aWNlIGZvciBleGVjdXRpbmcgd29yayBpbnNpZGUgb3Igb3V0c2lkZSBvZiB0aGUgQW5ndWxhciB6b25lLlxuICAgICAqXG4gICAgICogVGhlIG1vc3QgY29tbW9uIHVzZSBvZiB0aGlzIHNlcnZpY2UgaXMgdG8gb3B0aW1pemUgcGVyZm9ybWFuY2Ugd2hlbiBzdGFydGluZyBhIHdvcmsgY29uc2lzdGluZyBvZlxuICAgICAqIG9uZSBvciBtb3JlIGFzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IHJlcXVpcmUgVUkgdXBkYXRlcyBvciBlcnJvciBoYW5kbGluZyB0byBiZSBoYW5kbGVkIGJ5XG4gICAgICogQW5ndWxhci4gU3VjaCB0YXNrcyBjYW4gYmUga2lja2VkIG9mZiB2aWEge0BsaW5rICNydW5PdXRzaWRlQW5ndWxhcn0gYW5kIGlmIG5lZWRlZCwgdGhlc2UgdGFza3NcbiAgICAgKiBjYW4gcmVlbnRlciB0aGUgQW5ndWxhciB6b25lIHZpYSB7QGxpbmsgI3J1bn0uXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IGFkZC9maXggbGlua3MgdG86XG4gICAgICogICAtIGRvY3MgZXhwbGFpbmluZyB6b25lcyBhbmQgdGhlIHVzZSBvZiB6b25lcyBpbiBBbmd1bGFyIGFuZCBjaGFuZ2UtZGV0ZWN0aW9uXG4gICAgICogICAtIGxpbmsgdG8gcnVuT3V0c2lkZUFuZ3VsYXIvcnVuICh0aHJvdWdob3V0IHRoaXMgZmlsZSEpXG4gICAgICogICAtLT5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9sWTltOEhMeTd6MDZ2RG9VYVNOMj9wPXByZXZpZXcpKVxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7Q29tcG9uZW50LCBWaWV3LCBOZ1pvbmV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICAgICAqIGltcG9ydCB7TmdJZn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbiAgICAgKlxuICAgICAqIEBDb21wb25lbnQoe1xuICAgICAqICAgc2VsZWN0b3I6ICduZy16b25lLWRlbW8nLlxuICAgICAqICAgdGVtcGxhdGU6IGBcbiAgICAgKiAgICAgPGgyPkRlbW86IE5nWm9uZTwvaDI+XG4gICAgICpcbiAgICAgKiAgICAgPHA+UHJvZ3Jlc3M6IHt7cHJvZ3Jlc3N9fSU8L3A+XG4gICAgICogICAgIDxwICpuZ0lmPVwicHJvZ3Jlc3MgPj0gMTAwXCI+RG9uZSBwcm9jZXNzaW5nIHt7bGFiZWx9fSBvZiBBbmd1bGFyIHpvbmUhPC9wPlxuICAgICAqXG4gICAgICogICAgIDxidXR0b24gKGNsaWNrKT1cInByb2Nlc3NXaXRoaW5Bbmd1bGFyWm9uZSgpXCI+UHJvY2VzcyB3aXRoaW4gQW5ndWxhciB6b25lPC9idXR0b24+XG4gICAgICogICAgIDxidXR0b24gKGNsaWNrKT1cInByb2Nlc3NPdXRzaWRlT2ZBbmd1bGFyWm9uZSgpXCI+UHJvY2VzcyBvdXRzaWRlIG9mIEFuZ3VsYXIgem9uZTwvYnV0dG9uPlxuICAgICAqICAgYCxcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBOZ1pvbmVEZW1vIHtcbiAgICAgKiAgIHByb2dyZXNzOiBudW1iZXIgPSAwO1xuICAgICAqICAgbGFiZWw6IHN0cmluZztcbiAgICAgKlxuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHt9XG4gICAgICpcbiAgICAgKiAgIC8vIExvb3AgaW5zaWRlIHRoZSBBbmd1bGFyIHpvbmVcbiAgICAgKiAgIC8vIHNvIHRoZSBVSSBET0VTIHJlZnJlc2ggYWZ0ZXIgZWFjaCBzZXRUaW1lb3V0IGN5Y2xlXG4gICAgICogICBwcm9jZXNzV2l0aGluQW5ndWxhclpvbmUoKSB7XG4gICAgICogICAgIHRoaXMubGFiZWwgPSAnaW5zaWRlJztcbiAgICAgKiAgICAgdGhpcy5wcm9ncmVzcyA9IDA7XG4gICAgICogICAgIHRoaXMuX2luY3JlYXNlUHJvZ3Jlc3MoKCkgPT4gY29uc29sZS5sb2coJ0luc2lkZSBEb25lIScpKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgLy8gTG9vcCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmVcbiAgICAgKiAgIC8vIHNvIHRoZSBVSSBET0VTIE5PVCByZWZyZXNoIGFmdGVyIGVhY2ggc2V0VGltZW91dCBjeWNsZVxuICAgICAqICAgcHJvY2Vzc091dHNpZGVPZkFuZ3VsYXJab25lKCkge1xuICAgICAqICAgICB0aGlzLmxhYmVsID0gJ291dHNpZGUnO1xuICAgICAqICAgICB0aGlzLnByb2dyZXNzID0gMDtcbiAgICAgKiAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgKiAgICAgICB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKCgpID0+IHtcbiAgICAgKiAgICAgICAvLyByZWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgYW5kIGRpc3BsYXkgZG9uZVxuICAgICAqICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4ge2NvbnNvbGUubG9nKCdPdXRzaWRlIERvbmUhJykgfSk7XG4gICAgICogICAgIH19KSk7XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKlxuICAgICAqICAgX2luY3JlYXNlUHJvZ3Jlc3MoZG9uZUNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgICogICAgIHRoaXMucHJvZ3Jlc3MgKz0gMTtcbiAgICAgKiAgICAgY29uc29sZS5sb2coYEN1cnJlbnQgcHJvZ3Jlc3M6ICR7dGhpcy5wcm9ncmVzc30lYCk7XG4gICAgICpcbiAgICAgKiAgICAgaWYgKHRoaXMucHJvZ3Jlc3MgPCAxMDApIHtcbiAgICAgKiAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aGlzLl9pbmNyZWFzZVByb2dyZXNzKGRvbmVDYWxsYmFjaykpLCAxMClcbiAgICAgKiAgICAgfSBlbHNlIHtcbiAgICAgKiAgICAgICBkb25lQ2FsbGJhY2soKTtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIE5nWm9uZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nWm9uZShfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBfYiA9IF9hLmVuYWJsZUxvbmdTdGFja1RyYWNlLCBlbmFibGVMb25nU3RhY2tUcmFjZSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xuICAgICAgICAgICAgdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1BlbmRpbmdNYWNyb3Rhc2tzID0gZmFsc2U7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9uZXN0aW5nID0gMDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uVW5zdGFibGUgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uTWljcm90YXNrRW1wdHkgPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uU3RhYmxlID0gbmV3IEV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yRXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl96b25lSW1wbCA9IG5ldyBOZ1pvbmVJbXBsKHtcbiAgICAgICAgICAgICAgICB0cmFjZTogZW5hYmxlTG9uZ1N0YWNrVHJhY2UsXG4gICAgICAgICAgICAgICAgb25FbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnWk9ORS5lbnRlcicsIHRoaXMuX25lc3RpbmcsIHRoaXMuX2lzU3RhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX25lc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc1N0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzU3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fb25VbnN0YWJsZS5lbWl0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkxlYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9uZXN0aW5nLS07XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdaT05FLmxlYXZlJywgdGhpcy5fbmVzdGluZywgdGhpcy5faXNTdGFibGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tTdGFibGUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldE1pY3JvdGFzazogZnVuY3Rpb24gKGhhc01pY3JvdGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2hhc1BlbmRpbmdNaWNyb3Rhc2tzID0gaGFzTWljcm90YXNrcztcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NoZWNrU3RhYmxlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXRNYWNyb3Rhc2s6IGZ1bmN0aW9uIChoYXNNYWNyb3Rhc2tzKSB7IF90aGlzLl9oYXNQZW5kaW5nTWFjcm90YXNrcyA9IGhhc01hY3JvdGFza3M7IH0sXG4gICAgICAgICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBfdGhpcy5fb25FcnJvckV2ZW50cy5lbWl0KGVycm9yKTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgTmdab25lLmlzSW5Bbmd1bGFyWm9uZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nWm9uZUltcGwuaXNJbkFuZ3VsYXJab25lKCk7IH07XG4gICAgICAgIE5nWm9uZS5hc3NlcnRJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFOZ1pvbmVJbXBsLmlzSW5Bbmd1bGFyWm9uZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBiZSBpbiBBbmd1bGFyIFpvbmUsIGJ1dCBpdCBpcyBub3QhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nWm9uZS5hc3NlcnROb3RJbkFuZ3VsYXJab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKE5nWm9uZUltcGwuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIG5vdCBiZSBpbiBBbmd1bGFyIFpvbmUsIGJ1dCBpdCBpcyEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdab25lLnByb3RvdHlwZS5fY2hlY2tTdGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX25lc3RpbmcgPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3MgJiYgIXRoaXMuX2lzU3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnWk9ORS5taWNyb3Rhc2tFbXB0eScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVzdGluZysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25NaWNyb3Rhc2tFbXB0eS5lbWl0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmVzdGluZy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9oYXNQZW5kaW5nTWljcm90YXNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdaT05FLnN0YWJsZScsIHRoaXMuX25lc3RpbmcsIHRoaXMuX2lzU3RhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25TdGFibGUuZW1pdChudWxsKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc1N0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcIm9uVW5zdGFibGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3RpZmllcyB3aGVuIGNvZGUgZW50ZXJzIEFuZ3VsYXIgWm9uZS4gVGhpcyBnZXRzIGZpcmVkIGZpcnN0IG9uIFZNIFR1cm4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb25VbnN0YWJsZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcIm9uTWljcm90YXNrRW1wdHlcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3RpZmllcyB3aGVuIHRoZXJlIGlzIG5vIG1vcmUgbWljcm90YXNrcyBlbnF1ZXVlIGluIHRoZSBjdXJyZW50IFZNIFR1cm4uXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGEgaGludCBmb3IgQW5ndWxhciB0byBkbyBjaGFuZ2UgZGV0ZWN0aW9uLCB3aGljaCBtYXkgZW5xdWV1ZSBtb3JlIG1pY3JvdGFza3MuXG4gICAgICAgICAgICAgKiBGb3IgdGhpcyByZWFzb24gdGhpcyBldmVudCBjYW4gZmlyZSBtdWx0aXBsZSB0aW1lcyBwZXIgVk0gVHVybi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vbk1pY3JvdGFza0VtcHR5OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nWm9uZS5wcm90b3R5cGUsIFwib25TdGFibGVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3RpZmllcyB3aGVuIHRoZSBsYXN0IGBvbk1pY3JvdGFza0VtcHR5YCBoYXMgcnVuIGFuZCB0aGVyZSBhcmUgbm8gbW9yZSBtaWNyb3Rhc2tzLCB3aGljaFxuICAgICAgICAgICAgICogaW1wbGllcyB3ZSBhcmUgYWJvdXQgdG8gcmVsaW5xdWlzaCBWTSB0dXJuLlxuICAgICAgICAgICAgICogVGhpcyBldmVudCBnZXRzIGNhbGxlZCBqdXN0IG9uY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb25TdGFibGU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJvbkVycm9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90aWZ5IHRoYXQgYW4gZXJyb3IgaGFzIGJlZW4gZGVsaXZlcmVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX29uRXJyb3JFdmVudHM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJpc1N0YWJsZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlcmUgYXJlIG5vIG91dHN0YW5kaW5nIG1pY3JvdGFza3Mgb3IgbWljcm90YXNrcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pc1N0YWJsZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1pvbmUucHJvdG90eXBlLCBcImhhc1BlbmRpbmdNaWNyb3Rhc2tzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciB0aGVyZSBhcmUgYW55IG91dHN0YW5kaW5nIG1pY3JvdGFza3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faGFzUGVuZGluZ01pY3JvdGFza3M7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdab25lLnByb3RvdHlwZSwgXCJoYXNQZW5kaW5nTWFjcm90YXNrc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlcmUgYXJlIGFueSBvdXRzdGFuZGluZyBtaWNyb3Rhc2tzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2hhc1BlbmRpbmdNYWNyb3Rhc2tzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgd2l0aGluIHRoZSBBbmd1bGFyIHpvbmUgYW5kIHJldHVybnMgdmFsdWUgcmV0dXJuZWQgYnlcbiAgICAgICAgICogdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSdW5uaW5nIGZ1bmN0aW9ucyB2aWEgYHJ1bmAgYWxsb3dzIHlvdSB0byByZWVudGVyIEFuZ3VsYXIgem9uZSBmcm9tIGEgdGFzayB0aGF0IHdhcyBleGVjdXRlZFxuICAgICAgICAgKiBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUgKHR5cGljYWxseSBzdGFydGVkIHZpYSB7QGxpbmsgI3J1bk91dHNpZGVBbmd1bGFyfSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBmdXR1cmUgdGFza3Mgb3IgbWljcm90YXNrcyBzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIGV4ZWN1dGluZyBmcm9tXG4gICAgICAgICAqIHdpdGhpbiB0aGUgQW5ndWxhciB6b25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIHN5bmNocm9ub3VzIGVycm9yIGhhcHBlbnMgaXQgd2lsbCBiZSByZXRocm93biBhbmQgbm90IHJlcG9ydGVkIHZpYSBgb25FcnJvcmAuXG4gICAgICAgICAqL1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5fem9uZUltcGwucnVuSW5uZXIoZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2FtZSBhcyAjcnVuLCBleGNlcHQgdGhhdCBzeW5jaHJvbm91cyBlcnJvcnMgYXJlIGNhdWdodCBhbmQgZm9yd2FyZGVkXG4gICAgICAgICAqIHZpYSBgb25FcnJvcmAgYW5kIG5vdCByZXRocm93bi5cbiAgICAgICAgICovXG4gICAgICAgIE5nWm9uZS5wcm90b3R5cGUucnVuR3VhcmRlZCA9IGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdGhpcy5fem9uZUltcGwucnVuSW5uZXJHdWFyZGVkKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGVzIHRoZSBgZm5gIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgaW4gQW5ndWxhcidzIHBhcmVudCB6b25lIGFuZCByZXR1cm5zIHZhbHVlIHJldHVybmVkIGJ5XG4gICAgICAgICAqIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogUnVubmluZyBmdW5jdGlvbnMgdmlhIGBydW5PdXRzaWRlQW5ndWxhcmAgYWxsb3dzIHlvdSB0byBlc2NhcGUgQW5ndWxhcidzIHpvbmUgYW5kIGRvIHdvcmsgdGhhdFxuICAgICAgICAgKiBkb2Vzbid0IHRyaWdnZXIgQW5ndWxhciBjaGFuZ2UtZGV0ZWN0aW9uIG9yIGlzIHN1YmplY3QgdG8gQW5ndWxhcidzIGVycm9yIGhhbmRsaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbnkgZnV0dXJlIHRhc2tzIG9yIG1pY3JvdGFza3Mgc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBjb250aW51ZSBleGVjdXRpbmcgZnJvbVxuICAgICAgICAgKiBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB7QGxpbmsgI3J1bn0gdG8gcmVlbnRlciB0aGUgQW5ndWxhciB6b25lIGFuZCBkbyB3b3JrIHRoYXQgdXBkYXRlcyB0aGUgYXBwbGljYXRpb24gbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBOZ1pvbmUucHJvdG90eXBlLnJ1bk91dHNpZGVBbmd1bGFyID0gZnVuY3Rpb24gKGZuKSB7IHJldHVybiB0aGlzLl96b25lSW1wbC5ydW5PdXRlcihmbik7IH07XG4gICAgICAgIHJldHVybiBOZ1pvbmU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBUZXN0YWJpbGl0eSBzZXJ2aWNlIHByb3ZpZGVzIHRlc3RpbmcgaG9va3MgdGhhdCBjYW4gYmUgYWNjZXNzZWQgZnJvbVxuICAgICAqIHRoZSBicm93c2VyIGFuZCBieSBzZXJ2aWNlcyBzdWNoIGFzIFByb3RyYWN0b3IuIEVhY2ggYm9vdHN0cmFwcGVkIEFuZ3VsYXJcbiAgICAgKiBhcHBsaWNhdGlvbiBvbiB0aGUgcGFnZSB3aWxsIGhhdmUgYW4gaW5zdGFuY2Ugb2YgVGVzdGFiaWxpdHkuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBUZXN0YWJpbGl0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlc3RhYmlsaXR5KF9uZ1pvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ291bnQgPSAwO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faXNab25lU3RhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciBhbnkgd29yayB3YXMgZG9uZSBzaW5jZSB0aGUgbGFzdCAnd2hlblN0YWJsZScgY2FsbGJhY2suIFRoaXMgaXNcbiAgICAgICAgICAgICAqIHVzZWZ1bCB0byBkZXRlY3QgaWYgdGhpcyBjb3VsZCBoYXZlIHBvdGVudGlhbGx5IGRlc3RhYmlsaXplZCBhbm90aGVyXG4gICAgICAgICAgICAgKiBjb21wb25lbnQgd2hpbGUgaXQgaXMgc3RhYmlsaXppbmcuXG4gICAgICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fZGlkV29yayA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICB0aGlzLl93YXRjaEFuZ3VsYXJFdmVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5fd2F0Y2hBbmd1bGFyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5vblVuc3RhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGlkV29yayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1pvbmVTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX25nWm9uZS5vblN0YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBOZ1pvbmUuYXNzZXJ0Tm90SW5Bbmd1bGFyWm9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pc1pvbmVTdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ydW5DYWxsYmFja3NJZlJlYWR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5pbmNyZWFzZVBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQ291bnQgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuX2RpZFdvcmsgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmRlY3JlYXNlUGVuZGluZ1JlcXVlc3RDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdDb3VudCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BlbmRpbmcgYXN5bmMgcmVxdWVzdHMgYmVsb3cgemVybycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcnVuQ2FsbGJhY2tzSWZSZWFkeSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdDb3VudDtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmlzU3RhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzWm9uZVN0YWJsZSAmJiB0aGlzLl9wZW5kaW5nQ291bnQgPT0gMCAmJiAhdGhpcy5fbmdab25lLmhhc1BlbmRpbmdNYWNyb3Rhc2tzO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFRlc3RhYmlsaXR5LnByb3RvdHlwZS5fcnVuQ2FsbGJhY2tzSWZSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGVzIHRoZSBjYWxsIGJhY2tzIGluIGEgbmV3IGZyYW1lIHNvIHRoYXQgaXQgaXMgYWx3YXlzIGFzeW5jLlxuICAgICAgICAgICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKF90aGlzLl9jYWxsYmFja3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX3RoaXMuX2NhbGxiYWNrcy5wb3AoKSkoX3RoaXMuX2RpZFdvcmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaWRXb3JrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgUmVhZHlcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWRXb3JrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLndoZW5TdGFibGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRoaXMuX3J1bkNhbGxiYWNrc0lmUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkucHJvdG90eXBlLmdldFBlbmRpbmdSZXF1ZXN0Q291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQ7IH07XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgZmluZFByb3ZpZGVycyAqL1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZEJpbmRpbmdzID0gZnVuY3Rpb24gKHVzaW5nLCBwcm92aWRlciwgZXhhY3RNYXRjaCkge1xuICAgICAgICAgICAgLy8gVE9ETyhqdWxpZW1yKTogaW1wbGVtZW50LlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9O1xuICAgICAgICBUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZFByb3ZpZGVycyA9IGZ1bmN0aW9uICh1c2luZywgcHJvdmlkZXIsIGV4YWN0TWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oanVsaWVtcik6IGltcGxlbWVudC5cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgVGVzdGFiaWxpdHkuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IE5nWm9uZSwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFRlc3RhYmlsaXR5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQSBnbG9iYWwgcmVnaXN0cnkgb2Yge0BsaW5rIFRlc3RhYmlsaXR5fSBpbnN0YW5jZXMgZm9yIHNwZWNpZmljIGVsZW1lbnRzLlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgVGVzdGFiaWxpdHlSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRlc3RhYmlsaXR5UmVnaXN0cnkoKSB7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9hcHBsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBfdGVzdGFiaWxpdHlHZXR0ZXIuYWRkVG9XaW5kb3codGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJBcHBsaWNhdGlvbiA9IGZ1bmN0aW9uICh0b2tlbiwgdGVzdGFiaWxpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGxpY2F0aW9ucy5zZXQodG9rZW4sIHRlc3RhYmlsaXR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0VGVzdGFiaWxpdHkgPSBmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdGhpcy5fYXBwbGljYXRpb25zLmdldChlbGVtKTsgfTtcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5wcm90b3R5cGUuZ2V0QWxsVGVzdGFiaWxpdGllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hcFdyYXBwZXIudmFsdWVzKHRoaXMuX2FwcGxpY2F0aW9ucyk7IH07XG4gICAgICAgIFRlc3RhYmlsaXR5UmVnaXN0cnkucHJvdG90eXBlLmdldEFsbFJvb3RFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hcFdyYXBwZXIua2V5cyh0aGlzLl9hcHBsaWNhdGlvbnMpOyB9O1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LnByb3RvdHlwZS5maW5kVGVzdGFiaWxpdHlJblRyZWUgPSBmdW5jdGlvbiAoZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoZmluZEluQW5jZXN0b3JzID09PSB2b2lkIDApIHsgZmluZEluQW5jZXN0b3JzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgcmV0dXJuIF90ZXN0YWJpbGl0eUdldHRlci5maW5kVGVzdGFiaWxpdHlJblRyZWUodGhpcywgZWxlbSwgZmluZEluQW5jZXN0b3JzKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVzdGFiaWxpdHlSZWdpc3RyeS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBUZXN0YWJpbGl0eVJlZ2lzdHJ5O1xuICAgIH0oKSk7XG4gICAgdmFyIF9Ob29wR2V0VGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBfTm9vcEdldFRlc3RhYmlsaXR5KCkge1xuICAgICAgICB9XG4gICAgICAgIF9Ob29wR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmFkZFRvV2luZG93ID0gZnVuY3Rpb24gKHJlZ2lzdHJ5KSB7IH07XG4gICAgICAgIF9Ob29wR2V0VGVzdGFiaWxpdHkucHJvdG90eXBlLmZpbmRUZXN0YWJpbGl0eUluVHJlZSA9IGZ1bmN0aW9uIChyZWdpc3RyeSwgZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF9Ob29wR2V0VGVzdGFiaWxpdHk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHtAbGluayBHZXRUZXN0YWJpbGl0eX0gaW1wbGVtZW50YXRpb24gdXNlZCBieSB0aGUgQW5ndWxhciB0ZXN0aW5nIGZyYW1ld29yay5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0VGVzdGFiaWxpdHlHZXR0ZXIoZ2V0dGVyKSB7XG4gICAgICAgIF90ZXN0YWJpbGl0eUdldHRlciA9IGdldHRlcjtcbiAgICB9XG4gICAgdmFyIF90ZXN0YWJpbGl0eUdldHRlciA9IG5ldyBfTm9vcEdldFRlc3RhYmlsaXR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIF9kZXZNb2RlID0gdHJ1ZTtcbiAgICB2YXIgX3J1bk1vZGVMb2NrZWQgPSBmYWxzZTtcbiAgICB2YXIgX3BsYXRmb3JtO1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgQW5ndWxhcidzIGRldmVsb3BtZW50IG1vZGUsIHdoaWNoIHR1cm5zIG9mZiBhc3NlcnRpb25zIGFuZCBvdGhlclxuICAgICAqIGNoZWNrcyB3aXRoaW4gdGhlIGZyYW1ld29yay5cbiAgICAgKlxuICAgICAqIE9uZSBpbXBvcnRhbnQgYXNzZXJ0aW9uIHRoaXMgZGlzYWJsZXMgdmVyaWZpZXMgdGhhdCBhIGNoYW5nZSBkZXRlY3Rpb24gcGFzc1xuICAgICAqIGRvZXMgbm90IHJlc3VsdCBpbiBhZGRpdGlvbmFsIGNoYW5nZXMgdG8gYW55IGJpbmRpbmdzIChhbHNvIGtub3duIGFzXG4gICAgICogdW5pZGlyZWN0aW9uYWwgZGF0YSBmbG93KS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmFibGVQcm9kTW9kZSgpIHtcbiAgICAgICAgaWYgKF9ydW5Nb2RlTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmFibGUgcHJvZCBtb2RlIGFmdGVyIHBsYXRmb3JtIHNldHVwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9kZXZNb2RlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBBbmd1bGFyIGlzIGluIGRldmVsb3BtZW50IG1vZGUuIEFmdGVyIGNhbGxlZCBvbmNlLFxuICAgICAqIHRoZSB2YWx1ZSBpcyBsb2NrZWQgYW5kIHdvbid0IGNoYW5nZSBhbnkgbW9yZS5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoaXMgaXMgdHJ1ZSwgdW5sZXNzIGEgdXNlciBjYWxscyBgZW5hYmxlUHJvZE1vZGVgIGJlZm9yZSBjYWxsaW5nIHRoaXMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFQSXMgcmVsYXRlZCB0byBhcHBsaWNhdGlvbiBib290c3RyYXAgYXJlIGN1cnJlbnRseSB1bmRlciByZXZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEZXZNb2RlKCkge1xuICAgICAgICBfcnVuTW9kZUxvY2tlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBfZGV2TW9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBsYXRmb3JtLlxuICAgICAqIFBsYXRmb3JtcyBoYXZlIHRvIGJlIGVhZ2VybHkgY3JlYXRlZCB2aWEgdGhpcyBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQbGF0Zm9ybShpbmplY3Rvcikge1xuICAgICAgICBpZiAoX3BsYXRmb3JtICYmICFfcGxhdGZvcm0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGNhbiBiZSBvbmx5IG9uZSBwbGF0Zm9ybS4gRGVzdHJveSB0aGUgcHJldmlvdXMgb25lIHRvIGNyZWF0ZSBhIG5ldyBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3BsYXRmb3JtID0gaW5qZWN0b3IuZ2V0KFBsYXRmb3JtUmVmKTtcbiAgICAgICAgdmFyIGluaXRzID0gaW5qZWN0b3IuZ2V0KFBMQVRGT1JNX0lOSVRJQUxJWkVSLCBudWxsKTtcbiAgICAgICAgaWYgKGluaXRzKVxuICAgICAgICAgICAgaW5pdHMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdCkgeyByZXR1cm4gaW5pdCgpOyB9KTtcbiAgICAgICAgcmV0dXJuIF9wbGF0Zm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZm9yIGEgcGxhdGZvcm1cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQbGF0Zm9ybUZhY3RvcnkocGFyZW50UGxhZm9ybUZhY3RvcnksIG5hbWUsIHByb3ZpZGVycykge1xuICAgICAgICBpZiAocHJvdmlkZXJzID09PSB2b2lkIDApIHsgcHJvdmlkZXJzID0gW107IH1cbiAgICAgICAgdmFyIG1hcmtlciA9IG5ldyBPcGFxdWVUb2tlbihcIlBsYXRmb3JtOiBcIiArIG5hbWUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV4dHJhUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFQcm92aWRlcnMgPT09IHZvaWQgMCkgeyBleHRyYVByb3ZpZGVycyA9IFtdOyB9XG4gICAgICAgICAgICBpZiAoIWdldFBsYXRmb3JtKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50UGxhZm9ybUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UGxhZm9ybUZhY3RvcnkocHJvdmlkZXJzLmNvbmNhdChleHRyYVByb3ZpZGVycykuY29uY2F0KHsgcHJvdmlkZTogbWFya2VyLCB1c2VWYWx1ZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVQbGF0Zm9ybShSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShwcm92aWRlcnMuY29uY2F0KGV4dHJhUHJvdmlkZXJzKS5jb25jYXQoeyBwcm92aWRlOiBtYXJrZXIsIHVzZVZhbHVlOiB0cnVlIH0pKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzc2VydFBsYXRmb3JtKG1hcmtlcik7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGF0IHRoZXJlIGN1cnJlbnRseSBpcyBhIHBsYXRmb3JtXG4gICAgICogd2hpY2ggY29udGFpbnMgdGhlIGdpdmVuIHRva2VuIGFzIGEgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFQSXMgcmVsYXRlZCB0byBhcHBsaWNhdGlvbiBib290c3RyYXAgYXJlIGN1cnJlbnRseSB1bmRlciByZXZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0UGxhdGZvcm0ocmVxdWlyZWRUb2tlbikge1xuICAgICAgICB2YXIgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xuICAgICAgICBpZiAoIXBsYXRmb3JtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBsYXRmb3JtIGV4aXN0cyEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsYXRmb3JtLmluamVjdG9yLmdldChyZXF1aXJlZFRva2VuLCBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHBsYXRmb3JtIHdpdGggYSBkaWZmZXJlbnQgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBjcmVhdGVkLiBQbGVhc2UgZGVzdHJveSBpdCBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxhdGZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGV4aXN0aW5nIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlc3Ryb3lQbGF0Zm9ybSgpIHtcbiAgICAgICAgaWYgKF9wbGF0Zm9ybSAmJiAhX3BsYXRmb3JtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgX3BsYXRmb3JtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBUElzIHJlbGF0ZWQgdG8gYXBwbGljYXRpb24gYm9vdHN0cmFwIGFyZSBjdXJyZW50bHkgdW5kZXIgcmV2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICAgICAgICByZXR1cm4gX3BsYXRmb3JtICYmICFfcGxhdGZvcm0uZGVzdHJveWVkID8gX3BsYXRmb3JtIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIEFuZ3VsYXIgcGxhdGZvcm0gaXMgdGhlIGVudHJ5IHBvaW50IGZvciBBbmd1bGFyIG9uIGEgd2ViIHBhZ2UuIEVhY2ggcGFnZVxuICAgICAqIGhhcyBleGFjdGx5IG9uZSBwbGF0Zm9ybSwgYW5kIHNlcnZpY2VzIChzdWNoIGFzIHJlZmxlY3Rpb24pIHdoaWNoIGFyZSBjb21tb25cbiAgICAgKiB0byBldmVyeSBBbmd1bGFyIGFwcGxpY2F0aW9uIHJ1bm5pbmcgb24gdGhlIHBhZ2UgYXJlIGJvdW5kIGluIGl0cyBzY29wZS5cbiAgICAgKlxuICAgICAqIEEgcGFnZSdzIHBsYXRmb3JtIGlzIGluaXRpYWxpemVkIGltcGxpY2l0bHkgd2hlbiB7QGxpbmsgYm9vdHN0cmFwfSgpIGlzIGNhbGxlZCwgb3JcbiAgICAgKiBleHBsaWNpdGx5IGJ5IGNhbGxpbmcge0BsaW5rIGNyZWF0ZVBsYXRmb3JtfSgpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBQbGF0Zm9ybVJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBsYXRmb3JtUmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIGBATmdNb2R1bGVgIGZvciB0aGUgZ2l2ZW4gcGxhdGZvcm1cbiAgICAgICAgICogZm9yIG9mZmxpbmUgY29tcGlsYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIFNpbXBsZSBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogbXlfbW9kdWxlLnRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiBATmdNb2R1bGUoe1xuICAgICAgICAgKiAgIGltcG9ydHM6IFtCcm93c2VyTW9kdWxlXVxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBjbGFzcyBNeU1vZHVsZSB7fVxuICAgICAgICAgKlxuICAgICAgICAgKiBtYWluLnRzOlxuICAgICAgICAgKiBpbXBvcnQge015TW9kdWxlTmdGYWN0b3J5fSBmcm9tICcuL215X21vZHVsZS5uZ2ZhY3RvcnknO1xuICAgICAgICAgKiBpbXBvcnQge3BsYXRmb3JtQnJvd3Nlcn0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4gICAgICAgICAqXG4gICAgICAgICAqIGxldCBtb2R1bGVSZWYgPSBwbGF0Zm9ybUJyb3dzZXIoKS5ib290c3RyYXBNb2R1bGVGYWN0b3J5KE15TW9kdWxlTmdGYWN0b3J5KTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgQVBJcyByZWxhdGVkIHRvIGFwcGxpY2F0aW9uIGJvb3RzdHJhcCBhcmUgY3VycmVudGx5IHVuZGVyIHJldmlldy5cbiAgICAgICAgICovXG4gICAgICAgIFBsYXRmb3JtUmVmLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGVGYWN0b3J5ID0gZnVuY3Rpb24gKG1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRocm93IHVuaW1wbGVtZW50ZWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gYEBOZ01vZHVsZWAgZm9yIGEgZ2l2ZW4gcGxhdGZvcm0gdXNpbmcgdGhlIGdpdmVuIHJ1bnRpbWUgY29tcGlsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIFNpbXBsZSBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogQE5nTW9kdWxlKHtcbiAgICAgICAgICogICBpbXBvcnRzOiBbQnJvd3Nlck1vZHVsZV1cbiAgICAgICAgICogfSlcbiAgICAgICAgICogY2xhc3MgTXlNb2R1bGUge31cbiAgICAgICAgICpcbiAgICAgICAgICogbGV0IG1vZHVsZVJlZiA9IHBsYXRmb3JtQnJvd3NlcigpLmJvb3RzdHJhcE1vZHVsZShNeU1vZHVsZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAc3RhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBQbGF0Zm9ybVJlZi5wcm90b3R5cGUuYm9vdHN0cmFwTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGNvbXBpbGVyT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVyT3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgICB0aHJvdyB1bmltcGxlbWVudGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZi5wcm90b3R5cGUsIFwiaW5qZWN0b3JcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgcGxhdGZvcm0ge0BsaW5rIEluamVjdG9yfSwgd2hpY2ggaXMgdGhlIHBhcmVudCBpbmplY3RvciBmb3JcbiAgICAgICAgICAgICAqIGV2ZXJ5IEFuZ3VsYXIgYXBwbGljYXRpb24gb24gdGhlIHBhZ2UgYW5kIHByb3ZpZGVzIHNpbmdsZXRvbiBwcm92aWRlcnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQbGF0Zm9ybVJlZi5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGxhdGZvcm1SZWY7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY2FsbEFuZFJlcG9ydFRvRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlciwgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldGhyb3cgYXMgdGhlIGV4Y2VwdGlvbiBoYW5kbGVyIG1pZ2h0IG5vdCBkbyBpdFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JIYW5kbGVyLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgLy8gcmV0aHJvdyBhcyB0aGUgZXhjZXB0aW9uIGhhbmRsZXIgbWlnaHQgbm90IGRvIGl0XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBQbGF0Zm9ybVJlZl8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhQbGF0Zm9ybVJlZl8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFBsYXRmb3JtUmVmXyhfaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgICB0aGlzLl9tb2R1bGVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLnB1c2goY2FsbGJhY2spOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGxhdGZvcm1SZWZfLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2luamVjdG9yOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBsYXRmb3JtUmVmXy5wcm90b3R5cGUsIFwiZGVzdHJveWVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVzdHJveWVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBsYXRmb3JtIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbW9kdWxlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkgeyByZXR1cm4gbW9kdWxlLmRlc3Ryb3koKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcigpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIFBsYXRmb3JtUmVmXy5wcm90b3R5cGUuYm9vdHN0cmFwTW9kdWxlRmFjdG9yeSA9IGZ1bmN0aW9uIChtb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9vdHN0cmFwTW9kdWxlRmFjdG9yeVdpdGhab25lKG1vZHVsZUZhY3RvcnksIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9ib290c3RyYXBNb2R1bGVGYWN0b3J5V2l0aFpvbmUgPSBmdW5jdGlvbiAobW9kdWxlRmFjdG9yeSwgbmdab25lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBjcmVhdGUgdGhlIE5nWm9uZSBfYmVmb3JlXyB3ZSBpbnN0YW50aWF0ZSB0aGUgbW9kdWxlLFxuICAgICAgICAgICAgLy8gYXMgaW5zdGFudGlhdGluZyB0aGUgbW9kdWxlIGNyZWF0ZXMgc29tZSBwcm92aWRlcnMgZWFnZXJseS5cbiAgICAgICAgICAgIC8vIFNvIHdlIGNyZWF0ZSBhIG1pbmkgcGFyZW50IGluamVjdG9yIHRoYXQganVzdCBjb250YWlucyB0aGUgbmV3IE5nWm9uZSBhbmRcbiAgICAgICAgICAgIC8vIHBhc3MgdGhhdCBhcyBwYXJlbnQgdG8gdGhlIE5nTW9kdWxlRmFjdG9yeS5cbiAgICAgICAgICAgIGlmICghbmdab25lKVxuICAgICAgICAgICAgICAgIG5nWm9uZSA9IG5ldyBOZ1pvbmUoeyBlbmFibGVMb25nU3RhY2tUcmFjZTogaXNEZXZNb2RlKCkgfSk7XG4gICAgICAgICAgICAvLyBBdHRlbnRpb246IERvbid0IHVzZSBBcHBsaWNhdGlvblJlZi5ydW4gaGVyZSxcbiAgICAgICAgICAgIC8vIGFzIHdlIHdhbnQgdG8gYmUgc3VyZSB0aGF0IGFsbCBwb3NzaWJsZSBjb25zdHJ1Y3RvciBjYWxscyBhcmUgaW5zaWRlIGBuZ1pvbmUucnVuYCFcbiAgICAgICAgICAgIHJldHVybiBuZ1pvbmUucnVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmdab25lSW5qZWN0b3IgPSBSZWZsZWN0aXZlSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbeyBwcm92aWRlOiBOZ1pvbmUsIHVzZVZhbHVlOiBuZ1pvbmUgfV0sIF90aGlzLmluamVjdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlUmVmID0gbW9kdWxlRmFjdG9yeS5jcmVhdGUobmdab25lSW5qZWN0b3IpO1xuICAgICAgICAgICAgICAgIHZhciBleGNlcHRpb25IYW5kbGVyID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChFcnJvckhhbmRsZXIsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICghZXhjZXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEVycm9ySGFuZGxlci4gSXMgcGxhdGZvcm0gbW9kdWxlIChCcm93c2VyTW9kdWxlKSBpbmNsdWRlZD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kdWxlUmVmLm9uRGVzdHJveShmdW5jdGlvbiAoKSB7IHJldHVybiBMaXN0V3JhcHBlci5yZW1vdmUoX3RoaXMuX21vZHVsZXMsIG1vZHVsZVJlZik7IH0pO1xuICAgICAgICAgICAgICAgIG5nWm9uZS5vbkVycm9yLnN1YnNjcmliZSh7IG5leHQ6IGZ1bmN0aW9uIChlcnJvcikgeyBleGNlcHRpb25IYW5kbGVyLmhhbmRsZUVycm9yKGVycm9yKTsgfSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGxBbmRSZXBvcnRUb0Vycm9ySGFuZGxlcihleGNlcHRpb25IYW5kbGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0U3RhdHVzID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBcHBsaWNhdGlvbkluaXRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5pdFN0YXR1cy5kb25lUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tb2R1bGVEb0Jvb3RzdHJhcChtb2R1bGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVJlZjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5ib290c3RyYXBNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSwgY29tcGlsZXJPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoY29tcGlsZXJPcHRpb25zID09PSB2b2lkIDApIHsgY29tcGlsZXJPcHRpb25zID0gW107IH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib290c3RyYXBNb2R1bGVXaXRoWm9uZShtb2R1bGVUeXBlLCBjb21waWxlck9wdGlvbnMsIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8ucHJvdG90eXBlLl9ib290c3RyYXBNb2R1bGVXaXRoWm9uZSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBjb21waWxlck9wdGlvbnMsIG5nWm9uZSwgY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGNvbXBpbGVyT3B0aW9ucyA9IFtdOyB9XG4gICAgICAgICAgICB2YXIgY29tcGlsZXJGYWN0b3J5ID0gdGhpcy5pbmplY3Rvci5nZXQoQ29tcGlsZXJGYWN0b3J5KTtcbiAgICAgICAgICAgIHZhciBjb21waWxlciA9IGNvbXBpbGVyRmFjdG9yeS5jcmVhdGVDb21waWxlcihBcnJheS5pc0FycmF5KGNvbXBpbGVyT3B0aW9ucykgPyBjb21waWxlck9wdGlvbnMgOiBbY29tcGlsZXJPcHRpb25zXSk7XG4gICAgICAgICAgICAvLyB1Z2x5IGludGVybmFsIGFwaSBoYWNrOiBnZW5lcmF0ZSBob3N0IGNvbXBvbmVudCBmYWN0b3JpZXMgZm9yIGFsbCBkZWNsYXJlZCBjb21wb25lbnRzIGFuZFxuICAgICAgICAgICAgLy8gcGFzcyB0aGUgZmFjdG9yaWVzIGludG8gdGhlIGNhbGxiYWNrIC0gdGhpcyBpcyB1c2VkIGJ5IFVwZGF0ZUFkYXB0ZXIgdG8gZ2V0IGhvbGQgb2YgYWxsXG4gICAgICAgICAgICAvLyBmYWN0b3JpZXMuXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMobW9kdWxlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZ01vZHVsZUZhY3RvcnkgPSBfYS5uZ01vZHVsZUZhY3RvcnksIGNvbXBvbmVudEZhY3RvcmllcyA9IF9hLmNvbXBvbmVudEZhY3RvcmllcztcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeUNhbGxiYWNrKGNvbXBvbmVudEZhY3Rvcmllcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYm9vdHN0cmFwTW9kdWxlRmFjdG9yeVdpdGhab25lKG5nTW9kdWxlRmFjdG9yeSwgbmdab25lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21waWxlci5jb21waWxlTW9kdWxlQXN5bmMobW9kdWxlVHlwZSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobW9kdWxlRmFjdG9yeSkgeyByZXR1cm4gX3RoaXMuX2Jvb3RzdHJhcE1vZHVsZUZhY3RvcnlXaXRoWm9uZShtb2R1bGVGYWN0b3J5LCBuZ1pvbmUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUGxhdGZvcm1SZWZfLnByb3RvdHlwZS5fbW9kdWxlRG9Cb290c3RyYXAgPSBmdW5jdGlvbiAobW9kdWxlUmVmKSB7XG4gICAgICAgICAgICB2YXIgYXBwUmVmID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBcHBsaWNhdGlvblJlZik7XG4gICAgICAgICAgICBpZiAobW9kdWxlUmVmLmJvb3RzdHJhcEZhY3Rvcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlUmVmLmJvb3RzdHJhcEZhY3Rvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wRmFjdG9yeSkgeyByZXR1cm4gYXBwUmVmLmJvb3RzdHJhcChjb21wRmFjdG9yeSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kdWxlUmVmLmluc3RhbmNlLm5nRG9Cb290c3RyYXApIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVSZWYuaW5zdGFuY2UubmdEb0Jvb3RzdHJhcChhcHBSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlRoZSBtb2R1bGUgXCIgKyBzdHJpbmdpZnkobW9kdWxlUmVmLmluc3RhbmNlLmNvbnN0cnVjdG9yKSArIFwiIHdhcyBib290c3RyYXBwZWQsIGJ1dCBpdCBkb2VzIG5vdCBkZWNsYXJlIFxcXCJATmdNb2R1bGUuYm9vdHN0cmFwXFxcIiBjb21wb25lbnRzIG5vciBhIFxcXCJuZ0RvQm9vdHN0cmFwXFxcIiBtZXRob2QuIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiUGxlYXNlIGRlZmluZSBvbmUgb2YgdGhlc2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBQbGF0Zm9ybVJlZl8uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUGxhdGZvcm1SZWZfLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFBsYXRmb3JtUmVmXztcbiAgICB9KFBsYXRmb3JtUmVmKSk7XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gYW4gQW5ndWxhciBhcHBsaWNhdGlvbiBydW5uaW5nIG9uIGEgcGFnZS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGFib3V0IEFuZ3VsYXIgYXBwbGljYXRpb25zLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHtAbGluayBib290c3RyYXB9LlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBcHBsaWNhdGlvblJlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcGxpY2F0aW9uUmVmKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50VHlwZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYSBsaXN0IG9mIGNvbXBvbmVudCB0eXBlcyByZWdpc3RlcmVkIHRvIHRoaXMgYXBwbGljYXRpb24uXG4gICAgICAgICAgICAgKiBUaGlzIGxpc3QgaXMgcG9wdWxhdGVkIGV2ZW4gYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50c1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIGxpc3Qgb2YgY29tcG9uZW50cyByZWdpc3RlcmVkIHRvIHRoaXMgYXBwbGljYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25SZWY7XG4gICAgfSgpKTtcbiAgICB2YXIgQXBwbGljYXRpb25SZWZfID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoQXBwbGljYXRpb25SZWZfLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBcHBsaWNhdGlvblJlZl8oX3pvbmUsIF9jb25zb2xlLCBfaW5qZWN0b3IsIF9leGNlcHRpb25IYW5kbGVyLCBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBfaW5pdFN0YXR1cywgX3Rlc3RhYmlsaXR5UmVnaXN0cnksIF90ZXN0YWJpbGl0eSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICAgICAgdGhpcy5fY29uc29sZSA9IF9jb25zb2xlO1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgICAgICB0aGlzLl9leGNlcHRpb25IYW5kbGVyID0gX2V4Y2VwdGlvbkhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgICAgICAgICAgdGhpcy5faW5pdFN0YXR1cyA9IF9pbml0U3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5fdGVzdGFiaWxpdHlSZWdpc3RyeSA9IF90ZXN0YWJpbGl0eVJlZ2lzdHJ5O1xuICAgICAgICAgICAgdGhpcy5fdGVzdGFiaWxpdHkgPSBfdGVzdGFiaWxpdHk7XG4gICAgICAgICAgICB0aGlzLl9ib290c3RyYXBMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50VHlwZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZ1RpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2VuZm9yY2VOb05ld0NoYW5nZXMgPSBpc0Rldk1vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUub25NaWNyb3Rhc2tFbXB0eS5zdWJzY3JpYmUoeyBuZXh0OiBmdW5jdGlvbiAoKSB7IF90aGlzLl96b25lLnJ1bihmdW5jdGlvbiAoKSB7IF90aGlzLnRpY2soKTsgfSk7IH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5yZWdpc3RlckNoYW5nZURldGVjdG9yID0gZnVuY3Rpb24gKGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZnMucHVzaChjaGFuZ2VEZXRlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUudW5yZWdpc3RlckNoYW5nZURldGVjdG9yID0gZnVuY3Rpb24gKGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUodGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWZzLCBjaGFuZ2VEZXRlY3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUuYm9vdHN0cmFwID0gZnVuY3Rpb24gKGNvbXBvbmVudE9yRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdFN0YXR1cy5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYm9vdHN0cmFwIGFzIHRoZXJlIGFyZSBzdGlsbCBhc3luY2hyb25vdXMgaW5pdGlhbGl6ZXJzIHJ1bm5pbmcuIEJvb3RzdHJhcCBjb21wb25lbnRzIGluIHRoZSBgbmdEb0Jvb3RzdHJhcGAgbWV0aG9kIG9mIHRoZSByb290IG1vZHVsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wb25lbnRGYWN0b3J5O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudE9yRmFjdG9yeSBpbnN0YW5jZW9mIENvbXBvbmVudEZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5ID0gY29tcG9uZW50T3JGYWN0b3J5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnRPckZhY3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzLnB1c2goY29tcG9uZW50RmFjdG9yeS5jb21wb25lbnRUeXBlKTtcbiAgICAgICAgICAgIHZhciBjb21wUmVmID0gY29tcG9uZW50RmFjdG9yeS5jcmVhdGUodGhpcy5faW5qZWN0b3IsIFtdLCBjb21wb25lbnRGYWN0b3J5LnNlbGVjdG9yKTtcbiAgICAgICAgICAgIGNvbXBSZWYub25EZXN0cm95KGZ1bmN0aW9uICgpIHsgX3RoaXMuX3VubG9hZENvbXBvbmVudChjb21wUmVmKTsgfSk7XG4gICAgICAgICAgICB2YXIgdGVzdGFiaWxpdHkgPSBjb21wUmVmLmluamVjdG9yLmdldChUZXN0YWJpbGl0eSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAodGVzdGFiaWxpdHkpIHtcbiAgICAgICAgICAgICAgICBjb21wUmVmLmluamVjdG9yLmdldChUZXN0YWJpbGl0eVJlZ2lzdHJ5KVxuICAgICAgICAgICAgICAgICAgICAucmVnaXN0ZXJBcHBsaWNhdGlvbihjb21wUmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQsIHRlc3RhYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xvYWRDb21wb25lbnQoY29tcFJlZik7XG4gICAgICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zb2xlLmxvZyhcIkFuZ3VsYXIgMiBpcyBydW5uaW5nIGluIHRoZSBkZXZlbG9wbWVudCBtb2RlLiBDYWxsIGVuYWJsZVByb2RNb2RlKCkgdG8gZW5hYmxlIHRoZSBwcm9kdWN0aW9uIG1vZGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBSZWY7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS5fbG9hZENvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5wdXNoKGNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgICAgICAgICB0aGlzLnRpY2soKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RDb21wb25lbnRzLnB1c2goY29tcG9uZW50UmVmKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGlzdGVuZXJzIGxhemlseSB0byBwcmV2ZW50IERJIGN5Y2xlcy5cbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9pbmplY3Rvci5nZXQoQVBQX0JPT1RTVFJBUF9MSVNURU5FUiwgW10pXG4gICAgICAgICAgICAgICAgLmNvbmNhdCh0aGlzLl9ib290c3RyYXBMaXN0ZW5lcnMpO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihjb21wb25lbnRSZWYpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLl91bmxvYWRDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm9vdENvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnRSZWYpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyQ2hhbmdlRGV0ZWN0b3IoY29tcG9uZW50UmVmLmNoYW5nZURldGVjdG9yUmVmKTtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLl9yb290Q29tcG9uZW50cywgY29tcG9uZW50UmVmKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwbGljYXRpb25SZWZfLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmdUaWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcHBsaWNhdGlvblJlZi50aWNrIGlzIGNhbGxlZCByZWN1cnNpdmVseScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjb3BlID0gQXBwbGljYXRpb25SZWZfLl90aWNrU2NvcGUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZ1RpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXRlY3RvcikgeyByZXR1cm4gZGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW5mb3JjZU5vTmV3Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZGV0ZWN0b3IpIHsgcmV0dXJuIGRldGVjdG9yLmNoZWNrTm9DaGFuZ2VzKCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdUaWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd3RmTGVhdmUoc2NvcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBEaXNwb3NlIG9mIHRoZSBOZ1pvbmUuXG4gICAgICAgICAgICB0aGlzLl9yb290Q29tcG9uZW50cy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkgeyByZXR1cm4gY29tcG9uZW50LmRlc3Ryb3koKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBsaWNhdGlvblJlZl8ucHJvdG90eXBlLCBcImNvbXBvbmVudFR5cGVzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdENvbXBvbmVudFR5cGVzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGxpY2F0aW9uUmVmXy5wcm90b3R5cGUsIFwiY29tcG9uZW50c1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3RDb21wb25lbnRzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBcHBsaWNhdGlvblJlZl8uX3RpY2tTY29wZSA9IHd0ZkNyZWF0ZVNjb3BlKCdBcHBsaWNhdGlvblJlZiN0aWNrKCknKTtcbiAgICAgICAgQXBwbGljYXRpb25SZWZfLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEFwcGxpY2F0aW9uUmVmXy5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdab25lLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBDb25zb2xlLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RvciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogRXJyb3JIYW5kbGVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFwcGxpY2F0aW9uSW5pdFN0YXR1cywgfSxcbiAgICAgICAgICAgIHsgdHlwZTogVGVzdGFiaWxpdHlSZWdpc3RyeSwgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFRlc3RhYmlsaXR5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEFwcGxpY2F0aW9uUmVmXztcbiAgICB9KEFwcGxpY2F0aW9uUmVmKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ5ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBpbnN0YW5jZSBvZiBhbiBOZ01vZHVsZSBjcmVhdGVkIHZpYSBhIHtAbGluayBOZ01vZHVsZUZhY3Rvcnl9LlxuICAgICAqXG4gICAgICogYE5nTW9kdWxlUmVmYCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIE5nTW9kdWxlIEluc3RhbmNlIGFzIHdlbGwgb3RoZXIgb2JqZWN0cyByZWxhdGVkIHRvIHRoaXNcbiAgICAgKiBOZ01vZHVsZSBJbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2R1bGVSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ01vZHVsZVJlZigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVSZWYucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluamVjdG9yIHRoYXQgY29udGFpbnMgYWxsIG9mIHRoZSBwcm92aWRlcnMgb2YgdGhlIE5nTW9kdWxlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZVJlZi5wcm90b3R5cGUsIFwiY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB0byBnZXQgaG9sZCBvZiB0aGUgQ29tcG9uZW50RmFjdG9yaWVzXG4gICAgICAgICAgICAgKiBkZWNsYXJlZCBpbiB0aGUgYGVudHJ5Q29tcG9uZW50c2AgcHJvcGVydHkgb2YgdGhlIG1vZHVsZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVSZWYucHJvdG90eXBlLCBcImluc3RhbmNlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIE5nTW9kdWxlIGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBOZ01vZHVsZVJlZjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgTmdNb2R1bGVGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdNb2R1bGVGYWN0b3J5KF9pbmplY3RvckNsYXNzLCBfbW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5faW5qZWN0b3JDbGFzcyA9IF9pbmplY3RvckNsYXNzO1xuICAgICAgICAgICAgdGhpcy5fbW9kdWxlVHlwZSA9IF9tb2R1bGVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZUZhY3RvcnkucHJvdG90eXBlLCBcIm1vZHVsZVR5cGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tb2R1bGVUeXBlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdNb2R1bGVGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAocGFyZW50SW5qZWN0b3IpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50SW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmplY3RvciA9IEluamVjdG9yLk5VTEw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgdGhpcy5faW5qZWN0b3JDbGFzcyhwYXJlbnRJbmplY3Rvcik7XG4gICAgICAgICAgICBpbnN0YW5jZS5jcmVhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kdWxlRmFjdG9yeTtcbiAgICB9KCkpO1xuICAgIHZhciBfVU5ERUZJTkVEID0gbmV3IE9iamVjdCgpO1xuICAgIHZhciBOZ01vZHVsZUluamVjdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoTmdNb2R1bGVJbmplY3RvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdNb2R1bGVJbmplY3RvcihwYXJlbnQsIGZhY3RvcmllcywgYm9vdHN0cmFwRmFjdG9yaWVzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBmYWN0b3JpZXMsIHBhcmVudC5nZXQoQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIuTlVMTCkpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJvb3RzdHJhcEZhY3RvcmllcyA9IGJvb3RzdHJhcEZhY3RvcmllcztcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbnN0YW5jZSA9IHRoaXMuY3JlYXRlSW50ZXJuYWwoKTsgfTtcbiAgICAgICAgTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRva2VuLCBub3RGb3VuZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobm90Rm91bmRWYWx1ZSA9PT0gdm9pZCAwKSB7IG5vdEZvdW5kVmFsdWUgPSBUSFJPV19JRl9OT1RfRk9VTkQ7IH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gSW5qZWN0b3IgfHwgdG9rZW4gPT09IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0SW50ZXJuYWwodG9rZW4sIF9VTkRFRklORUQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gX1VOREVGSU5FRCA/IHRoaXMucGFyZW50LmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSkgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZHVsZUluamVjdG9yLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2R1bGVJbmplY3Rvci5wcm90b3R5cGUsIFwiY29tcG9uZW50RmFjdG9yeVJlc29sdmVyXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5nIG1vZHVsZSBcIiArIHN0cmluZ2lmeSh0aGlzLmluc3RhbmNlLmNvbnN0cnVjdG9yKSArIFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kdWxlSW5qZWN0b3IucHJvdG90eXBlLm9uRGVzdHJveSA9IGZ1bmN0aW9uIChjYWxsYmFjaykgeyB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLnB1c2goY2FsbGJhY2spOyB9O1xuICAgICAgICByZXR1cm4gTmdNb2R1bGVJbmplY3RvcjtcbiAgICB9KENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGxvYWQgbmcgbW9kdWxlIGZhY3Rvcmllcy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nTW9kdWxlRmFjdG9yeUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kdWxlRmFjdG9yeUxvYWRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTmdNb2R1bGVGYWN0b3J5TG9hZGVyO1xuICAgIH0oKSk7XG4gICAgdmFyIG1vZHVsZUZhY3RvcmllcyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBsb2FkZWQgbW9kdWxlLiBTaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSBnZW5lcmF0ZWQgTmdNb2R1bGVGYWN0b3J5IGNvZGUuXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlRmFjdG9yeShpZCwgZmFjdG9yeSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBtb2R1bGVGYWN0b3JpZXMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgbW9kdWxlIHJlZ2lzdGVyZWQgZm9yIFwiICsgaWQgKyBcIiAtIFwiICsgZXhpc3RpbmcubW9kdWxlVHlwZS5uYW1lICsgXCIgdnMgXCIgKyBmYWN0b3J5Lm1vZHVsZVR5cGUubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kdWxlRmFjdG9yaWVzLnNldChpZCwgZmFjdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5nTW9kdWxlRmFjdG9yeSB3aXRoIHRoZSBnaXZlbiBpZCwgaWYgaXQgZXhpc3RzIGFuZCBoYXMgYmVlbiBsb2FkZWQuXG4gICAgICogRmFjdG9yaWVzIGZvciBtb2R1bGVzIHRoYXQgZG8gbm90IHNwZWNpZnkgYW4gYGlkYCBjYW5ub3QgYmUgcmV0cmlldmVkLiBUaHJvd3MgaWYgdGhlIG1vZHVsZVxuICAgICAqIGNhbm5vdCBiZSBmb3VuZC5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TW9kdWxlRmFjdG9yeShpZCkge1xuICAgICAgICB2YXIgZmFjdG9yeSA9IG1vZHVsZUZhY3Rvcmllcy5nZXQoaWQpO1xuICAgICAgICBpZiAoIWZhY3RvcnkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb2R1bGUgd2l0aCBJRCBcIiArIGlkICsgXCIgbG9hZGVkXCIpO1xuICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiB1bm1vZGlmaWFibGUgbGlzdCBvZiBpdGVtcyB0aGF0IEFuZ3VsYXIga2VlcHMgdXAgdG8gZGF0ZSB3aGVuIHRoZSBzdGF0ZVxuICAgICAqIG9mIHRoZSBhcHBsaWNhdGlvbiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVGhlIHR5cGUgb2Ygb2JqZWN0IHRoYXQge0BsaW5rIFF1ZXJ5fSBhbmQge0BsaW5rIFZpZXdRdWVyeU1ldGFkYXRhfSBwcm92aWRlLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50cyBhbiBpdGVyYWJsZSBpbnRlcmZhY2UsIHRoZXJlZm9yZSBpdCBjYW4gYmUgdXNlZCBpbiBib3RoIEVTNlxuICAgICAqIGphdmFzY3JpcHQgYGZvciAodmFyIGkgb2YgaXRlbXMpYCBsb29wcyBhcyB3ZWxsIGFzIGluIEFuZ3VsYXIgdGVtcGxhdGVzIHdpdGhcbiAgICAgKiBgKm5nRm9yPVwibGV0IGkgb2YgbXlMaXN0XCJgLlxuICAgICAqXG4gICAgICogQ2hhbmdlcyBjYW4gYmUgb2JzZXJ2ZWQgYnkgc3Vic2NyaWJpbmcgdG8gdGhlIGNoYW5nZXMgYE9ic2VydmFibGVgLlxuICAgICAqXG4gICAgICogTk9URTogSW4gdGhlIGZ1dHVyZSB0aGlzIGNsYXNzIHdpbGwgaW1wbGVtZW50IGFuIGBPYnNlcnZhYmxlYCBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvUlg4c0puUVlsOUZXdVNDV21lNXo/cD1wcmV2aWV3KSlcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7Li4ufSlcbiAgICAgKiBjbGFzcyBDb250YWluZXIge1xuICAgICAqICAgQFZpZXdDaGlsZHJlbihJdGVtKSBpdGVtczpRdWVyeUxpc3Q8SXRlbT47XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUXVlcnlMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUXVlcnlMaXN0KCkge1xuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnlMaXN0LnByb3RvdHlwZSwgXCJjaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZW1pdHRlcjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHMubGVuZ3RoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXN1bHRzWzBdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5TGlzdC5wcm90b3R5cGUsIFwibGFzdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHNbdGhpcy5sZW5ndGggLSAxXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWVcbiAgICAgICAgICogW0FycmF5Lm1hcF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwKVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdHMubWFwKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkuZmlsdGVyXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXIpXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdHMuZmlsdGVyKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkucmVkdWNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2UpXG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChmbiwgaW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdHMucmVkdWNlKGZuLCBpbml0KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlZVxuICAgICAgICAgKiBbQXJyYXkuZm9yRWFjaF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZm9yRWFjaClcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9yZXN1bHRzLmZvckVhY2goZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlXG4gICAgICAgICAqIFtBcnJheS5zb21lXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb21lKVxuICAgICAgICAgKi9cbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0cy5zb21lKGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgUXVlcnlMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy5zbGljZSgpOyB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlW2dldFN5bWJvbEl0ZXJhdG9yKCldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0c1tnZXRTeW1ib2xJdGVyYXRvcigpXSgpOyB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0cy50b1N0cmluZygpOyB9O1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0cyA9IExpc3RXcmFwcGVyLmZsYXR0ZW4ocmVzKTtcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFF1ZXJ5TGlzdC5wcm90b3R5cGUubm90aWZ5T25DaGFuZ2VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9lbWl0dGVyLmVtaXQodGhpcyk7IH07XG4gICAgICAgIC8qKiBpbnRlcm5hbCAqL1xuICAgICAgICBRdWVyeUxpc3QucHJvdG90eXBlLnNldERpcnR5ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kaXJ0eSA9IHRydWU7IH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUxpc3QucHJvdG90eXBlLCBcImRpcnR5XCIsIHtcbiAgICAgICAgICAgIC8qKiBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kaXJ0eTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBRdWVyeUxpc3Q7XG4gICAgfSgpKTtcblxuICAgIHZhciBfU0VQQVJBVE9SID0gJyMnO1xuICAgIHZhciBGQUNUT1JZX0NMQVNTX1NVRkZJWCA9ICdOZ0ZhY3RvcnknO1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIuXG4gICAgICogdG9rZW4uXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyQ29uZmlnO1xuICAgIH0oKSk7XG4gICAgdmFyIERFRkFVTFRfQ09ORklHID0ge1xuICAgICAgICBmYWN0b3J5UGF0aFByZWZpeDogJycsXG4gICAgICAgIGZhY3RvcnlQYXRoU3VmZml4OiAnLm5nZmFjdG9yeScsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBOZ01vZHVsZUZhY3RvcnlMb2FkZXIgdGhhdCB1c2VzIFN5c3RlbUpTIHRvIGxvYWQgTmdNb2R1bGVGYWN0b3J5XG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3lzdGVtSnNOZ01vZHVsZUxvYWRlcihfY29tcGlsZXIsIGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZXIgPSBfY29tcGlsZXI7XG4gICAgICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWcgfHwgREVGQVVMVF9DT05GSUc7XG4gICAgICAgIH1cbiAgICAgICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB2YXIgb2ZmbGluZU1vZGUgPSB0aGlzLl9jb21waWxlciBpbnN0YW5jZW9mIENvbXBpbGVyO1xuICAgICAgICAgICAgcmV0dXJuIG9mZmxpbmVNb2RlID8gdGhpcy5sb2FkRmFjdG9yeShwYXRoKSA6IHRoaXMubG9hZEFuZENvbXBpbGUocGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIFN5c3RlbUpzTmdNb2R1bGVMb2FkZXIucHJvdG90eXBlLmxvYWRBbmRDb21waWxlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EgPSBwYXRoLnNwbGl0KF9TRVBBUkFUT1IpLCBtb2R1bGUgPSBfYVswXSwgZXhwb3J0TmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5pbXBvcnQobW9kdWxlKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtb2R1bGUpIHsgcmV0dXJuIG1vZHVsZVtleHBvcnROYW1lXTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gY2hlY2tOb3RFbXB0eSh0eXBlLCBtb2R1bGUsIGV4cG9ydE5hbWUpOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBfdGhpcy5fY29tcGlsZXIuY29tcGlsZU1vZHVsZUFzeW5jKHR5cGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5wcm90b3R5cGUubG9hZEZhY3RvcnkgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgdmFyIF9hID0gcGF0aC5zcGxpdChfU0VQQVJBVE9SKSwgbW9kdWxlID0gX2FbMF0sIGV4cG9ydE5hbWUgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBmYWN0b3J5Q2xhc3NTdWZmaXggPSBGQUNUT1JZX0NMQVNTX1NVRkZJWDtcbiAgICAgICAgICAgIGlmIChleHBvcnROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgICAgIGZhY3RvcnlDbGFzc1N1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN5c3RlbS5pbXBvcnQodGhpcy5fY29uZmlnLmZhY3RvcnlQYXRoUHJlZml4ICsgbW9kdWxlICsgdGhpcy5fY29uZmlnLmZhY3RvcnlQYXRoU3VmZml4KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtb2R1bGUpIHsgcmV0dXJuIG1vZHVsZVtleHBvcnROYW1lICsgZmFjdG9yeUNsYXNzU3VmZml4XTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZmFjdG9yeSkgeyByZXR1cm4gY2hlY2tOb3RFbXB0eShmYWN0b3J5LCBtb2R1bGUsIGV4cG9ydE5hbWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU3lzdGVtSnNOZ01vZHVsZUxvYWRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBJbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb21waWxlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZywgZGVjb3JhdG9yczogW3sgdHlwZTogT3B0aW9uYWwgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gY2hlY2tOb3RFbXB0eSh2YWx1ZSwgbW9kdWxlUGF0aCwgZXhwb3J0TmFtZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCAnXCIgKyBleHBvcnROYW1lICsgXCInIGluICdcIiArIG1vZHVsZVBhdGggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEwID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBFbWJlZGRlZCBUZW1wbGF0ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGluc3RhbnRpYXRlIEVtYmVkZGVkIFZpZXdzLlxuICAgICAqXG4gICAgICogWW91IGNhbiBhY2Nlc3MgYSBgVGVtcGxhdGVSZWZgLCBpbiB0d28gd2F5cy4gVmlhIGEgZGlyZWN0aXZlIHBsYWNlZCBvbiBhIGA8dGVtcGxhdGU+YCBlbGVtZW50IChvclxuICAgICAqIGRpcmVjdGl2ZSBwcmVmaXhlZCB3aXRoIGAqYCkgYW5kIGhhdmUgdGhlIGBUZW1wbGF0ZVJlZmAgZm9yIHRoaXMgRW1iZWRkZWQgVmlldyBpbmplY3RlZCBpbnRvIHRoZVxuICAgICAqIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXJlY3RpdmUgdXNpbmcgdGhlIGBUZW1wbGF0ZVJlZmAgVG9rZW4uIEFsdGVybmF0aXZlbHkgeW91IGNhbiBxdWVyeSBmb3IgdGhlXG4gICAgICogYFRlbXBsYXRlUmVmYCBmcm9tIGEgQ29tcG9uZW50IG9yIGEgRGlyZWN0aXZlIHZpYSB7QGxpbmsgUXVlcnl9LlxuICAgICAqXG4gICAgICogVG8gaW5zdGFudGlhdGUgRW1iZWRkZWQgVmlld3MgYmFzZWQgb24gYSBUZW1wbGF0ZSwgdXNlXG4gICAgICoge0BsaW5rIFZpZXdDb250YWluZXJSZWYjY3JlYXRlRW1iZWRkZWRWaWV3fSwgd2hpY2ggd2lsbCBjcmVhdGUgdGhlIFZpZXcgYW5kIGF0dGFjaCBpdCB0byB0aGVcbiAgICAgKiBWaWV3IENvbnRhaW5lci5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFRlbXBsYXRlUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbXBsYXRlUmVmLnByb3RvdHlwZSwgXCJlbGVtZW50UmVmXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGxvY2F0aW9uIGluIHRoZSBWaWV3IHdoZXJlIHRoZSBFbWJlZGRlZCBWaWV3IGxvZ2ljYWxseSBiZWxvbmdzIHRvLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZSBkYXRhLWJpbmRpbmcgYW5kIGluamVjdGlvbiBjb250ZXh0cyBvZiBFbWJlZGRlZCBWaWV3cyBjcmVhdGVkIGZyb20gdGhpcyBgVGVtcGxhdGVSZWZgXG4gICAgICAgICAgICAgKiBpbmhlcml0IGZyb20gdGhlIGNvbnRleHRzIG9mIHRoaXMgbG9jYXRpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVHlwaWNhbGx5IG5ldyBFbWJlZGRlZCBWaWV3cyBhcmUgYXR0YWNoZWQgdG8gdGhlIFZpZXcgQ29udGFpbmVyIG9mIHRoaXMgbG9jYXRpb24sIGJ1dCBpblxuICAgICAgICAgICAgICogYWR2YW5jZWQgdXNlLWNhc2VzLCB0aGUgVmlldyBjYW4gYmUgYXR0YWNoZWQgdG8gYSBkaWZmZXJlbnQgY29udGFpbmVyIHdoaWxlIGtlZXBpbmcgdGhlXG4gICAgICAgICAgICAgKiBkYXRhLWJpbmRpbmcgYW5kIGluamVjdGlvbiBjb250ZXh0IGZyb20gdGhlIG9yaWdpbmFsIGxvY2F0aW9uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVE9ETyhpKTogcmVuYW1lIHRvIGFuY2hvciBvciBsb2NhdGlvblxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRlbXBsYXRlUmVmO1xuICAgIH0oKSk7XG4gICAgdmFyIFRlbXBsYXRlUmVmXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMChUZW1wbGF0ZVJlZl8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFRlbXBsYXRlUmVmXyhfYXBwRWxlbWVudCwgX3ZpZXdGYWN0b3J5KSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcEVsZW1lbnQgPSBfYXBwRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdGYWN0b3J5ID0gX3ZpZXdGYWN0b3J5O1xuICAgICAgICB9XG4gICAgICAgIFRlbXBsYXRlUmVmXy5wcm90b3R5cGUuY3JlYXRlRW1iZWRkZWRWaWV3ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5fdmlld0ZhY3RvcnkodGhpcy5fYXBwRWxlbWVudC5wYXJlbnRWaWV3LnZpZXdVdGlscywgdGhpcy5fYXBwRWxlbWVudC5wYXJlbnRJbmplY3RvciwgdGhpcy5fYXBwRWxlbWVudCk7XG4gICAgICAgICAgICB2aWV3LmNyZWF0ZShjb250ZXh0IHx8IHt9LCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LnJlZjtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbXBsYXRlUmVmXy5wcm90b3R5cGUsIFwiZWxlbWVudFJlZlwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2FwcEVsZW1lbnQuZWxlbWVudFJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZVJlZl87XG4gICAgfShUZW1wbGF0ZVJlZikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfcXVldWVkQW5pbWF0aW9ucyA9IFtdO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBxdWV1ZUFuaW1hdGlvbihwbGF5ZXIpIHtcbiAgICAgICAgX3F1ZXVlZEFuaW1hdGlvbnMucHVzaChwbGF5ZXIpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gdHJpZ2dlclF1ZXVlZEFuaW1hdGlvbnMoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3F1ZXVlZEFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwbGF5ZXIgPSBfcXVldWVkQW5pbWF0aW9uc1tpXTtcbiAgICAgICAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgX3F1ZXVlZEFuaW1hdGlvbnMgPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgVmlld1JlZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFZpZXdSZWYoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWYucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBWaWV3UmVmO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBBbmd1bGFyIFZpZXcuXG4gICAgICpcbiAgICAgKiA8IS0tIFRPRE86IG1vdmUgdGhlIG5leHQgdHdvIHBhcmFncmFwaHMgdG8gdGhlIGRldiBndWlkZSAtLT5cbiAgICAgKiBBIFZpZXcgaXMgYSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9jayBvZiB0aGUgYXBwbGljYXRpb24gVUkuIEl0IGlzIHRoZSBzbWFsbGVzdCBncm91cGluZyBvZlxuICAgICAqIEVsZW1lbnRzIHdoaWNoIGFyZSBjcmVhdGVkIGFuZCBkZXN0cm95ZWQgdG9nZXRoZXIuXG4gICAgICpcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGVsZW1lbnRzIGluIGEgVmlldyBjYW4gY2hhbmdlLCBidXQgdGhlIHN0cnVjdHVyZSAobnVtYmVyIGFuZCBvcmRlcikgb2YgZWxlbWVudHMgaW5cbiAgICAgKiBhIFZpZXcgY2Fubm90LiBDaGFuZ2luZyB0aGUgc3RydWN0dXJlIG9mIEVsZW1lbnRzIGNhbiBvbmx5IGJlIGRvbmUgYnkgaW5zZXJ0aW5nLCBtb3Zpbmcgb3JcbiAgICAgKiByZW1vdmluZyBuZXN0ZWQgVmlld3MgdmlhIGEge0BsaW5rIFZpZXdDb250YWluZXJSZWZ9LiBFYWNoIFZpZXcgY2FuIGNvbnRhaW4gbWFueSBWaWV3IENvbnRhaW5lcnMuXG4gICAgICogPCEtLSAvVE9ETyAtLT5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBHaXZlbiB0aGlzIHRlbXBsYXRlLi4uXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBDb3VudDoge3tpdGVtcy5sZW5ndGh9fVxuICAgICAqIDx1bD5cbiAgICAgKiAgIDxsaSAqbmdGb3I9XCJsZXQgIGl0ZW0gb2YgaXRlbXNcIj57e2l0ZW19fTwvbGk+XG4gICAgICogPC91bD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdlIGhhdmUgdHdvIHtAbGluayBUZW1wbGF0ZVJlZn1zOlxuICAgICAqXG4gICAgICogT3V0ZXIge0BsaW5rIFRlbXBsYXRlUmVmfTpcbiAgICAgKiBgYGBcbiAgICAgKiBDb3VudDoge3tpdGVtcy5sZW5ndGh9fVxuICAgICAqIDx1bD5cbiAgICAgKiAgIDx0ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XCJpdGVtc1wiPjwvdGVtcGxhdGU+XG4gICAgICogPC91bD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElubmVyIHtAbGluayBUZW1wbGF0ZVJlZn06XG4gICAgICogYGBgXG4gICAgICogICA8bGk+e3tpdGVtfX08L2xpPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTm90aWNlIHRoYXQgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGlzIGJyb2tlbiBkb3duIGludG8gdHdvIHNlcGFyYXRlIHtAbGluayBUZW1wbGF0ZVJlZn1zLlxuICAgICAqXG4gICAgICogVGhlIG91dGVyL2lubmVyIHtAbGluayBUZW1wbGF0ZVJlZn1zIGFyZSB0aGVuIGFzc2VtYmxlZCBpbnRvIHZpZXdzIGxpa2Ugc286XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8IS0tIFZpZXdSZWY6IG91dGVyLTAgLS0+XG4gICAgICogQ291bnQ6IDJcbiAgICAgKiA8dWw+XG4gICAgICogICA8dGVtcGxhdGUgdmlldy1jb250YWluZXItcmVmPjwvdGVtcGxhdGU+XG4gICAgICogICA8IS0tIFZpZXdSZWY6IGlubmVyLTEgLS0+PGxpPmZpcnN0PC9saT48IS0tIC9WaWV3UmVmOiBpbm5lci0xIC0tPlxuICAgICAqICAgPCEtLSBWaWV3UmVmOiBpbm5lci0yIC0tPjxsaT5zZWNvbmQ8L2xpPjwhLS0gL1ZpZXdSZWY6IGlubmVyLTIgLS0+XG4gICAgICogPC91bD5cbiAgICAgKiA8IS0tIC9WaWV3UmVmOiBvdXRlci0wIC0tPlxuICAgICAqIGBgYFxuICAgICAqIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgRW1iZWRkZWRWaWV3UmVmID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDExKEVtYmVkZGVkVmlld1JlZiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRW1iZWRkZWRWaWV3UmVmKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtYmVkZGVkVmlld1JlZi5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWJlZGRlZFZpZXdSZWYucHJvdG90eXBlLCBcInJvb3ROb2Rlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgcmV0dXJuIEVtYmVkZGVkVmlld1JlZjtcbiAgICB9KFZpZXdSZWYpKTtcbiAgICB2YXIgVmlld1JlZl8gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWaWV3UmVmXyhfdmlldykge1xuICAgICAgICAgICAgdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICAgICAgdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNb2RlID0gdGhpcy5fdmlldy5jZE1vZGU7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWZfLnByb3RvdHlwZSwgXCJpbnRlcm5hbFZpZXdcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3OyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdSZWZfLnByb3RvdHlwZSwgXCJyb290Tm9kZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmZsYXRSb290Tm9kZXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92aWV3LmNvbnRleHQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld1JlZl8ucHJvdG90eXBlLCBcImRlc3Ryb3llZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXcuZGVzdHJveWVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLm1hcmtGb3JDaGVjayA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5tYXJrUGF0aFRvUm9vdEFzQ2hlY2tPbmNlKCk7IH07XG4gICAgICAgIFZpZXdSZWZfLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXcuY2RNb2RlID0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGV0YWNoZWQ7IH07XG4gICAgICAgIFZpZXdSZWZfLnByb3RvdHlwZS5kZXRlY3RDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmlldy5kZXRlY3RDaGFuZ2VzKGZhbHNlKTtcbiAgICAgICAgICAgIHRyaWdnZXJRdWV1ZWRBbmltYXRpb25zKCk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdSZWZfLnByb3RvdHlwZS5jaGVja05vQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmlldy5kZXRlY3RDaGFuZ2VzKHRydWUpOyB9O1xuICAgICAgICBWaWV3UmVmXy5wcm90b3R5cGUucmVhdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3LmNkTW9kZSA9IHRoaXMuX29yaWdpbmFsTW9kZTtcbiAgICAgICAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdSZWZfLnByb3RvdHlwZS5vbkRlc3Ryb3kgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHsgdGhpcy5fdmlldy5kaXNwb3NhYmxlcy5wdXNoKGNhbGxiYWNrKTsgfTtcbiAgICAgICAgVmlld1JlZl8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZpZXcuZGVzdHJveSgpOyB9O1xuICAgICAgICByZXR1cm4gVmlld1JlZl87XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIEV2ZW50TGlzdGVuZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgcmV0dXJuIEV2ZW50TGlzdGVuZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFsbCBkZWJ1Z2dpbmcgYXBpcyBhcmUgY3VycmVudGx5IGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgRGVidWdOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdOb2RlKG5hdGl2ZU5vZGUsIHBhcmVudCwgX2RlYnVnSW5mbykge1xuICAgICAgICAgICAgdGhpcy5fZGVidWdJbmZvID0gX2RlYnVnSW5mbztcbiAgICAgICAgICAgIHRoaXMubmF0aXZlTm9kZSA9IG5hdGl2ZU5vZGU7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudCkgJiYgcGFyZW50IGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmFkZENoaWxkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdOb2RlLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9kZWJ1Z0luZm8pID8gdGhpcy5fZGVidWdJbmZvLmluamVjdG9yIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcImNvbXBvbmVudEluc3RhbmNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fZGVidWdJbmZvKSA/IHRoaXMuX2RlYnVnSW5mby5jb21wb25lbnQgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcImNvbnRleHRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5fZGVidWdJbmZvKSA/IHRoaXMuX2RlYnVnSW5mby5jb250ZXh0IDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9kZWJ1Z0luZm8pID8gdGhpcy5fZGVidWdJbmZvLnJlZmVyZW5jZXMgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z05vZGUucHJvdG90eXBlLCBcInByb3ZpZGVyVG9rZW5zXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fZGVidWdJbmZvKSA/IHRoaXMuX2RlYnVnSW5mby5wcm92aWRlclRva2VucyA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnTm9kZS5wcm90b3R5cGUsIFwic291cmNlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2RlYnVnSW5mbykgPyB0aGlzLl9kZWJ1Z0luZm8uc291cmNlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBEZWJ1Z05vZGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFsbCBkZWJ1Z2dpbmcgYXBpcyBhcmUgY3VycmVudGx5IGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgRGVidWdFbGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEyKERlYnVnRWxlbWVudCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdFbGVtZW50KG5hdGl2ZU5vZGUsIHBhcmVudCwgX2RlYnVnSW5mbykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbmF0aXZlTm9kZSwgcGFyZW50LCBfZGVidWdJbmZvKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWxlbWVudCA9IG5hdGl2ZU5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkSW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5zcGxpY2UoY2hpbGRJbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUuaW5zZXJ0Q2hpbGRyZW5BZnRlciA9IGZ1bmN0aW9uIChjaGlsZCwgbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nSW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCk7XG4gICAgICAgICAgICBpZiAoc2libGluZ0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0NoaWxkcmVuID0gdGhpcy5jaGlsZE5vZGVzLnNsaWNlKDAsIHNpYmxpbmdJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLmNoaWxkTm9kZXMuc2xpY2Uoc2libGluZ0luZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzID1cbiAgICAgICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIuY29uY2F0KExpc3RXcmFwcGVyLmNvbmNhdChwcmV2aW91c0NoaWxkcmVuLCBuZXdDaGlsZHJlbiksIG5leHRDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChuZXdDaGlsZC5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB0aGlzLnF1ZXJ5QWxsKHByZWRpY2F0ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cy5sZW5ndGggPiAwID8gcmVzdWx0c1swXSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUucXVlcnlBbGwgPSBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgX3F1ZXJ5RWxlbWVudENoaWxkcmVuKHRoaXMsIHByZWRpY2F0ZSwgbWF0Y2hlcyk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdFbGVtZW50LnByb3RvdHlwZS5xdWVyeUFsbE5vZGVzID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIF9xdWVyeU5vZGVDaGlsZHJlbih0aGlzLCBwcmVkaWNhdGUsIG1hdGNoZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0VsZW1lbnQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIERlYnVnRWxlbWVudC5wcm90b3R5cGUudHJpZ2dlckV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50T2JqKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5uYW1lID09IGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjayhldmVudE9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWJ1Z0VsZW1lbnQ7XG4gICAgfShEZWJ1Z05vZGUpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNOYXRpdmVFbGVtZW50cyhkZWJ1Z0Vscykge1xuICAgICAgICByZXR1cm4gZGVidWdFbHMubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwubmF0aXZlRWxlbWVudDsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9xdWVyeUVsZW1lbnRDaGlsZHJlbihlbGVtZW50LCBwcmVkaWNhdGUsIG1hdGNoZXMpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRGVidWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9xdWVyeUVsZW1lbnRDaGlsZHJlbihub2RlLCBwcmVkaWNhdGUsIG1hdGNoZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3F1ZXJ5Tm9kZUNoaWxkcmVuKHBhcmVudE5vZGUsIHByZWRpY2F0ZSwgbWF0Y2hlcykge1xuICAgICAgICBpZiAocGFyZW50Tm9kZSBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3F1ZXJ5Tm9kZUNoaWxkcmVuKG5vZGUsIHByZWRpY2F0ZSwgbWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTmVlZCB0byBrZWVwIHRoZSBub2RlcyBpbiBhIGdsb2JhbCBNYXAgc28gdGhhdCBtdWx0aXBsZSBhbmd1bGFyIGFwcHMgYXJlIHN1cHBvcnRlZC5cbiAgICB2YXIgX25hdGl2ZU5vZGVUb0RlYnVnTm9kZSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RGVidWdOb2RlKG5hdGl2ZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUuZ2V0KG5hdGl2ZU5vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmRleERlYnVnTm9kZShub2RlKSB7XG4gICAgICAgIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUuc2V0KG5vZGUubmF0aXZlTm9kZSwgbm9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZURlYnVnTm9kZUZyb21JbmRleChub2RlKSB7XG4gICAgICAgIF9uYXRpdmVOb2RlVG9EZWJ1Z05vZGUuZGVsZXRlKG5vZGUubmF0aXZlTm9kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlZmxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHJlZmxlY3RvcjtcbiAgICB9XG4gICAgdmFyIF9DT1JFX1BMQVRGT1JNX1BST1ZJREVSUyA9IFtcbiAgICAgICAgUGxhdGZvcm1SZWZfLFxuICAgICAgICB7IHByb3ZpZGU6IFBsYXRmb3JtUmVmLCB1c2VFeGlzdGluZzogUGxhdGZvcm1SZWZfIH0sXG4gICAgICAgIHsgcHJvdmlkZTogUmVmbGVjdG9yLCB1c2VGYWN0b3J5OiBfcmVmbGVjdG9yLCBkZXBzOiBbXSB9LFxuICAgICAgICB7IHByb3ZpZGU6IFJlZmxlY3RvclJlYWRlciwgdXNlRXhpc3Rpbmc6IFJlZmxlY3RvciB9LFxuICAgICAgICBUZXN0YWJpbGl0eVJlZ2lzdHJ5LFxuICAgICAgICBDb25zb2xlLFxuICAgIF07XG4gICAgLyoqXG4gICAgICogVGhpcyBwbGF0Zm9ybSBoYXMgdG8gYmUgaW5jbHVkZWQgaW4gYW55IG90aGVyIHBsYXRmb3JtXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIHBsYXRmb3JtQ29yZSA9IGNyZWF0ZVBsYXRmb3JtRmFjdG9yeShudWxsLCAnY29yZScsIF9DT1JFX1BMQVRGT1JNX1BST1ZJREVSUyk7XG5cbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIGkxOG4gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIExPQ0FMRV9JRCA9IG5ldyBPcGFxdWVUb2tlbignTG9jYWxlSWQnKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIGkxOG4gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIFRSQU5TTEFUSU9OUyA9IG5ldyBPcGFxdWVUb2tlbignVHJhbnNsYXRpb25zJyk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBpMThuIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBUUkFOU0xBVElPTlNfRk9STUFUID0gbmV3IE9wYXF1ZVRva2VuKCdUcmFuc2xhdGlvbnNGb3JtYXQnKTtcblxuICAgIGZ1bmN0aW9uIF9pdGVyYWJsZURpZmZlcnNGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEl0ZXJhYmxlRGlmZmVycztcbiAgICB9XG4gICAgZnVuY3Rpb24gX2tleVZhbHVlRGlmZmVyc0ZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0S2V5VmFsdWVEaWZmZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZHVsZSBpbmNsdWRlcyB0aGUgcHJvdmlkZXJzIG9mIEBhbmd1bGFyL2NvcmUgdGhhdCBhcmUgbmVlZGVkXG4gICAgICogdG8gYm9vdHN0cmFwIGNvbXBvbmVudHMgdmlhIGBBcHBsaWNhdGlvblJlZmAuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEFwcGxpY2F0aW9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbGljYXRpb25Nb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQXBwbGljYXRpb25Nb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHBsaWNhdGlvblJlZl8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBBcHBsaWNhdGlvblJlZiwgdXNlRXhpc3Rpbmc6IEFwcGxpY2F0aW9uUmVmXyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwcGxpY2F0aW9uSW5pdFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb21waWxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBUFBfSURfUkFORE9NX1BST1ZJREVSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZpZXdVdGlscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEl0ZXJhYmxlRGlmZmVycywgdXNlRmFjdG9yeTogX2l0ZXJhYmxlRGlmZmVyc0ZhY3RvcnkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEtleVZhbHVlRGlmZmVycywgdXNlRmFjdG9yeTogX2tleVZhbHVlRGlmZmVyc0ZhY3RvcnkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IExPQ0FMRV9JRCwgdXNlVmFsdWU6ICdlbi1VUycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBBcHBsaWNhdGlvbk1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gQXBwbGljYXRpb25Nb2R1bGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgRklMTF9TVFlMRV9GTEFHID0gJ3RydWUnOyAvLyBUT0RPIChtYXRza28pOiBjaGFuZ2UgdG8gYm9vbGVhblxuICAgIHZhciBBTllfU1RBVEUgPSAnKic7XG4gICAgdmFyIERFRkFVTFRfU1RBVEUgPSAnKic7XG4gICAgdmFyIEVNUFRZX1NUQVRFID0gJ3ZvaWQnO1xuXG4gICAgdmFyIE1hdGgkMSA9IGdsb2JhbCQxLk1hdGg7XG5cbiAgICB2YXIgQW5pbWF0aW9uR3JvdXBQbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Hcm91cFBsYXllcihfcGxheWVycykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMgPSBfcGxheWVycztcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgdG90YWwgPSB0aGlzLl9wbGF5ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0b3RhbCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVNaWNyb1Rhc2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uRmluaXNoKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnBhcmVudFBsYXllciA9IF90aGlzO1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIub25Eb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50ID49IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHRoaXMucGFyZW50UGxheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuaW5pdCgpOyB9KTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLm9uRG9uZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRvbmVGbnMucHVzaChmbik7IH07XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhcnRlZDsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBhcmVudFBsYXllcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLnBsYXkoKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5wYXVzZSgpOyB9KTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucmVzdGFydCgpOyB9KTsgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmZpbmlzaCgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uR3JvdXBQbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5kZXN0cm95KCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucmVzZXQoKTsgfSk7IH07XG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyBwbGF5ZXIuc2V0UG9zaXRpb24ocCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25Hcm91cFBsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwbGF5ZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoJDEubWluKHAsIG1pbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBbmltYXRpb25Hcm91cFBsYXllcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25LZXlmcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbktleWZyYW1lKG9mZnNldCwgc3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25LZXlmcmFtZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblBsYXllcigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZSwgXCJwYXJlbnRQbGF5ZXJcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTk9UIElNUExFTUVOVEVEOiBCYXNlIENsYXNzJyk7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwbGF5ZXIpIHsgdGhyb3cgbmV3IEVycm9yKCdOT1QgSU1QTEVNRU5URUQ6IEJhc2UgQ2xhc3MnKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBbmltYXRpb25QbGF5ZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTm9PcEFuaW1hdGlvblBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5vT3BBbmltYXRpb25QbGF5ZXIoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmVGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUub25Eb25lID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uRG9uZUZucy5wdXNoKGZuKTsgfTtcbiAgICAgICAgTm9PcEFuaW1hdGlvblBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7IHRoaXMuX29uRmluaXNoKCk7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBOb09wQW5pbWF0aW9uUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwIC8qKiBUT0RPICM5MTAwICovKSB7IH07XG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcbiAgICAgICAgcmV0dXJuIE5vT3BBbmltYXRpb25QbGF5ZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBBbmltYXRpb25TZXF1ZW5jZVBsYXllciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyKF9wbGF5ZXJzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycyA9IF9wbGF5ZXJzO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHBsYXllci5wYXJlbnRQbGF5ZXIgPSBfdGhpczsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vbk5leHQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5fb25OZXh0ID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wbGF5ZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGxheWVyID0gbmV3IE5vT3BBbmltYXRpb25QbGF5ZXIoKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jdXJyZW50SW5kZXggPj0gdGhpcy5fcGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQbGF5ZXIgPSBuZXcgTm9PcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxheWVyID0gdGhpcy5fcGxheWVyc1t0aGlzLl9jdXJyZW50SW5kZXgrK107XG4gICAgICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25OZXh0KHRydWUpOyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQbGF5ZXIgPSBwbGF5ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBhcmVudFBsYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBsYXllcikgeyByZXR1cm4gcGxheWVyLmluaXQoKTsgfSk7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uU3RhcnRGbnMucHVzaChmbik7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQodGhpcy5wYXJlbnRQbGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlUGxheWVyLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9hY3RpdmVQbGF5ZXIucGF1c2UoKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXllcnNbMF0ucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIucmVzZXQoKTsgfSk7IH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5maW5pc2goKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFuaW1hdGlvblNlcXVlbmNlUGxheWVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAocGxheWVyKSB7IHJldHVybiBwbGF5ZXIuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHAgLyoqIFRPRE8gIzkxMDAgKi8pIHsgdGhpcy5fcGxheWVyc1swXS5zZXRQb3NpdGlvbihwKTsgfTtcbiAgICAgICAgQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGxheWVyc1swXS5nZXRQb3NpdGlvbigpOyB9O1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXI7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFVVE9fU1RZTEUgPSAnKic7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIHRyaWdnZXIgdHJpZ2dlclxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbkVudHJ5TWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25FbnRyeU1ldGFkYXRhKG5hbWUsIGRlZmluaXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25FbnRyeU1ldGFkYXRhO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdGF0ZU1ldGFkYXRhKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdGF0ZU1ldGFkYXRhO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIHN0YXRlIHN0YXRlIGFuaW1hdGlvblxuICAgICAqIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhKHN0YXRlTmFtZUV4cHIsIHN0eWxlcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlTmFtZUV4cHIgPSBzdGF0ZU5hbWVFeHByO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvblN0YXRlTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuXG4gICAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIHByb3ZpZGVkIHZpYSB0aGUgYW5pbWF0aW9uIERTTCB3aGVuIHRoZVxuICAgICAqIHtAbGluayB0cmFuc2l0aW9uIHRyYW5zaXRpb24gYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUV4cHIgPSBzdGF0ZUNoYW5nZUV4cHI7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uU3RhdGVNZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIHZhciBBbmltYXRpb25NZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbk1ldGFkYXRhKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25NZXRhZGF0YTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBrZXlmcmFtZXMga2V5ZnJhbWVzXG4gICAgICogYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc3RlcHMgPSBzdGVwcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIHN0eWxlIHN0eWxlIGFuaW1hdGlvblxuICAgICAqIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25TdHlsZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25TdHlsZU1ldGFkYXRhKHN0eWxlcywgb2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBNZXRhZGF0YSByZXByZXNlbnRpbmcgdGhlIGVudHJ5IG9mIGFuaW1hdGlvbnMuXG4gICAgICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIHByb3ZpZGVkIHZpYSB0aGUgYW5pbWF0aW9uIERTTCB3aGVuIHRoZSB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlXG4gICAgICogYW5pbWF0aW9uIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhKHRpbWluZ3MsIHN0eWxlcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRpbWluZ3MgPSB0aW1pbmdzO1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbk1ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEzKEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YS5wcm90b3R5cGUsIFwic3RlcHNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcignTk9UIElNUExFTUVOVEVEOiBCYXNlIENsYXNzJyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGE7XG4gICAgfShBbmltYXRpb25NZXRhZGF0YSkpO1xuICAgIC8qKlxuICAgICAqIE1ldGFkYXRhIHJlcHJlc2VudGluZyB0aGUgZW50cnkgb2YgYW5pbWF0aW9ucy5cbiAgICAgKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgcHJvdmlkZWQgdmlhIHRoZSBhbmltYXRpb24gRFNMIHdoZW4gdGhlIHtAbGluayBzZXF1ZW5jZSBzZXF1ZW5jZVxuICAgICAqIGFuaW1hdGlvbiBmdW5jdGlvbn0gaXMgY2FsbGVkLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTMoQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YShfc3RlcHMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc3RlcHMgPSBfc3RlcHM7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEucHJvdG90eXBlLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RlcHM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbiAgICB9KEFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4gICAgLyoqXG4gICAgICogTWV0YWRhdGEgcmVwcmVzZW50aW5nIHRoZSBlbnRyeSBvZiBhbmltYXRpb25zLlxuICAgICAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBwcm92aWRlZCB2aWEgdGhlIGFuaW1hdGlvbiBEU0wgd2hlbiB0aGUge0BsaW5rIGdyb3VwIGdyb3VwIGFuaW1hdGlvblxuICAgICAqIGZ1bmN0aW9ufSBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMyhBbmltYXRpb25Hcm91cE1ldGFkYXRhLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBbmltYXRpb25Hcm91cE1ldGFkYXRhKF9zdGVwcykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zdGVwcyA9IF9zdGVwcztcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQW5pbWF0aW9uR3JvdXBNZXRhZGF0YS5wcm90b3R5cGUsIFwic3RlcHNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGVwczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICAgIH0oQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEpKTtcbiAgICAvKipcbiAgICAgKiBgYW5pbWF0ZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYGFuaW1hdGVgIHNwZWNpZmllcyBhbiBhbmltYXRpb24gc3RlcCB0aGF0IHdpbGwgYXBwbHkgdGhlIHByb3ZpZGVkIGBzdHlsZXNgIGRhdGEgZm9yIGEgZ2l2ZW5cbiAgICAgKiBhbW91bnQgb2ZcbiAgICAgKiB0aW1lIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBgdGltaW5nYCBleHByZXNzaW9uIHZhbHVlLiBDYWxscyB0byBgYW5pbWF0ZWAgYXJlIGV4cGVjdGVkIHRvIGJlXG4gICAgICogdXNlZCB3aXRoaW4ge0BsaW5rIHNlcXVlbmNlIGFuIGFuaW1hdGlvbiBzZXF1ZW5jZX0sIHtAbGluayBncm91cCBncm91cH0sIG9yIHtAbGluayB0cmFuc2l0aW9uXG4gICAgICogdHJhbnNpdGlvbn0uXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIFRoZSBgYW5pbWF0ZWAgZnVuY3Rpb24gYWNjZXB0cyB0d28gaW5wdXQgcGFyYW1ldGVyczogYHRpbWluZ2AgYW5kIGBzdHlsZXNgOlxuICAgICAqXG4gICAgICogLSBgdGltaW5nYCBpcyBhIHN0cmluZyBiYXNlZCB2YWx1ZSB0aGF0IGNhbiBiZSBhIGNvbWJpbmF0aW9uIG9mIGEgZHVyYXRpb24gd2l0aCBvcHRpb25hbFxuICAgICAqIGRlbGF5IGFuZCBlYXNpbmcgdmFsdWVzLiBUaGUgZm9ybWF0IGZvciB0aGUgZXhwcmVzc2lvbiBicmVha3MgZG93biB0byBgZHVyYXRpb24gZGVsYXkgZWFzaW5nYFxuICAgICAqICh0aGVyZWZvcmUgYSB2YWx1ZSBzdWNoIGFzIGAxcyAxMDBtcyBlYXNlLW91dGAgd2lsbCBiZSBwYXJzZSBpdHNlbGYgaW50byBgZHVyYXRpb249MTAwMCxcbiAgICAgKiBkZWxheT0xMDAsIGVhc2luZz1lYXNlLW91dGAuXG4gICAgICogSWYgYSBudW1lcmljIHZhbHVlIGlzIHByb3ZpZGVkIHRoZW4gdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGBkdXJhdGlvbmAgdmFsdWUgaW4gbWlsbGlzZWNvbmRcbiAgICAgKiBmb3JtLlxuICAgICAqIC0gYHN0eWxlc2AgaXMgdGhlIHN0eWxlIGlucHV0IGRhdGEgd2hpY2ggY2FuIGVpdGhlciBiZSBhIGNhbGwgdG8ge0BsaW5rIHN0eWxlIHN0eWxlfSBvciB7QGxpbmtcbiAgICAgKiBrZXlmcmFtZXMga2V5ZnJhbWVzfS5cbiAgICAgKiBJZiBsZWZ0IGVtcHR5IHRoZW4gdGhlIHN0eWxlcyBmcm9tIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZSB3aWxsIGJlIGNvbGxlY3RlZCBhbmQgdXNlZCAodGhpcyBpc1xuICAgICAqIHVzZWZ1bCB3aGVuXG4gICAgICogZGVzY3JpYmluZyBhbiBhbmltYXRpb24gc3RlcCB0aGF0IHdpbGwgY29tcGxldGUgYW4gYW5pbWF0aW9uIGJ5IHtAbGlua1xuICAgICAqIHRyYW5zaXRpb24jdGhlLWZpbmFsLWFuaW1hdGUtY2FsbCBhbmltYXRpbmcgdG8gdGhlIGZpbmFsIHN0YXRlfSkuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gdmFyaW91cyBmdW5jdGlvbnMgZm9yIHNwZWNpZnlpbmcgdGltaW5nIGRhdGFcbiAgICAgKiBhbmltYXRlKDUwMCwgc3R5bGUoLi4uKSlcbiAgICAgKiBhbmltYXRlKFwiMXNcIiwgc3R5bGUoLi4uKSlcbiAgICAgKiBhbmltYXRlKFwiMTAwbXMgMC41c1wiLCBzdHlsZSguLi4pKVxuICAgICAqIGFuaW1hdGUoXCI1cyBlYXNlXCIsIHN0eWxlKC4uLikpXG4gICAgICogYW5pbWF0ZShcIjVzIDEwbXMgY3ViaWMtYmV6aWVyKC4xNywuNjcsLjg4LC4xKVwiLCBzdHlsZSguLi4pKVxuICAgICAqXG4gICAgICogLy8gZWl0aGVyIHN0eWxlKCkgb2Yga2V5ZnJhbWVzKCkgY2FuIGJlIHVzZWRcbiAgICAgKiBhbmltYXRlKDUwMCwgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcInJlZFwiIH0pKVxuICAgICAqIGFuaW1hdGUoNTAwLCBrZXlmcmFtZXMoW1xuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kOiBcImJsdWVcIiB9KSksXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmQ6IFwicmVkXCIgfSkpXG4gICAgICogXSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbmltYXRlKHRpbWluZywgc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMgPT09IHZvaWQgMCkgeyBzdHlsZXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBzdHlsZXNFbnRyeSA9IHN0eWxlcztcbiAgICAgICAgaWYgKCFpc1ByZXNlbnQoc3R5bGVzRW50cnkpKSB7XG4gICAgICAgICAgICB2YXIgRU1QVFlfU1RZTEUgPSB7fTtcbiAgICAgICAgICAgIHN0eWxlc0VudHJ5ID0gbmV3IEFuaW1hdGlvblN0eWxlTWV0YWRhdGEoW0VNUFRZX1NUWUxFXSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25BbmltYXRlTWV0YWRhdGEodGltaW5nLCBzdHlsZXNFbnRyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBncm91cGAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYGdyb3VwYCBzcGVjaWZpZXMgYSBsaXN0IG9mIGFuaW1hdGlvbiBzdGVwcyB0aGF0IGFyZSBhbGwgcnVuIGluIHBhcmFsbGVsLiBHcm91cGVkIGFuaW1hdGlvbnNcbiAgICAgKiBhcmUgdXNlZnVsIHdoZW4gYSBzZXJpZXMgb2Ygc3R5bGVzIG11c3QgYmUgYW5pbWF0ZWQvY2xvc2VkIG9mZlxuICAgICAqIGF0IGRpZmZlcmVudCBzdGF0cnRpbmcvZW5kaW5nIHRpbWVzLlxuICAgICAqXG4gICAgICogVGhlIGBncm91cGAgZnVuY3Rpb24gY2FuIGVpdGhlciBiZSB1c2VkIHdpdGhpbiBhIHtAbGluayBzZXF1ZW5jZSBzZXF1ZW5jZX0gb3IgYSB7QGxpbmsgdHJhbnNpdGlvblxuICAgICAqIHRyYW5zaXRpb259XG4gICAgICogYW5kIGl0IHdpbGwgb25seSBjb250aW51ZSB0byB0aGUgbmV4dCBpbnN0cnVjdGlvbiBvbmNlIGFsbCBvZiB0aGUgaW5uZXIgYW5pbWF0aW9uIHN0ZXBzXG4gICAgICogaGF2ZSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIFRoZSBgc3RlcHNgIGRhdGEgdGhhdCBpcyBwYXNzZWQgaW50byB0aGUgYGdyb3VwYCBhbmltYXRpb24gZnVuY3Rpb24gY2FuIGVpdGhlciBjb25zaXN0XG4gICAgICogb2Yge0BsaW5rIHN0eWxlIHN0eWxlfSBvciB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBmdW5jdGlvbiBjYWxscy4gRWFjaCBjYWxsIHRvIGBzdHlsZSgpYCBvclxuICAgICAqIGBhbmltYXRlKClgXG4gICAgICogd2l0aGluIGEgZ3JvdXAgd2lsbCBiZSBleGVjdXRlZCBpbnN0YW50bHkgKHVzZSB7QGxpbmsga2V5ZnJhbWVzIGtleWZyYW1lc30gb3IgYVxuICAgICAqIHtAbGluayBhbmltYXRlI3VzYWdlIGFuaW1hdGUoKSB3aXRoIGEgZGVsYXkgdmFsdWV9IHRvIG9mZnNldCBzdHlsZXMgdG8gYmUgYXBwbGllZCBhdCBhIGxhdGVyXG4gICAgICogdGltZSkuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZ3JvdXAoW1xuICAgICAqICAgYW5pbWF0ZShcIjFzXCIsIHsgYmFja2dyb3VuZDogXCJibGFja1wiIH0pKVxuICAgICAqICAgYW5pbWF0ZShcIjJzXCIsIHsgY29sb3I6IFwid2hpdGVcIiB9KSlcbiAgICAgKiBdKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L0tlejhYR1dCeFd1ZTdxUDduTnZGP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9hbmltYXRpb24vdHMvZHNsL2FuaW1hdGlvbl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgQW5pbWF0aW9uIHN1cHBvcnQgaXMgZXhwZXJpbWVudGFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdyb3VwKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uR3JvdXBNZXRhZGF0YShzdGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBzZXF1ZW5jZWAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHNlcXVlbmNlYCBTcGVjaWZpZXMgYSBsaXN0IG9mIGFuaW1hdGlvbiBzdGVwcyB0aGF0IGFyZSBydW4gb25lIGJ5IG9uZS4gKGBzZXF1ZW5jZWAgaXMgdXNlZFxuICAgICAqIGJ5IGRlZmF1bHQgd2hlbiBhbiBhcnJheSBpcyBwYXNzZWQgYXMgYW5pbWF0aW9uIGRhdGEgaW50byB7QGxpbmsgdHJhbnNpdGlvbiB0cmFuc2l0aW9ufS4pXG4gICAgICpcbiAgICAgKiBUaGUgYHNlcXVlbmNlYCBmdW5jdGlvbiBjYW4gZWl0aGVyIGJlIHVzZWQgd2l0aGluIGEge0BsaW5rIGdyb3VwIGdyb3VwfSBvciBhIHtAbGluayB0cmFuc2l0aW9uXG4gICAgICogdHJhbnNpdGlvbn1cbiAgICAgKiBhbmQgaXQgd2lsbCBvbmx5IGNvbnRpbnVlIHRvIHRoZSBuZXh0IGluc3RydWN0aW9uIG9uY2UgZWFjaCBvZiB0aGUgaW5uZXIgYW5pbWF0aW9uIHN0ZXBzXG4gICAgICogaGF2ZSBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBUbyBwZXJmb3JtIGFuaW1hdGlvbiBzdHlsaW5nIGluIHBhcmFsbGVsIHdpdGggb3RoZXIgYW5pbWF0aW9uIHN0ZXBzIHRoZW5cbiAgICAgKiBoYXZlIGEgbG9vayBhdCB0aGUge0BsaW5rIGdyb3VwIGdyb3VwfSBhbmltYXRpb24gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIFRoZSBgc3RlcHNgIGRhdGEgdGhhdCBpcyBwYXNzZWQgaW50byB0aGUgYHNlcXVlbmNlYCBhbmltYXRpb24gZnVuY3Rpb24gY2FuIGVpdGhlciBjb25zaXN0XG4gICAgICogb2Yge0BsaW5rIHN0eWxlIHN0eWxlfSBvciB7QGxpbmsgYW5pbWF0ZSBhbmltYXRlfSBmdW5jdGlvbiBjYWxscy4gQSBjYWxsIHRvIGBzdHlsZSgpYCB3aWxsIGFwcGx5XG4gICAgICogdGhlXG4gICAgICogcHJvdmlkZWQgc3R5bGluZyBkYXRhIGltbWVkaWF0ZWx5IHdoaWxlIGEgY2FsbCB0byBgYW5pbWF0ZSgpYCB3aWxsIGFwcGx5IGl0cyBzdHlsaW5nXG4gICAgICogZGF0YSBvdmVyIGEgZ2l2ZW4gdGltZSBkZXBlbmRpbmcgb24gaXRzIHRpbWluZyBkYXRhLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHNlcXVlbmNlKFtcbiAgICAgKiAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSksXG4gICAgICogICBhbmltYXRlKFwiMXNcIiwgeyBvcGFjaXR5OiAxIH0pKVxuICAgICAqIF0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VxdWVuY2Uoc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYHN0eWxlYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyMidzXG4gICAgICogYW5pbWF0aW9uXG4gICAgICogRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZVxuICAgICAqIHtAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucy1hbmNob3IgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGFcbiAgICAgKiBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2YgaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhcjIgYXJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBgc3R5bGVgIGRlY2xhcmVzIGEga2V5L3ZhbHVlIG9iamVjdCBjb250YWluaW5nIENTUyBwcm9wZXJ0aWVzL3N0eWxlcyB0aGF0IGNhbiB0aGVuXG4gICAgICogYmUgdXNlZCBmb3Ige0BsaW5rIHN0YXRlIGFuaW1hdGlvbiBzdGF0ZXN9LCB3aXRoaW4gYW4ge0BsaW5rIHNlcXVlbmNlIGFuaW1hdGlvbiBzZXF1ZW5jZX0sIG9yIGFzXG4gICAgICogc3R5bGluZyBkYXRhIGZvciBib3RoIHtAbGluayBhbmltYXRlIGFuaW1hdGV9IGFuZCB7QGxpbmsga2V5ZnJhbWVzIGtleWZyYW1lc30uXG4gICAgICpcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIGBzdHlsZWAgdGFrZXMgaW4gYSBrZXkvdmFsdWUgc3RyaW5nIG1hcCBhcyBkYXRhIGFuZCBleHBlY3RzIG9uZSBvciBtb3JlIENTUyBwcm9wZXJ0eS92YWx1ZVxuICAgICAqIHBhaXJzIHRvIGJlIGRlZmluZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gc3RyaW5nIHZhbHVlcyBhcmUgdXNlZCBmb3IgY3NzIHByb3BlcnRpZXNcbiAgICAgKiBzdHlsZSh7IGJhY2tncm91bmQ6IFwicmVkXCIsIGNvbG9yOiBcImJsdWVcIiB9KVxuICAgICAqXG4gICAgICogLy8gbnVtZXJpY2FsIChwaXhlbCkgdmFsdWVzIGFyZSBhbHNvIHN1cHBvcnRlZFxuICAgICAqIHN0eWxlKHsgd2lkdGg6IDEwMCwgaGVpZ2h0OiAwIH0pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMjIEF1dG8tc3R5bGVzICh1c2luZyBgKmApXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGFzdGVyaXggKGAqYCkgY2hhcmFjdGVyIGlzIHVzZWQgYXMgYSB2YWx1ZSB0aGVuIGl0IHdpbGwgYmUgZGV0ZWN0ZWQgZnJvbSB0aGUgZWxlbWVudFxuICAgICAqIGJlaW5nIGFuaW1hdGVkXG4gICAgICogYW5kIGFwcGxpZWQgYXMgYW5pbWF0aW9uIGRhdGEgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZmVhdHVyZSBwcm92ZXMgdXNlZnVsIGZvciBhIHN0YXRlIGRlcGVuZGluZyBvbiBsYXlvdXQgYW5kL29yIGVudmlyb25tZW50IGZhY3RvcnM7IGluIHN1Y2hcbiAgICAgKiBjYXNlc1xuICAgICAqIHRoZSBzdHlsZXMgYXJlIGNhbGN1bGF0ZWQganVzdCBiZWZvcmUgdGhlIGFuaW1hdGlvbiBzdGFydHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gdGhlIHN0ZXBzIGJlbG93IHdpbGwgYW5pbWF0ZSBmcm9tIDAgdG8gdGhlXG4gICAgICogLy8gYWN0dWFsIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgICAqIHN0eWxlKHsgaGVpZ2h0OiAwIH0pLFxuICAgICAqIGFuaW1hdGUoXCIxc1wiLCBzdHlsZSh7IGhlaWdodDogXCIqXCIgfSkpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R5bGUodG9rZW5zKSB7XG4gICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgdmFyIG9mZnNldCA9IG51bGw7XG4gICAgICAgIGlmIChpc1N0cmluZyh0b2tlbnMpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IFt0b2tlbnNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodG9rZW5zKSkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBbdG9rZW5zXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlucHV0LmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVudHJ5T2Zmc2V0ID0gZW50cnlbJ29mZnNldCddO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZW50cnlPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCA9PSBudWxsID8gcGFyc2VGbG9hdChlbnRyeU9mZnNldCkgOiBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TdHlsZU1ldGFkYXRhKGlucHV0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgc3RhdGVgIGlzIGFuIGFuaW1hdGlvbi1zcGVjaWZpYyBmdW5jdGlvbiB0aGF0IGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgaW5zaWRlIG9mIEFuZ3VsYXIyJ3NcbiAgICAgKiBhbmltYXRpb25cbiAgICAgKiBEU0wgbGFuZ3VhZ2UuIElmIHRoaXMgaW5mb3JtYXRpb24gaXMgbmV3LCBwbGVhc2UgbmF2aWdhdGUgdG8gdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBjb21wb25lbnQgYW5pbWF0aW9ucyBtZXRhZGF0YVxuICAgICAqIHBhZ2V9IHRvIGdhaW4gYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiBob3cgYW5pbWF0aW9ucyBpbiBBbmd1bGFyMiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIGBzdGF0ZWAgZGVjbGFyZXMgYW4gYW5pbWF0aW9uIHN0YXRlIHdpdGhpbiB0aGUgZ2l2ZW4gdHJpZ2dlci4gV2hlbiBhIHN0YXRlIGlzXG4gICAgICogYWN0aXZlIHdpdGhpbiBhIGNvbXBvbmVudCB0aGVuIGl0cyBhc3NvY2lhdGVkIHN0eWxlcyB3aWxsIHBlcnNpc3Qgb25cbiAgICAgKiB0aGUgZWxlbWVudCB0aGF0IHRoZSB0cmlnZ2VyIGlzIGF0dGFjaGVkIHRvIChldmVuIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzKS5cbiAgICAgKlxuICAgICAqIFRvIGFuaW1hdGUgYmV0d2VlbiBzdGF0ZXMsIGhhdmUgYSBsb29rIGF0IHRoZSBhbmltYXRpb24ge0BsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn1cbiAgICAgKiBEU0wgZnVuY3Rpb24uIFRvIHJlZ2lzdGVyIHN0YXRlcyB0byBhbiBhbmltYXRpb24gdHJpZ2dlciBwbGVhc2UgaGF2ZSBhIGxvb2tcbiAgICAgKiBhdCB0aGUge0BsaW5rIHRyaWdnZXIgdHJpZ2dlcn0gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAjIyMjIFRoZSBgdm9pZGAgc3RhdGVcbiAgICAgKlxuICAgICAqIFRoZSBgdm9pZGAgc3RhdGUgdmFsdWUgaXMgYSByZXNlcnZlZCB3b3JkIHRoYXQgYW5ndWxhciB1c2VzIHRvIGRldGVybWluZSB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdFxuICAgICAqIGFwYXJ0XG4gICAgICogb2YgdGhlIGFwcGxpY2F0aW9uIGFueW1vcmUgKGUuZy4gd2hlbiBhbiBgbmdJZmAgZXZhbHVhdGVzIHRvIGZhbHNlIHRoZW4gdGhlIHN0YXRlIG9mIHRoZVxuICAgICAqIGFzc29jaWF0ZWQgZWxlbWVudFxuICAgICAqIGlzIHZvaWQpLlxuICAgICAqXG4gICAgICogIyMjIyBUaGUgYCpgIChkZWZhdWx0KSBzdGF0ZVxuICAgICAqXG4gICAgICogVGhlIGAqYCBzdGF0ZSAod2hlbiBzdHlsZWQpIGlzIGEgZmFsbGJhY2sgc3RhdGUgdGhhdCB3aWxsIGJlIHVzZWQgaWZcbiAgICAgKiB0aGUgc3RhdGUgdGhhdCBpcyBiZWluZyBhbmltYXRlZCBpcyBub3QgZGVjbGFyZWQgd2l0aGluIHRoZSB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBgc3RhdGVgIHdpbGwgZGVjbGFyZSBhbiBhbmltYXRpb24gc3RhdGUgd2l0aCBpdHMgYXNzb2NpYXRlZCBzdHlsZXNcbiAgICAgKiB3aXRoaW4gdGhlIGdpdmVuIHRyaWdnZXIuXG4gICAgICpcbiAgICAgKiAtIGBzdGF0ZU5hbWVFeHByYCBjYW4gYmUgb25lIG9yIG1vcmUgc3RhdGUgbmFtZXMgc2VwYXJhdGVkIGJ5IGNvbW1hcy5cbiAgICAgKiAtIGBzdHlsZXNgIHJlZmVycyB0byB0aGUge0BsaW5rIHN0eWxlIHN0eWxpbmcgZGF0YX0gdGhhdCB3aWxsIGJlIHBlcnNpc3RlZCBvbiB0aGUgZWxlbWVudCBvbmNlXG4gICAgICogdGhlIHN0YXRlXG4gICAgICogaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBcInZvaWRcIiBpcyBhIHJlc2VydmVkIG5hbWUgZm9yIGEgc3RhdGUgYW5kIGlzIHVzZWQgdG8gcmVwcmVzZW50XG4gICAgICogLy8gdGhlIHN0YXRlIGluIHdoaWNoIGFuIGVsZW1lbnQgaXMgZGV0YWNoZWQgZnJvbSBmcm9tIHRoZSBhcHBsaWNhdGlvbi5cbiAgICAgKiBzdGF0ZShcInZvaWRcIiwgc3R5bGUoeyBoZWlnaHQ6IDAgfSkpXG4gICAgICpcbiAgICAgKiAvLyB1c2VyLWRlZmluZWQgc3RhdGVzXG4gICAgICogc3RhdGUoXCJjbG9zZWRcIiwgc3R5bGUoeyBoZWlnaHQ6IDAgfSkpXG4gICAgICogc3RhdGUoXCJvcGVuLCB2aXNpYmxlXCIsIHN0eWxlKHsgaGVpZ2h0OiBcIipcIiB9KSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGF0ZShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEoc3RhdGVOYW1lRXhwciwgc3R5bGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGtleWZyYW1lc2AgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYGtleWZyYW1lc2Agc3BlY2lmaWVzIGEgY29sbGVjdGlvbiBvZiB7QGxpbmsgc3R5bGUgc3R5bGV9IGVudHJpZXMgZWFjaCBvcHRpb25hbGx5IGNoYXJhY3Rlcml6ZWRcbiAgICAgKiBieSBhbiBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogVGhlIGBrZXlmcmFtZXNgIGFuaW1hdGlvbiBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGFsb25nc2lkZSB0aGUge0BsaW5rIGFuaW1hdGUgYW5pbWF0ZX1cbiAgICAgKiBhbmltYXRpb24gZnVuY3Rpb24uIEluc3RlYWQgb2YgYXBwbHlpbmcgYW5pbWF0aW9ucyBmcm9tIHdoZXJlIHRoZXkgYXJlXG4gICAgICogY3VycmVudGx5IHRvIHRoZWlyIGRlc3RpbmF0aW9uLCBrZXlmcmFtZXMgY2FuIGRlc2NyaWJlIGhvdyBlYWNoIHN0eWxlIGVudHJ5IGlzIGFwcGxpZWRcbiAgICAgKiBhbmQgYXQgd2hhdCBwb2ludCB3aXRoaW4gdGhlIGFuaW1hdGlvbiBhcmMgKG11Y2ggbGlrZSBDU1MgS2V5ZnJhbWUgQW5pbWF0aW9ucyBkbykuXG4gICAgICpcbiAgICAgKiBGb3IgZWFjaCBgc3R5bGUoKWAgZW50cnkgYW4gYG9mZnNldGAgdmFsdWUgY2FuIGJlIHNldC4gRG9pbmcgc28gYWxsb3dzIHRvIHNwZWNpZml5IGF0XG4gICAgICogd2hhdCBwZXJjZW50YWdlIG9mIHRoZSBhbmltYXRlIHRpbWUgdGhlIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gdGhlIHByb3ZpZGVkIG9mZnNldCB2YWx1ZXMgZGVzY3JpYmUgd2hlbiBlYWNoIGJhY2tncm91bmRDb2xvciB2YWx1ZSBpcyBhcHBsaWVkLlxuICAgICAqIGFuaW1hdGUoXCI1c1wiLCBrZXlmcmFtZXMoW1xuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmVkXCIsIG9mZnNldDogMCB9KSxcbiAgICAgKiAgIHN0eWxlKHsgYmFja2dyb3VuZENvbG9yOiBcImJsdWVcIiwgb2Zmc2V0OiAwLjIgfSksXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJvcmFuZ2VcIiwgb2Zmc2V0OiAwLjMgfSksXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJibGFja1wiLCBvZmZzZXQ6IDEgfSlcbiAgICAgKiBdKSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEFsdGVybmF0aXZlbHksIGlmIHRoZXJlIGFyZSBubyBgb2Zmc2V0YCB2YWx1ZXMgdXNlZCB3aXRoaW4gdGhlIHN0eWxlIGVudHJpZXMgdGhlbiB0aGUgb2Zmc2V0c1xuICAgICAqIHdpbGxcbiAgICAgKiBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogYW5pbWF0ZShcIjVzXCIsIGtleWZyYW1lcyhbXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJyZWRcIiB9KSAvLyBvZmZzZXQgPSAwXG4gICAgICogICBzdHlsZSh7IGJhY2tncm91bmRDb2xvcjogXCJibHVlXCIgfSkgLy8gb2Zmc2V0ID0gMC4zM1xuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwib3JhbmdlXCIgfSkgLy8gb2Zmc2V0ID0gMC42NlxuICAgICAqICAgc3R5bGUoeyBiYWNrZ3JvdW5kQ29sb3I6IFwiYmxhY2tcIiB9KSAvLyBvZmZzZXQgPSAxXG4gICAgICogXSkpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5ZnJhbWVzKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YShzdGVwcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0cmFuc2l0aW9uYCBpcyBhbiBhbmltYXRpb24tc3BlY2lmaWMgZnVuY3Rpb24gdGhhdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGluc2lkZSBvZiBBbmd1bGFyMidzXG4gICAgICogYW5pbWF0aW9uXG4gICAgICogRFNMIGxhbmd1YWdlLiBJZiB0aGlzIGluZm9ybWF0aW9uIGlzIG5ldywgcGxlYXNlIG5hdmlnYXRlIHRvIHRoZVxuICAgICAqIHtAbGluayBDb21wb25lbnQjYW5pbWF0aW9ucy1hbmNob3IgY29tcG9uZW50IGFuaW1hdGlvbnMgbWV0YWRhdGFcbiAgICAgKiBwYWdlfSB0byBnYWluIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2YgaG93IGFuaW1hdGlvbnMgaW4gQW5ndWxhcjIgYXJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBgdHJhbnNpdGlvbmAgZGVjbGFyZXMgdGhlIHtAbGluayBzZXF1ZW5jZSBzZXF1ZW5jZSBvZiBhbmltYXRpb24gc3RlcHN9IHRoYXQgd2lsbCBiZSBydW4gd2hlbiB0aGVcbiAgICAgKiBwcm92aWRlZFxuICAgICAqIGBzdGF0ZUNoYW5nZUV4cHJgIHZhbHVlIGlzIHNhdGlzZmllZC4gVGhlIGBzdGF0ZUNoYW5nZUV4cHJgIGNvbnNpc3RzIG9mIGEgYHN0YXRlMSA9PiBzdGF0ZTJgXG4gICAgICogd2hpY2ggY29uc2lzdHNcbiAgICAgKiBvZiB0d28ga25vd24gc3RhdGVzICh1c2UgYW4gYXN0ZXJpeCAoYCpgKSB0byByZWZlciB0byBhIGR5bmFtaWMgc3RhcnRpbmcgYW5kL29yIGVuZGluZyBzdGF0ZSkuXG4gICAgICpcbiAgICAgKiBBbmltYXRpb24gdHJhbnNpdGlvbnMgYXJlIHBsYWNlZCB3aXRoaW4gYW4ge0BsaW5rIHRyaWdnZXIgYW5pbWF0aW9uIHRyaWdnZXJ9LiBGb3IgYW4gdHJhbnNpdGlvblxuICAgICAqIHRvIGFuaW1hdGUgdG9cbiAgICAgKiBhIHN0YXRlIHZhbHVlIGFuZCBwZXJzaXN0IGl0cyBzdHlsZXMgdGhlbiBvbmUgb3IgbW9yZSB7QGxpbmsgc3RhdGUgYW5pbWF0aW9uIHN0YXRlc30gaXMgZXhwZWN0ZWRcbiAgICAgKiB0byBiZSBkZWZpbmVkLlxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBBbiBhbmltYXRpb24gdHJhbnNpdGlvbiBpcyBraWNrZWQgb2ZmIHRoZSBgc3RhdGVDaGFuZ2VFeHByYCBwcmVkaWNhdGUgZXZhbHVhdGVzIHRvIHRydWUgYmFzZWQgb25cbiAgICAgKiB3aGF0IHRoZVxuICAgICAqIHByZXZpb3VzIHN0YXRlIGlzIGFuZCB3aGF0IHRoZSBjdXJyZW50IHN0YXRlIGhhcyBiZWNvbWUuIEluIG90aGVyIHdvcmRzLCBpZiBhIHRyYW5zaXRpb24gaXNcbiAgICAgKiBkZWZpbmVkIHRoYXRcbiAgICAgKiBtYXRjaGVzIHRoZSBvbGQvY3VycmVudCBzdGF0ZSBjcml0ZXJpYSB0aGVuIHRoZSBhc3NvY2lhdGVkIGFuaW1hdGlvbiB3aWxsIGJlIHRyaWdnZXJlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBhbGwgdHJhbnNpdGlvbi9zdGF0ZSBjaGFuZ2VzIGFyZSBkZWZpbmVkIHdpdGhpbiBhbiBhbmltYXRpb24gdHJpZ2dlclxuICAgICAqIHRyaWdnZXIoXCJteUFuaW1hdGlvblRyaWdnZXJcIiwgW1xuICAgICAqICAgLy8gaWYgYSBzdGF0ZSBpcyBkZWZpbmVkIHRoZW4gaXRzIHN0eWxlcyB3aWxsIGJlIHBlcnNpc3RlZCB3aGVuIHRoZVxuICAgICAqICAgLy8gYW5pbWF0aW9uIGhhcyBmdWxseSBjb21wbGV0ZWQgaXRzZWxmXG4gICAgICogICBzdGF0ZShcIm9uXCIsIHN0eWxlKHsgYmFja2dyb3VuZDogXCJncmVlblwiIH0pKSxcbiAgICAgKiAgIHN0YXRlKFwib2ZmXCIsIHN0eWxlKHsgYmFja2dyb3VuZDogXCJncmV5XCIgfSkpLFxuICAgICAqXG4gICAgICogICAvLyBhIHRyYW5zaXRpb24gYW5pbWF0aW9uIHRoYXQgd2lsbCBiZSBraWNrZWQgb2ZmIHdoZW4gdGhlIHN0YXRlIHZhbHVlXG4gICAgICogICAvLyBib3VuZCB0byBcIm15QW5pbWF0aW9uVHJpZ2dlclwiIGNoYW5nZXMgZnJvbSBcIm9uXCIgdG8gXCJvZmZcIlxuICAgICAqICAgdHJhbnNpdGlvbihcIm9uID0+IG9mZlwiLCBhbmltYXRlKDUwMCkpLFxuICAgICAqXG4gICAgICogICAvLyBpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGRvIHJ1biB0aGUgc2FtZSBhbmltYXRpb24gZm9yIGJvdGggZGlyZWN0aW9uc1xuICAgICAqICAgdHJhbnNpdGlvbihcIm9uIDw9PiBvZmZcIiwgYW5pbWF0ZSg1MDApKSxcbiAgICAgKlxuICAgICAqICAgLy8gb3IgdG8gZGVmaW5lIG11bHRpcGxlIHN0YXRlcyBwYWlycyBzZXBhcmF0ZWQgYnkgY29tbWFzXG4gICAgICogICB0cmFuc2l0aW9uKFwib24gPT4gb2ZmLCBvZmYgPT4gdm9pZFwiLCBhbmltYXRlKDUwMCkpLFxuICAgICAqXG4gICAgICogICAvLyB0aGlzIGlzIGEgY2F0Y2gtYWxsIHN0YXRlIGNoYW5nZSBmb3Igd2hlbiBhbiBlbGVtZW50IGlzIGluc2VydGVkIGludG9cbiAgICAgKiAgIC8vIHRoZSBwYWdlIGFuZCB0aGUgZGVzdGluYXRpb24gc3RhdGUgaXMgdW5rbm93blxuICAgICAqICAgdHJhbnNpdGlvbihcInZvaWQgPT4gKlwiLCBbXG4gICAgICogICAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSxcbiAgICAgKiAgICAgYW5pbWF0ZSg1MDApXG4gICAgICogICBdKSxcbiAgICAgKlxuICAgICAqICAgLy8gdGhpcyB3aWxsIGNhcHR1cmUgYSBzdGF0ZSBjaGFuZ2UgYmV0d2VlbiBhbnkgc3RhdGVzXG4gICAgICogICB0cmFuc2l0aW9uKFwiKiA9PiAqXCIsIGFuaW1hdGUoXCIxcyAwc1wiKSksXG4gICAgICogXSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb21wb25lbnQgd2lsbCBtYWtlIHVzZSBvZiB0aGUgYG15QW5pbWF0aW9uVHJpZ2dlcmBcbiAgICAgKiBhbmltYXRpb24gdHJpZ2dlciBieSBiaW5kaW5nIHRvIGFuIGVsZW1lbnQgd2l0aGluIGl0cyB0ZW1wbGF0ZSBjb2RlLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS0gc29tZXdoZXJlIGluc2lkZSBvZiBteS1jb21wb25lbnQtdHBsLmh0bWwgLS0+XG4gICAgICogPGRpdiBbQG15QW5pbWF0aW9uVHJpZ2dlcl09XCJteVN0YXR1c0V4cFwiPi4uLjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIyBUaGUgZmluYWwgYGFuaW1hdGVgIGNhbGxcbiAgICAgKlxuICAgICAqIElmIHRoZSBmaW5hbCBzdGVwIHdpdGhpbiB0aGUgdHJhbnNpdGlvbiBzdGVwcyBpcyBhIGNhbGwgdG8gYGFuaW1hdGUoKWAgdGhhdCAqKm9ubHkqKlxuICAgICAqIHVzZXMgYSB0aW1pbmcgdmFsdWUgd2l0aCAqKm5vIHN0eWxlIGRhdGEqKiB0aGVuIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSB1c2VkIGFzIHRoZSBmaW5hbFxuICAgICAqIGFuaW1hdGlvblxuICAgICAqIGFyYyBmb3IgdGhlIGVsZW1lbnQgdG8gYW5pbWF0ZSBpdHNlbGYgdG8gdGhlIGZpbmFsIHN0YXRlLiBUaGlzIGludm9sdmVzIGFuIGF1dG9tYXRpYyBtaXggb2ZcbiAgICAgKiBhZGRpbmcvcmVtb3ZpbmcgQ1NTIHN0eWxlcyBzbyB0aGF0IHRoZSBlbGVtZW50IHdpbGwgYmUgaW4gdGhlIGV4YWN0IHN0YXRlIGl0IHNob3VsZCBiZSBmb3IgdGhlXG4gICAgICogYXBwbGllZCBzdGF0ZSB0byBiZSBwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogLy8gc3RhcnQgb2ZmIGJ5IGhpZGluZyB0aGUgZWxlbWVudCwgYnV0IG1ha2Ugc3VyZSB0aGF0IGl0IGFuaW1hdGVzIHByb3Blcmx5IHRvIHdoYXRldmVyIHN0YXRlXG4gICAgICogLy8gaXMgY3VycmVudGx5IGFjdGl2ZSBmb3IgXCJteUFuaW1hdGlvblRyaWdnZXJcIlxuICAgICAqIHRyYW5zaXRpb24oXCJ2b2lkID0+ICpcIiwgW1xuICAgICAqICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICAgICAqICAgYW5pbWF0ZSg1MDApXG4gICAgICogXSlcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9LZXo4WEdXQnhXdWU3cVA3bk52Rj9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvYW5pbWF0aW9uL3RzL2RzbC9hbmltYXRpb25fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFuaW1hdGlvbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbkRhdGEgPSBpc0FycmF5KHN0ZXBzKSA/IG5ldyBBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSA6XG4gICAgICAgICAgICBzdGVwcztcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YShzdGF0ZUNoYW5nZUV4cHIsIGFuaW1hdGlvbkRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgdHJpZ2dlcmAgaXMgYW4gYW5pbWF0aW9uLXNwZWNpZmljIGZ1bmN0aW9uIHRoYXQgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgQW5ndWxhcjInc1xuICAgICAqIGFuaW1hdGlvblxuICAgICAqIERTTCBsYW5ndWFnZS4gSWYgdGhpcyBpbmZvcm1hdGlvbiBpcyBuZXcsIHBsZWFzZSBuYXZpZ2F0ZSB0byB0aGVcbiAgICAgKiB7QGxpbmsgQ29tcG9uZW50I2FuaW1hdGlvbnMtYW5jaG9yIGNvbXBvbmVudCBhbmltYXRpb25zIG1ldGFkYXRhXG4gICAgICogcGFnZX0gdG8gZ2FpbiBhIGJldHRlciB1bmRlcnN0YW5kaW5nIG9mIGhvdyBhbmltYXRpb25zIGluIEFuZ3VsYXIyIGFyZSB1c2VkLlxuICAgICAqXG4gICAgICogYHRyaWdnZXJgIENyZWF0ZXMgYW4gYW5pbWF0aW9uIHRyaWdnZXIgd2hpY2ggd2lsbCBhIGxpc3Qgb2Yge0BsaW5rIHN0YXRlIHN0YXRlfSBhbmQge0BsaW5rXG4gICAgICogdHJhbnNpdGlvbiB0cmFuc2l0aW9ufVxuICAgICAqIGVudHJpZXMgdGhhdCB3aWxsIGJlIGV2YWx1YXRlZCB3aGVuIHRoZSBleHByZXNzaW9uIGJvdW5kIHRvIHRoZSB0cmlnZ2VyIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBUcmlnZ2VycyBhcmUgcmVnaXN0ZXJlZCB3aXRoaW4gdGhlIGNvbXBvbmVudCBhbm5vdGF0aW9uIGRhdGEgdW5kZXIgdGhlXG4gICAgICoge0BsaW5rIENvbXBvbmVudCNhbmltYXRpb25zLWFuY2hvciBhbmltYXRpb25zIHNlY3Rpb259LiBBbiBhbmltYXRpb24gdHJpZ2dlciBjYW5cbiAgICAgKiBiZSBwbGFjZWQgb24gYW4gZWxlbWVudCB3aXRoaW4gYSB0ZW1wbGF0ZSBieSByZWZlcmVuY2luZyB0aGUgbmFtZSBvZiB0aGVcbiAgICAgKiB0cmlnZ2VyIGZvbGxvd2VkIGJ5IHRoZSBleHByZXNzaW9uIHZhbHVlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYm91bmQgdG9cbiAgICAgKiAoaW4gdGhlIGZvcm0gb2YgYFtAdHJpZ2dlck5hbWVdPVwiZXhwcmVzc2lvblwiYC5cbiAgICAgKlxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogYHRyaWdnZXJgIHdpbGwgY3JlYXRlIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIHJlZmVyZW5jZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYG5hbWVgIHZhbHVlLlxuICAgICAqIFRoZSBwcm92aWRlZCBgYW5pbWF0aW9uYCB2YWx1ZSBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheSBjb25zaXN0aW5nIG9mIHtAbGluayBzdGF0ZSBzdGF0ZX0gYW5kXG4gICAgICoge0BsaW5rIHRyYW5zaXRpb24gdHJhbnNpdGlvbn1cbiAgICAgKiBkZWNsYXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ215LWNvbXBvbmVudCcsXG4gICAgICogICB0ZW1wbGF0ZVVybDogJ215LWNvbXBvbmVudC10cGwuaHRtbCcsXG4gICAgICogICBhbmltYXRpb25zOiBbXG4gICAgICogICAgIHRyaWdnZXIoXCJteUFuaW1hdGlvblRyaWdnZXJcIiwgW1xuICAgICAqICAgICAgIHN0YXRlKC4uLiksXG4gICAgICogICAgICAgc3RhdGUoLi4uKSxcbiAgICAgKiAgICAgICB0cmFuc2l0aW9uKC4uLiksXG4gICAgICogICAgICAgdHJhbnNpdGlvbiguLi4pXG4gICAgICogICAgIF0pXG4gICAgICogICBdXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeUNvbXBvbmVudCB7XG4gICAgICogICBteVN0YXR1c0V4cCA9IFwic29tZXRoaW5nXCI7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIHRlbXBsYXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbXBvbmVudCB3aWxsIG1ha2UgdXNlIG9mIHRoZSBgbXlBbmltYXRpb25UcmlnZ2VyYFxuICAgICAqIGFuaW1hdGlvbiB0cmlnZ2VyIGJ5IGJpbmRpbmcgdG8gYW4gZWxlbWVudCB3aXRoaW4gaXRzIHRlbXBsYXRlIGNvZGUuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLSBzb21ld2hlcmUgaW5zaWRlIG9mIG15LWNvbXBvbmVudC10cGwuaHRtbCAtLT5cbiAgICAgKiA8ZGl2IFtAbXlBbmltYXRpb25UcmlnZ2VyXT1cIm15U3RhdHVzRXhwXCI+Li4uPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvS2V6OFhHV0J4V3VlN3FQN25OdkY/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb3JlL2FuaW1hdGlvbi90cy9kc2wvYW5pbWF0aW9uX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpZ2dlcihuYW1lLCBhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25FbnRyeU1ldGFkYXRhKG5hbWUsIGFuaW1hdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUZpbmFsQW5pbWF0aW9uU3R5bGVzKHByZXZpb3VzU3R5bGVzLCBuZXdTdHlsZXMsIG51bGxWYWx1ZSkge1xuICAgICAgICBpZiAobnVsbFZhbHVlID09PSB2b2lkIDApIHsgbnVsbFZhbHVlID0gbnVsbDsgfVxuICAgICAgICB2YXIgZmluYWxTdHlsZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMobmV3U3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICBmaW5hbFN0eWxlc1twcm9wXSA9IHZhbHVlID09IEFVVE9fU1RZTEUgPyBudWxsVmFsdWUgOiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXMocHJldmlvdXNTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGZpbmFsU3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIGZpbmFsU3R5bGVzW3Byb3BdID0gbnVsbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsU3R5bGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYWxhbmNlQW5pbWF0aW9uS2V5ZnJhbWVzKGNvbGxlY3RlZFN0eWxlcywgZmluYWxTdGF0ZVN0eWxlcywga2V5ZnJhbWVzKSB7XG4gICAgICAgIHZhciBsaW1pdCA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgZmlyc3RLZXlmcmFtZSA9IGtleWZyYW1lc1swXTtcbiAgICAgICAgLy8gcGhhc2UgMTogY29weSBhbGwgdGhlIHN0eWxlcyBmcm9tIHRoZSBmaXJzdCBrZXlmcmFtZSBpbnRvIHRoZSBsb29rdXAgbWFwXG4gICAgICAgIHZhciBmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXMgPSBmbGF0dGVuU3R5bGVzKGZpcnN0S2V5ZnJhbWUuc3R5bGVzLnN0eWxlcyk7XG4gICAgICAgIHZhciBleHRyYUZpcnN0S2V5ZnJhbWVTdHlsZXMgPSB7fTtcbiAgICAgICAgdmFyIGhhc0V4dHJhRmlyc3RTdHlsZXMgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmtleXMoY29sbGVjdGVkU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xsZWN0ZWRTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAvLyBpZiB0aGUgc3R5bGUgaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBmaXJzdCBrZXlmcmFtZSB0aGVuXG4gICAgICAgICAgICAvLyB3ZSBkbyBub3QgcmVwbGFjZSBpdC5cbiAgICAgICAgICAgIGlmICghZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgZmxhdGVuZWRGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZXh0cmFGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaGFzRXh0cmFGaXJzdFN0eWxlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIga2V5ZnJhbWVDb2xsZWN0ZWRTdHlsZXMgPSBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKHt9LCBmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXMpO1xuICAgICAgICAvLyBwaGFzZSAyOiBub3JtYWxpemUgdGhlIGZpbmFsIGtleWZyYW1lXG4gICAgICAgIHZhciBmaW5hbEtleWZyYW1lID0ga2V5ZnJhbWVzW2xpbWl0XTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0KGZpbmFsS2V5ZnJhbWUuc3R5bGVzLnN0eWxlcywgMCwgZmluYWxTdGF0ZVN0eWxlcyk7XG4gICAgICAgIHZhciBmbGF0ZW5lZEZpbmFsS2V5ZnJhbWVTdHlsZXMgPSBmbGF0dGVuU3R5bGVzKGZpbmFsS2V5ZnJhbWUuc3R5bGVzLnN0eWxlcyk7XG4gICAgICAgIHZhciBleHRyYUZpbmFsS2V5ZnJhbWVTdHlsZXMgPSB7fTtcbiAgICAgICAgdmFyIGhhc0V4dHJhRmluYWxTdHlsZXMgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LmtleXMoa2V5ZnJhbWVDb2xsZWN0ZWRTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGZsYXRlbmVkRmluYWxLZXlmcmFtZVN0eWxlc1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICBleHRyYUZpbmFsS2V5ZnJhbWVTdHlsZXNbcHJvcF0gPSBBVVRPX1NUWUxFO1xuICAgICAgICAgICAgICAgIGhhc0V4dHJhRmluYWxTdHlsZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0V4dHJhRmluYWxTdHlsZXMpIHtcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWUuc3R5bGVzLnN0eWxlcy5wdXNoKGV4dHJhRmluYWxLZXlmcmFtZVN0eWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoZmxhdGVuZWRGaW5hbEtleWZyYW1lU3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChmbGF0ZW5lZEZpcnN0S2V5ZnJhbWVTdHlsZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFGaXJzdEtleWZyYW1lU3R5bGVzW3Byb3BdID0gQVVUT19TVFlMRTtcbiAgICAgICAgICAgICAgICBoYXNFeHRyYUZpcnN0U3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNFeHRyYUZpcnN0U3R5bGVzKSB7XG4gICAgICAgICAgICBmaXJzdEtleWZyYW1lLnN0eWxlcy5zdHlsZXMucHVzaChleHRyYUZpcnN0S2V5ZnJhbWVTdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyU3R5bGVzKHN0eWxlcykge1xuICAgICAgICB2YXIgZmluYWxTdHlsZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZmluYWxTdHlsZXNba2V5XSA9IG51bGw7IH0pO1xuICAgICAgICByZXR1cm4gZmluYWxTdHlsZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzKGNvbGxlY3Rpb24sIHN0eWxlcykge1xuICAgICAgICByZXR1cm4gc3R5bGVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXNPYmogPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZW50cnlbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IEZJTExfU1RZTEVfRkxBRykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbGxlY3Rpb25bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBBVVRPX1NUWUxFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25bcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBzdHlsZXNPYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlc09iajtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlclN0eWxlcyhlbGVtZW50LCByZW5kZXJlciwgc3R5bGVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZW5kZXJlci5zZXRFbGVtZW50U3R5bGUoZWxlbWVudCwgcHJvcCwgc3R5bGVzW3Byb3BdKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5TdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIHZhciBmaW5hbFN0eWxlcyA9IHt9O1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7IGZpbmFsU3R5bGVzW3Byb3BdID0gZW50cnlbcHJvcF07IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsU3R5bGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uU3R5bGVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uU3R5bGVzKHN0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuaW1hdGlvblN0eWxlcztcbiAgICB9KCkpO1xuXG4gICAgdmFyIERlYnVnRG9tUm9vdFJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdEb21Sb290UmVuZGVyZXIoX2RlbGVnYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IF9kZWxlZ2F0ZTtcbiAgICAgICAgfVxuICAgICAgICBEZWJ1Z0RvbVJvb3RSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudFByb3RvKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlYnVnRG9tUmVuZGVyZXIodGhpcy5fZGVsZWdhdGUucmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudFByb3RvKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWJ1Z0RvbVJvb3RSZW5kZXJlcjtcbiAgICB9KCkpO1xuICAgIHZhciBEZWJ1Z0RvbVJlbmRlcmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdEb21SZW5kZXJlcihfZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlID0gX2RlbGVnYXRlO1xuICAgICAgICB9XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLnNlbGVjdFJvb3RFbGVtZW50ID0gZnVuY3Rpb24gKHNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVFbCA9IHRoaXMuX2RlbGVnYXRlLnNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBuZXcgRGVidWdFbGVtZW50KG5hdGl2ZUVsLCBudWxsLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlRWw7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgbmFtZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlRWwgPSB0aGlzLl9kZWxlZ2F0ZS5jcmVhdGVFbGVtZW50KHBhcmVudEVsZW1lbnQsIG5hbWUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z0VsZW1lbnQobmF0aXZlRWwsIGdldERlYnVnTm9kZShwYXJlbnRFbGVtZW50KSwgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIGRlYnVnRWwubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBpbmRleERlYnVnTm9kZShkZWJ1Z0VsKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVFbDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVmlld1Jvb3QgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQpIHsgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVZpZXdSb290KGhvc3RFbGVtZW50KTsgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGVtcGxhdGVBbmNob3IgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVRlbXBsYXRlQW5jaG9yKHBhcmVudEVsZW1lbnQsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z05vZGUoY29tbWVudCwgZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCB2YWx1ZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2RlbGVnYXRlLmNyZWF0ZVRleHQocGFyZW50RWxlbWVudCwgdmFsdWUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IG5ldyBEZWJ1Z05vZGUodGV4dCwgZ2V0RGVidWdOb2RlKHBhcmVudEVsZW1lbnQpLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgaW5kZXhEZWJ1Z05vZGUoZGVidWdFbCk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUucHJvamVjdE5vZGVzID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIG5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdQYXJlbnQgPSBnZXREZWJ1Z05vZGUocGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnUGFyZW50KSAmJiBkZWJ1Z1BhcmVudCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z0VsZW1lbnRfMSA9IGRlYnVnUGFyZW50O1xuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgZGVidWdFbGVtZW50XzEuYWRkQ2hpbGQoZ2V0RGVidWdOb2RlKG5vZGUpKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5wcm9qZWN0Tm9kZXMocGFyZW50RWxlbWVudCwgbm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hWaWV3QWZ0ZXIgPSBmdW5jdGlvbiAobm9kZSwgdmlld1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgdmFyIGRlYnVnTm9kZSA9IGdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdOb2RlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z1BhcmVudCA9IGRlYnVnTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdSb290Tm9kZXMubGVuZ3RoID4gMCAmJiBpc1ByZXNlbnQoZGVidWdQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWJ1Z1ZpZXdSb290Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmlld1Jvb3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb290Tm9kZSkgeyByZXR1cm4gZGVidWdWaWV3Um9vdE5vZGVzLnB1c2goZ2V0RGVidWdOb2RlKHJvb3ROb2RlKSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z1BhcmVudC5pbnNlcnRDaGlsZHJlbkFmdGVyKGRlYnVnTm9kZSwgZGVidWdWaWV3Um9vdE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5hdHRhY2hWaWV3QWZ0ZXIobm9kZSwgdmlld1Jvb3ROb2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmRldGFjaFZpZXcgPSBmdW5jdGlvbiAodmlld1Jvb3ROb2Rlcykge1xuICAgICAgICAgICAgdmlld1Jvb3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlYnVnTm9kZSA9IGdldERlYnVnTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnTm9kZSkgJiYgaXNQcmVzZW50KGRlYnVnTm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTm9kZS5wYXJlbnQucmVtb3ZlQ2hpbGQoZGVidWdOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLmRldGFjaFZpZXcodmlld1Jvb3ROb2Rlcyk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3lWaWV3ID0gZnVuY3Rpb24gKGhvc3RFbGVtZW50LCB2aWV3QWxsTm9kZXMpIHtcbiAgICAgICAgICAgIHZpZXdBbGxOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJlbW92ZURlYnVnTm9kZUZyb21JbmRleChnZXREZWJ1Z05vZGUobm9kZSkpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lWaWV3KGhvc3RFbGVtZW50LCB2aWV3QWxsTm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBkZWJ1Z0VsID0gZ2V0RGVidWdOb2RlKHJlbmRlckVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChkZWJ1Z0VsKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwubGlzdGVuZXJzLnB1c2gobmV3IEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5saXN0ZW4ocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW5HbG9iYWwgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmxpc3Rlbkdsb2JhbCh0YXJnZXQsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudFByb3BlcnR5ID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5zZXRFbGVtZW50UHJvcGVydHkocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLnNldEVsZW1lbnRBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRCaW5kaW5nRGVidWdJbmZvID0gZnVuY3Rpb24gKHJlbmRlckVsZW1lbnQsIHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0QmluZGluZ0RlYnVnSW5mbyhyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3MgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnRWwgPSBnZXREZWJ1Z05vZGUocmVuZGVyRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGRlYnVnRWwpICYmIGRlYnVnRWwgaW5zdGFuY2VvZiBEZWJ1Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0VsLmNsYXNzZXNbY2xhc3NOYW1lXSA9IGlzQWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudENsYXNzKHJlbmRlckVsZW1lbnQsIGNsYXNzTmFtZSwgaXNBZGQpO1xuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0RvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGVidWdFbCA9IGdldERlYnVnTm9kZShyZW5kZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZGVidWdFbCkgJiYgZGVidWdFbCBpbnN0YW5jZW9mIERlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlYnVnRWwuc3R5bGVzW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuc2V0RWxlbWVudFN0eWxlKHJlbmRlckVsZW1lbnQsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmludm9rZUVsZW1lbnRNZXRob2QgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbWV0aG9kTmFtZSwgYXJncykge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUuaW52b2tlRWxlbWVudE1ldGhvZChyZW5kZXJFbGVtZW50LCBtZXRob2ROYW1lLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0VGV4dCA9IGZ1bmN0aW9uIChyZW5kZXJOb2RlLCB0ZXh0KSB7IHRoaXMuX2RlbGVnYXRlLnNldFRleHQocmVuZGVyTm9kZSwgdGV4dCk7IH07XG4gICAgICAgIERlYnVnRG9tUmVuZGVyZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5hbmltYXRlKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERlYnVnRG9tUmVuZGVyZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBTdGF0aWNOb2RlRGVidWdJbmZvID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RhdGljTm9kZURlYnVnSW5mbyhwcm92aWRlclRva2VucywgY29tcG9uZW50VG9rZW4sIHJlZlRva2Vucykge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlclRva2VucyA9IHByb3ZpZGVyVG9rZW5zO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRUb2tlbiA9IGNvbXBvbmVudFRva2VuO1xuICAgICAgICAgICAgdGhpcy5yZWZUb2tlbnMgPSByZWZUb2tlbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0YXRpY05vZGVEZWJ1Z0luZm87XG4gICAgfSgpKTtcbiAgICB2YXIgRGVidWdDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVidWdDb250ZXh0KF92aWV3LCBfbm9kZUluZGV4LCBfdHBsUm93LCBfdHBsQ29sKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3ID0gX3ZpZXc7XG4gICAgICAgICAgICB0aGlzLl9ub2RlSW5kZXggPSBfbm9kZUluZGV4O1xuICAgICAgICAgICAgdGhpcy5fdHBsUm93ID0gX3RwbFJvdztcbiAgICAgICAgICAgIHRoaXMuX3RwbENvbCA9IF90cGxDb2w7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiX3N0YXRpY05vZGVJbmZvXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fbm9kZUluZGV4KSA/IHRoaXMuX3ZpZXcuc3RhdGljTm9kZURlYnVnSW5mb3NbdGhpcy5fbm9kZUluZGV4XSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZpZXcuY29udGV4dDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImNvbXBvbmVudFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGljTm9kZUluZm8gPSB0aGlzLl9zdGF0aWNOb2RlSW5mbztcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHN0YXRpY05vZGVJbmZvKSAmJiBpc1ByZXNlbnQoc3RhdGljTm9kZUluZm8uY29tcG9uZW50VG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yLmdldChzdGF0aWNOb2RlSW5mby5jb21wb25lbnRUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImNvbXBvbmVudFJlbmRlckVsZW1lbnRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFZpZXcgPSB0aGlzLl92aWV3O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpc1ByZXNlbnQoY29tcG9uZW50Vmlldy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcudHlwZSAhPT0gVmlld1R5cGUuQ09NUE9ORU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcgPSBjb21wb25lbnRWaWV3LmRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGNvbXBvbmVudFZpZXcuZGVjbGFyYXRpb25BcHBFbGVtZW50KSA/XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXcuZGVjbGFyYXRpb25BcHBFbGVtZW50Lm5hdGl2ZUVsZW1lbnQgOlxuICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcImluamVjdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdmlldy5pbmplY3Rvcih0aGlzLl9ub2RlSW5kZXgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlYnVnQ29udGV4dC5wcm90b3R5cGUsIFwicmVuZGVyTm9kZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX25vZGVJbmRleCkgJiYgdGhpcy5fdmlldy5hbGxOb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5hbGxOb2Rlc1t0aGlzLl9ub2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcInByb3ZpZGVyVG9rZW5zXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0aWNOb2RlSW5mbyA9IHRoaXMuX3N0YXRpY05vZGVJbmZvO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoc3RhdGljTm9kZUluZm8pID8gc3RhdGljTm9kZUluZm8ucHJvdmlkZXJUb2tlbnMgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWJ1Z0NvbnRleHQucHJvdG90eXBlLCBcInNvdXJjZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5jb21wb25lbnRUeXBlLnRlbXBsYXRlVXJsICsgXCI6XCIgKyB0aGlzLl90cGxSb3cgKyBcIjpcIiArIHRoaXMuX3RwbENvbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVidWdDb250ZXh0LnByb3RvdHlwZSwgXCJyZWZlcmVuY2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHZhclZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBzdGF0aWNOb2RlSW5mbyA9IHRoaXMuX3N0YXRpY05vZGVJbmZvO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RhdGljTm9kZUluZm8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWZzID0gc3RhdGljTm9kZUluZm8ucmVmVG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZWZzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWZOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmVG9rZW4gPSByZWZzW3JlZk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhclZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsocmVmVG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyVmFsdWUgPSBfdGhpcy5fdmlldy5hbGxOb2RlcyA/IF90aGlzLl92aWV3LmFsbE5vZGVzW190aGlzLl9ub2RlSW5kZXhdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclZhbHVlID0gX3RoaXMuX3ZpZXcuaW5qZWN0b3JHZXQocmVmVG9rZW4sIF90aGlzLl9ub2RlSW5kZXgsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyVmFsdWVzW3JlZk5hbWVdID0gdmFyVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyVmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBEZWJ1Z0NvbnRleHQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGlzIHJldHVybmVkIGFzIGFuIGV2ZW50IHBhcmFtZXRlciB3aGVuIGFuIGFuaW1hdGlvblxuICAgICAqIGNhbGxiYWNrIGlzIGNhcHR1cmVkIGZvciBhbiBhbmltYXRpb24gZWl0aGVyIGR1cmluZyB0aGUgc3RhcnQgb3IgZG9uZSBwaGFzZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAQ29tcG9uZW50KHtcbiAgICAgKiAgIGhvc3Q6IHtcbiAgICAgKiAgICAgJ1tAbXlBbmltYXRpb25UcmlnZ2VyXSc6ICdzb21lRXhwcmVzc2lvbicsXG4gICAgICogICAgICcoQG15QW5pbWF0aW9uVHJpZ2dlci5zdGFydCknOiAnY2FwdHVyZVN0YXJ0RXZlbnQoJGV2ZW50KScsXG4gICAgICogICAgICcoQG15QW5pbWF0aW9uVHJpZ2dlci5kb25lKSc6ICdjYXB0dXJlRG9uZUV2ZW50KCRldmVudCknLFxuICAgICAqICAgfSxcbiAgICAgKiAgIGFuaW1hdGlvbnM6IFtcbiAgICAgKiAgICAgdHJpZ2dlcihcIm15QW5pbWF0aW9uVHJpZ2dlclwiLCBbXG4gICAgICogICAgICAgIC8vIC4uLlxuICAgICAqICAgICBdKVxuICAgICAqICAgXVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTXlDb21wb25lbnQge1xuICAgICAqICAgc29tZUV4cHJlc3Npb246IGFueSA9IGZhbHNlO1xuICAgICAqICAgY2FwdHVyZVN0YXJ0RXZlbnQoZXZlbnQ6IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCkge1xuICAgICAqICAgICAvLyB0aGUgdG9TdGF0ZSwgZnJvbVN0YXRlIGFuZCB0b3RhbFRpbWUgZGF0YSBpcyBhY2Nlc3NpYmxlIGZyb20gdGhlIGV2ZW50IHZhcmlhYmxlXG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiAgIGNhcHR1cmVEb25lRXZlbnQoZXZlbnQ6IEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCkge1xuICAgICAqICAgICAvLyB0aGUgdG9TdGF0ZSwgZnJvbVN0YXRlIGFuZCB0b3RhbFRpbWUgZGF0YSBpcyBhY2Nlc3NpYmxlIGZyb20gdGhlIGV2ZW50IHZhcmlhYmxlXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBBbmltYXRpb24gc3VwcG9ydCBpcyBleHBlcmltZW50YWwuXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvblRyYW5zaXRpb25FdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvblRyYW5zaXRpb25FdmVudChfYSkge1xuICAgICAgICAgICAgdmFyIGZyb21TdGF0ZSA9IF9hLmZyb21TdGF0ZSwgdG9TdGF0ZSA9IF9hLnRvU3RhdGUsIHRvdGFsVGltZSA9IF9hLnRvdGFsVGltZTtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0YXRlID0gZnJvbVN0YXRlO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRlID0gdG9TdGF0ZTtcbiAgICAgICAgICAgIHRoaXMudG90YWxUaW1lID0gdG90YWxUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmltYXRpb25UcmFuc2l0aW9uRXZlbnQ7XG4gICAgfSgpKTtcblxuICAgIHZhciBWaWV3QW5pbWF0aW9uTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmlld0FuaW1hdGlvbk1hcCgpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX2FsbFBsYXllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0FuaW1hdGlvbk1hcC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5nZXRBbGxQbGF5ZXJzKCkubGVuZ3RoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgVmlld0FuaW1hdGlvbk1hcC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb25OYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGxheWVyc0J5QW5pbWF0aW9uID0gdGhpcy5fbWFwLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGxheWVyc0J5QW5pbWF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbGF5ZXJzQnlBbmltYXRpb25bYW5pbWF0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFZpZXdBbmltYXRpb25NYXAucHJvdG90eXBlLmZpbmRBbGxQbGF5ZXJzQnlFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZWwgPyBPYmplY3Qua2V5cyhlbCkubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBlbFtrXTsgfSkgOiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgVmlld0FuaW1hdGlvbk1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUsIHBsYXllcikge1xuICAgICAgICAgICAgdmFyIHBsYXllcnNCeUFuaW1hdGlvbiA9IHRoaXMuX21hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudChwbGF5ZXJzQnlBbmltYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgcGxheWVyc0J5QW5pbWF0aW9uID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdFbnRyeSA9IHBsYXllcnNCeUFuaW1hdGlvblthbmltYXRpb25OYW1lXTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXhpc3RpbmdFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShlbGVtZW50LCBhbmltYXRpb25OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsYXllcnNCeUFuaW1hdGlvblthbmltYXRpb25OYW1lXSA9IHBsYXllcjtcbiAgICAgICAgICAgIHRoaXMuX2FsbFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgdGhpcy5fbWFwLnNldChlbGVtZW50LCBwbGF5ZXJzQnlBbmltYXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBWaWV3QW5pbWF0aW9uTWFwLnByb3RvdHlwZS5nZXRBbGxQbGF5ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYWxsUGxheWVyczsgfTtcbiAgICAgICAgVmlld0FuaW1hdGlvbk1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIHZhciBwbGF5ZXJzQnlBbmltYXRpb24gPSB0aGlzLl9tYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHBsYXllcnNCeUFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBwbGF5ZXIgPSBwbGF5ZXJzQnlBbmltYXRpb25bYW5pbWF0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsYXllcnNCeUFuaW1hdGlvblthbmltYXRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9hbGxQbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxQbGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBsYXllcnNCeUFuaW1hdGlvbikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVmlld0FuaW1hdGlvbk1hcDtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTUgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgX1VOREVGSU5FRCQxID0gbmV3IE9iamVjdCgpO1xuICAgIHZhciBFbGVtZW50SW5qZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTUoRWxlbWVudEluamVjdG9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFbGVtZW50SW5qZWN0b3IoX3ZpZXcsIF9ub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdmlldyA9IF92aWV3O1xuICAgICAgICAgICAgdGhpcy5fbm9kZUluZGV4ID0gX25vZGVJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBFbGVtZW50SW5qZWN0b3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm90Rm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5vdEZvdW5kVmFsdWUgPT09IHZvaWQgMCkgeyBub3RGb3VuZFZhbHVlID0gVEhST1dfSUZfTk9UX0ZPVU5EOyB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX1VOREVGSU5FRCQxO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gX1VOREVGSU5FRCQxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fdmlldy5pbmplY3RvckdldCh0b2tlbiwgdGhpcy5fbm9kZUluZGV4LCBfVU5ERUZJTkVEJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gX1VOREVGSU5FRCQxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fdmlldy5wYXJlbnRJbmplY3Rvci5nZXQodG9rZW4sIG5vdEZvdW5kVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRJbmplY3RvcjtcbiAgICB9KEluamVjdG9yKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBfc2NvcGVfY2hlY2sgPSB3dGZDcmVhdGVTY29wZShcIkFwcFZpZXcjY2hlY2soYXNjaWkgaWQpXCIpO1xuICAgIC8qKlxuICAgICAqIENvc3Qgb2YgbWFraW5nIG9iamVjdHM6IGh0dHA6Ly9qc3BlcmYuY29tL2luc3RhbnRpYXRlLXNpemUtb2Ytb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgQXBwVmlldyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFwcFZpZXcoY2xhenosIGNvbXBvbmVudFR5cGUsIHR5cGUsIHZpZXdVdGlscywgcGFyZW50SW5qZWN0b3IsIGRlY2xhcmF0aW9uQXBwRWxlbWVudCwgY2RNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXp6ID0gY2xheno7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRoaXMudmlld1V0aWxzID0gdmlld1V0aWxzO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRJbmplY3RvciA9IHBhcmVudEluamVjdG9yO1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQgPSBkZWNsYXJhdGlvbkFwcEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmNkTW9kZSA9IGNkTW9kZTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudENoaWxkcmVuID0gW107XG4gICAgICAgICAgICB0aGlzLnZpZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQ2hlY2tzID0gMDtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUGxheWVycyA9IG5ldyBWaWV3QW5pbWF0aW9uTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9hbmltYXRpb25MaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IG5ldyBWaWV3UmVmXyh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQgfHwgdHlwZSA9PT0gVmlld1R5cGUuSE9TVCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSB2aWV3VXRpbHMucmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IGRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3LnJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJkZXN0cm95ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGVzdHJveWVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuY2FuY2VsQWN0aXZlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUsIHJlbW92ZUFsbEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChyZW1vdmVBbGxBbmltYXRpb25zID09PSB2b2lkIDApIHsgcmVtb3ZlQWxsQW5pbWF0aW9ucyA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAocmVtb3ZlQWxsQW5pbWF0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUGxheWVycy5maW5kQWxsUGxheWVyc0J5RWxlbWVudChlbGVtZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChwbGF5ZXIpIHsgcmV0dXJuIHBsYXllci5kZXN0cm95KCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYXllciA9IHRoaXMuYW5pbWF0aW9uUGxheWVycy5maW5kKGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGxheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUucXVldWVBbmltYXRpb24gPSBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSwgcGxheWVyLCB0b3RhbFRpbWUsIGZyb21TdGF0ZSwgdG9TdGF0ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHF1ZXVlQW5pbWF0aW9uKHBsYXllcik7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50KHsgJ2Zyb21TdGF0ZSc6IGZyb21TdGF0ZSwgJ3RvU3RhdGUnOiB0b1N0YXRlLCAndG90YWxUaW1lJzogdG90YWxUaW1lIH0pO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25QbGF5ZXJzLnNldChlbGVtZW50LCBhbmltYXRpb25OYW1lLCBwbGF5ZXIpO1xuICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbWFrZSB0aGlzIGludG8gYSBkYXRhc3RydWN0dXJlIGZvciBkb25lfHN0YXJ0XG4gICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckFuaW1hdGlvbk91dHB1dChlbGVtZW50LCBhbmltYXRpb25OYW1lLCAnZG9uZScsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hbmltYXRpb25QbGF5ZXJzLnJlbW92ZShlbGVtZW50LCBhbmltYXRpb25OYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoZnVuY3Rpb24gKCkgeyBfdGhpcy50cmlnZ2VyQW5pbWF0aW9uT3V0cHV0KGVsZW1lbnQsIGFuaW1hdGlvbk5hbWUsICdzdGFydCcsIGV2ZW50KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLnRyaWdnZXJBbmltYXRpb25PdXRwdXQgPSBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uTmFtZSwgcGhhc2UsIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fYW5pbWF0aW9uTGlzdGVuZXJzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobGlzdGVuZXJzKSAmJiBsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjaGVjayBmb3IgYm90aCB0aGUgbmFtZSBpbiBhZGRpdGlvbiB0byB0aGUgcGhhc2UgaW4gdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgQHRyaWdnZXIgb24gdGhlIHNhbWUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIuZXZlbnROYW1lID09PSBhbmltYXRpb25OYW1lICYmIGxpc3RlbmVyLmV2ZW50UGhhc2UgPT09IHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5yZWdpc3RlckFuaW1hdGlvbk91dHB1dCA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGV2ZW50UGhhc2UsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLl9hbmltYXRpb25MaXN0ZW5lcnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFpc1ByZXNlbnQoYW5pbWF0aW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25MaXN0ZW5lcnMuc2V0KGVsZW1lbnQsIGFuaW1hdGlvbnMgPSBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2gobmV3IF9BbmltYXRpb25PdXRwdXRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRQaGFzZSwgZXZlbnRIYW5kbGVyKSk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBnaXZlblByb2plY3RhYmxlTm9kZXMsIHJvb3RTZWxlY3Rvck9yTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0YWJsZU5vZGVzO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFZpZXdUeXBlLkNPTVBPTkVOVDpcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdGFibGVOb2RlcyA9IGVuc3VyZVNsb3RDb3VudChnaXZlblByb2plY3RhYmxlTm9kZXMsIHRoaXMuY29tcG9uZW50VHlwZS5zbG90Q291bnQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFZpZXdUeXBlLkVNQkVEREVEOlxuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0YWJsZU5vZGVzID0gdGhpcy5kZWNsYXJhdGlvbkFwcEVsZW1lbnQucGFyZW50Vmlldy5wcm9qZWN0YWJsZU5vZGVzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFZpZXdUeXBlLkhPU1Q6XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IERvbid0IGVuc3VyZSB0aGUgc2xvdCBjb3VudCBmb3IgdGhlIHByb2plY3RhYmxlTm9kZXMgYXMgd2Ugc3RvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbSBvbmx5IGZvciB0aGUgY29udGFpbmVkIGNvbXBvbmVudCB2aWV3ICh3aGljaCB3aWxsIGxhdGVyIGNoZWNrIHRoZSBzbG90IGNvdW50Li4uKVxuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0YWJsZU5vZGVzID0gZ2l2ZW5Qcm9qZWN0YWJsZU5vZGVzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2hhc0V4dGVybmFsSG9zdEVsZW1lbnQgPSBpc1ByZXNlbnQocm9vdFNlbGVjdG9yT3JOb2RlKTtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGFibGVOb2RlcyA9IHByb2plY3RhYmxlTm9kZXM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnRlcm5hbChyb290U2VsZWN0b3JPck5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zLlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBBcHBFbGVtZW50IGZvciB0aGUgaG9zdCBlbGVtZW50IGZvciBWaWV3VHlwZS5IT1NULlxuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuY3JlYXRlSW50ZXJuYWwgPSBmdW5jdGlvbiAocm9vdFNlbGVjdG9yT3JOb2RlKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHJvb3ROb2Rlc09yQXBwRWxlbWVudHMsIGFsbE5vZGVzLCBkaXNwb3NhYmxlcywgc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzID0gcm9vdE5vZGVzT3JBcHBFbGVtZW50cztcbiAgICAgICAgICAgIHRoaXMuYWxsTm9kZXMgPSBhbGxOb2RlcztcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZXMgPSBkaXNwb3NhYmxlcztcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHN1YnNjcmlwdGlvbnM7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGUgcmVuZGVyIG5vZGVzIGhhdmUgYmVlbiBhdHRhY2hlZCB0byB0aGVpciBob3N0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgVmlld0ZhY3RvcnkgYWxyZWFkeS5cbiAgICAgICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3LnZpZXdDaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuc2VsZWN0T3JDcmVhdGVIb3N0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgcm9vdFNlbGVjdG9yT3JOb2RlLCBkZWJ1Z0luZm8pIHtcbiAgICAgICAgICAgIHZhciBob3N0RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocm9vdFNlbGVjdG9yT3JOb2RlKSkge1xuICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50ID0gdGhpcy5yZW5kZXJlci5zZWxlY3RSb290RWxlbWVudChyb290U2VsZWN0b3JPck5vZGUsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBob3N0RWxlbWVudCA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudChudWxsLCBlbGVtZW50TmFtZSwgZGVidWdJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3N0RWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuaW5qZWN0b3JHZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluamVjdG9yR2V0SW50ZXJuYWwodG9rZW4sIG5vZGVJbmRleCwgbm90Rm91bmRSZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5pbmplY3RvckdldEludGVybmFsID0gZnVuY3Rpb24gKHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbm90Rm91bmRSZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmluamVjdG9yID0gZnVuY3Rpb24gKG5vZGVJbmRleCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChub2RlSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50SW5qZWN0b3IodGhpcywgbm9kZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudEluamVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc0V4dGVybmFsSG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmRldGFjaFZpZXcodGhpcy5mbGF0Um9vdE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLnZpZXdDb250YWluZXJFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lckVsZW1lbnQuZGV0YWNoVmlldyh0aGlzLnZpZXdDb250YWluZXJFbGVtZW50Lm5lc3RlZFZpZXdzLmluZGV4T2YodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveVJlY3Vyc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuX2Rlc3Ryb3lSZWN1cnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2RNb2RlID09PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNvbnRlbnRDaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5fZGVzdHJveVJlY3Vyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy52aWV3Q2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uX2Rlc3Ryb3lSZWN1cnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lMb2NhbCgpO1xuICAgICAgICAgICAgdGhpcy5jZE1vZGUgPSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXN0cm95ZWQ7XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRlc3Ryb3lMb2NhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaG9zdEVsZW1lbnQgPSB0aGlzLnR5cGUgPT09IFZpZXdUeXBlLkNPTVBPTkVOVCA/IHRoaXMuZGVjbGFyYXRpb25BcHBFbGVtZW50Lm5hdGl2ZUVsZW1lbnQgOiBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpc3Bvc2FibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlc1tpXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbaV0udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVzdHJveUludGVybmFsKCk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25QbGF5ZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95Vmlldyhob3N0RWxlbWVudCwgdGhpcy5hbGxOb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxheWVyID0gbmV3IEFuaW1hdGlvbkdyb3VwUGxheWVyKHRoaXMuYW5pbWF0aW9uUGxheWVycy5nZXRBbGxQbGF5ZXJzKCkpO1xuICAgICAgICAgICAgICAgIHBsYXllci5vbkRvbmUoZnVuY3Rpb24gKCkgeyBfdGhpcy5yZW5kZXJlci5kZXN0cm95Vmlldyhob3N0RWxlbWVudCwgX3RoaXMuYWxsTm9kZXMpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGVzdHJveUludGVybmFsID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcndyaXR0ZW4gYnkgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5kZXRhY2hJbnRlcm5hbCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoSW50ZXJuYWwoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblBsYXllcnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmRldGFjaFZpZXcodGhpcy5mbGF0Um9vdE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwbGF5ZXIgPSBuZXcgQW5pbWF0aW9uR3JvdXBQbGF5ZXIodGhpcy5hbmltYXRpb25QbGF5ZXJzLmdldEFsbFBsYXllcnMoKSk7XG4gICAgICAgICAgICAgICAgcGxheWVyLm9uRG9uZShmdW5jdGlvbiAoKSB7IF90aGlzLnJlbmRlcmVyLmRldGFjaFZpZXcoX3RoaXMuZmxhdFJvb3ROb2Rlcyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwVmlldy5wcm90b3R5cGUsIFwiY2hhbmdlRGV0ZWN0b3JSZWZcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJlZjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmRlY2xhcmF0aW9uQXBwRWxlbWVudCkgPyB0aGlzLmRlY2xhcmF0aW9uQXBwRWxlbWVudC5wYXJlbnRWaWV3IDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwVmlldy5wcm90b3R5cGUsIFwiZmxhdFJvb3ROb2Rlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXModGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBWaWV3LnByb3RvdHlwZSwgXCJsYXN0Um9vdE5vZGVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gdGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3ROb2Rlc09yQXBwRWxlbWVudHNbdGhpcy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLmxlbmd0aCAtIDFdIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmRMYXN0UmVuZGVyTm9kZShsYXN0Tm9kZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIHMgPSBfc2NvcGVfY2hlY2sodGhpcy5jbGF6eik7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRXJyb3JlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGhyb3dEZXN0cm95ZWRFcnJvcignZGV0ZWN0Q2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzSW50ZXJuYWwodGhyb3dPbkNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZSlcbiAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQ2hlY2tzKys7XG4gICAgICAgICAgICB3dGZMZWF2ZShzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE92ZXJ3cml0dGVuIGJ5IGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q2hhbmdlc0ludGVybmFsID0gZnVuY3Rpb24gKHRocm93T25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q29udGVudENoaWxkcmVuQ2hhbmdlcyh0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0Vmlld0NoaWxkcmVuQ2hhbmdlcyh0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZGV0ZWN0Q29udGVudENoaWxkcmVuQ2hhbmdlcyA9IGZ1bmN0aW9uICh0aHJvd09uQ2hhbmdlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudENoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jb250ZW50Q2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuRGV0YWNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkLmRldGVjdENoYW5nZXModGhyb3dPbkNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLmRldGVjdFZpZXdDaGlsZHJlbkNoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZpZXdDaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMudmlld0NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jZE1vZGUgPT09IENoYW5nZURldGVjdG9yU3RhdHVzLkRldGFjaGVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXRlY3RDaGFuZ2VzKHRocm93T25DaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBcHBWaWV3LnByb3RvdHlwZS5tYXJrQ29udGVudENoaWxkQXNNb3ZlZCA9IGZ1bmN0aW9uIChyZW5kZXJBcHBFbGVtZW50KSB7IHRoaXMuZGlydHlQYXJlbnRRdWVyaWVzSW50ZXJuYWwoKTsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuYWRkVG9Db250ZW50Q2hpbGRyZW4gPSBmdW5jdGlvbiAocmVuZGVyQXBwRWxlbWVudCkge1xuICAgICAgICAgICAgcmVuZGVyQXBwRWxlbWVudC5wYXJlbnRWaWV3LmNvbnRlbnRDaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyRWxlbWVudCA9IHJlbmRlckFwcEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmRpcnR5UGFyZW50UXVlcmllc0ludGVybmFsKCk7XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLnJlbW92ZUZyb21Db250ZW50Q2hpbGRyZW4gPSBmdW5jdGlvbiAocmVuZGVyQXBwRWxlbWVudCkge1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlKHJlbmRlckFwcEVsZW1lbnQucGFyZW50Vmlldy5jb250ZW50Q2hpbGRyZW4sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eVBhcmVudFF1ZXJpZXNJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLm1hcmtBc0NoZWNrT25jZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5jZE1vZGUgPSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5DaGVja09uY2U7IH07XG4gICAgICAgIEFwcFZpZXcucHJvdG90eXBlLm1hcmtQYXRoVG9Sb290QXNDaGVja09uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoaXNQcmVzZW50KGMpICYmIGMuY2RNb2RlICE9PSBDaGFuZ2VEZXRlY3RvclN0YXR1cy5EZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgIGlmIChjLmNkTW9kZSA9PT0gQ2hhbmdlRGV0ZWN0b3JTdGF0dXMuQ2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBjLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkNoZWNrT25jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gYy50eXBlID09PSBWaWV3VHlwZS5DT01QT05FTlQgPyBjLmRlY2xhcmF0aW9uQXBwRWxlbWVudCA6IGMudmlld0NvbnRhaW5lckVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgYyA9IGlzUHJlc2VudChwYXJlbnRFbCkgPyBwYXJlbnRFbC5wYXJlbnRWaWV3IDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUuZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYjsgfTtcbiAgICAgICAgQXBwVmlldy5wcm90b3R5cGUudGhyb3dEZXN0cm95ZWRFcnJvciA9IGZ1bmN0aW9uIChkZXRhaWxzKSB7IHRocm93IG5ldyBWaWV3RGVzdHJveWVkRXJyb3IoZGV0YWlscyk7IH07XG4gICAgICAgIHJldHVybiBBcHBWaWV3O1xuICAgIH0oKSk7XG4gICAgdmFyIERlYnVnQXBwVmlldyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxNChEZWJ1Z0FwcFZpZXcsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERlYnVnQXBwVmlldyhjbGF6eiwgY29tcG9uZW50VHlwZSwgdHlwZSwgdmlld1V0aWxzLCBwYXJlbnRJbmplY3RvciwgZGVjbGFyYXRpb25BcHBFbGVtZW50LCBjZE1vZGUsIHN0YXRpY05vZGVEZWJ1Z0luZm9zKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjbGF6eiwgY29tcG9uZW50VHlwZSwgdHlwZSwgdmlld1V0aWxzLCBwYXJlbnRJbmplY3RvciwgZGVjbGFyYXRpb25BcHBFbGVtZW50LCBjZE1vZGUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0aWNOb2RlRGVidWdJbmZvcyA9IHN0YXRpY05vZGVEZWJ1Z0luZm9zO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudERlYnVnQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZ2l2ZW5Qcm9qZWN0YWJsZU5vZGVzLCByb290U2VsZWN0b3JPck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RGVidWcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY3JlYXRlLmNhbGwodGhpcywgY29udGV4dCwgZ2l2ZW5Qcm9qZWN0YWJsZU5vZGVzLCByb290U2VsZWN0b3JPck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5pbmplY3RvckdldCA9IGZ1bmN0aW9uICh0b2tlbiwgbm9kZUluZGV4LCBub3RGb3VuZFJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5pbmplY3RvckdldC5jYWxsKHRoaXMsIHRva2VuLCBub2RlSW5kZXgsIG5vdEZvdW5kUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRldGFjaC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRocm93V2l0aENvbnRleHQoZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5kZXN0cm95TG9jYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldERlYnVnKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveUxvY2FsLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JldGhyb3dXaXRoQ29udGV4dChlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRldGVjdENoYW5nZXMgPSBmdW5jdGlvbiAodGhyb3dPbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRldGVjdENoYW5nZXMuY2FsbCh0aGlzLCB0aHJvd09uQ2hhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERlYnVnQXBwVmlldy5wcm90b3R5cGUuX3Jlc2V0RGVidWcgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2N1cnJlbnREZWJ1Z0NvbnRleHQgPSBudWxsOyB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG5vZGVJbmRleCwgcm93TnVtLCBjb2xOdW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RGVidWdDb250ZXh0ID0gbmV3IERlYnVnQ29udGV4dCh0aGlzLCBub2RlSW5kZXgsIHJvd051bSwgY29sTnVtKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVidWdBcHBWaWV3LnByb3RvdHlwZS5fcmV0aHJvd1dpdGhDb250ZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBWaWV3V3JhcHBlZEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNkTW9kZSA9IENoYW5nZURldGVjdG9yU3RhdHVzLkVycm9yZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fY3VycmVudERlYnVnQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZpZXdXcmFwcGVkRXJyb3IoZSwgdGhpcy5fY3VycmVudERlYnVnQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEZWJ1Z0FwcFZpZXcucHJvdG90eXBlLmV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBzdXBlckhhbmRsZXIgPSBfc3VwZXIucHJvdG90eXBlLmV2ZW50SGFuZGxlci5jYWxsKHRoaXMsIGNiKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXREZWJ1ZygpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlckhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmV0aHJvd1dpdGhDb250ZXh0KGUpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEZWJ1Z0FwcFZpZXc7XG4gICAgfShBcHBWaWV3KSk7XG4gICAgZnVuY3Rpb24gX2ZpbmRMYXN0UmVuZGVyTm9kZShub2RlKSB7XG4gICAgICAgIHZhciBsYXN0Tm9kZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcHBFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgYXBwRWwgPSBub2RlO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBhcHBFbC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhcHBFbC5uZXN0ZWRWaWV3cykpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBWaWV3cyBtaWdodCBoYXZlIG5vIHJvb3Qgbm9kZXMgYXQgYWxsIVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBhcHBFbC5uZXN0ZWRWaWV3cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmVzdGVkVmlldyA9IGFwcEVsLm5lc3RlZFZpZXdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVzdGVkVmlldy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gX2ZpbmRMYXN0UmVuZGVyTm9kZShuZXN0ZWRWaWV3LnJvb3ROb2Rlc09yQXBwRWxlbWVudHNbbmVzdGVkVmlldy5yb290Tm9kZXNPckFwcEVsZW1lbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdE5vZGU7XG4gICAgfVxuICAgIHZhciBfQW5pbWF0aW9uT3V0cHV0SGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIF9BbmltYXRpb25PdXRwdXRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRQaGFzZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX0FuaW1hdGlvbk91dHB1dEhhbmRsZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBfX2NvcmVfcHJpdmF0ZV9fID0ge1xuICAgICAgICBpc0RlZmF1bHRDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTogaXNEZWZhdWx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgICAgIENoYW5nZURldGVjdG9yU3RhdHVzOiBDaGFuZ2VEZXRlY3RvclN0YXR1cyxcbiAgICAgICAgY29uc3RydWN0RGVwZW5kZW5jaWVzOiBjb25zdHJ1Y3REZXBlbmRlbmNpZXMsXG4gICAgICAgIExpZmVjeWNsZUhvb2tzOiBMaWZlY3ljbGVIb29rcyxcbiAgICAgICAgTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUzogTElGRUNZQ0xFX0hPT0tTX1ZBTFVFUyxcbiAgICAgICAgUmVmbGVjdG9yUmVhZGVyOiBSZWZsZWN0b3JSZWFkZXIsXG4gICAgICAgIENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIEFwcEVsZW1lbnQ6IEFwcEVsZW1lbnQsXG4gICAgICAgIEFwcFZpZXc6IEFwcFZpZXcsXG4gICAgICAgIERlYnVnQXBwVmlldzogRGVidWdBcHBWaWV3LFxuICAgICAgICBOZ01vZHVsZUluamVjdG9yOiBOZ01vZHVsZUluamVjdG9yLFxuICAgICAgICByZWdpc3Rlck1vZHVsZUZhY3Rvcnk6IHJlZ2lzdGVyTW9kdWxlRmFjdG9yeSxcbiAgICAgICAgVmlld1R5cGU6IFZpZXdUeXBlLFxuICAgICAgICBNQVhfSU5URVJQT0xBVElPTl9WQUxVRVM6IE1BWF9JTlRFUlBPTEFUSU9OX1ZBTFVFUyxcbiAgICAgICAgY2hlY2tCaW5kaW5nOiBjaGVja0JpbmRpbmcsXG4gICAgICAgIGZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXM6IGZsYXR0ZW5OZXN0ZWRWaWV3UmVuZGVyTm9kZXMsXG4gICAgICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICAgICAgVmlld1V0aWxzOiBWaWV3VXRpbHMsXG4gICAgICAgIFZpZXdNZXRhZGF0YTogVmlld01ldGFkYXRhLFxuICAgICAgICBEZWJ1Z0NvbnRleHQ6IERlYnVnQ29udGV4dCxcbiAgICAgICAgU3RhdGljTm9kZURlYnVnSW5mbzogU3RhdGljTm9kZURlYnVnSW5mbyxcbiAgICAgICAgZGV2TW9kZUVxdWFsOiBkZXZNb2RlRXF1YWwsXG4gICAgICAgIFVOSU5JVElBTElaRUQ6IFVOSU5JVElBTElaRUQsXG4gICAgICAgIFZhbHVlVW53cmFwcGVyOiBWYWx1ZVVud3JhcHBlcixcbiAgICAgICAgUmVuZGVyRGVidWdJbmZvOiBSZW5kZXJEZWJ1Z0luZm8sXG4gICAgICAgIFRlbXBsYXRlUmVmXzogVGVtcGxhdGVSZWZfLFxuICAgICAgICBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzOiBSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLFxuICAgICAgICBtYWtlRGVjb3JhdG9yOiBtYWtlRGVjb3JhdG9yLFxuICAgICAgICBEZWJ1Z0RvbVJvb3RSZW5kZXJlcjogRGVidWdEb21Sb290UmVuZGVyZXIsXG4gICAgICAgIEVNUFRZX0FSUkFZOiBFTVBUWV9BUlJBWSxcbiAgICAgICAgRU1QVFlfTUFQOiBFTVBUWV9NQVAsXG4gICAgICAgIHB1cmVQcm94eTE6IHB1cmVQcm94eTEsXG4gICAgICAgIHB1cmVQcm94eTI6IHB1cmVQcm94eTIsXG4gICAgICAgIHB1cmVQcm94eTM6IHB1cmVQcm94eTMsXG4gICAgICAgIHB1cmVQcm94eTQ6IHB1cmVQcm94eTQsXG4gICAgICAgIHB1cmVQcm94eTU6IHB1cmVQcm94eTUsXG4gICAgICAgIHB1cmVQcm94eTY6IHB1cmVQcm94eTYsXG4gICAgICAgIHB1cmVQcm94eTc6IHB1cmVQcm94eTcsXG4gICAgICAgIHB1cmVQcm94eTg6IHB1cmVQcm94eTgsXG4gICAgICAgIHB1cmVQcm94eTk6IHB1cmVQcm94eTksXG4gICAgICAgIHB1cmVQcm94eTEwOiBwdXJlUHJveHkxMCxcbiAgICAgICAgY2FzdEJ5VmFsdWU6IGNhc3RCeVZhbHVlLFxuICAgICAgICBDb25zb2xlOiBDb25zb2xlLFxuICAgICAgICByZWZsZWN0b3I6IHJlZmxlY3RvcixcbiAgICAgICAgUmVmbGVjdG9yOiBSZWZsZWN0b3IsXG4gICAgICAgIE5vT3BBbmltYXRpb25QbGF5ZXI6IE5vT3BBbmltYXRpb25QbGF5ZXIsXG4gICAgICAgIEFuaW1hdGlvblBsYXllcjogQW5pbWF0aW9uUGxheWVyLFxuICAgICAgICBBbmltYXRpb25TZXF1ZW5jZVBsYXllcjogQW5pbWF0aW9uU2VxdWVuY2VQbGF5ZXIsXG4gICAgICAgIEFuaW1hdGlvbkdyb3VwUGxheWVyOiBBbmltYXRpb25Hcm91cFBsYXllcixcbiAgICAgICAgQW5pbWF0aW9uS2V5ZnJhbWU6IEFuaW1hdGlvbktleWZyYW1lLFxuICAgICAgICBwcmVwYXJlRmluYWxBbmltYXRpb25TdHlsZXM6IHByZXBhcmVGaW5hbEFuaW1hdGlvblN0eWxlcyxcbiAgICAgICAgYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lczogYmFsYW5jZUFuaW1hdGlvbktleWZyYW1lcyxcbiAgICAgICAgZmxhdHRlblN0eWxlczogZmxhdHRlblN0eWxlcyxcbiAgICAgICAgY2xlYXJTdHlsZXM6IGNsZWFyU3R5bGVzLFxuICAgICAgICByZW5kZXJTdHlsZXM6IHJlbmRlclN0eWxlcyxcbiAgICAgICAgY29sbGVjdEFuZFJlc29sdmVTdHlsZXM6IGNvbGxlY3RBbmRSZXNvbHZlU3R5bGVzLFxuICAgICAgICBBbmltYXRpb25TdHlsZXM6IEFuaW1hdGlvblN0eWxlcyxcbiAgICAgICAgQU5ZX1NUQVRFOiBBTllfU1RBVEUsXG4gICAgICAgIERFRkFVTFRfU1RBVEU6IERFRkFVTFRfU1RBVEUsXG4gICAgICAgIEVNUFRZX1NUQVRFOiBFTVBUWV9TVEFURSxcbiAgICAgICAgRklMTF9TVFlMRV9GTEFHOiBGSUxMX1NUWUxFX0ZMQUcsXG4gICAgICAgIENvbXBvbmVudFN0aWxsTG9hZGluZ0Vycm9yOiBDb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcixcbiAgICAgICAgaXNQcm9taXNlOiBpc1Byb21pc2VcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5jcmVhdGVQbGF0Zm9ybSA9IGNyZWF0ZVBsYXRmb3JtO1xuICAgIGV4cG9ydHMuYXNzZXJ0UGxhdGZvcm0gPSBhc3NlcnRQbGF0Zm9ybTtcbiAgICBleHBvcnRzLmRlc3Ryb3lQbGF0Zm9ybSA9IGRlc3Ryb3lQbGF0Zm9ybTtcbiAgICBleHBvcnRzLmdldFBsYXRmb3JtID0gZ2V0UGxhdGZvcm07XG4gICAgZXhwb3J0cy5QbGF0Zm9ybVJlZiA9IFBsYXRmb3JtUmVmO1xuICAgIGV4cG9ydHMuQXBwbGljYXRpb25SZWYgPSBBcHBsaWNhdGlvblJlZjtcbiAgICBleHBvcnRzLmVuYWJsZVByb2RNb2RlID0gZW5hYmxlUHJvZE1vZGU7XG4gICAgZXhwb3J0cy5pc0Rldk1vZGUgPSBpc0Rldk1vZGU7XG4gICAgZXhwb3J0cy5jcmVhdGVQbGF0Zm9ybUZhY3RvcnkgPSBjcmVhdGVQbGF0Zm9ybUZhY3Rvcnk7XG4gICAgZXhwb3J0cy5BUFBfSUQgPSBBUFBfSUQ7XG4gICAgZXhwb3J0cy5QQUNLQUdFX1JPT1RfVVJMID0gUEFDS0FHRV9ST09UX1VSTDtcbiAgICBleHBvcnRzLlBMQVRGT1JNX0lOSVRJQUxJWkVSID0gUExBVEZPUk1fSU5JVElBTElaRVI7XG4gICAgZXhwb3J0cy5BUFBfQk9PVFNUUkFQX0xJU1RFTkVSID0gQVBQX0JPT1RTVFJBUF9MSVNURU5FUjtcbiAgICBleHBvcnRzLkFQUF9JTklUSUFMSVpFUiA9IEFQUF9JTklUSUFMSVpFUjtcbiAgICBleHBvcnRzLkFwcGxpY2F0aW9uSW5pdFN0YXR1cyA9IEFwcGxpY2F0aW9uSW5pdFN0YXR1cztcbiAgICBleHBvcnRzLkRlYnVnRWxlbWVudCA9IERlYnVnRWxlbWVudDtcbiAgICBleHBvcnRzLkRlYnVnTm9kZSA9IERlYnVnTm9kZTtcbiAgICBleHBvcnRzLmFzTmF0aXZlRWxlbWVudHMgPSBhc05hdGl2ZUVsZW1lbnRzO1xuICAgIGV4cG9ydHMuZ2V0RGVidWdOb2RlID0gZ2V0RGVidWdOb2RlO1xuICAgIGV4cG9ydHMuVGVzdGFiaWxpdHkgPSBUZXN0YWJpbGl0eTtcbiAgICBleHBvcnRzLlRlc3RhYmlsaXR5UmVnaXN0cnkgPSBUZXN0YWJpbGl0eVJlZ2lzdHJ5O1xuICAgIGV4cG9ydHMuc2V0VGVzdGFiaWxpdHlHZXR0ZXIgPSBzZXRUZXN0YWJpbGl0eUdldHRlcjtcbiAgICBleHBvcnRzLlRSQU5TTEFUSU9OUyA9IFRSQU5TTEFUSU9OUztcbiAgICBleHBvcnRzLlRSQU5TTEFUSU9OU19GT1JNQVQgPSBUUkFOU0xBVElPTlNfRk9STUFUO1xuICAgIGV4cG9ydHMuTE9DQUxFX0lEID0gTE9DQUxFX0lEO1xuICAgIGV4cG9ydHMuQXBwbGljYXRpb25Nb2R1bGUgPSBBcHBsaWNhdGlvbk1vZHVsZTtcbiAgICBleHBvcnRzLnd0ZkNyZWF0ZVNjb3BlID0gd3RmQ3JlYXRlU2NvcGU7XG4gICAgZXhwb3J0cy53dGZMZWF2ZSA9IHd0ZkxlYXZlO1xuICAgIGV4cG9ydHMud3RmU3RhcnRUaW1lUmFuZ2UgPSB3dGZTdGFydFRpbWVSYW5nZTtcbiAgICBleHBvcnRzLnd0ZkVuZFRpbWVSYW5nZSA9IHd0ZkVuZFRpbWVSYW5nZTtcbiAgICBleHBvcnRzLlR5cGUgPSBUeXBlO1xuICAgIGV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuICAgIGV4cG9ydHMuRXJyb3JIYW5kbGVyID0gRXJyb3JIYW5kbGVyO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50ID0gQW5pbWF0aW9uVHJhbnNpdGlvbkV2ZW50O1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uUGxheWVyID0gQW5pbWF0aW9uUGxheWVyO1xuICAgIGV4cG9ydHMuU2FuaXRpemVyID0gU2FuaXRpemVyO1xuICAgIGV4cG9ydHMuQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyA9IEFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFM7XG4gICAgZXhwb3J0cy5BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5Db250ZW50Q2hpbGQgPSBDb250ZW50Q2hpbGQ7XG4gICAgZXhwb3J0cy5Db250ZW50Q2hpbGRyZW4gPSBDb250ZW50Q2hpbGRyZW47XG4gICAgZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xuICAgIGV4cG9ydHMuVmlld0NoaWxkID0gVmlld0NoaWxkO1xuICAgIGV4cG9ydHMuVmlld0NoaWxkcmVuID0gVmlld0NoaWxkcmVuO1xuICAgIGV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuICAgIGV4cG9ydHMuRGlyZWN0aXZlID0gRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuSG9zdEJpbmRpbmcgPSBIb3N0QmluZGluZztcbiAgICBleHBvcnRzLkhvc3RMaXN0ZW5lciA9IEhvc3RMaXN0ZW5lcjtcbiAgICBleHBvcnRzLklucHV0ID0gSW5wdXQ7XG4gICAgZXhwb3J0cy5PdXRwdXQgPSBPdXRwdXQ7XG4gICAgZXhwb3J0cy5QaXBlID0gUGlwZTtcbiAgICBleHBvcnRzLkFmdGVyQ29udGVudENoZWNrZWQgPSBBZnRlckNvbnRlbnRDaGVja2VkO1xuICAgIGV4cG9ydHMuQWZ0ZXJDb250ZW50SW5pdCA9IEFmdGVyQ29udGVudEluaXQ7XG4gICAgZXhwb3J0cy5BZnRlclZpZXdDaGVja2VkID0gQWZ0ZXJWaWV3Q2hlY2tlZDtcbiAgICBleHBvcnRzLkFmdGVyVmlld0luaXQgPSBBZnRlclZpZXdJbml0O1xuICAgIGV4cG9ydHMuRG9DaGVjayA9IERvQ2hlY2s7XG4gICAgZXhwb3J0cy5PbkNoYW5nZXMgPSBPbkNoYW5nZXM7XG4gICAgZXhwb3J0cy5PbkRlc3Ryb3kgPSBPbkRlc3Ryb3k7XG4gICAgZXhwb3J0cy5PbkluaXQgPSBPbkluaXQ7XG4gICAgZXhwb3J0cy5DVVNUT01fRUxFTUVOVFNfU0NIRU1BID0gQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQTtcbiAgICBleHBvcnRzLk5PX0VSUk9SU19TQ0hFTUEgPSBOT19FUlJPUlNfU0NIRU1BO1xuICAgIGV4cG9ydHMuTmdNb2R1bGUgPSBOZ01vZHVsZTtcbiAgICBleHBvcnRzLkNsYXNzID0gQ2xhc3M7XG4gICAgZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbiAgICBleHBvcnRzLnJlc29sdmVGb3J3YXJkUmVmID0gcmVzb2x2ZUZvcndhcmRSZWY7XG4gICAgZXhwb3J0cy5JbmplY3RvciA9IEluamVjdG9yO1xuICAgIGV4cG9ydHMuUmVmbGVjdGl2ZUluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yO1xuICAgIGV4cG9ydHMuUmVzb2x2ZWRSZWZsZWN0aXZlRmFjdG9yeSA9IFJlc29sdmVkUmVmbGVjdGl2ZUZhY3Rvcnk7XG4gICAgZXhwb3J0cy5SZWZsZWN0aXZlS2V5ID0gUmVmbGVjdGl2ZUtleTtcbiAgICBleHBvcnRzLk9wYXF1ZVRva2VuID0gT3BhcXVlVG9rZW47XG4gICAgZXhwb3J0cy5JbmplY3QgPSBJbmplY3Q7XG4gICAgZXhwb3J0cy5PcHRpb25hbCA9IE9wdGlvbmFsO1xuICAgIGV4cG9ydHMuSW5qZWN0YWJsZSA9IEluamVjdGFibGU7XG4gICAgZXhwb3J0cy5TZWxmID0gU2VsZjtcbiAgICBleHBvcnRzLlNraXBTZWxmID0gU2tpcFNlbGY7XG4gICAgZXhwb3J0cy5Ib3N0ID0gSG9zdDtcbiAgICBleHBvcnRzLk5nWm9uZSA9IE5nWm9uZTtcbiAgICBleHBvcnRzLlJlbmRlckNvbXBvbmVudFR5cGUgPSBSZW5kZXJDb21wb25lbnRUeXBlO1xuICAgIGV4cG9ydHMuUmVuZGVyZXIgPSBSZW5kZXJlcjtcbiAgICBleHBvcnRzLlJvb3RSZW5kZXJlciA9IFJvb3RSZW5kZXJlcjtcbiAgICBleHBvcnRzLkNPTVBJTEVSX09QVElPTlMgPSBDT01QSUxFUl9PUFRJT05TO1xuICAgIGV4cG9ydHMuQ29tcGlsZXIgPSBDb21waWxlcjtcbiAgICBleHBvcnRzLkNvbXBpbGVyRmFjdG9yeSA9IENvbXBpbGVyRmFjdG9yeTtcbiAgICBleHBvcnRzLk1vZHVsZVdpdGhDb21wb25lbnRGYWN0b3JpZXMgPSBNb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzO1xuICAgIGV4cG9ydHMuQ29tcG9uZW50RmFjdG9yeSA9IENvbXBvbmVudEZhY3Rvcnk7XG4gICAgZXhwb3J0cy5Db21wb25lbnRSZWYgPSBDb21wb25lbnRSZWY7XG4gICAgZXhwb3J0cy5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgZXhwb3J0cy5FbGVtZW50UmVmID0gRWxlbWVudFJlZjtcbiAgICBleHBvcnRzLk5nTW9kdWxlRmFjdG9yeSA9IE5nTW9kdWxlRmFjdG9yeTtcbiAgICBleHBvcnRzLk5nTW9kdWxlUmVmID0gTmdNb2R1bGVSZWY7XG4gICAgZXhwb3J0cy5OZ01vZHVsZUZhY3RvcnlMb2FkZXIgPSBOZ01vZHVsZUZhY3RvcnlMb2FkZXI7XG4gICAgZXhwb3J0cy5nZXRNb2R1bGVGYWN0b3J5ID0gZ2V0TW9kdWxlRmFjdG9yeTtcbiAgICBleHBvcnRzLlF1ZXJ5TGlzdCA9IFF1ZXJ5TGlzdDtcbiAgICBleHBvcnRzLlN5c3RlbUpzTmdNb2R1bGVMb2FkZXIgPSBTeXN0ZW1Kc05nTW9kdWxlTG9hZGVyO1xuICAgIGV4cG9ydHMuU3lzdGVtSnNOZ01vZHVsZUxvYWRlckNvbmZpZyA9IFN5c3RlbUpzTmdNb2R1bGVMb2FkZXJDb25maWc7XG4gICAgZXhwb3J0cy5UZW1wbGF0ZVJlZiA9IFRlbXBsYXRlUmVmO1xuICAgIGV4cG9ydHMuVmlld0NvbnRhaW5lclJlZiA9IFZpZXdDb250YWluZXJSZWY7XG4gICAgZXhwb3J0cy5FbWJlZGRlZFZpZXdSZWYgPSBFbWJlZGRlZFZpZXdSZWY7XG4gICAgZXhwb3J0cy5WaWV3UmVmID0gVmlld1JlZjtcbiAgICBleHBvcnRzLkNoYW5nZURldGVjdG9yUmVmID0gQ2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgZXhwb3J0cy5Db2xsZWN0aW9uQ2hhbmdlUmVjb3JkID0gQ29sbGVjdGlvbkNoYW5nZVJlY29yZDtcbiAgICBleHBvcnRzLkRlZmF1bHRJdGVyYWJsZURpZmZlciA9IERlZmF1bHRJdGVyYWJsZURpZmZlcjtcbiAgICBleHBvcnRzLkl0ZXJhYmxlRGlmZmVycyA9IEl0ZXJhYmxlRGlmZmVycztcbiAgICBleHBvcnRzLktleVZhbHVlQ2hhbmdlUmVjb3JkID0gS2V5VmFsdWVDaGFuZ2VSZWNvcmQ7XG4gICAgZXhwb3J0cy5LZXlWYWx1ZURpZmZlcnMgPSBLZXlWYWx1ZURpZmZlcnM7XG4gICAgZXhwb3J0cy5TaW1wbGVDaGFuZ2UgPSBTaW1wbGVDaGFuZ2U7XG4gICAgZXhwb3J0cy5XcmFwcGVkVmFsdWUgPSBXcmFwcGVkVmFsdWU7XG4gICAgZXhwb3J0cy5wbGF0Zm9ybUNvcmUgPSBwbGF0Zm9ybUNvcmU7XG4gICAgZXhwb3J0cy5fX2NvcmVfcHJpdmF0ZV9fID0gX19jb3JlX3ByaXZhdGVfXztcbiAgICBleHBvcnRzLkFVVE9fU1RZTEUgPSBBVVRPX1NUWUxFO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uRW50cnlNZXRhZGF0YSA9IEFuaW1hdGlvbkVudHJ5TWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TdGF0ZU1ldGFkYXRhID0gQW5pbWF0aW9uU3RhdGVNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YSA9IEFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhID0gQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25NZXRhZGF0YSA9IEFuaW1hdGlvbk1ldGFkYXRhO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSA9IEFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TdHlsZU1ldGFkYXRhID0gQW5pbWF0aW9uU3R5bGVNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSA9IEFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhID0gQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGE7XG4gICAgZXhwb3J0cy5BbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhID0gQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbiAgICBleHBvcnRzLkFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSBBbmltYXRpb25Hcm91cE1ldGFkYXRhO1xuICAgIGV4cG9ydHMuYW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgZXhwb3J0cy5ncm91cCA9IGdyb3VwO1xuICAgIGV4cG9ydHMuc2VxdWVuY2UgPSBzZXF1ZW5jZTtcbiAgICBleHBvcnRzLnN0eWxlID0gc3R5bGU7XG4gICAgZXhwb3J0cy5zdGF0ZSA9IHN0YXRlO1xuICAgIGV4cG9ydHMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgIGV4cG9ydHMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgZXhwb3J0cy50cmlnZ2VyID0gdHJpZ2dlcjtcblxufSkpO1xuIiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYyLjAuMlxuICogKGMpIDIwMTAtMjAxNiBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAYW5ndWxhci9jb21waWxlcicpLCByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvY29tcGlsZXInLCAnQGFuZ3VsYXIvY29yZScsICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyRHluYW1pYyA9IGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljIHx8IHt9KSxnbG9iYWwubmcuY29tcGlsZXIsZ2xvYmFsLm5nLmNvcmUsZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlcikpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb21waWxlcixfYW5ndWxhcl9jb3JlLF9hbmd1bGFyX3BsYXRmb3JtQnJvd3NlcikgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgSU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMgPSBfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuX19wbGF0Zm9ybV9icm93c2VyX3ByaXZhdGVfXy5JTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUztcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgZ2xvYmFsU2NvcGU7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBhbnkgd2l0aCBXb3JrZXJHbG9iYWxTY29wZSBmcm9tIGxpYi53ZWJ3b3JrZXIuZC50cyAjMzQ5MlxuICAgICAgICAgICAgZ2xvYmFsU2NvcGUgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsU2NvcGUgPSBnbG9iYWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsb2JhbFNjb3BlID0gd2luZG93O1xuICAgIH1cbiAgICAvLyBOZWVkIHRvIGRlY2xhcmUgYSBuZXcgdmFyaWFibGUgZm9yIGdsb2JhbCBoZXJlIHNpbmNlIFR5cGVTY3JpcHRcbiAgICAvLyBleHBvcnRzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgc3ltYm9sLlxuICAgIHZhciBnbG9iYWwkMSA9IGdsb2JhbFNjb3BlO1xuICAgIC8vIFRPRE86IHJlbW92ZSBjYWxscyB0byBhc3NlcnQgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudFxuICAgIC8vIE5vdGU6IENhbid0IGp1c3QgZXhwb3J0IHRoaXMgYW5kIGltcG9ydCBpbiBpbiBvdGhlciBmaWxlc1xuICAgIC8vIGFzIGBhc3NlcnRgIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCBpbiBEYXJ0XG4gICAgZ2xvYmFsJDEuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xuICAgIH07XG4gICAgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsO1xuICAgIH1cbiAgICB2YXIgTnVtYmVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE51bWJlcldyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTnVtYmVyV3JhcHBlci50b0ZpeGVkID0gZnVuY3Rpb24gKG4sIGZyYWN0aW9uRGlnaXRzKSB7IHJldHVybiBuLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpOyB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT09IGI7IH07XG4gICAgICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50ID0gZnVuY3Rpb24gKHRleHQsIHJhZGl4KSB7XG4gICAgICAgICAgICBpZiAocmFkaXggPT0gMTApIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOV0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJhZGl4ID09IDE2KSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTlBQkNERUZhYmNkZWZdKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0ICsgJyBpbiBiYXNlICcgKyByYWRpeCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJXcmFwcGVyLCBcIk5hTlwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5hTjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE51bWJlcldyYXBwZXIuaXNOdW1lcmljID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAhaXNOYU4odmFsdWUgLSBwYXJzZUZsb2F0KHZhbHVlKSk7IH07XG4gICAgICAgIE51bWJlcldyYXBwZXIuaXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzTmFOKHZhbHVlKTsgfTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5pc0ludGVnZXIgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpOyB9O1xuICAgICAgICByZXR1cm4gTnVtYmVyV3JhcHBlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBSZXNvdXJjZUxvYWRlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoUmVzb3VyY2VMb2FkZXJJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBSZXNvdXJjZUxvYWRlckltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlO1xuICAgICAgICAgICAgdmFyIHJlamVjdDtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2VUZXh0IGlzIHRoZSBvbGQtc2Nob29sIHdheSBvZiByZXRyaWV2aW5nIHJlc3BvbnNlIChzdXBwb3J0ZWQgYnkgSUU4ICYgOSlcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZS9yZXNwb25zZVR5cGUgcHJvcGVydGllcyB3ZXJlIGludHJvZHVjZWQgaW4gUmVzb3VyY2VMb2FkZXIgTGV2ZWwyIHNwZWMgKHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIC8vIGJ5IElFMTApXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gaXNQcmVzZW50KHhoci5yZXNwb25zZSkgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxuICAgICAgICAgICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgcmV0cmlldmluZyBmaWxlcyBmcm9tIGFwcGxpY2F0aW9uIGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gcmVzcG9uc2UgPyAyMDAgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoMjAwIDw9IHN0YXR1cyAmJiBzdGF0dXMgPD0gMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmVqZWN0KFwiRmFpbGVkIHRvIGxvYWQgXCIgKyB1cmwpOyB9O1xuICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9O1xuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGwuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFJlc291cmNlTG9hZGVySW1wbDtcbiAgICB9KF9hbmd1bGFyX2NvbXBpbGVyLlJlc291cmNlTG9hZGVyKSk7XG5cbiAgICB2YXIgSU5URVJOQUxfQlJPV1NFUl9EWU5BTUlDX1BMQVRGT1JNX1BST1ZJREVSUyA9IFtcbiAgICAgICAgSU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMsXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuQ09NUElMRVJfT1BUSU9OUyxcbiAgICAgICAgICAgIHVzZVZhbHVlOiB7IHByb3ZpZGVyczogW3sgcHJvdmlkZTogX2FuZ3VsYXJfY29tcGlsZXIuUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBSZXNvdXJjZUxvYWRlckltcGwgfV0gfSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG4gICAgXTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiBSZXNvdXJjZUxvYWRlciB0aGF0IHVzZXMgYSB0ZW1wbGF0ZSBjYWNoZSB0byBhdm9pZCBkb2luZyBhbiBhY3R1YWxcbiAgICAgKiBSZXNvdXJjZUxvYWRlci5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBjYWNoZSBuZWVkcyB0byBiZSBidWlsdCBhbmQgbG9hZGVkIGludG8gd2luZG93LiR0ZW1wbGF0ZUNhY2hlXG4gICAgICogdmlhIGEgc2VwYXJhdGUgbWVjaGFuaXNtLlxuICAgICAqL1xuICAgIHZhciBDYWNoZWRSZXNvdXJjZUxvYWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKENhY2hlZFJlc291cmNlTG9hZGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDYWNoZWRSZXNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSBnbG9iYWwkMS4kdGVtcGxhdGVDYWNoZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogVGVtcGxhdGUgY2FjaGUgd2FzIG5vdCBmb3VuZCBpbiAkdGVtcGxhdGVDYWNoZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDYWNoZWRSZXNvdXJjZUxvYWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlLmhhc093blByb3BlcnR5KHVybCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NhY2hlW3VybF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogRGlkIG5vdCBmaW5kIGNhY2hlZCB0ZW1wbGF0ZSBmb3IgJyArIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDYWNoZWRSZXNvdXJjZUxvYWRlcjtcbiAgICB9KF9hbmd1bGFyX2NvbXBpbGVyLlJlc291cmNlTG9hZGVyKSk7XG5cbiAgICB2YXIgX19wbGF0Zm9ybV9icm93c2VyX2R5bmFtaWNfcHJpdmF0ZV9fID0ge1xuICAgICAgICBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTOiBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTLFxuICAgICAgICBSZXNvdXJjZUxvYWRlckltcGw6IFJlc291cmNlTG9hZGVySW1wbFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSID0gW3sgcHJvdmlkZTogX2FuZ3VsYXJfY29tcGlsZXIuUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBDYWNoZWRSZXNvdXJjZUxvYWRlciB9XTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFQSSByZWxhdGVkIHRvIGJvb3RzdHJhcHBpbmcgYXJlIHN0aWxsIHVuZGVyIHJldmlldy5cbiAgICAgKi9cbiAgICB2YXIgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyA9IF9hbmd1bGFyX2NvcmUuY3JlYXRlUGxhdGZvcm1GYWN0b3J5KF9hbmd1bGFyX2NvbXBpbGVyLnBsYXRmb3JtQ29yZUR5bmFtaWMsICdicm93c2VyRHluYW1pYycsIElOVEVSTkFMX0JST1dTRVJfRFlOQU1JQ19QTEFURk9STV9QUk9WSURFUlMpO1xuXG4gICAgZXhwb3J0cy5SRVNPVVJDRV9DQUNIRV9QUk9WSURFUiA9IFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSO1xuICAgIGV4cG9ydHMucGxhdGZvcm1Ccm93c2VyRHluYW1pYyA9IHBsYXRmb3JtQnJvd3NlckR5bmFtaWM7XG4gICAgZXhwb3J0cy5fX3BsYXRmb3JtX2Jyb3dzZXJfZHluYW1pY19wcml2YXRlX18gPSBfX3BsYXRmb3JtX2Jyb3dzZXJfZHluYW1pY19wcml2YXRlX187XG5cbn0pKTtcbiIsIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi4wLjJcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29tbW9uJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvY29tbW9uJywgJ0Bhbmd1bGFyL2NvcmUnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwubmcgPSBnbG9iYWwubmcgfHwge30sIGdsb2JhbC5uZy5wbGF0Zm9ybUJyb3dzZXIgPSBnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyIHx8IHt9KSxnbG9iYWwubmcuY29tbW9uLGdsb2JhbC5uZy5jb3JlKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvbW1vbixfYW5ndWxhcl9jb3JlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBEZWJ1Z0RvbVJvb3RSZW5kZXJlciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5EZWJ1Z0RvbVJvb3RSZW5kZXJlcjtcbiAgICB2YXIgTm9PcEFuaW1hdGlvblBsYXllciA9IF9hbmd1bGFyX2NvcmUuX19jb3JlX3ByaXZhdGVfXy5Ob09wQW5pbWF0aW9uUGxheWVyO1xuXG4gICAgdmFyIF9Ob09wQW5pbWF0aW9uRHJpdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gX05vT3BBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgX05vT3BBbmltYXRpb25Ecml2ZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9PcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX05vT3BBbmltYXRpb25Ecml2ZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEFuaW1hdGlvbkRyaXZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkRyaXZlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBBbmltYXRpb25Ecml2ZXIuTk9PUCA9IG5ldyBfTm9PcEFuaW1hdGlvbkRyaXZlcigpO1xuICAgICAgICByZXR1cm4gQW5pbWF0aW9uRHJpdmVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIGdsb2JhbFNjb3BlO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYW55IHdpdGggV29ya2VyR2xvYmFsU2NvcGUgZnJvbSBsaWIud2Vid29ya2VyLmQudHMgIzM0OTJcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFNjb3BlID0gZ2xvYmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxTY29wZSA9IHdpbmRvdztcbiAgICB9XG4gICAgLy8gTmVlZCB0byBkZWNsYXJlIGEgbmV3IHZhcmlhYmxlIGZvciBnbG9iYWwgaGVyZSBzaW5jZSBUeXBlU2NyaXB0XG4gICAgLy8gZXhwb3J0cyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIHN5bWJvbC5cbiAgICB2YXIgZ2xvYmFsJDEgPSBnbG9iYWxTY29wZTtcbiAgICAvLyBUT0RPOiByZW1vdmUgY2FsbHMgdG8gYXNzZXJ0IGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRcbiAgICAvLyBOb3RlOiBDYW4ndCBqdXN0IGV4cG9ydCB0aGlzIGFuZCBpbXBvcnQgaW4gaW4gb3RoZXIgZmlsZXNcbiAgICAvLyBhcyBgYXNzZXJ0YCBpcyBhIHJlc2VydmVkIGtleXdvcmQgaW4gRGFydFxuICAgIGdsb2JhbCQxLmFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogdG8gYmUgZml4ZWQgcHJvcGVybHkgdmlhICMyODMwLCBub29wIGZvciBub3dcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzUHJlc2VudChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCbGFuayhvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5KHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09PSB1bmRlZmluZWQgfHwgdG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5vdmVycmlkZGVuTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuLm92ZXJyaWRkZW5OYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW4ubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIG5ld0xpbmVJbmRleCA9IHJlcy5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgcmV0dXJuIG5ld0xpbmVJbmRleCA9PT0gLTEgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG4gICAgfVxuICAgIHZhciBTdHJpbmdXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBTdHJpbmdXcmFwcGVyLmZyb21DaGFyQ29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpOyB9O1xuICAgICAgICBTdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQgPSBmdW5jdGlvbiAocywgaW5kZXgpIHsgcmV0dXJuIHMuY2hhckNvZGVBdChpbmRleCk7IH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIuc3BsaXQgPSBmdW5jdGlvbiAocywgcmVnRXhwKSB7IHJldHVybiBzLnNwbGl0KHJlZ0V4cCk7IH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKHMsIHMyKSB7IHJldHVybiBzID09PSBzMjsgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5zdHJpcExlZnQgPSBmdW5jdGlvbiAocywgY2hhclZhbCkge1xuICAgICAgICAgICAgaWYgKHMgJiYgcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNbaV0gIT0gY2hhclZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5zdHJpcFJpZ2h0ID0gZnVuY3Rpb24gKHMsIGNoYXJWYWwpIHtcbiAgICAgICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzW2ldICE9IGNoYXJWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIucmVwbGFjZSA9IGZ1bmN0aW9uIChzLCBmcm9tLCByZXBsYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIHJlcGxhY2UpO1xuICAgICAgICB9O1xuICAgICAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwgPSBmdW5jdGlvbiAocywgZnJvbSwgcmVwbGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5zbGljZSA9IGZ1bmN0aW9uIChzLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gcy5zbGljZShmcm9tLCB0byA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkID0gZnVuY3Rpb24gKHMsIGZyb20sIGNiKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKGZyb20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvZmZzZXQgJiBzdHJpbmcgZnJvbSB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5zcGxpY2UoLTIsIDIpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayByZWNlaXZlcyBtYXRjaCwgcDEsIC4uLiwgcG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobWF0Y2hlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5jb250YWlucyA9IGZ1bmN0aW9uIChzLCBzdWJzdHIpIHsgcmV0dXJuIHMuaW5kZXhPZihzdWJzdHIpICE9IC0xOyB9O1xuICAgICAgICBTdHJpbmdXcmFwcGVyLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyaW5nV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIHZhciBOdW1iZXJXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTnVtYmVyV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBOdW1iZXJXcmFwcGVyLnRvRml4ZWQgPSBmdW5jdGlvbiAobiwgZnJhY3Rpb25EaWdpdHMpIHsgcmV0dXJuIG4udG9GaXhlZChmcmFjdGlvbkRpZ2l0cyk7IH07XG4gICAgICAgIE51bWJlcldyYXBwZXIuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5wYXJzZUludEF1dG9SYWRpeCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnQgPSBmdW5jdGlvbiAodGV4dCwgcmFkaXgpIHtcbiAgICAgICAgICAgIGlmIChyYWRpeCA9PSAxMCkge1xuICAgICAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT9bMC05XSskLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmFkaXggPT0gMTYpIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOUFCQ0RFRmFiY2RlZl0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0LCByYWRpeCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgbGl0ZXJhbCB3aGVuIHBhcnNpbmcgJyArIHRleHQgKyAnIGluIGJhc2UgJyArIHJhZGl4KTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIFwiTmFOXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmFOOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5pc051bWVyaWMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTsgfTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5pc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXNOYU4odmFsdWUpOyB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7IH07XG4gICAgICAgIHJldHVybiBOdW1iZXJXcmFwcGVyO1xuICAgIH0oKSk7XG4gICAgLy8gQ2FuJ3QgYmUgYWxsIHVwcGVyY2FzZSBhcyBvdXIgdHJhbnNwaWxlciB3b3VsZCB0aGluayBpdCBpcyBhIHNwZWNpYWwgZGlyZWN0aXZlLi4uXG4gICAgdmFyIEpzb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBKc29uKCkge1xuICAgICAgICB9XG4gICAgICAgIEpzb24ucGFyc2UgPSBmdW5jdGlvbiAocykgeyByZXR1cm4gZ2xvYmFsJDEuSlNPTi5wYXJzZShzKTsgfTtcbiAgICAgICAgSnNvbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gRGFydCBkb2Vzbid0IHRha2UgMyBhcmd1bWVudHNcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWwkMS5KU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEpzb247XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBzZXRWYWx1ZU9uUGF0aChnbG9iYWwsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIG9iaiA9IGdsb2JhbDtcbiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNQcmVzZW50KG9ialtuYW1lXSkpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBvYmpbcGFydHMuc2hpZnQoKV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgQ0FNRUxfQ0FTRV9SRUdFWFAgPSAvKFtBLVpdKS9nO1xuICAgIHZhciBEQVNIX0NBU0VfUkVHRVhQID0gLy0oW2Etel0pL2c7XG4gICAgZnVuY3Rpb24gY2FtZWxDYXNlVG9EYXNoQ2FzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsTWFwcGVkKGlucHV0LCBDQU1FTF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuICctJyArIG1bMV0udG9Mb3dlckNhc2UoKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRhc2hDYXNlVG9DYW1lbENhc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZChpbnB1dCwgREFTSF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1bMV0udG9VcHBlckNhc2UoKTsgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfRE9NID0gbnVsbDtcbiAgICBmdW5jdGlvbiBnZXRET00oKSB7XG4gICAgICAgIHJldHVybiBfRE9NO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRSb290RG9tQWRhcHRlcihhZGFwdGVyKSB7XG4gICAgICAgIGlmICghX0RPTSkge1xuICAgICAgICAgICAgX0RPTSA9IGFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogdHNsaW50OmRpc2FibGU6cmVxdWlyZVBhcmFtZXRlclR5cGUgKi9cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBET00gb3BlcmF0aW9ucyBpbiBhbiBlbnZpcm9ubWVudC1hZ25vc3RpYyB3YXkuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgVHJlYWQgY2FyZWZ1bGx5ISBJbnRlcmFjdGluZyB3aXRoIHRoZSBET00gZGlyZWN0bHkgaXMgZGFuZ2Vyb3VzIGFuZFxuICAgICAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICAgICAqL1xuICAgIHZhciBEb21BZGFwdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRG9tQWRhcHRlcigpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VMb2FkZXJUeXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRG9tQWRhcHRlci5wcm90b3R5cGUsIFwiYXR0clRvUHJvcE1hcFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcHMgYXR0cmlidXRlIG5hbWVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMgZm9yIGNhc2VzXG4gICAgICAgICAgICAgKiB3aGVyZSBhdHRyaWJ1dGUgbmFtZSBkb2Vzbid0IG1hdGNoIHByb3BlcnR5IG5hbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYXR0clRvUHJvcE1hcDsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuX2F0dHJUb1Byb3BNYXAgPSB2YWx1ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIDtcbiAgICAgICAgO1xuICAgICAgICByZXR1cm4gRG9tQWRhcHRlcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFdlYkFuaW1hdGlvbnNQbGF5ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zUGxheWVyKGVsZW1lbnQsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IG9wdGlvbnNbJ2R1cmF0aW9uJ107XG4gICAgICAgIH1cbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuX29uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9maW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh0aGlzLnBhcmVudFBsYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcy5tYXAoZnVuY3Rpb24gKHN0eWxlcykge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRLZXlmcmFtZSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZEtleWZyYW1lW3Byb3BdID0gdmFsdWUgPT0gX2FuZ3VsYXJfY29yZS5BVVRPX1NUWUxFID8gX2NvbXB1dGVTdHlsZShfdGhpcy5lbGVtZW50LCBwcm9wKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWRLZXlmcmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyID0gdGhpcy5fdHJpZ2dlcldlYkFuaW1hdGlvbih0aGlzLmVsZW1lbnQsIGtleWZyYW1lcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgc28gdGhhdCB0aGUgcGxheWVyIGRvZXNuJ3Qgc3RhcnQgdG8gYW5pbWF0ZSByaWdodCBhd2F5XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIub25maW5pc2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25GaW5pc2goKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5fdHJpZ2dlcldlYkFuaW1hdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUub25TdGFydCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vblN0YXJ0Rm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5vbkRvbmUgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25Eb25lRm5zLnB1c2goZm4pOyB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25TdGFydEZucyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGxheWVyLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXllci5wYXVzZSgpO1xuICAgICAgICB9O1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5ZXIuZmluaXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9wbGF5ZXIuY2FuY2VsKCk7IH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuaGFzU3RhcnRlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7IH07XG4gICAgICAgIFdlYkFuaW1hdGlvbnNQbGF5ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaCgpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUsIFwidG90YWxUaW1lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZHVyYXRpb247IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBXZWJBbmltYXRpb25zUGxheWVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwKSB7IHRoaXMuX3BsYXllci5jdXJyZW50VGltZSA9IHAgKiB0aGlzLnRvdGFsVGltZTsgfTtcbiAgICAgICAgV2ViQW5pbWF0aW9uc1BsYXllci5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wbGF5ZXIuY3VycmVudFRpbWUgLyB0aGlzLnRvdGFsVGltZTsgfTtcbiAgICAgICAgcmV0dXJuIFdlYkFuaW1hdGlvbnNQbGF5ZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY29tcHV0ZVN0eWxlKGVsZW1lbnQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGdldERPTSgpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbcHJvcF07XG4gICAgfVxuXG4gICAgdmFyIFdlYkFuaW1hdGlvbnNEcml2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBXZWJBbmltYXRpb25zRHJpdmVyKCkge1xuICAgICAgICB9XG4gICAgICAgIFdlYkFuaW1hdGlvbnNEcml2ZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRTdGVwcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0aW5nU3R5bGVMb29rdXAgPSB7fTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3RhcnRpbmdTdHlsZXMpICYmIHN0YXJ0aW5nU3R5bGVzLnN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdTdHlsZUxvb2t1cCA9IF9wb3B1bGF0ZVN0eWxlcyhlbGVtZW50LCBzdGFydGluZ1N0eWxlcywge30pO1xuICAgICAgICAgICAgICAgIHN0YXJ0aW5nU3R5bGVMb29rdXBbJ29mZnNldCddID0gMDtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdGVwcy5wdXNoKHN0YXJ0aW5nU3R5bGVMb29rdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfcG9wdWxhdGVTdHlsZXMoZWxlbWVudCwga2V5ZnJhbWUuc3R5bGVzLCBzdGFydGluZ1N0eWxlTG9va3VwKTtcbiAgICAgICAgICAgICAgICBkYXRhWydvZmZzZXQnXSA9IGtleWZyYW1lLm9mZnNldDtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRTdGVwcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZW4gb25seSBzdHlsZXMgYXJlIGFwcGxpZWQgYXMgYW5cbiAgICAgICAgICAgIC8vIGFuaW1hdGlvbi4gV2hlbiB0aGlzIG9jY3VycyB3ZSB3YW50IHRvIGFuaW1hdGUgZnJvbSBzdGFydCB0b1xuICAgICAgICAgICAgLy8gZW5kIHdpdGggdGhlIHNhbWUgdmFsdWVzLiBSZW1vdmluZyB0aGUgb2Zmc2V0IGFuZCBoYXZpbmcgb25seVxuICAgICAgICAgICAgLy8gc3RhcnQvZW5kIHZhbHVlcyBpcyBzdWl0YWJsZSBlbm91Z2ggZm9yIHRoZSB3ZWItYW5pbWF0aW9ucyBBUElcbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRTdGVwcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGZvcm1hdHRlZFN0ZXBzWzBdO1xuICAgICAgICAgICAgICAgIHN0YXJ0WydvZmZzZXQnXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkU3RlcHMgPSBbc3RhcnQsIHN0YXJ0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwbGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICdkdXJhdGlvbic6IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICdkZWxheSc6IGRlbGF5LFxuICAgICAgICAgICAgICAgICdmaWxsJzogJ2JvdGgnIC8vIHdlIHVzZSBgYm90aGAgYmVjYXVzZSBpdCBhbGxvd3MgZm9yIHN0eWxpbmcgYXQgMCUgdG8gd29yayB3aXRoIGBkZWxheWBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyB3ZSBjaGVjayBmb3IgdGhpcyB0byBhdm9pZCBoYXZpbmcgYSBudWxsfHVuZGVmaW5lZCB2YWx1ZSBiZSBwcmVzZW50XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVhc2luZyAod2hpY2ggcmVzdWx0cyBpbiBhbiBlcnJvciBmb3IgY2VydGFpbiBicm93c2VycyAjOTc1MilcbiAgICAgICAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXJPcHRpb25zWydlYXNpbmcnXSA9IGVhc2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQW5pbWF0aW9uc1BsYXllcihlbGVtZW50LCBmb3JtYXR0ZWRTdGVwcywgcGxheWVyT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBXZWJBbmltYXRpb25zRHJpdmVyO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX3BvcHVsYXRlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcywgZGVmYXVsdFN0eWxlcykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBzdHlsZXMuc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlbnRyeSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbnRyeVtwcm9wXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkUHJvcCA9IGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcCk7XG4gICAgICAgICAgICAgICAgZGF0YVtmb3JtYXR0ZWRQcm9wXSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9PSBfYW5ndWxhcl9jb3JlLkFVVE9fU1RZTEUgPyB2YWwgOiB2YWwudG9TdHJpbmcoKSArIF9yZXNvbHZlU3R5bGVVbml0KHZhbCwgcHJvcCwgZm9ybWF0dGVkUHJvcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICghaXNQcmVzZW50KGRhdGFbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtwcm9wXSA9IGRlZmF1bHRTdHlsZXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3Jlc29sdmVTdHlsZVVuaXQodmFsLCB1c2VyUHJvdmlkZWRQcm9wLCBmb3JtYXR0ZWRQcm9wKSB7XG4gICAgICAgIHZhciB1bml0ID0gJyc7XG4gICAgICAgIGlmIChfaXNQaXhlbERpbWVuc2lvblN0eWxlKGZvcm1hdHRlZFByb3ApICYmIHZhbCAhPSAwICYmIHZhbCAhPSAnMCcpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcih2YWwpKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfZmluZERpbWVuc2lvbmFsU3VmZml4KHZhbC50b1N0cmluZygpKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYSBDU1MgdW5pdCB2YWx1ZSBmb3IgJyArIHVzZXJQcm92aWRlZFByb3AgKyAnOicgKyB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bml0O1xuICAgIH1cbiAgICB2YXIgXyQwID0gNDg7XG4gICAgdmFyIF8kOSA9IDU3O1xuICAgIHZhciBfJFBFUklPRCA9IDQ2O1xuICAgIGZ1bmN0aW9uIF9maW5kRGltZW5zaW9uYWxTdWZmaXgodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBTdHJpbmdXcmFwcGVyLmNoYXJDb2RlQXQodmFsdWUsIGkpO1xuICAgICAgICAgICAgaWYgKChjID49IF8kMCAmJiBjIDw9IF8kOSkgfHwgYyA9PSBfJFBFUklPRClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoaSwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9pc1BpeGVsRGltZW5zaW9uU3R5bGUocHJvcCkge1xuICAgICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICBjYXNlICdtaW5XaWR0aCc6XG4gICAgICAgICAgICBjYXNlICdtaW5IZWlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnbWF4V2lkdGgnOlxuICAgICAgICAgICAgY2FzZSAnbWF4SGVpZ2h0JzpcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBjYXNlICdmb250U2l6ZSc6XG4gICAgICAgICAgICBjYXNlICdvdXRsaW5lV2lkdGgnOlxuICAgICAgICAgICAgY2FzZSAnb3V0bGluZU9mZnNldCc6XG4gICAgICAgICAgICBjYXNlICdwYWRkaW5nVG9wJzpcbiAgICAgICAgICAgIGNhc2UgJ3BhZGRpbmdMZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ3BhZGRpbmdCb3R0b20nOlxuICAgICAgICAgICAgY2FzZSAncGFkZGluZ1JpZ2h0JzpcbiAgICAgICAgICAgIGNhc2UgJ21hcmdpblRvcCc6XG4gICAgICAgICAgICBjYXNlICdtYXJnaW5MZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ21hcmdpbkJvdHRvbSc6XG4gICAgICAgICAgICBjYXNlICdtYXJnaW5SaWdodCc6XG4gICAgICAgICAgICBjYXNlICdib3JkZXJSYWRpdXMnOlxuICAgICAgICAgICAgY2FzZSAnYm9yZGVyV2lkdGgnOlxuICAgICAgICAgICAgY2FzZSAnYm9yZGVyVG9wV2lkdGgnOlxuICAgICAgICAgICAgY2FzZSAnYm9yZGVyTGVmdFdpZHRoJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvcmRlclJpZ2h0V2lkdGgnOlxuICAgICAgICAgICAgY2FzZSAnYm9yZGVyQm90dG9tV2lkdGgnOlxuICAgICAgICAgICAgY2FzZSAndGV4dEluZGVudCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBET00gb3BlcmF0aW9ucyBpbiBhbnkgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAgKlxuICAgICAqIEBzZWN1cml0eSBUcmVhZCBjYXJlZnVsbHkhIEludGVyYWN0aW5nIHdpdGggdGhlIERPTSBkaXJlY3RseSBpcyBkYW5nZXJvdXMgYW5kXG4gICAgICogY2FuIGludHJvZHVjZSBYU1Mgcmlza3MuXG4gICAgICovXG4gICAgdmFyIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxKEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudF8xID0gdGhpcy5jcmVhdGVFbGVtZW50KCdkaXYnLCB0aGlzLmRlZmF1bHREb2MoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmdldFN0eWxlKGVsZW1lbnRfMSwgJ2FuaW1hdGlvbk5hbWUnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tUHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnTycsICdtcyddO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbVByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZ2V0U3R5bGUoZWxlbWVudF8xLCBkb21QcmVmaXhlc1tpXSArICdBbmltYXRpb25OYW1lJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUHJlZml4ID0gJy0nICsgZG9tUHJlZml4ZXNbaV0udG9Mb3dlckNhc2UoKSArICctJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzXzEgPSB7XG4gICAgICAgICAgICAgICAgICAgIFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgICAgICAgICAgICAgICAgTW96VHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgICAgICAgICAgICAgICBPVHJhbnNpdGlvbjogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0cmFuc0VuZEV2ZW50TmFtZXNfMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoX3RoaXMuZ2V0U3R5bGUoZWxlbWVudF8xLCBrZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyYW5zaXRpb25FbmQgPSB0cmFuc0VuZEV2ZW50TmFtZXNfMVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblByZWZpeCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXREaXN0cmlidXRlZE5vZGVzID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5nZXREaXN0cmlidXRlZE5vZGVzKCk7IH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVzb2x2ZUFuZFNldEhyZWYgPSBmdW5jdGlvbiAoZWwsIGJhc2VVcmwsIGhyZWYpIHtcbiAgICAgICAgICAgIGVsLmhyZWYgPSBocmVmID09IG51bGwgPyBiYXNlVXJsIDogYmFzZVVybCArICcvLi4vJyArIGhyZWY7XG4gICAgICAgIH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNET01FdmVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzTmF0aXZlU2hhZG93RE9NID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLmRlZmF1bHREb2MoKS5ib2R5LmNyZWF0ZVNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uUHJlZml4ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fYW5pbWF0aW9uUHJlZml4ID8gdGhpcy5fYW5pbWF0aW9uUHJlZml4IDogJyc7IH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25FbmQgPyB0aGlzLl90cmFuc2l0aW9uRW5kIDogJyc7IH07XG4gICAgICAgIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc3VwcG9ydHNBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2FuaW1hdGlvblByZWZpeCkgJiYgaXNQcmVzZW50KHRoaXMuX3RyYW5zaXRpb25FbmQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gR2VuZXJpY0Jyb3dzZXJEb21BZGFwdGVyO1xuICAgIH0oRG9tQWRhcHRlcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgX2F0dHJUb1Byb3BNYXAgPSB7XG4gICAgICAgICdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICAgICAgICAnaW5uZXJIdG1sJzogJ2lubmVySFRNTCcsXG4gICAgICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgICAgICd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG4gICAgfTtcbiAgICB2YXIgRE9NX0tFWV9MT0NBVElPTl9OVU1QQUQgPSAzO1xuICAgIC8vIE1hcCB0byBjb252ZXJ0IHNvbWUga2V5IG9yIGtleUlkZW50aWZpZXIgdmFsdWVzIHRvIHdoYXQgd2lsbCBiZSByZXR1cm5lZCBieSBnZXRFdmVudEtleVxuICAgIHZhciBfa2V5TWFwID0ge1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHZhbHVlcyBhcmUgaGVyZSBmb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IGFuZCB0byBtYXRjaCB0aGUgVzNDIHN0YW5kYXJkXG4gICAgICAgIC8vIGNmIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy1rZXkvXG4gICAgICAgICdcXGInOiAnQmFja3NwYWNlJyxcbiAgICAgICAgJ1xcdCc6ICdUYWInLFxuICAgICAgICAnXFx4N0YnOiAnRGVsZXRlJyxcbiAgICAgICAgJ1xceDFCJzogJ0VzY2FwZScsXG4gICAgICAgICdEZWwnOiAnRGVsZXRlJyxcbiAgICAgICAgJ0VzYyc6ICdFc2NhcGUnLFxuICAgICAgICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxuICAgICAgICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICAgICAgICdVcCc6ICdBcnJvd1VwJyxcbiAgICAgICAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcbiAgICAgICAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxuICAgICAgICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAgICAgICAnV2luJzogJ09TJ1xuICAgIH07XG4gICAgLy8gVGhlcmUgaXMgYSBidWcgaW4gQ2hyb21lIGZvciBudW1lcmljIGtleXBhZCBrZXlzOlxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNTU2NTRcbiAgICAvLyAxLCAyLCAzIC4uLiBhcmUgcmVwb3J0ZWQgYXMgQSwgQiwgQyAuLi5cbiAgICB2YXIgX2Nocm9tZU51bUtleVBhZE1hcCA9IHtcbiAgICAgICAgJ0EnOiAnMScsXG4gICAgICAgICdCJzogJzInLFxuICAgICAgICAnQyc6ICczJyxcbiAgICAgICAgJ0QnOiAnNCcsXG4gICAgICAgICdFJzogJzUnLFxuICAgICAgICAnRic6ICc2JyxcbiAgICAgICAgJ0cnOiAnNycsXG4gICAgICAgICdIJzogJzgnLFxuICAgICAgICAnSSc6ICc5JyxcbiAgICAgICAgJ0onOiAnKicsXG4gICAgICAgICdLJzogJysnLFxuICAgICAgICAnTSc6ICctJyxcbiAgICAgICAgJ04nOiAnLicsXG4gICAgICAgICdPJzogJy8nLFxuICAgICAgICAnXFx4NjAnOiAnMCcsXG4gICAgICAgICdcXHg5MCc6ICdOdW1Mb2NrJ1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBgRG9tQWRhcHRlcmAgcG93ZXJlZCBieSBmdWxsIGJyb3dzZXIgRE9NIEFQSXMuXG4gICAgICpcbiAgICAgKiBAc2VjdXJpdHkgVHJlYWQgY2FyZWZ1bGx5ISBJbnRlcmFjdGluZyB3aXRoIHRoZSBET00gZGlyZWN0bHkgaXMgZGFuZ2Vyb3VzIGFuZFxuICAgICAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICAgICAqL1xuICAgIC8qIHRzbGludDpkaXNhYmxlOnJlcXVpcmVQYXJhbWV0ZXJUeXBlICovXG4gICAgdmFyIEJyb3dzZXJEb21BZGFwdGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEJyb3dzZXJEb21BZGFwdGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBCcm93c2VyRG9tQWRhcHRlcigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZUh0bWwpIHsgdGhyb3cgbmV3IEVycm9yKCdwYXJzZSBub3QgaW1wbGVtZW50ZWQnKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIubWFrZUN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7IHNldFJvb3REb21BZGFwdGVyKG5ldyBCcm93c2VyRG9tQWRhcHRlcigpKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHsgcmV0dXJuIG5hbWUgaW4gZWxlbWVudDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkgeyBlbFtuYW1lXSA9IHZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiAoZWwsIG5hbWUpIHsgcmV0dXJuIGVsW25hbWVdOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGVsLCBtZXRob2ROYW1lLCBhcmdzKSB7IChfYSA9IGVsKVttZXRob2ROYW1lXS5hcHBseShfYSwgYXJncyk7IHZhciBfYTsgfTtcbiAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBtb3ZlIHRoaXMgaW50byBhIHNlcGFyYXRlIGVudmlyb25tZW50IGNsYXNzIG9uY2Ugd2UgaGF2ZSBpdFxuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHsgKHdpbmRvdy5jb25zb2xlLmVycm9yIHx8IHdpbmRvdy5jb25zb2xlLmxvZykoZXJyb3IpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGVycm9yKSB7IHdpbmRvdy5jb25zb2xlLmxvZyhlcnJvcik7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2dHcm91cCA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZ3JvdXAgJiYgd2luZG93LmNvbnNvbGUuZ3JvdXAoZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5sb2dFcnJvcihlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5sb2dHcm91cEVuZCA9IGZ1bmN0aW9uICgpIHsgd2luZG93LmNvbnNvbGUuZ3JvdXBFbmQgJiYgd2luZG93LmNvbnNvbGUuZ3JvdXBFbmQoKTsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZSwgXCJhdHRyVG9Qcm9wTWFwXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2F0dHJUb1Byb3BNYXA7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucXVlcnlTZWxlY3RvciA9IGZ1bmN0aW9uIChlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPSBmdW5jdGlvbiAoZWwsIHNlbGVjdG9yKSB7IHJldHVybiBlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGVsLCBldnQsIGxpc3RlbmVyKSB7IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBsaXN0ZW5lciwgZmFsc2UpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUub25BbmRDYW5jZWwgPSBmdW5jdGlvbiAoZWwsIGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gTmVlZGVkIHRvIGZvbGxvdyBEYXJ0J3Mgc3Vic2NyaXB0aW9uIHNlbWFudGljLCB1bnRpbCBmaXggb2ZcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZGFydC9pc3N1ZXMvZGV0YWlsP2lkPTE3NDA2XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZWwsIGV2dCkgeyBlbC5kaXNwYXRjaEV2ZW50KGV2dCk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVNb3VzZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2dC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNQcmV2ZW50ZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgaXNQcmVzZW50KGV2dC5yZXR1cm5WYWx1ZSkgJiYgIWV2dC5yZXR1cm5WYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldElubmVySFRNTCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuaW5uZXJIVE1MOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VGVtcGxhdGVDb250ZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbnRlbnQnIGluIGVsICYmIGVsIGluc3RhbmNlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCA/IGVsLmNvbnRlbnQgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0T3V0ZXJIVE1MID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5vdXRlckhUTUw7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5ub2RlTmFtZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVOYW1lOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubm9kZVZhbHVlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVZhbHVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnR5cGU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1Byb3BlcnR5KG5vZGUsICdjb250ZW50JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5maXJzdENoaWxkID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5maXJzdENoaWxkOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUubmV4dFNpYmxpbmcgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLm5leHRTaWJsaW5nOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucGFyZW50RWxlbWVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwucGFyZW50Tm9kZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNoaWxkTm9kZXMgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNoaWxkTm9kZXM7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jaGlsZE5vZGVzQXNMaXN0ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGVsLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IEFycmF5KGNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2xlYXJOb2RlcyA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChlbC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLmFwcGVuZENoaWxkKG5vZGUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoZWwsIG5vZGUpIHsgZWwucmVtb3ZlQ2hpbGQobm9kZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQgPSBmdW5jdGlvbiAoZWwsIG5ld0NoaWxkLCBvbGRDaGlsZCkgeyBlbC5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoZWwsIG5vZGUpIHsgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgZWwpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW5zZXJ0QWxsQmVmb3JlID0gZnVuY3Rpb24gKGVsLCBub2Rlcykge1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobiwgZWwpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24gKGVsLCBub2RlKSB7IGVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIGVsLm5leHRTaWJsaW5nKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldElubmVySFRNTCA9IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHsgZWwuaW5uZXJIVE1MID0gdmFsdWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC50ZXh0Q29udGVudDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFRleHQgPSBmdW5jdGlvbiAoZWwsIHZhbHVlKSB7IGVsLnRleHRDb250ZW50ID0gdmFsdWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwudmFsdWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHsgZWwudmFsdWUgPSB2YWx1ZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldENoZWNrZWQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmNoZWNrZWQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRDaGVja2VkID0gZnVuY3Rpb24gKGVsLCB2YWx1ZSkgeyBlbC5jaGVja2VkID0gdmFsdWU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVDb21tZW50ID0gZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dCk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICB0LmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgZG9jKSB7XG4gICAgICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cbiAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnROUyA9IGZ1bmN0aW9uIChucywgdGFnTmFtZSwgZG9jKSB7XG4gICAgICAgICAgICBpZiAoZG9jID09PSB2b2lkIDApIHsgZG9jID0gZG9jdW1lbnQ7IH1cbiAgICAgICAgICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWdOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVRleHROb2RlID0gZnVuY3Rpb24gKHRleHQsIGRvYykge1xuICAgICAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XG4gICAgICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlU2NyaXB0VGFnID0gZnVuY3Rpb24gKGF0dHJOYW1lLCBhdHRyVmFsdWUsIGRvYykge1xuICAgICAgICAgICAgaWYgKGRvYyA9PT0gdm9pZCAwKSB7IGRvYyA9IGRvY3VtZW50OyB9XG4gICAgICAgICAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnU0NSSVBUJyk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiAoY3NzLCBkb2MpIHtcbiAgICAgICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBkb2N1bWVudDsgfVxuICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHN0eWxlLCB0aGlzLmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY3JlYXRlU2hhZG93Um9vdCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuY3JlYXRlU2hhZG93Um9vdCgpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0U2hhZG93Um9vdCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwuc2hhZG93Um9vdDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEhvc3QgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmhvc3Q7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLmNsb25lTm9kZSh0cnVlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuY2xhc3NMaXN0ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnQuY2xhc3NMaXN0LCAwKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkgeyBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkgeyBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZW5hbWUpIHtcbiAgICAgICAgICAgIC8vIElFIHJlcXVpcmVzICcnIGluc3RlYWQgb2YgbnVsbFxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzc5MTZcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVuYW1lXSA9ICcnO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0U3R5bGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3R5bGVuYW1lKSB7IHJldHVybiBlbGVtZW50LnN0eWxlW3N0eWxlbmFtZV07IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5oYXNTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZVZhbHVlID09PSB2b2lkIDApIHsgc3R5bGVWYWx1ZSA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0U3R5bGUoZWxlbWVudCwgc3R5bGVOYW1lKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiBzdHlsZVZhbHVlID8gdmFsdWUgPT0gc3R5bGVWYWx1ZSA6IHZhbHVlLmxlbmd0aCA+IDA7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS50YWdOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQudGFnTmFtZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZU1hcCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdmFyIGVsQXR0cnMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsQXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmliID0gZWxBdHRyc1tpXTtcbiAgICAgICAgICAgICAgICByZXMuc2V0KGF0dHJpYi5uYW1lLCBhdHRyaWIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmhhc0F0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzQXR0cmlidXRlTlMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbnMsIGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlTlMobnMsIGF0dHJpYnV0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5TID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5zLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGVOUyhucywgbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHsgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMgPSBmdW5jdGlvbiAoZWxlbWVudCwgbnMsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG5zLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgYXR0cmlidXRlKSB7IGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGVOUyA9IGZ1bmN0aW9uIChlbGVtZW50LCBucywgbmFtZSkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGVOUyhucywgbmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS50ZW1wbGF0ZUF3YXJlUm9vdCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gdGhpcy5pc1RlbXBsYXRlRWxlbWVudChlbCkgPyB0aGlzLmNvbnRlbnQoZWwpIDogZWw7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVIdG1sRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCdmYWtlVGl0bGUnKTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmRlZmF1bHREb2MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudDsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCByaWdodDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC50aXRsZTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKG5ld1RpdGxlKSB7IGRvY3VtZW50LnRpdGxlID0gbmV3VGl0bGUgfHwgJyc7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5lbGVtZW50TWF0Y2hlcyA9IGZ1bmN0aW9uIChuLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuLm1hdGNoZXMgJiYgbi5tYXRjaGVzKHNlbGVjdG9yKSB8fFxuICAgICAgICAgICAgICAgICAgICBuLm1zTWF0Y2hlc1NlbGVjdG9yICYmIG4ubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpIHx8XG4gICAgICAgICAgICAgICAgICAgIG4ud2Via2l0TWF0Y2hlc1NlbGVjdG9yICYmIG4ud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzVGVtcGxhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBlbC5ub2RlTmFtZSA9PSAnVEVNUExBVEUnO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNUZXh0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmlzQ29tbWVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5DT01NRU5UX05PREU7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5pc0VsZW1lbnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaGFzU2hhZG93Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KG5vZGUuc2hhZG93Um9vdCkgJiYgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaXNTaGFkb3dSb290ID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50OyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuaW1wb3J0SW50b0RvYyA9IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBkb2N1bWVudC5pbXBvcnROb2RlKHRoaXMudGVtcGxhdGVBd2FyZVJvb3Qobm9kZSksIHRydWUpOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuYWRvcHROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGRvY3VtZW50LmFkb3B0Tm9kZShub2RlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEhyZWYgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmhyZWY7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRFdmVudEtleSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKGtleSkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBldmVudC5rZXlJZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIC8vIGtleUlkZW50aWZpZXIgaXMgZGVmaW5lZCBpbiB0aGUgb2xkIGRyYWZ0IG9mIERPTSBMZXZlbCAzIEV2ZW50cyBpbXBsZW1lbnRlZCBieSBDaHJvbWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGNmXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwNy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwNzEyMjEvZXZlbnRzLmh0bWwjRXZlbnRzLUtleWJvYXJkRXZlbnRzLUludGVyZmFjZXNcbiAgICAgICAgICAgICAgICBpZiAoaXNCbGFuayhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnVW5pZGVudGlmaWVkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdVKycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoa2V5LnN1YnN0cmluZygyKSwgMTYpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmxvY2F0aW9uID09PSBET01fS0VZX0xPQ0FUSU9OX05VTVBBRCAmJiBfY2hyb21lTnVtS2V5UGFkTWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgYnVnIGluIENocm9tZSBmb3IgbnVtZXJpYyBrZXlwYWQga2V5czpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNTU2NTRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEsIDIsIDMgLi4uIGFyZSByZXBvcnRlZCBhcyBBLCBCLCBDIC4uLlxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gX2Nocm9tZU51bUtleVBhZE1hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9rZXlNYXBba2V5XSB8fCBrZXk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5nZXRHbG9iYWxFdmVudFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldEhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuaGlzdG9yeTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LmxvY2F0aW9uOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaHJlZiA9IGdldEJhc2VFbGVtZW50SHJlZigpO1xuICAgICAgICAgICAgcmV0dXJuIGlzQmxhbmsoaHJlZikgPyBudWxsIDogcmVsYXRpdmVQYXRoKGhyZWYpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucmVzZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHsgYmFzZUVsZW1lbnQgPSBudWxsOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0VXNlckFnZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7IH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShlbGVtZW50LCAnZGF0YS0nICsgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoZWxlbWVudCwgJ2RhdGEtJyArIG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpOyB9O1xuICAgICAgICAvLyBUT0RPKHRib3NjaCk6IG1vdmUgdGhpcyBpbnRvIGEgc2VwYXJhdGUgZW52aXJvbm1lbnQgY2xhc3Mgb25jZSB3ZSBoYXZlIGl0XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zZXRHbG9iYWxWYXIgPSBmdW5jdGlvbiAocGF0aCwgdmFsdWUpIHsgc2V0VmFsdWVPblBhdGgoZ2xvYmFsJDEsIHBhdGgsIHZhbHVlKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnN1cHBvcnRzV2ViQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZVsnYW5pbWF0ZSddID09PSAnZnVuY3Rpb24nO1xuICAgICAgICB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUucGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBwZXJmb3JtYW5jZS5ub3coKSBpcyBub3QgYXZhaWxhYmxlIGluIGFsbCBicm93c2Vycywgc2VlXG4gICAgICAgICAgICAvLyBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1wZXJmb3JtYW5jZS5ub3dcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6XG4gICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyLnByb3RvdHlwZS5zdXBwb3J0c0Nvb2tpZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29va2llID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHBhcnNlQ29va2llVmFsdWUoZG9jdW1lbnQuY29va2llLCBuYW1lKTsgfTtcbiAgICAgICAgQnJvd3NlckRvbUFkYXB0ZXIucHJvdG90eXBlLnNldENvb2tpZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuY29va2llIGlzIG1hZ2ljYWwsIGFzc2lnbmluZyBpbnRvIGl0IGFzc2lnbnMvb3ZlcnJpZGVzIG9uZSBjb29raWUgdmFsdWUsIGJ1dCBkb2VzXG4gICAgICAgICAgICAvLyBub3QgY2xlYXIgb3RoZXIgY29va2llcy5cbiAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCcm93c2VyRG9tQWRhcHRlcjtcbiAgICB9KEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlcikpO1xuICAgIHZhciBiYXNlRWxlbWVudCA9IG51bGw7XG4gICAgZnVuY3Rpb24gZ2V0QmFzZUVsZW1lbnRIcmVmKCkge1xuICAgICAgICBpZiAoIWJhc2VFbGVtZW50KSB7XG4gICAgICAgICAgICBiYXNlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICAgICAgICAgIGlmICghYmFzZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgfVxuICAgIC8vIGJhc2VkIG9uIHVybFV0aWxzLmpzIGluIEFuZ3VsYXJKUyAxXG4gICAgdmFyIHVybFBhcnNpbmdOb2RlO1xuICAgIGZ1bmN0aW9uIHJlbGF0aXZlUGF0aCh1cmwpIHtcbiAgICAgICAgaWYgKCF1cmxQYXJzaW5nTm9kZSkge1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsKTtcbiAgICAgICAgcmV0dXJuICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgPyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDb29raWVWYWx1ZShjb29raWVTdHIsIG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChuYW1lKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvb2tpZVN0ci5zcGxpdCgnOycpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNvb2tpZSA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBlcUluZGV4ID0gY29va2llLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgIHZhciBfYiA9IGVxSW5kZXggPT0gLTEgPyBbY29va2llLCAnJ10gOiBbY29va2llLnNsaWNlKDAsIGVxSW5kZXgpLCBjb29raWUuc2xpY2UoZXFJbmRleCArIDEpXSwgY29va2llTmFtZSA9IF9iWzBdLCBjb29raWVWYWx1ZSA9IF9iWzFdO1xuICAgICAgICAgICAgaWYgKGNvb2tpZU5hbWUudHJpbSgpID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChjb29raWVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1cHBvcnRzU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiAhIXdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQyID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYFBsYXRmb3JtTG9jYXRpb25gIGVuY2Fwc3VsYXRlcyBhbGwgb2YgdGhlIGRpcmVjdCBjYWxscyB0byBwbGF0Zm9ybSBBUElzLlxuICAgICAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5IGJ5IGFuIGFwcGxpY2F0aW9uIGRldmVsb3Blci4gSW5zdGVhZCwgdXNlXG4gICAgICoge0BsaW5rIExvY2F0aW9ufS5cbiAgICAgKi9cbiAgICB2YXIgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMihCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQnJvd3NlclBsYXRmb3JtTG9jYXRpb24oKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIG1vdmVkIHRvIGl0cyBvd24gbWV0aG9kIHNvIHRoYXQgYE1vY2tQbGF0Zm9ybUxvY2F0aW9uU3RyYXRlZ3lgIGNhbiBvdmVyd3JpdGUgaXRcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGdldERPTSgpLmdldExvY2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9oaXN0b3J5ID0gZ2V0RE9NKCkuZ2V0SGlzdG9yeSgpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcImxvY2F0aW9uXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbG9jYXRpb247IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUuZ2V0QmFzZUhyZWZGcm9tRE9NID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0RE9NKCkuZ2V0QmFzZUhyZWYoKTsgfTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLm9uUG9wU3RhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGdldERPTSgpLmdldEdsb2JhbEV2ZW50VGFyZ2V0KCd3aW5kb3cnKS5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZuLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5vbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGdldERPTSgpLmdldEdsb2JhbEV2ZW50VGFyZ2V0KCd3aW5kb3cnKS5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZm4sIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZSwgXCJwYXRobmFtZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnBhdGhuYW1lOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UGF0aCkgeyB0aGlzLl9sb2NhdGlvbi5wYXRobmFtZSA9IG5ld1BhdGg7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLCBcInNlYXJjaFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnNlYXJjaDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUsIFwiaGFzaFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLmhhc2g7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5wcm90b3R5cGUucHVzaFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCB0aXRsZSwgdXJsKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsIHRpdGxlLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYXRpb24uaGFzaCA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlLCB0aXRsZSwgdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9uLmhhc2ggPSB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9oaXN0b3J5LmZvcndhcmQoKTsgfTtcbiAgICAgICAgQnJvd3NlclBsYXRmb3JtTG9jYXRpb24ucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2hpc3RvcnkuYmFjaygpOyB9O1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbjtcbiAgICB9KF9hbmd1bGFyX2NvbW1vbi5QbGF0Zm9ybUxvY2F0aW9uKSk7XG5cbiAgICB2YXIgX2NsZWFyVmFsdWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKChuZXcgTWFwKCkpLmtleXMoKS5uZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2NsZWFyVmFsdWVzKG0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5SXRlcmF0b3IgPSBtLmtleXMoKTtcbiAgICAgICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgICAgICB3aGlsZSAoISgoayA9IGtleUl0ZXJhdG9yLm5leHQoKSkuZG9uZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbS5zZXQoay52YWx1ZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBfY2xlYXJWYWx1ZXNXaXRoRm9yZUVhY2gobSkge1xuICAgICAgICAgICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyBtLnNldChrLCBudWxsKTsgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICAvLyBTYWZhcmkgZG9lc24ndCBpbXBsZW1lbnQgTWFwSXRlcmF0b3IubmV4dCgpLCB3aGljaCBpcyB1c2VkIGlzIFRyYWNldXIncyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXG4gICAgLy8gVE9ETyhtbGF2YWwpOiByZW1vdmUgdGhlIHdvcmsgYXJvdW5kIG9uY2Ugd2UgaGF2ZSBhIHdvcmtpbmcgcG9seWZpbGwgb2YgQXJyYXkuZnJvbVxuICAgIHZhciBfYXJyYXlGcm9tTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgobmV3IE1hcCgpKS52YWx1ZXMoKS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1hcChtLCBnZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlcyA/IEFycmF5LmZyb20obS52YWx1ZXMoKSkgOiBBcnJheS5mcm9tKG0ua2V5cygpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1hcFdpdGhGb3JlYWNoKG0sIGdldFZhbHVlcykge1xuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheShtLnNpemUpLCBpID0gMDtcbiAgICAgICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IGdldFZhbHVlcyA/IHYgOiBrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuICAgIC8qKlxuICAgICAqIFdyYXBzIEphdmFzY3JpcHQgT2JqZWN0c1xuICAgICAqL1xuICAgIHZhciBTdHJpbmdNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nTWFwV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIG0gPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0xW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IE9iamVjdC5rZXlzKG0yKTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTJba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgICB2YXIgazEgPSBPYmplY3Qua2V5cyhtMSk7XG4gICAgICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gazFbaV07XG4gICAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIHZhciBMaXN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTIGhhcyBubyB3YXkgdG8gZXhwcmVzcyBhIHN0YXRpY2FsbHkgZml4ZWQgc2l6ZSBsaXN0LCBidXQgZGFydCBkb2VzIHNvIHdlXG4gICAgICAgIC8vIGtlZXAgYm90aCBtZXRob2RzLlxuICAgICAgICBMaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jcmVhdGVHcm93YWJsZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jbG9uZSA9IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm4oYXJyYXlbaV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5maXJzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFhcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIubGFzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSB2b2lkIDApIHsgc3RhcnRJbmRleCA9IDA7IH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlLCBzdGFydEluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY29udGFpbnMgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHsgcmV0dXJuIGxpc3QuaW5kZXhPZihlbCkgIT09IC0xOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZXZlcnNlZCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgdmFyIGEgPSBMaXN0V3JhcHBlci5jbG9uZShhcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYS5yZXZlcnNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmNvbmNhdCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0ID0gZnVuY3Rpb24gKGxpc3QsIGluZGV4LCB2YWx1ZSkgeyBsaXN0LnNwbGljZShpbmRleCwgMCwgdmFsdWUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jbGVhciA9IGZ1bmN0aW9uIChsaXN0KSB7IGxpc3QubGVuZ3RoID0gMDsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaXNFbXB0eSA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0Lmxlbmd0aCA9PSAwOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5maWxsID0gZnVuY3Rpb24gKGxpc3QsIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBudWxsOyB9XG4gICAgICAgICAgICBsaXN0LmZpbGwodmFsdWUsIHN0YXJ0LCBlbmQgPT09IG51bGwgPyBsaXN0Lmxlbmd0aCA6IGVuZCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5zbGljZSA9IGZ1bmN0aW9uIChsLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gbC5zbGljZShmcm9tLCB0byA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc3BsaWNlID0gZnVuY3Rpb24gKGwsIGZyb20sIGxlbmd0aCkgeyByZXR1cm4gbC5zcGxpY2UoZnJvbSwgbGVuZ3RoKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc29ydCA9IGZ1bmN0aW9uIChsLCBjb21wYXJlRm4pIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29tcGFyZUZuKSkge1xuICAgICAgICAgICAgICAgIGwuc29ydChjb21wYXJlRm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbC5zb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwudG9TdHJpbmcoKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIudG9KU09OID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGwpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5tYXhpbXVtID0gZnVuY3Rpb24gKGxpc3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbWF4VmFsdWUgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZVZhbHVlID0gcHJlZGljYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gY2FuZGlkYXRlVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkobGlzdCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbCA9IGZ1bmN0aW9uIChsaXN0LCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaXN0V3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9mbGF0dGVuQXJyYXkoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkoaXRlbSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBCcm93c2VyR2V0VGVzdGFiaWxpdHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCcm93c2VyR2V0VGVzdGFiaWxpdHkoKSB7XG4gICAgICAgIH1cbiAgICAgICAgQnJvd3NlckdldFRlc3RhYmlsaXR5LmluaXQgPSBmdW5jdGlvbiAoKSB7IF9hbmd1bGFyX2NvcmUuc2V0VGVzdGFiaWxpdHlHZXR0ZXIobmV3IEJyb3dzZXJHZXRUZXN0YWJpbGl0eSgpKTsgfTtcbiAgICAgICAgQnJvd3NlckdldFRlc3RhYmlsaXR5LnByb3RvdHlwZS5hZGRUb1dpbmRvdyA9IGZ1bmN0aW9uIChyZWdpc3RyeSkge1xuICAgICAgICAgICAgZ2xvYmFsJDEuZ2V0QW5ndWxhclRlc3RhYmlsaXR5ID0gZnVuY3Rpb24gKGVsZW0sIGZpbmRJbkFuY2VzdG9ycykge1xuICAgICAgICAgICAgICAgIGlmIChmaW5kSW5BbmNlc3RvcnMgPT09IHZvaWQgMCkgeyBmaW5kSW5BbmNlc3RvcnMgPSB0cnVlOyB9XG4gICAgICAgICAgICAgICAgdmFyIHRlc3RhYmlsaXR5ID0gcmVnaXN0cnkuZmluZFRlc3RhYmlsaXR5SW5UcmVlKGVsZW0sIGZpbmRJbkFuY2VzdG9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RhYmlsaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0ZXN0YWJpbGl0eSBmb3IgZWxlbWVudC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlc3RhYmlsaXR5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbCQxLmdldEFsbEFuZ3VsYXJUZXN0YWJpbGl0aWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVnaXN0cnkuZ2V0QWxsVGVzdGFiaWxpdGllcygpOyB9O1xuICAgICAgICAgICAgZ2xvYmFsJDEuZ2V0QWxsQW5ndWxhclJvb3RFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ2lzdHJ5LmdldEFsbFJvb3RFbGVtZW50cygpOyB9O1xuICAgICAgICAgICAgdmFyIHdoZW5BbGxTdGFibGUgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdGFiaWxpdGllcyA9IGdsb2JhbCQxLmdldEFsbEFuZ3VsYXJUZXN0YWJpbGl0aWVzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGVzdGFiaWxpdGllcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGRpZFdvcmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50ID0gZnVuY3Rpb24gKGRpZFdvcmtfIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFdvcmsgPSBkaWRXb3JrIHx8IGRpZFdvcmtfO1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGlkV29yayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRlc3RhYmlsaXRpZXMuZm9yRWFjaChmdW5jdGlvbiAodGVzdGFiaWxpdHkgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGVzdGFiaWxpdHkud2hlblN0YWJsZShkZWNyZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghZ2xvYmFsJDFbJ2ZyYW1ld29ya1N0YWJpbGl6ZXJzJ10pIHtcbiAgICAgICAgICAgICAgICBnbG9iYWwkMVsnZnJhbWV3b3JrU3RhYmlsaXplcnMnXSA9IExpc3RXcmFwcGVyLmNyZWF0ZUdyb3dhYmxlU2l6ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsb2JhbCQxWydmcmFtZXdvcmtTdGFiaWxpemVycyddLnB1c2god2hlbkFsbFN0YWJsZSk7XG4gICAgICAgIH07XG4gICAgICAgIEJyb3dzZXJHZXRUZXN0YWJpbGl0eS5wcm90b3R5cGUuZmluZFRlc3RhYmlsaXR5SW5UcmVlID0gZnVuY3Rpb24gKHJlZ2lzdHJ5LCBlbGVtLCBmaW5kSW5BbmNlc3RvcnMpIHtcbiAgICAgICAgICAgIGlmIChlbGVtID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0ID0gcmVnaXN0cnkuZ2V0VGVzdGFiaWxpdHkoZWxlbSk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0RE9NKCkuaXNTaGFkb3dSb290KGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZFRlc3RhYmlsaXR5SW5UcmVlKHJlZ2lzdHJ5LCBnZXRET00oKS5nZXRIb3N0KGVsZW0pLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRUZXN0YWJpbGl0eUluVHJlZShyZWdpc3RyeSwgZ2V0RE9NKCkucGFyZW50RWxlbWVudChlbGVtKSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCcm93c2VyR2V0VGVzdGFiaWxpdHk7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEEgc2VydmljZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGdldCBhbmQgc2V0IHRoZSB0aXRsZSBvZiBhIGN1cnJlbnQgSFRNTCBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIFNpbmNlIGFuIEFuZ3VsYXIgMiBhcHBsaWNhdGlvbiBjYW4ndCBiZSBib290c3RyYXBwZWQgb24gdGhlIGVudGlyZSBIVE1MIGRvY3VtZW50IChgPGh0bWw+YCB0YWcpXG4gICAgICogaXQgaXMgbm90IHBvc3NpYmxlIHRvIGJpbmQgdG8gdGhlIGB0ZXh0YCBwcm9wZXJ0eSBvZiB0aGUgYEhUTUxUaXRsZUVsZW1lbnRgIGVsZW1lbnRzXG4gICAgICogKHJlcHJlc2VudGluZyB0aGUgYDx0aXRsZT5gIHRhZykuIEluc3RlYWQsIHRoaXMgc2VydmljZSBjYW4gYmUgdXNlZCB0byBzZXQgYW5kIGdldCB0aGUgY3VycmVudFxuICAgICAqIHRpdGxlIHZhbHVlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBUaXRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRpdGxlKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHRpdGxlIG9mIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBUaXRsZS5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRET00oKS5nZXRUaXRsZSgpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBIVE1MIGRvY3VtZW50LlxuICAgICAgICAgKiBAcGFyYW0gbmV3VGl0bGVcbiAgICAgICAgICovXG4gICAgICAgIFRpdGxlLnByb3RvdHlwZS5zZXRUaXRsZSA9IGZ1bmN0aW9uIChuZXdUaXRsZSkgeyBnZXRET00oKS5zZXRUaXRsZShuZXdUaXRsZSk7IH07XG4gICAgICAgIHJldHVybiBUaXRsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQSBESSBUb2tlbiByZXByZXNlbnRpbmcgdGhlIG1haW4gcmVuZGVyaW5nIGNvbnRleHQuIEluIGEgYnJvd3NlciB0aGlzIGlzIHRoZSBET00gRG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBEb2N1bWVudCBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGluIHRoZSBBcHBsaWNhdGlvbiBDb250ZXh0IHdoZW4gQXBwbGljYXRpb24gYW5kIFJlbmRlcmluZ1xuICAgICAqIENvbnRleHRzIGFyZSBub3QgdGhlIHNhbWUgKGUuZy4gd2hlbiBydW5uaW5nIHRoZSBhcHBsaWNhdGlvbiBpbnRvIGEgV2ViIFdvcmtlcikuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIERPQ1VNRU5UID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ0RvY3VtZW50VG9rZW4nKTtcblxuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRVZFTlRfTUFOQUdFUl9QTFVHSU5TID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ0V2ZW50TWFuYWdlclBsdWdpbnMnKTtcbiAgICAvKipcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEV2ZW50TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEV2ZW50TWFuYWdlcihwbHVnaW5zLCBfem9uZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3pvbmUgPSBfem9uZTtcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5tYW5hZ2VyID0gX3RoaXM7IH0pO1xuICAgICAgICAgICAgdGhpcy5fcGx1Z2lucyA9IHBsdWdpbnMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMuX2ZpbmRQbHVnaW5Gb3IoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW4uYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLl9maW5kUGx1Z2luRm9yKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2luLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFpvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl96b25lOyB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuX2ZpbmRQbHVnaW5Gb3IgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnN1cHBvcnRzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBldmVudCBtYW5hZ2VyIHBsdWdpbiBmb3VuZCBmb3IgZXZlbnQgXCIgKyBldmVudE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBFdmVudE1hbmFnZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBFdmVudE1hbmFnZXIuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0VWRU5UX01BTkFHRVJfUExVR0lOUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nWm9uZSwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEV2ZW50TWFuYWdlcjtcbiAgICB9KCkpO1xuICAgIHZhciBFdmVudE1hbmFnZXJQbHVnaW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBFdmVudE1hbmFnZXJQbHVnaW4oKSB7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhhdCBpcyBlcXVpdmFsZW50IHRvIGhhdmluZyBzdXBwb3J0aW5nICRldmVudC50YXJnZXRcbiAgICAgICAgRXZlbnRNYW5hZ2VyUGx1Z2luLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICBFdmVudE1hbmFnZXJQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyAnbm90IGltcGxlbWVudGVkJztcbiAgICAgICAgfTtcbiAgICAgICAgRXZlbnRNYW5hZ2VyUGx1Z2luLnByb3RvdHlwZS5hZGRHbG9iYWxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgJ25vdCBpbXBsZW1lbnRlZCc7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmVudE1hbmFnZXJQbHVnaW47XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgU2hhcmVkU3R5bGVzSG9zdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNoYXJlZFN0eWxlc0hvc3QoKSB7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9zdHlsZXMgPSBbXTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3N0eWxlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBTaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5hZGRTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fc3R5bGVzU2V0LmhhcyhzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0eWxlc1NldC5hZGQoc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3R5bGVzLnB1c2goc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbnMucHVzaChzdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm9uU3R5bGVzQWRkZWQoYWRkaXRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUub25TdHlsZXNBZGRlZCA9IGZ1bmN0aW9uIChhZGRpdGlvbnMpIHsgfTtcbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5wcm90b3R5cGUuZ2V0QWxsU3R5bGVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3R5bGVzOyB9O1xuICAgICAgICBTaGFyZWRTdHlsZXNIb3N0LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgU2hhcmVkU3R5bGVzSG9zdC5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gU2hhcmVkU3R5bGVzSG9zdDtcbiAgICB9KCkpO1xuICAgIHZhciBEb21TaGFyZWRTdHlsZXNIb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDQoRG9tU2hhcmVkU3R5bGVzSG9zdCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRG9tU2hhcmVkU3R5bGVzSG9zdChkb2MpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faG9zdE5vZGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5faG9zdE5vZGVzLmFkZChkb2MuaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5fYWRkU3R5bGVzVG9Ib3N0ID0gZnVuY3Rpb24gKHN0eWxlcywgaG9zdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbaV07XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuYXBwZW5kQ2hpbGQoaG9zdCwgZ2V0RE9NKCkuY3JlYXRlU3R5bGVFbGVtZW50KHN0eWxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVNoYXJlZFN0eWxlc0hvc3QucHJvdG90eXBlLmFkZEhvc3QgPSBmdW5jdGlvbiAoaG9zdE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFN0eWxlc1RvSG9zdCh0aGlzLl9zdHlsZXMsIGhvc3ROb2RlKTtcbiAgICAgICAgICAgIHRoaXMuX2hvc3ROb2Rlcy5hZGQoaG9zdE5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5yZW1vdmVIb3N0ID0gZnVuY3Rpb24gKGhvc3ROb2RlKSB7IHRoaXMuX2hvc3ROb2Rlcy5kZWxldGUoaG9zdE5vZGUpOyB9O1xuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0LnByb3RvdHlwZS5vblN0eWxlc0FkZGVkID0gZnVuY3Rpb24gKGFkZGl0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2hvc3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChob3N0Tm9kZSkgeyBfdGhpcy5fYWRkU3R5bGVzVG9Ib3N0KGFkZGl0aW9ucywgaG9zdE5vZGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tU2hhcmVkU3R5bGVzSG9zdC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIERvbVNoYXJlZFN0eWxlc0hvc3QuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtET0NVTUVOVCxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gRG9tU2hhcmVkU3R5bGVzSG9zdDtcbiAgICB9KFNoYXJlZFN0eWxlc0hvc3QpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgTkFNRVNQQUNFX1VSSVMgPSB7XG4gICAgICAgICd4bGluayc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgICAgICAgJ3N2Zyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgICAgICd4aHRtbCc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJ1xuICAgIH07XG4gICAgdmFyIFRFTVBMQVRFX0NPTU1FTlRfVEVYVCA9ICd0ZW1wbGF0ZSBiaW5kaW5ncz17fSc7XG4gICAgdmFyIFRFTVBMQVRFX0JJTkRJTkdTX0VYUCA9IC9edGVtcGxhdGUgYmluZGluZ3M9KC4qKSQvO1xuICAgIHZhciBEb21Sb290UmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEb21Sb290UmVuZGVyZXIoZG9jdW1lbnQsIGV2ZW50TWFuYWdlciwgc2hhcmVkU3R5bGVzSG9zdCwgYW5pbWF0aW9uRHJpdmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzSG9zdCA9IHNoYXJlZFN0eWxlc0hvc3Q7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkRyaXZlciA9IGFuaW1hdGlvbkRyaXZlcjtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZENvbXBvbmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgRG9tUm9vdFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50UHJvdG8pIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVnaXN0ZXJlZENvbXBvbmVudHMuZ2V0KGNvbXBvbmVudFByb3RvLmlkKTtcbiAgICAgICAgICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlciA9IG5ldyBEb21SZW5kZXJlcih0aGlzLCBjb21wb25lbnRQcm90bywgdGhpcy5hbmltYXRpb25Ecml2ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZENvbXBvbmVudHMuc2V0KGNvbXBvbmVudFByb3RvLmlkLCByZW5kZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEb21Sb290UmVuZGVyZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgRG9tUm9vdFJlbmRlcmVyXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKERvbVJvb3RSZW5kZXJlcl8sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERvbVJvb3RSZW5kZXJlcl8oX2RvY3VtZW50LCBfZXZlbnRNYW5hZ2VyLCBzaGFyZWRTdHlsZXNIb3N0LCBhbmltYXRpb25Ecml2ZXIpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIF9kb2N1bWVudCwgX2V2ZW50TWFuYWdlciwgc2hhcmVkU3R5bGVzSG9zdCwgYW5pbWF0aW9uRHJpdmVyKTtcbiAgICAgICAgfVxuICAgICAgICBEb21Sb290UmVuZGVyZXJfLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRG9tUm9vdFJlbmRlcmVyXy5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW0RPQ1VNRU5ULF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEV2ZW50TWFuYWdlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogRG9tU2hhcmVkU3R5bGVzSG9zdCwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogQW5pbWF0aW9uRHJpdmVyLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gRG9tUm9vdFJlbmRlcmVyXztcbiAgICB9KERvbVJvb3RSZW5kZXJlcikpO1xuICAgIHZhciBEb21SZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERvbVJlbmRlcmVyKF9yb290UmVuZGVyZXIsIGNvbXBvbmVudFByb3RvLCBfYW5pbWF0aW9uRHJpdmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290UmVuZGVyZXIgPSBfcm9vdFJlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRQcm90byA9IGNvbXBvbmVudFByb3RvO1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uRHJpdmVyID0gX2FuaW1hdGlvbkRyaXZlcjtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlcyA9IF9mbGF0dGVuU3R5bGVzKGNvbXBvbmVudFByb3RvLmlkLCBjb21wb25lbnRQcm90by5zdHlsZXMsIFtdKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRQcm90by5lbmNhcHN1bGF0aW9uICE9PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3RSZW5kZXJlci5zaGFyZWRTdHlsZXNIb3N0LmFkZFN0eWxlcyh0aGlzLl9zdHlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50UHJvdG8uZW5jYXBzdWxhdGlvbiA9PT0gX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRBdHRyID0gX3NoaW1Db250ZW50QXR0cmlidXRlKGNvbXBvbmVudFByb3RvLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob3N0QXR0ciA9IF9zaGltSG9zdEF0dHJpYnV0ZShjb21wb25lbnRQcm90by5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50QXR0ciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5faG9zdEF0dHIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZWxlY3RSb290RWxlbWVudCA9IGZ1bmN0aW9uIChzZWxlY3Rvck9yTm9kZSwgZGVidWdJbmZvKSB7XG4gICAgICAgICAgICB2YXIgZWw7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoc2VsZWN0b3JPck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBnZXRET00oKS5xdWVyeVNlbGVjdG9yKHRoaXMuX3Jvb3RSZW5kZXJlci5kb2N1bWVudCwgc2VsZWN0b3JPck5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0JsYW5rKGVsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2VsZWN0b3IgXFxcIlwiICsgc2VsZWN0b3JPck5vZGUgKyBcIlxcXCIgZGlkIG5vdCBtYXRjaCBhbnkgZWxlbWVudHNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwgPSBzZWxlY3Rvck9yTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldERPTSgpLmNsZWFyTm9kZXMoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIG5zQW5kTmFtZSA9IHNwbGl0TmFtZXNwYWNlKG5hbWUpO1xuICAgICAgICAgICAgdmFyIGVsID0gaXNQcmVzZW50KG5zQW5kTmFtZVswXSkgP1xuICAgICAgICAgICAgICAgIGdldERPTSgpLmNyZWF0ZUVsZW1lbnROUyhOQU1FU1BBQ0VfVVJJU1tuc0FuZE5hbWVbMF1dLCBuc0FuZE5hbWVbMV0pIDpcbiAgICAgICAgICAgICAgICBnZXRET00oKS5jcmVhdGVFbGVtZW50KG5zQW5kTmFtZVsxXSk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX2NvbnRlbnRBdHRyKSkge1xuICAgICAgICAgICAgICAgIGdldERPTSgpLnNldEF0dHJpYnV0ZShlbCwgdGhpcy5fY29udGVudEF0dHIsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGdldERPTSgpLmFwcGVuZENoaWxkKHBhcmVudCwgZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVmlld1Jvb3QgPSBmdW5jdGlvbiAoaG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBub2Rlc1BhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFByb3RvLmVuY2Fwc3VsYXRpb24gPT09IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNQYXJlbnQgPSBnZXRET00oKS5jcmVhdGVTaGFkb3dSb290KGhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290UmVuZGVyZXIuc2hhcmVkU3R5bGVzSG9zdC5hZGRIb3N0KG5vZGVzUGFyZW50KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBnZXRET00oKS5hcHBlbmRDaGlsZChub2Rlc1BhcmVudCwgZ2V0RE9NKCkuY3JlYXRlU3R5bGVFbGVtZW50KHRoaXMuX3N0eWxlc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5faG9zdEF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLnNldEF0dHJpYnV0ZShob3N0RWxlbWVudCwgdGhpcy5faG9zdEF0dHIsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZXNQYXJlbnQgPSBob3N0RWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2Rlc1BhcmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRlbXBsYXRlQW5jaG9yID0gZnVuY3Rpb24gKHBhcmVudEVsZW1lbnQsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBnZXRET00oKS5jcmVhdGVDb21tZW50KFRFTVBMQVRFX0NPTU1FTlRfVEVYVCk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuYXBwZW5kQ2hpbGQocGFyZW50RWxlbWVudCwgY29tbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAocGFyZW50RWxlbWVudCwgdmFsdWUsIGRlYnVnSW5mbykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBnZXRET00oKS5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkuYXBwZW5kQ2hpbGQocGFyZW50RWxlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnByb2plY3ROb2RlcyA9IGZ1bmN0aW9uIChwYXJlbnRFbGVtZW50LCBub2Rlcykge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsocGFyZW50RWxlbWVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYXBwZW5kTm9kZXMocGFyZW50RWxlbWVudCwgbm9kZXMpO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoVmlld0FmdGVyID0gZnVuY3Rpb24gKG5vZGUsIHZpZXdSb290Tm9kZXMpIHsgbW92ZU5vZGVzQWZ0ZXJTaWJsaW5nKG5vZGUsIHZpZXdSb290Tm9kZXMpOyB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuZGV0YWNoVmlldyA9IGZ1bmN0aW9uICh2aWV3Um9vdE5vZGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXdSb290Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5yZW1vdmUodmlld1Jvb3ROb2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95VmlldyA9IGZ1bmN0aW9uIChob3N0RWxlbWVudCwgdmlld0FsbE5vZGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnRQcm90by5lbmNhcHN1bGF0aW9uID09PSBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5hdGl2ZSAmJiBpc1ByZXNlbnQoaG9zdEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdFJlbmRlcmVyLnNoYXJlZFN0eWxlc0hvc3QucmVtb3ZlSG9zdChnZXRET00oKS5nZXRTaGFkb3dSb290KGhvc3RFbGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290UmVuZGVyZXIuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIocmVuZGVyRWxlbWVudCwgbmFtZSwgZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChjYWxsYmFjaykpO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUubGlzdGVuR2xvYmFsID0gZnVuY3Rpb24gKHRhcmdldCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290UmVuZGVyZXIuZXZlbnRNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBuYW1lLCBkZWNvcmF0ZVByZXZlbnREZWZhdWx0KGNhbGxiYWNrKSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRFbGVtZW50UHJvcGVydHkgPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICBnZXRET00oKS5zZXRQcm9wZXJ0eShyZW5kZXJFbGVtZW50LCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuc2V0RWxlbWVudEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGF0dHJOcztcbiAgICAgICAgICAgIHZhciBuc0FuZE5hbWUgPSBzcGxpdE5hbWVzcGFjZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQobnNBbmROYW1lWzBdKSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBuc0FuZE5hbWVbMF0gKyAnOicgKyBuc0FuZE5hbWVbMV07XG4gICAgICAgICAgICAgICAgYXR0ck5zID0gTkFNRVNQQUNFX1VSSVNbbnNBbmROYW1lWzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChhdHRyTnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLnNldEF0dHJpYnV0ZU5TKHJlbmRlckVsZW1lbnQsIGF0dHJOcywgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RE9NKCkuc2V0QXR0cmlidXRlKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGF0dHJOcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RE9NKCkucmVtb3ZlQXR0cmlidXRlTlMocmVuZGVyRWxlbWVudCwgYXR0ck5zLCBuc0FuZE5hbWVbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RE9NKCkucmVtb3ZlQXR0cmlidXRlKHJlbmRlckVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEJpbmRpbmdEZWJ1Z0luZm8gPSBmdW5jdGlvbiAocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGFzaENhc2VkUHJvcGVydHlOYW1lID0gY2FtZWxDYXNlVG9EYXNoQ2FzZShwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgaWYgKGdldERPTSgpLmlzQ29tbWVudE5vZGUocmVuZGVyRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdCaW5kaW5ncyA9IFN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChnZXRET00oKS5nZXRUZXh0KHJlbmRlckVsZW1lbnQpLCAvXFxuL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAubWF0Y2goVEVNUExBVEVfQklORElOR1NfRVhQKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkQmluZGluZ3MgPSBKc29uLnBhcnNlKGV4aXN0aW5nQmluZGluZ3NbMV0pO1xuICAgICAgICAgICAgICAgIHBhcnNlZEJpbmRpbmdzW2Rhc2hDYXNlZFByb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgICAgICAgICAgIGdldERPTSgpLnNldFRleHQocmVuZGVyRWxlbWVudCwgU3RyaW5nV3JhcHBlci5yZXBsYWNlKFRFTVBMQVRFX0NPTU1FTlRfVEVYVCwgJ3t9JywgSnNvbi5zdHJpbmdpZnkocGFyc2VkQmluZGluZ3MpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVsZW1lbnRBdHRyaWJ1dGUocmVuZGVyRWxlbWVudCwgcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRDbGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBjbGFzc05hbWUsIGlzQWRkKSB7XG4gICAgICAgICAgICBpZiAoaXNBZGQpIHtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5hZGRDbGFzcyhyZW5kZXJFbGVtZW50LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkucmVtb3ZlQ2xhc3MocmVuZGVyRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLnNldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBzdHlsZU5hbWUsIHN0eWxlVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc3R5bGVWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5zZXRTdHlsZShyZW5kZXJFbGVtZW50LCBzdHlsZU5hbWUsIHN0cmluZ2lmeShzdHlsZVZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRET00oKS5yZW1vdmVTdHlsZShyZW5kZXJFbGVtZW50LCBzdHlsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21SZW5kZXJlci5wcm90b3R5cGUuaW52b2tlRWxlbWVudE1ldGhvZCA9IGZ1bmN0aW9uIChyZW5kZXJFbGVtZW50LCBtZXRob2ROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICBnZXRET00oKS5pbnZva2UocmVuZGVyRWxlbWVudCwgbWV0aG9kTmFtZSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVJlbmRlcmVyLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gKHJlbmRlck5vZGUsIHRleHQpIHsgZ2V0RE9NKCkuc2V0VGV4dChyZW5kZXJOb2RlLCB0ZXh0KTsgfTtcbiAgICAgICAgRG9tUmVuZGVyZXIucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgc3RhcnRpbmdTdHlsZXMsIGtleWZyYW1lcywgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpb25Ecml2ZXIuYW5pbWF0ZShlbGVtZW50LCBzdGFydGluZ1N0eWxlcywga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBEb21SZW5kZXJlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIG1vdmVOb2Rlc0FmdGVyU2libGluZyhzaWJsaW5nIC8qKiBUT0RPICM5MTAwICovLCBub2RlcyAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICB2YXIgcGFyZW50ID0gZ2V0RE9NKCkucGFyZW50RWxlbWVudChzaWJsaW5nKTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDAgJiYgaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgIHZhciBuZXh0U2libGluZyA9IGdldERPTSgpLm5leHRTaWJsaW5nKHNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChuZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldERPTSgpLmluc2VydEJlZm9yZShuZXh0U2libGluZywgbm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RE9NKCkuYXBwZW5kQ2hpbGQocGFyZW50LCBub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGVuZE5vZGVzKHBhcmVudCAvKiogVE9ETyAjOTEwMCAqLywgbm9kZXMgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ2V0RE9NKCkuYXBwZW5kQ2hpbGQocGFyZW50LCBub2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChldmVudEhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICAgICAgdmFyIGFsbG93RGVmYXVsdEJlaGF2aW9yID0gZXZlbnRIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhbGxvd0RlZmF1bHRCZWhhdmlvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHRib3NjaCk6IG1vdmUgcHJldmVudERlZmF1bHQgaW50byBldmVudCBwbHVnaW5zLi4uXG4gICAgICAgICAgICAgICAgZ2V0RE9NKCkucHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgQ09NUE9ORU5UX1JFR0VYID0gLyVDT01QJS9nO1xuICAgIHZhciBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbiAgICB2YXIgSE9TVF9BVFRSID0gXCJfbmdob3N0LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xuICAgIHZhciBDT05URU5UX0FUVFIgPSBcIl9uZ2NvbnRlbnQtXCIgKyBDT01QT05FTlRfVkFSSUFCTEU7XG4gICAgZnVuY3Rpb24gX3NoaW1Db250ZW50QXR0cmlidXRlKGNvbXBvbmVudFNob3J0SWQpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbChDT05URU5UX0FUVFIsIENPTVBPTkVOVF9SRUdFWCwgY29tcG9uZW50U2hvcnRJZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9zaGltSG9zdEF0dHJpYnV0ZShjb21wb25lbnRTaG9ydElkKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoSE9TVF9BVFRSLCBDT01QT05FTlRfUkVHRVgsIGNvbXBvbmVudFNob3J0SWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZmxhdHRlblN0eWxlcyhjb21wSWQsIHN0eWxlcywgdGFyZ2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbaV07XG4gICAgICAgICAgICBpZiAoaXNBcnJheShzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBfZmxhdHRlblN0eWxlcyhjb21wSWQsIHN0eWxlLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBTdHJpbmdXcmFwcGVyLnJlcGxhY2VBbGwoc3R5bGUsIENPTVBPTkVOVF9SRUdFWCwgY29tcElkKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgdmFyIE5TX1BSRUZJWF9SRSA9IC9eOihbXjpdKyk6KC4rKSQvO1xuICAgIGZ1bmN0aW9uIHNwbGl0TmFtZXNwYWNlKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCA9IG5hbWUubWF0Y2goTlNfUFJFRklYX1JFKTtcbiAgICAgICAgcmV0dXJuIFttYXRjaFsxXSwgbWF0Y2hbMl1dO1xuICAgIH1cblxuICAgIHZhciBDT1JFX1RPS0VOUyA9IHtcbiAgICAgICAgJ0FwcGxpY2F0aW9uUmVmJzogX2FuZ3VsYXJfY29yZS5BcHBsaWNhdGlvblJlZixcbiAgICAgICAgJ05nWm9uZSc6IF9hbmd1bGFyX2NvcmUuTmdab25lXG4gICAgfTtcbiAgICB2YXIgSU5TUEVDVF9HTE9CQUxfTkFNRSA9ICduZy5wcm9iZSc7XG4gICAgdmFyIENPUkVfVE9LRU5TX0dMT0JBTF9OQU1FID0gJ25nLmNvcmVUb2tlbnMnO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgRGVidWdFbGVtZW50fSBmb3IgdGhlIGdpdmVuIG5hdGl2ZSBET00gZWxlbWVudCwgb3JcbiAgICAgKiBudWxsIGlmIHRoZSBnaXZlbiBuYXRpdmUgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGFuIEFuZ3VsYXIgdmlldyBhc3NvY2lhdGVkXG4gICAgICogd2l0aCBpdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0TmF0aXZlRWxlbWVudChlbGVtZW50IC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgIHJldHVybiBfYW5ndWxhcl9jb3JlLmdldERlYnVnTm9kZShlbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBOZ1Byb2JlVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1Byb2JlVG9rZW4obmFtZSwgdG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5nUHJvYmVUb2tlbjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9jcmVhdGVDb25kaXRpb25hbFJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIgLyoqIFRPRE8gIzkxMDAgKi8sIGV4dHJhVG9rZW5zKSB7XG4gICAgICAgIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZVJvb3RSZW5kZXJlcihyb290UmVuZGVyZXIsIGV4dHJhVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdFJlbmRlcmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfY3JlYXRlUm9vdFJlbmRlcmVyKHJvb3RSZW5kZXJlciAvKiogVE9ETyAjOTEwMCAqLywgZXh0cmFUb2tlbnMpIHtcbiAgICAgICAgZ2V0RE9NKCkuc2V0R2xvYmFsVmFyKElOU1BFQ1RfR0xPQkFMX05BTUUsIGluc3BlY3ROYXRpdmVFbGVtZW50KTtcbiAgICAgICAgZ2V0RE9NKCkuc2V0R2xvYmFsVmFyKENPUkVfVE9LRU5TX0dMT0JBTF9OQU1FLCBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKENPUkVfVE9LRU5TLCBfbmdQcm9iZVRva2Vuc1RvTWFwKGV4dHJhVG9rZW5zIHx8IFtdKSkpO1xuICAgICAgICByZXR1cm4gbmV3IERlYnVnRG9tUm9vdFJlbmRlcmVyKHJvb3RSZW5kZXJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9uZ1Byb2JlVG9rZW5zVG9NYXAodG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0b2tlbnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCB0KSB7IHJldHVybiAocHJldlt0Lm5hbWVdID0gdC50b2tlbiwgcHJldik7IH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXJzIHdoaWNoIHN1cHBvcnQgZGVidWdnaW5nIEFuZ3VsYXIgYXBwbGljYXRpb25zIChlLmcuIHZpYSBgbmcucHJvYmVgKS5cbiAgICAgKi9cbiAgICB2YXIgRUxFTUVOVF9QUk9CRV9QUk9WSURFUlMgPSBbe1xuICAgICAgICAgICAgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5Sb290UmVuZGVyZXIsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBfY3JlYXRlQ29uZGl0aW9uYWxSb290UmVuZGVyZXIsXG4gICAgICAgICAgICBkZXBzOiBbRG9tUm9vdFJlbmRlcmVyLCBbTmdQcm9iZVRva2VuLCBuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpXV1cbiAgICAgICAgfV07XG4gICAgdmFyIEVMRU1FTlRfUFJPQkVfUFJPVklERVJTX1BST0RfTU9ERSA9IFt7XG4gICAgICAgICAgICBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlJvb3RSZW5kZXJlcixcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IF9jcmVhdGVSb290UmVuZGVyZXIsXG4gICAgICAgICAgICBkZXBzOiBbRG9tUm9vdFJlbmRlcmVyLCBbTmdQcm9iZVRva2VuLCBuZXcgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpXV1cbiAgICAgICAgfV07XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIERvbUV2ZW50c1BsdWdpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ1KERvbUV2ZW50c1BsdWdpbiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRG9tRXZlbnRzUGx1Z2luKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBwbHVnaW4gc2hvdWxkIGNvbWUgbGFzdCBpbiB0aGUgbGlzdCBvZiBwbHVnaW5zLCBiZWNhdXNlIGl0IGFjY2VwdHMgYWxsXG4gICAgICAgIC8vIGV2ZW50cy5cbiAgICAgICAgRG9tRXZlbnRzUGx1Z2luLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgICAgIERvbUV2ZW50c1BsdWdpbi5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciB6b25lID0gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKTtcbiAgICAgICAgICAgIHZhciBvdXRzaWRlSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCAvKiogVE9ETyAjOTEwMCAqLykgeyByZXR1cm4gem9uZS5ydW5HdWFyZGVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhbmRsZXIoZXZlbnQpOyB9KTsgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldERPTSgpLm9uQW5kQ2FuY2VsKGVsZW1lbnQsIGV2ZW50TmFtZSwgb3V0c2lkZUhhbmRsZXIpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRG9tRXZlbnRzUGx1Z2luLnByb3RvdHlwZS5hZGRHbG9iYWxFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGdldERPTSgpLmdldEdsb2JhbEV2ZW50VGFyZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICB2YXIgem9uZSA9IHRoaXMubWFuYWdlci5nZXRab25lKCk7XG4gICAgICAgICAgICB2YXIgb3V0c2lkZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQgLyoqIFRPRE8gIzkxMDAgKi8pIHsgcmV0dXJuIHpvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBoYW5kbGVyKGV2ZW50KTsgfSk7IH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldFpvbmUoKS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRET00oKS5vbkFuZENhbmNlbChlbGVtZW50LCBldmVudE5hbWUsIG91dHNpZGVIYW5kbGVyKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbUV2ZW50c1BsdWdpbi5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIERvbUV2ZW50c1BsdWdpbi5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gRG9tRXZlbnRzUGx1Z2luO1xuICAgIH0oRXZlbnRNYW5hZ2VyUGx1Z2luKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ3ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIF9ldmVudE5hbWVzID0ge1xuICAgICAgICAvLyBwYW5cbiAgICAgICAgJ3Bhbic6IHRydWUsXG4gICAgICAgICdwYW5zdGFydCc6IHRydWUsXG4gICAgICAgICdwYW5tb3ZlJzogdHJ1ZSxcbiAgICAgICAgJ3BhbmVuZCc6IHRydWUsXG4gICAgICAgICdwYW5jYW5jZWwnOiB0cnVlLFxuICAgICAgICAncGFubGVmdCc6IHRydWUsXG4gICAgICAgICdwYW5yaWdodCc6IHRydWUsXG4gICAgICAgICdwYW51cCc6IHRydWUsXG4gICAgICAgICdwYW5kb3duJzogdHJ1ZSxcbiAgICAgICAgLy8gcGluY2hcbiAgICAgICAgJ3BpbmNoJzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNoc3RhcnQnOiB0cnVlLFxuICAgICAgICAncGluY2htb3ZlJzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNoZW5kJzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNoY2FuY2VsJzogdHJ1ZSxcbiAgICAgICAgJ3BpbmNoaW4nOiB0cnVlLFxuICAgICAgICAncGluY2hvdXQnOiB0cnVlLFxuICAgICAgICAvLyBwcmVzc1xuICAgICAgICAncHJlc3MnOiB0cnVlLFxuICAgICAgICAncHJlc3N1cCc6IHRydWUsXG4gICAgICAgIC8vIHJvdGF0ZVxuICAgICAgICAncm90YXRlJzogdHJ1ZSxcbiAgICAgICAgJ3JvdGF0ZXN0YXJ0JzogdHJ1ZSxcbiAgICAgICAgJ3JvdGF0ZW1vdmUnOiB0cnVlLFxuICAgICAgICAncm90YXRlZW5kJzogdHJ1ZSxcbiAgICAgICAgJ3JvdGF0ZWNhbmNlbCc6IHRydWUsXG4gICAgICAgIC8vIHN3aXBlXG4gICAgICAgICdzd2lwZSc6IHRydWUsXG4gICAgICAgICdzd2lwZWxlZnQnOiB0cnVlLFxuICAgICAgICAnc3dpcGVyaWdodCc6IHRydWUsXG4gICAgICAgICdzd2lwZXVwJzogdHJ1ZSxcbiAgICAgICAgJ3N3aXBlZG93bic6IHRydWUsXG4gICAgICAgIC8vIHRhcFxuICAgICAgICAndGFwJzogdHJ1ZSxcbiAgICB9O1xuICAgIHZhciBIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ3KEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbigpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXZlbnROYW1lcy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBIYW1tZXJHZXN0dXJlc1BsdWdpbkNvbW1vbjtcbiAgICB9KEV2ZW50TWFuYWdlclBsdWdpbikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgREkgdG9rZW4gdGhhdCB5b3UgY2FuIHVzZSB0byBwcm92aWRle0BsaW5rIEhhbW1lckdlc3R1cmVDb25maWd9IHRvIEFuZ3VsYXIuIFVzZSBpdCB0byBjb25maWd1cmVcbiAgICAgKiBIYW1tZXIgZ2VzdHVyZXMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEhBTU1FUl9HRVNUVVJFX0NPTkZJRyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdIYW1tZXJHZXN0dXJlQ29uZmlnJyk7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBIYW1tZXJHZXN0dXJlQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSGFtbWVyR2VzdHVyZUNvbmZpZygpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLm92ZXJyaWRlcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIEhhbW1lckdlc3R1cmVDb25maWcucHJvdG90eXBlLmJ1aWxkSGFtbWVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBtYyA9IG5ldyBIYW1tZXIoZWxlbWVudCk7XG4gICAgICAgICAgICBtYy5nZXQoJ3BpbmNoJykuc2V0KHsgZW5hYmxlOiB0cnVlIH0pO1xuICAgICAgICAgICAgbWMuZ2V0KCdyb3RhdGUnKS5zZXQoeyBlbmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gdGhpcy5vdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICBtYy5nZXQoZXZlbnROYW1lKS5zZXQodGhpcy5vdmVycmlkZXNbZXZlbnROYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWM7XG4gICAgICAgIH07XG4gICAgICAgIEhhbW1lckdlc3R1cmVDb25maWcuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBIYW1tZXJHZXN0dXJlQ29uZmlnLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBIYW1tZXJHZXN0dXJlQ29uZmlnO1xuICAgIH0oKSk7XG4gICAgdmFyIEhhbW1lckdlc3R1cmVzUGx1Z2luID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoSGFtbWVyR2VzdHVyZXNQbHVnaW4sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEhhbW1lckdlc3R1cmVzUGx1Z2luKF9jb25maWcpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbi5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBpZiAoIV9zdXBlci5wcm90b3R5cGUuc3VwcG9ydHMuY2FsbCh0aGlzLCBldmVudE5hbWUpICYmICF0aGlzLmlzQ3VzdG9tRXZlbnQoZXZlbnROYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIWlzUHJlc2VudCh3aW5kb3dbJ0hhbW1lciddKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhhbW1lci5qcyBpcyBub3QgbG9hZGVkLCBjYW4gbm90IGJpbmQgXCIgKyBldmVudE5hbWUgKyBcIiBldmVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbi5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgem9uZSA9IHRoaXMubWFuYWdlci5nZXRab25lKCk7XG4gICAgICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGluZyB0aGUgbWFuYWdlciBiaW5kIGV2ZW50cywgbXVzdCBiZSBkb25lIG91dHNpZGUgb2YgYW5ndWxhclxuICAgICAgICAgICAgICAgIHZhciBtYyA9IF90aGlzLl9jb25maWcuYnVpbGRIYW1tZXIoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGV2ZW50T2JqIC8qKiBUT0RPICM/Pz8/ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IGhhbmRsZXIoZXZlbnRPYmopOyB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1jLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IG1jLm9mZihldmVudE5hbWUsIGNhbGxiYWNrKTsgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBIYW1tZXJHZXN0dXJlc1BsdWdpbi5wcm90b3R5cGUuaXNDdXN0b21FdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHsgcmV0dXJuIHRoaXMuX2NvbmZpZy5ldmVudHMuaW5kZXhPZihldmVudE5hbWUpID4gLTE7IH07XG4gICAgICAgIEhhbW1lckdlc3R1cmVzUGx1Z2luLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW4uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEhhbW1lckdlc3R1cmVDb25maWcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbSEFNTUVSX0dFU1RVUkVfQ09ORklHLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBIYW1tZXJHZXN0dXJlc1BsdWdpbjtcbiAgICB9KEhhbW1lckdlc3R1cmVzUGx1Z2luQ29tbW9uKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ4ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIG1vZGlmaWVyS2V5cyA9IFsnYWx0JywgJ2NvbnRyb2wnLCAnbWV0YScsICdzaGlmdCddO1xuICAgIHZhciBtb2RpZmllcktleUdldHRlcnMgPSB7XG4gICAgICAgICdhbHQnOiBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmFsdEtleTsgfSxcbiAgICAgICAgJ2NvbnRyb2wnOiBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmN0cmxLZXk7IH0sXG4gICAgICAgICdtZXRhJzogZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5tZXRhS2V5OyB9LFxuICAgICAgICAnc2hpZnQnOiBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LnNoaWZ0S2V5OyB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEtleUV2ZW50c1BsdWdpbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ4KEtleUV2ZW50c1BsdWdpbiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gS2V5RXZlbnRzUGx1Z2luKCkge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLnByb3RvdHlwZS5zdXBwb3J0cyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lKGV2ZW50TmFtZSkpO1xuICAgICAgICB9O1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkRXZlbnQgPSBLZXlFdmVudHNQbHVnaW4ucGFyc2VFdmVudE5hbWUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHZhciBvdXRzaWRlSGFuZGxlciA9IEtleUV2ZW50c1BsdWdpbi5ldmVudENhbGxiYWNrKGVsZW1lbnQsIHBhcnNlZEV2ZW50WydmdWxsS2V5J10sIGhhbmRsZXIsIHRoaXMubWFuYWdlci5nZXRab25lKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFuYWdlci5nZXRab25lKCkucnVuT3V0c2lkZUFuZ3VsYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRET00oKS5vbkFuZENhbmNlbChlbGVtZW50LCBwYXJzZWRFdmVudFsnZG9tRXZlbnROYW1lJ10sIG91dHNpZGVIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4ucGFyc2VFdmVudE5hbWUgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFyIGRvbUV2ZW50TmFtZSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoKHBhcnRzLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICAhKFN0cmluZ1dyYXBwZXIuZXF1YWxzKGRvbUV2ZW50TmFtZSwgJ2tleWRvd24nKSB8fFxuICAgICAgICAgICAgICAgICAgICBTdHJpbmdXcmFwcGVyLmVxdWFscyhkb21FdmVudE5hbWUsICdrZXl1cCcpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IEtleUV2ZW50c1BsdWdpbi5fbm9ybWFsaXplS2V5KHBhcnRzLnBvcCgpKTtcbiAgICAgICAgICAgIHZhciBmdWxsS2V5ID0gJyc7XG4gICAgICAgICAgICBtb2RpZmllcktleXMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKExpc3RXcmFwcGVyLmNvbnRhaW5zKHBhcnRzLCBtb2RpZmllck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZShwYXJ0cywgbW9kaWZpZXJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbEtleSArPSBtb2RpZmllck5hbWUgKyAnLic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdWxsS2V5ICs9IGtleTtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT0gMCB8fCBrZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuaW5nIG51bGwgaW5zdGVhZCBvZiB0aHJvd2luZyB0byBsZXQgYW5vdGhlciBwbHVnaW4gcHJvY2VzcyB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHJlc3VsdFsnZG9tRXZlbnROYW1lJ10gPSBkb21FdmVudE5hbWU7XG4gICAgICAgICAgICByZXN1bHRbJ2Z1bGxLZXknXSA9IGZ1bGxLZXk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4uZ2V0RXZlbnRGdWxsS2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZnVsbEtleSA9ICcnO1xuICAgICAgICAgICAgdmFyIGtleSA9IGdldERPTSgpLmdldEV2ZW50S2V5KGV2ZW50KTtcbiAgICAgICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKFN0cmluZ1dyYXBwZXIuZXF1YWxzKGtleSwgJyAnKSkge1xuICAgICAgICAgICAgICAgIGtleSA9ICdzcGFjZSc7IC8vIGZvciByZWFkYWJpbGl0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoU3RyaW5nV3JhcHBlci5lcXVhbHMoa2V5LCAnLicpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gJ2RvdCc7IC8vIGJlY2F1c2UgJy4nIGlzIHVzZWQgYXMgYSBzZXBhcmF0b3IgaW4gZXZlbnQgbmFtZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGlmaWVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJOYW1lICE9IGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZXJHZXR0ZXIgPSBtb2RpZmllcktleUdldHRlcnNbbW9kaWZpZXJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVyR2V0dGVyKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbEtleSArPSBtb2RpZmllck5hbWUgKyAnLic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bGxLZXkgKz0ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIGZ1bGxLZXk7XG4gICAgICAgIH07XG4gICAgICAgIEtleUV2ZW50c1BsdWdpbi5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24gKGVsZW1lbnQsIGZ1bGxLZXksIGhhbmRsZXIsIHpvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoU3RyaW5nV3JhcHBlci5lcXVhbHMoS2V5RXZlbnRzUGx1Z2luLmdldEV2ZW50RnVsbEtleShldmVudCksIGZ1bGxLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvbmUucnVuR3VhcmRlZChmdW5jdGlvbiAoKSB7IHJldHVybiBoYW5kbGVyKGV2ZW50KTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBLZXlFdmVudHNQbHVnaW4uX25vcm1hbGl6ZUtleSA9IGZ1bmN0aW9uIChrZXlOYW1lKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBzd2l0Y2ggdG8gYSBTdHJpbmdNYXAgaWYgdGhlIG1hcHBpbmcgZ3Jvd3MgdG9vIG11Y2hcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VzYyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZXNjYXBlJztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgS2V5RXZlbnRzUGx1Z2luLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBLZXlFdmVudHNQbHVnaW47XG4gICAgfShFdmVudE1hbmFnZXJQbHVnaW4pKTtcblxuICAgIC8qKlxuICAgICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIG1hdGNoZXMgYSBzdWJzZXQgb2YgVVJMcyB0aGF0IHdpbGwgbm90IGNhdXNlIHNjcmlwdFxuICAgICAqIGV4ZWN1dGlvbiBpZiB1c2VkIGluIFVSTCBjb250ZXh0IHdpdGhpbiBhIEhUTUwgZG9jdW1lbnQuIFNwZWNpZmljYWxseSwgdGhpc1xuICAgICAqIHJlZ3VsYXIgZXhwcmVzc2lvbiBtYXRjaGVzIGlmIChjb21tZW50IGZyb20gaGVyZSBvbiBhbmQgcmVnZXggY29waWVkIGZyb21cbiAgICAgKiBTb3kncyBFc2NhcGluZ0NvbnZlbnRpb25zKTpcbiAgICAgKiAoMSkgRWl0aGVyIGEgcHJvdG9jb2wgaW4gYSB3aGl0ZWxpc3QgKGh0dHAsIGh0dHBzLCBtYWlsdG8gb3IgZnRwKS5cbiAgICAgKiAoMikgb3Igbm8gcHJvdG9jb2wuICBBIHByb3RvY29sIG11c3QgYmUgZm9sbG93ZWQgYnkgYSBjb2xvbi4gVGhlIGJlbG93XG4gICAgICogICAgIGFsbG93cyB0aGF0IGJ5IGFsbG93aW5nIGNvbG9ucyBvbmx5IGFmdGVyIG9uZSBvZiB0aGUgY2hhcmFjdGVycyBbLz8jXS5cbiAgICAgKiAgICAgQSBjb2xvbiBhZnRlciBhIGhhc2ggKCMpIG11c3QgYmUgaW4gdGhlIGZyYWdtZW50LlxuICAgICAqICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSAoPykgbXVzdCBiZSBpbiBhIHF1ZXJ5LlxuICAgICAqICAgICBPdGhlcndpc2UsIGEgY29sb24gYWZ0ZXIgYSBzaW5nbGUgc29saWR1cyAoLykgbXVzdCBiZSBpbiBhIHBhdGguXG4gICAgICogICAgIE90aGVyd2lzZSwgYSBjb2xvbiBhZnRlciBhIGRvdWJsZSBzb2xpZHVzICgvLykgbXVzdCBiZSBpbiB0aGUgYXV0aG9yaXR5XG4gICAgICogICAgIChiZWZvcmUgcG9ydCkuXG4gICAgICpcbiAgICAgKiBUaGUgcGF0dGVybiBkaXNhbGxvd3MgJiwgdXNlZCBpbiBIVE1MIGVudGl0eSBkZWNsYXJhdGlvbnMgYmVmb3JlXG4gICAgICogb25lIG9mIHRoZSBjaGFyYWN0ZXJzIGluIFsvPyNdLiBUaGlzIGRpc2FsbG93cyBIVE1MIGVudGl0aWVzIHVzZWQgaW4gdGhlXG4gICAgICogcHJvdG9jb2wgbmFtZSwgd2hpY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiwgZS5nLiBcImgmIzExNjt0cFwiIGZvciBcImh0dHBcIi5cbiAgICAgKiBJdCBhbHNvIGRpc2FsbG93cyBIVE1MIGVudGl0aWVzIGluIHRoZSBmaXJzdCBwYXRoIHBhcnQgb2YgYSByZWxhdGl2ZSBwYXRoLFxuICAgICAqIGUuZy4gXCJmb28mbHQ7YmFyL2JhelwiLiAgT3VyIGV4aXN0aW5nIGVzY2FwaW5nIGZ1bmN0aW9ucyBzaG91bGQgbm90IHByb2R1Y2VcbiAgICAgKiB0aGF0LiBNb3JlIGltcG9ydGFudGx5LCBpdCBkaXNhbGxvd3MgbWFza2luZyBvZiBhIGNvbG9uLFxuICAgICAqIGUuZy4gXCJqYXZhc2NyaXB0JiM1ODsuLi5cIi5cbiAgICAgKlxuICAgICAqIFRoaXMgcmVndWxhciBleHByZXNzaW9uIHdhcyB0YWtlbiBmcm9tIHRoZSBDbG9zdXJlIHNhbml0aXphdGlvbiBsaWJyYXJ5LlxuICAgICAqL1xuICAgIHZhciBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteJjovPyNdKig/OlsvPyNdfCQpKS9naTtcbiAgICAvKiogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuICovXG4gICAgdmFyIERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbYS16MC05K1xcL10rPSokL2k7XG4gICAgZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsKSB7XG4gICAgICAgIHVybCA9IFN0cmluZyh1cmwpO1xuICAgICAgICBpZiAodXJsLm1hdGNoKFNBRkVfVVJMX1BBVFRFUk4pIHx8IHVybC5tYXRjaChEQVRBX1VSTF9QQVRURVJOKSlcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpKSB7XG4gICAgICAgICAgICBnZXRET00oKS5sb2coXCJXQVJOSU5HOiBzYW5pdGl6aW5nIHVuc2FmZSBVUkwgdmFsdWUgXCIgKyB1cmwgKyBcIiAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcylcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd1bnNhZmU6JyArIHVybDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FuaXRpemVTcmNzZXQoc3Jjc2V0KSB7XG4gICAgICAgIHNyY3NldCA9IFN0cmluZyhzcmNzZXQpO1xuICAgICAgICByZXR1cm4gc3Jjc2V0LnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChzcmNzZXQpIHsgcmV0dXJuIHNhbml0aXplVXJsKHNyY3NldC50cmltKCkpOyB9KS5qb2luKCcsICcpO1xuICAgIH1cblxuICAgIC8qKiBBIDxib2R5PiBlbGVtZW50IHRoYXQgY2FuIGJlIHNhZmVseSB1c2VkIHRvIHBhcnNlIHVudHJ1c3RlZCBIVE1MLiBMYXppbHkgaW5pdGlhbGl6ZWQgYmVsb3cuICovXG4gICAgdmFyIGluZXJ0RWxlbWVudCA9IG51bGw7XG4gICAgLyoqIExhemlseSBpbml0aWFsaXplZCB0byBtYWtlIHN1cmUgdGhlIERPTSBhZGFwdGVyIGdldHMgc2V0IGJlZm9yZSB1c2UuICovXG4gICAgdmFyIERPTSA9IG51bGw7XG4gICAgLyoqIFJldHVybnMgYW4gSFRNTCBlbGVtZW50IHRoYXQgaXMgZ3VhcmFudGVlZCB0byBub3QgZXhlY3V0ZSBjb2RlIHdoZW4gY3JlYXRpbmcgZWxlbWVudHMgaW4gaXQuICovXG4gICAgZnVuY3Rpb24gZ2V0SW5lcnRFbGVtZW50KCkge1xuICAgICAgICBpZiAoaW5lcnRFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuIGluZXJ0RWxlbWVudDtcbiAgICAgICAgRE9NID0gZ2V0RE9NKCk7XG4gICAgICAgIC8vIFByZWZlciB1c2luZyA8dGVtcGxhdGU+IGVsZW1lbnQgaWYgc3VwcG9ydGVkLlxuICAgICAgICB2YXIgdGVtcGxhdGVFbCA9IERPTS5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAoJ2NvbnRlbnQnIGluIHRlbXBsYXRlRWwpXG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVFbDtcbiAgICAgICAgdmFyIGRvYyA9IERPTS5jcmVhdGVIdG1sRG9jdW1lbnQoKTtcbiAgICAgICAgaW5lcnRFbGVtZW50ID0gRE9NLnF1ZXJ5U2VsZWN0b3IoZG9jLCAnYm9keScpO1xuICAgICAgICBpZiAoaW5lcnRFbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHVzdWFsbHkgdGhlcmUgc2hvdWxkIGJlIG9ubHkgb25lIGJvZHkgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQsIGJ1dCBJRSBkb2Vzbid0IGhhdmUgYW55LCBzbyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byBjcmVhdGUgb25lLlxuICAgICAgICAgICAgdmFyIGh0bWwgPSBET00uY3JlYXRlRWxlbWVudCgnaHRtbCcsIGRvYyk7XG4gICAgICAgICAgICBpbmVydEVsZW1lbnQgPSBET00uY3JlYXRlRWxlbWVudCgnYm9keScsIGRvYyk7XG4gICAgICAgICAgICBET00uYXBwZW5kQ2hpbGQoaHRtbCwgaW5lcnRFbGVtZW50KTtcbiAgICAgICAgICAgIERPTS5hcHBlbmRDaGlsZChkb2MsIGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmVydEVsZW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRhZ1NldCh0YWdzKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRhZ3Muc3BsaXQoJywnKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gX2FbX2ldO1xuICAgICAgICAgICAgcmVzW3RdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICAgICAgdmFyIHNldHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHNldHNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHNldHNfMSA9IHNldHM7IF9hIDwgc2V0c18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHMgPSBzZXRzXzFbX2FdO1xuICAgICAgICAgICAgZm9yICh2YXIgdiBpbiBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMuaGFzT3duUHJvcGVydHkodikpXG4gICAgICAgICAgICAgICAgICAgIHJlc1t2XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLy8gR29vZCBzb3VyY2Ugb2YgaW5mbyBhYm91dCBlbGVtZW50cyBhbmQgYXR0cmlidXRlc1xuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCNzZW1hbnRpY3NcbiAgICAvLyBodHRwOi8vc2ltb24uaHRtbDUub3JnL2h0bWwtZWxlbWVudHNcbiAgICAvLyBTYWZlIFZvaWQgRWxlbWVudHMgLSBIVE1MNVxuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCN2b2lkLWVsZW1lbnRzXG4gICAgdmFyIFZPSURfRUxFTUVOVFMgPSB0YWdTZXQoJ2FyZWEsYnIsY29sLGhyLGltZyx3YnInKTtcbiAgICAvLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW4gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3NwZWMvT3ZlcnZpZXcuaHRtbCNvcHRpb25hbC10YWdzXG4gICAgdmFyIE9QVElPTkFMX0VORF9UQUdfQkxPQ0tfRUxFTUVOVFMgPSB0YWdTZXQoJ2NvbGdyb3VwLGRkLGR0LGxpLHAsdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsdHInKTtcbiAgICB2YXIgT1BUSU9OQUxfRU5EX1RBR19JTkxJTkVfRUxFTUVOVFMgPSB0YWdTZXQoJ3JwLHJ0Jyk7XG4gICAgdmFyIE9QVElPTkFMX0VORF9UQUdfRUxFTUVOVFMgPSBtZXJnZShPUFRJT05BTF9FTkRfVEFHX0lOTElORV9FTEVNRU5UUywgT1BUSU9OQUxfRU5EX1RBR19CTE9DS19FTEVNRU5UUyk7XG4gICAgLy8gU2FmZSBCbG9jayBFbGVtZW50cyAtIEhUTUw1XG4gICAgdmFyIEJMT0NLX0VMRU1FTlRTID0gbWVyZ2UoT1BUSU9OQUxfRU5EX1RBR19CTE9DS19FTEVNRU5UUywgdGFnU2V0KCdhZGRyZXNzLGFydGljbGUsJyArXG4gICAgICAgICdhc2lkZSxibG9ja3F1b3RlLGNhcHRpb24sY2VudGVyLGRlbCxkZXRhaWxzLGRpYWxvZyxkaXIsZGl2LGRsLGZpZ3VyZSxmaWdjYXB0aW9uLGZvb3RlcixoMSxoMixoMyxoNCxoNSwnICtcbiAgICAgICAgJ2g2LGhlYWRlcixoZ3JvdXAsaHIsaW5zLG1haW4sbWFwLG1lbnUsbmF2LG9sLHByZSxzZWN0aW9uLHN1bW1hcnksdGFibGUsdWwnKSk7XG4gICAgLy8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTDVcbiAgICB2YXIgSU5MSU5FX0VMRU1FTlRTID0gbWVyZ2UoT1BUSU9OQUxfRU5EX1RBR19JTkxJTkVfRUxFTUVOVFMsIHRhZ1NldCgnYSxhYmJyLGFjcm9ueW0sYXVkaW8sYiwnICtcbiAgICAgICAgJ2JkaSxiZG8sYmlnLGJyLGNpdGUsY29kZSxkZWwsZGZuLGVtLGZvbnQsaSxpbWcsaW5zLGtiZCxsYWJlbCxtYXAsbWFyayxwaWN0dXJlLHEscnVieSxycCxydCxzLCcgK1xuICAgICAgICAnc2FtcCxzbWFsbCxzb3VyY2Usc3BhbixzdHJpa2Usc3Ryb25nLHN1YixzdXAsdGltZSx0cmFjayx0dCx1LHZhcix2aWRlbycpKTtcbiAgICB2YXIgVkFMSURfRUxFTUVOVFMgPSBtZXJnZShWT0lEX0VMRU1FTlRTLCBCTE9DS19FTEVNRU5UUywgSU5MSU5FX0VMRU1FTlRTLCBPUFRJT05BTF9FTkRfVEFHX0VMRU1FTlRTKTtcbiAgICAvLyBBdHRyaWJ1dGVzIHRoYXQgaGF2ZSBocmVmIGFuZCBoZW5jZSBuZWVkIHRvIGJlIHNhbml0aXplZFxuICAgIHZhciBVUklfQVRUUlMgPSB0YWdTZXQoJ2JhY2tncm91bmQsY2l0ZSxocmVmLGl0ZW10eXBlLGxvbmdkZXNjLHBvc3RlcixzcmMseGxpbms6aHJlZicpO1xuICAgIC8vIEF0dHJpYnV0ZXMgdGhhdCBoYXZlIHNwZWNpYWwgaHJlZiBzZXQgaGVuY2UgbmVlZCB0byBiZSBzYW5pdGl6ZWRcbiAgICB2YXIgU1JDU0VUX0FUVFJTID0gdGFnU2V0KCdzcmNzZXQnKTtcbiAgICB2YXIgSFRNTF9BVFRSUyA9IHRhZ1NldCgnYWJicixhY2Nlc3NrZXksYWxpZ24sYWx0LGF1dG9wbGF5LGF4aXMsYmdjb2xvcixib3JkZXIsY2VsbHBhZGRpbmcsY2VsbHNwYWNpbmcsY2xhc3MsY2xlYXIsY29sb3IsY29scyxjb2xzcGFuLCcgK1xuICAgICAgICAnY29tcGFjdCxjb250cm9scyxjb29yZHMsZGF0ZXRpbWUsZGVmYXVsdCxkaXIsZG93bmxvYWQsZmFjZSxoZWFkZXJzLGhlaWdodCxoaWRkZW4saHJlZmxhbmcsaHNwYWNlLCcgK1xuICAgICAgICAnaXNtYXAsaXRlbXNjb3BlLGl0ZW1wcm9wLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb29wLG1lZGlhLG11dGVkLG5vaHJlZixub3dyYXAsb3BlbixwcmVsb2FkLHJlbCxyZXYscm9sZSxyb3dzLHJvd3NwYW4scnVsZXMsJyArXG4gICAgICAgICdzY29wZSxzY3JvbGxpbmcsc2hhcGUsc2l6ZSxzaXplcyxzcGFuLHNyY2xhbmcsc3RhcnQsc3VtbWFyeSx0YWJpbmRleCx0YXJnZXQsdGl0bGUsdHJhbnNsYXRlLHR5cGUsdXNlbWFwLCcgK1xuICAgICAgICAndmFsaWduLHZhbHVlLHZzcGFjZSx3aWR0aCcpO1xuICAgIC8vIE5COiBUaGlzIGN1cnJlbnRseSBjb25jaW91c2x5IGRvZXNuJ3Qgc3VwcG9ydCBTVkcuIFNWRyBzYW5pdGl6YXRpb24gaGFzIGhhZCBzZXZlcmFsIHNlY3VyaXR5XG4gICAgLy8gaXNzdWVzIGluIHRoZSBwYXN0LCBzbyBpdCBzZWVtcyBzYWZlciB0byBsZWF2ZSBpdCBvdXQgaWYgcG9zc2libGUuIElmIHN1cHBvcnQgZm9yIGJpbmRpbmcgU1ZHIHZpYVxuICAgIC8vIGlubmVySFRNTCBpcyByZXF1aXJlZCwgU1ZHIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGFkZGVkIGhlcmUuXG4gICAgLy8gTkI6IFNhbml0aXphdGlvbiBkb2VzIG5vdCBhbGxvdyA8Zm9ybT4gZWxlbWVudHMgb3Igb3RoZXIgYWN0aXZlIGVsZW1lbnRzICg8YnV0dG9uPiBldGMpLiBUaG9zZVxuICAgIC8vIGNhbiBiZSBzYW5pdGl6ZWQsIGJ1dCB0aGV5IGluY3JlYXNlIHNlY3VyaXR5IHN1cmZhY2UgYXJlYSB3aXRob3V0IGEgbGVnaXRpbWF0ZSB1c2UgY2FzZSwgc28gdGhleVxuICAgIC8vIGFyZSBsZWZ0IG91dCBoZXJlLlxuICAgIHZhciBWQUxJRF9BVFRSUyA9IG1lcmdlKFVSSV9BVFRSUywgU1JDU0VUX0FUVFJTLCBIVE1MX0FUVFJTKTtcbiAgICAvKipcbiAgICAgKiBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIgc2VyaWFsaXplcyBhIERPTSBmcmFnbWVudCwgc3RyaXBwaW5nIG91dCBhbnkgdW5zYWZlIGVsZW1lbnRzIGFuZCB1bnNhZmVcbiAgICAgKiBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIHZhciBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIoKSB7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHRyYWNrIGlmIHNvbWV0aGluZyB3YXMgc3RyaXBwZWQsIHRvIGF2b2lkIGFjY2lkZW50YWxseSB3YXJuaW5nIG9mIHNhbml0aXphdGlvbiBqdXN0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNoYXJhY3RlcnMgd2VyZSByZS1lbmNvZGVkLlxuICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gW107XG4gICAgICAgIH1cbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5zYW5pdGl6ZUNoaWxkcmVuID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbm5vdCB1c2UgYSBUcmVlV2Fsa2VyLCBhcyBpdCBoYXMgdG8gcnVuIG9uIEFuZ3VsYXIncyB2YXJpb3VzIERPTSBhZGFwdGVycy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhpcyBjb2RlIG5ldmVyIGFjY2Vzc2VzIHByb3BlcnRpZXMgb2ZmIG9mIGBkb2N1bWVudGAgYmVmb3JlIGRlbGV0aW5nIGl0cyBjb250ZW50c1xuICAgICAgICAgICAgLy8gYWdhaW4sIHNvIGl0IHNob3VsZG4ndCBiZSB2dWxuZXJhYmxlIHRvIERPTSBjbG9iYmVyaW5nLlxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoRE9NLmlzRWxlbWVudE5vZGUoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEVsZW1lbnQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKERPTS5pc1RleHROb2RlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhcnMoRE9NLm5vZGVWYWx1ZShjdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCBub24tZWxlbWVudCwgbm9uLXRleHQgbm9kZXMuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKERPTS5maXJzdENoaWxkKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBET00uZmlyc3RDaGlsZChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlYXZpbmcgdGhlIGVsZW1lbnQuIFdhbGsgdXAgYW5kIHRvIHRoZSByaWdodCwgY2xvc2luZyB0YWdzIGFzIHdlIGdvLlxuICAgICAgICAgICAgICAgICAgICBpZiAoRE9NLmlzRWxlbWVudE5vZGUoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kRWxlbWVudChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoRE9NLm5leHRTaWJsaW5nKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gRE9NLm5leHRTaWJsaW5nKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IERPTS5wYXJlbnRFbGVtZW50KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1Zi5qb2luKCcnKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5zdGFydEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gRE9NLm5vZGVOYW1lKGVsZW1lbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIVZBTElEX0VMRU1FTlRTLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYW5pdGl6ZWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJzwnKTtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2godGFnTmFtZSk7XG4gICAgICAgICAgICBET00uYXR0cmlidXRlTWFwKGVsZW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBhdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBsb3dlciA9IGF0dHJOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFWQUxJRF9BVFRSUy5oYXNPd25Qcm9wZXJ0eShsb3dlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2FuaXRpemVkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IFNwZWNpYWwgY2FzZSBpbWFnZSBVUklzIGZvciBkYXRhOmltYWdlLy4uLlxuICAgICAgICAgICAgICAgIGlmIChVUklfQVRUUlNbbG93ZXJdKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNhbml0aXplVXJsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoU1JDU0VUX0FUVFJTW2xvd2VyXSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzYW5pdGl6ZVNyY3NldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5idWYucHVzaChhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goJz1cIicpO1xuICAgICAgICAgICAgICAgIF90aGlzLmJ1Zi5wdXNoKGVuY29kZUVudGl0aWVzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYnVmLnB1c2goJ1wiJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnVmLnB1c2goJz4nKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2FuaXRpemluZ0h0bWxTZXJpYWxpemVyLnByb3RvdHlwZS5lbmRFbGVtZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gRE9NLm5vZGVOYW1lKGN1cnJlbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoVkFMSURfRUxFTUVOVFMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkgJiYgIVZPSURfRUxFTUVOVFMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zi5wdXNoKCc8LycpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmLnB1c2godGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWYucHVzaCgnPicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIucHJvdG90eXBlLmNoYXJzID0gZnVuY3Rpb24gKGNoYXJzIC8qKiBUT0RPICM5MTAwICovKSB7IHRoaXMuYnVmLnB1c2goZW5jb2RlRW50aXRpZXMoY2hhcnMpKTsgfTtcbiAgICAgICAgcmV0dXJuIFNhbml0aXppbmdIdG1sU2VyaWFsaXplcjtcbiAgICB9KCkpO1xuICAgIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuICAgIHZhciBTVVJST0dBVEVfUEFJUl9SRUdFWFAgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xuICAgIC8vICEgdG8gfiBpcyB0aGUgQVNDSUkgcmFuZ2UuXG4gICAgdmFyIE5PTl9BTFBIQU5VTUVSSUNfUkVHRVhQID0gLyhbXlxcIy1+IHwhXSkvZztcbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIGFsbCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgY2hhcmFjdGVycywgc28gdGhhdCB0aGVcbiAgICAgKiByZXN1bHRpbmcgc3RyaW5nIGNhbiBiZSBzYWZlbHkgaW5zZXJ0ZWQgaW50byBhdHRyaWJ1dGUgb3JcbiAgICAgKiBlbGVtZW50IHRleHQuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCB0ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5jb2RlRW50aXRpZXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKFNVUlJPR0FURV9QQUlSX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgaGkgPSBtYXRjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgdmFyIGxvdyA9IG1hdGNoLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgICAgICByZXR1cm4gJyYjJyArICgoKGhpIC0gMHhEODAwKSAqIDB4NDAwKSArIChsb3cgLSAweERDMDApICsgMHgxMDAwMCkgKyAnOyc7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVwbGFjZShOT05fQUxQSEFOVU1FUklDX1JFR0VYUCwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiAnJiMnICsgbWF0Y2guY2hhckNvZGVBdCgwKSArICc7JzsgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gSUU5LTExIGNvbWVzIGFjcm9zcyBhbiB1bmtub3duIG5hbWVzcGFjZWQgYXR0cmlidXRlIGUuZy4gJ3hsaW5rOmZvbycgaXQgYWRkcyAneG1sbnM6bnMxJ1xuICAgICAqIGF0dHJpYnV0ZSB0byBkZWNsYXJlIG5zMSBuYW1lc3BhY2UgYW5kIHByZWZpeGVzIHRoZSBhdHRyaWJ1dGUgd2l0aCAnbnMxJyAoZS5nLiAnbnMxOnhsaW5rOmZvbycpLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1bmRlc2lyYWJsZSBzaW5jZSB3ZSBkb24ndCB3YW50IHRvIGFsbG93IGFueSBvZiB0aGVzZSBjdXN0b20gYXR0cmlidXRlcy4gVGhpcyBtZXRob2RcbiAgICAgKiBzdHJpcHMgdGhlbSBhbGwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RyaXBDdXN0b21Oc0F0dHJzKGVsKSB7XG4gICAgICAgIERPTS5hdHRyaWJ1dGVNYXAoZWwpLmZvckVhY2goZnVuY3Rpb24gKF8sIGF0dHJOYW1lKSB7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgPT09ICd4bWxuczpuczEnIHx8IGF0dHJOYW1lLmluZGV4T2YoJ25zMTonKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIERPTS5yZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBET00uY2hpbGROb2Rlc0FzTGlzdChlbCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbiA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChET00uaXNFbGVtZW50Tm9kZShuKSlcbiAgICAgICAgICAgICAgICBzdHJpcEN1c3RvbU5zQXR0cnMobik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIHRoZSBnaXZlbiB1bnNhZmUsIHVudHJ1c3RlZCBIVE1MIGZyYWdtZW50LCBhbmQgcmV0dXJucyBIVE1MIHRleHQgdGhhdCBpcyBzYWZlIHRvIGFkZCB0b1xuICAgICAqIHRoZSBET00gaW4gYSBicm93c2VyIGVudmlyb25tZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sSW5wdXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJFbCA9IGdldEluZXJ0RWxlbWVudCgpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHVuc2FmZUh0bWwgaXMgYWN0dWFsbHkgYSBzdHJpbmcgKFR5cGVTY3JpcHQgdHlwZXMgYXJlIG5vdCBlbmZvcmNlZCBhdCBydW50aW1lKS5cbiAgICAgICAgICAgIHZhciB1bnNhZmVIdG1sID0gdW5zYWZlSHRtbElucHV0ID8gU3RyaW5nKHVuc2FmZUh0bWxJbnB1dCkgOiAnJztcbiAgICAgICAgICAgIC8vIG1YU1MgcHJvdGVjdGlvbi4gUmVwZWF0ZWRseSBwYXJzZSB0aGUgZG9jdW1lbnQgdG8gbWFrZSBzdXJlIGl0IHN0YWJpbGl6ZXMsIHNvIHRoYXQgYSBicm93c2VyXG4gICAgICAgICAgICAvLyB0cnlpbmcgdG8gYXV0by1jb3JyZWN0IGluY29ycmVjdCBIVE1MIGNhbm5vdCBjYXVzZSBmb3JtZXJseSBpbmVydCBIVE1MIHRvIGJlY29tZSBkYW5nZXJvdXMuXG4gICAgICAgICAgICB2YXIgbVhTU0F0dGVtcHRzID0gNTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRIdG1sID0gdW5zYWZlSHRtbDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAobVhTU0F0dGVtcHRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhbml0aXplIGh0bWwgYmVjYXVzZSB0aGUgaW5wdXQgaXMgdW5zdGFibGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbVhTU0F0dGVtcHRzLS07XG4gICAgICAgICAgICAgICAgdW5zYWZlSHRtbCA9IHBhcnNlZEh0bWw7XG4gICAgICAgICAgICAgICAgRE9NLnNldElubmVySFRNTChjb250YWluZXJFbCwgdW5zYWZlSHRtbCk7XG4gICAgICAgICAgICAgICAgaWYgKERPTS5kZWZhdWx0RG9jKCkuZG9jdW1lbnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIGN1c3RvbS1uYW1lc3BhY2VkIGF0dHJpYnV0ZXMgb24gSUU8PTExXG4gICAgICAgICAgICAgICAgICAgIHN0cmlwQ3VzdG9tTnNBdHRycyhjb250YWluZXJFbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZEh0bWwgPSBET00uZ2V0SW5uZXJIVE1MKGNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHVuc2FmZUh0bWwgIT09IHBhcnNlZEh0bWwpO1xuICAgICAgICAgICAgdmFyIHNhbml0aXplciA9IG5ldyBTYW5pdGl6aW5nSHRtbFNlcmlhbGl6ZXIoKTtcbiAgICAgICAgICAgIHZhciBzYWZlSHRtbCA9IHNhbml0aXplci5zYW5pdGl6ZUNoaWxkcmVuKERPTS5nZXRUZW1wbGF0ZUNvbnRlbnQoY29udGFpbmVyRWwpIHx8IGNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgIC8vIENsZWFyIG91dCB0aGUgYm9keSBlbGVtZW50LlxuICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gRE9NLmdldFRlbXBsYXRlQ29udGVudChjb250YWluZXJFbCkgfHwgY29udGFpbmVyRWw7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gRE9NLmNoaWxkTm9kZXNBc0xpc3QocGFyZW50XzEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBET00ucmVtb3ZlQ2hpbGQocGFyZW50XzEsIGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfYW5ndWxhcl9jb3JlLmlzRGV2TW9kZSgpICYmIHNhbml0aXplci5zYW5pdGl6ZWRTb21ldGhpbmcpIHtcbiAgICAgICAgICAgICAgICBET00ubG9nKCdXQVJOSU5HOiBzYW5pdGl6aW5nIEhUTUwgc3RyaXBwZWQgc29tZSBjb250ZW50IChzZWUgaHR0cDovL2cuY28vbmcvc2VjdXJpdHkjeHNzKS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYWZlSHRtbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBhbnl0aGluZyBnb2VzIHdyb25nLCBjbGVhciBvdXQgaW5lcnRFbGVtZW50IHRvIHJlc2V0IHRoZSBlbnRpcmUgRE9NIHN0cnVjdHVyZS5cbiAgICAgICAgICAgIGluZXJ0RWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVndWxhciBleHByZXNzaW9uIGZvciBzYWZlIHN0eWxlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFF1b3RlcyAoXCIgYW5kICcpIGFyZSBhbGxvd2VkLCBidXQgYSBjaGVjayBtdXN0IGJlIGRvbmUgZWxzZXdoZXJlIHRvIGVuc3VyZSB0aGV5J3JlIGJhbGFuY2VkLlxuICAgICAqXG4gICAgICogJywnIGFsbG93cyBtdWx0aXBsZSB2YWx1ZXMgdG8gYmUgYXNzaWduZWQgdG8gdGhlIHNhbWUgcHJvcGVydHkgKGUuZy4gYmFja2dyb3VuZC1hdHRhY2htZW50IG9yXG4gICAgICogZm9udC1mYW1pbHkpIGFuZCBoZW5jZSBjb3VsZCBhbGxvdyBtdWx0aXBsZSB2YWx1ZXMgdG8gZ2V0IGluamVjdGVkLCBidXQgdGhhdCBzaG91bGQgcG9zZSBubyByaXNrXG4gICAgICogb2YgWFNTLlxuICAgICAqXG4gICAgICogVGhlIGZ1bmN0aW9uIGV4cHJlc3Npb24gY2hlY2tzIG9ubHkgZm9yIFhTUyBzYWZldHksIG5vdCBmb3IgQ1NTIHZhbGlkaXR5LlxuICAgICAqXG4gICAgICogVGhpcyByZWd1bGFyIGV4cHJlc3Npb24gd2FzIHRha2VuIGZyb20gdGhlIENsb3N1cmUgc2FuaXRpemF0aW9uIGxpYnJhcnksIGFuZCBhdWdtZW50ZWQgZm9yXG4gICAgICogdHJhbnNmb3JtYXRpb24gdmFsdWVzLlxuICAgICAqL1xuICAgIHZhciBWQUxVRVMgPSAnWy0sLlwiXFwnJV8hIyBhLXpBLVowLTldKyc7XG4gICAgdmFyIFRSQU5TRk9STUFUSU9OX0ZOUyA9ICcoPzptYXRyaXh8dHJhbnNsYXRlfHNjYWxlfHJvdGF0ZXxza2V3fHBlcnNwZWN0aXZlKSg/Olh8WXwzZCk/JztcbiAgICB2YXIgQ09MT1JfRk5TID0gJyg/OnJnYnxoc2wpYT8nO1xuICAgIHZhciBGTl9BUkdTID0gJ1xcXFwoWy0wLTkuJSwgYS16QS1aXStcXFxcKSc7XG4gICAgdmFyIFNBRkVfU1RZTEVfVkFMVUUgPSBuZXcgUmVnRXhwKFwiXihcIiArIFZBTFVFUyArIFwifCg/OlwiICsgVFJBTlNGT1JNQVRJT05fRk5TICsgXCJ8XCIgKyBDT0xPUl9GTlMgKyBcIilcIiArIEZOX0FSR1MgKyBcIikkXCIsICdnJyk7XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBhIGB1cmwoLi4uKWAgdmFsdWUgd2l0aCBhbiBhcmJpdHJhcnkgYXJndW1lbnQgYXMgbG9uZyBhcyBpdCBkb2VzXG4gICAgICogbm90IGNvbnRhaW4gcGFyZW50aGVzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgVVJMIHZhbHVlIHN0aWxsIG5lZWRzIHRvIGJlIHNhbml0aXplZCBzZXBhcmF0ZWx5LlxuICAgICAqXG4gICAgICogYHVybCguLi4pYCB2YWx1ZXMgYXJlIGEgdmVyeSBjb21tb24gdXNlIGNhc2UsIGUuZy4gZm9yIGBiYWNrZ3JvdW5kLWltYWdlYC4gV2l0aCBjYXJlZnVsbHkgY3JhZnRlZFxuICAgICAqIENTUyBzdHlsZSBydWxlcywgaXQgaXMgcG9zc2libGUgdG8gY29uc3RydWN0IGFuIGluZm9ybWF0aW9uIGxlYWsgd2l0aCBgdXJsYCB2YWx1ZXMgaW4gQ1NTLCBlLmcuXG4gICAgICogYnkgb2JzZXJ2aW5nIHdoZXRoZXIgc2Nyb2xsIGJhcnMgYXJlIGRpc3BsYXllZCwgb3IgY2hhcmFjdGVyIHJhbmdlcyB1c2VkIGJ5IGEgZm9udCBmYWNlXG4gICAgICogZGVmaW5pdGlvbi5cbiAgICAgKlxuICAgICAqIEFuZ3VsYXIgb25seSBhbGxvd3MgYmluZGluZyBDU1MgdmFsdWVzIChhcyBvcHBvc2VkIHRvIGVudGlyZSBDU1MgcnVsZXMpLCBzbyBpdCBpcyB1bmxpa2VseSB0aGF0XG4gICAgICogYmluZGluZyBhIFVSTCB2YWx1ZSB3aXRob3V0IGZ1cnRoZXIgY29vcGVyYXRpb24gZnJvbSB0aGUgcGFnZSB3aWxsIGNhdXNlIGFuIGluZm9ybWF0aW9uIGxlYWssIGFuZFxuICAgICAqIGlmIHNvLCBpdCBpcyBqdXN0IGEgbGVhaywgbm90IGEgZnVsbCBibG93biBYU1MgdnVsbmVyYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEdpdmVuIHRoZSBjb21tb24gdXNlIGNhc2UsIGxvdyBsaWtlbGlob29kIG9mIGF0dGFjayB2ZWN0b3IsIGFuZCBsb3cgaW1wYWN0IG9mIGFuIGF0dGFjaywgdGhpc1xuICAgICAqIGNvZGUgaXMgcGVybWlzc2l2ZSBhbmQgYWxsb3dzIFVSTHMgdGhhdCBzYW5pdGl6ZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmFyIFVSTF9SRSA9IC9edXJsXFwoKFteKV0rKVxcKSQvO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGF0IHF1b3RlcyAoXCIgYW5kICcpIGFyZSBwcm9wZXJseSBiYWxhbmNlZCBpbnNpZGUgYSBzdHJpbmcuIEFzc3VtZXNcbiAgICAgKiB0aGF0IG5laXRoZXIgZXNjYXBlIChcXCkgbm9yIGFueSBvdGhlciBjaGFyYWN0ZXIgdGhhdCBjb3VsZCByZXN1bHQgaW5cbiAgICAgKiBicmVha2luZyBvdXQgb2YgYSBzdHJpbmcgcGFyc2luZyBjb250ZXh0IGFyZSBhbGxvd2VkO1xuICAgICAqIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jc3RyaW5nLXRva2VuLWRpYWdyYW0uXG4gICAgICpcbiAgICAgKiBUaGlzIGNvZGUgd2FzIHRha2VuIGZyb20gdGhlIENsb3N1cmUgc2FuaXRpemF0aW9uIGxpYnJhcnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzQmFsYW5jZWRRdW90ZXModmFsdWUpIHtcbiAgICAgICAgdmFyIG91dHNpZGVTaW5nbGUgPSB0cnVlO1xuICAgICAgICB2YXIgb3V0c2lkZURvdWJsZSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gdmFsdWUuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXCcnICYmIG91dHNpZGVEb3VibGUpIHtcbiAgICAgICAgICAgICAgICBvdXRzaWRlU2luZ2xlID0gIW91dHNpZGVTaW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXCInICYmIG91dHNpZGVTaW5nbGUpIHtcbiAgICAgICAgICAgICAgICBvdXRzaWRlRG91YmxlID0gIW91dHNpZGVEb3VibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHNpZGVTaW5nbGUgJiYgb3V0c2lkZURvdWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIHRoZSBnaXZlbiB1bnRydXN0ZWQgQ1NTIHN0eWxlIHByb3BlcnR5IHZhbHVlIChpLmUuIG5vdCBhbiBlbnRpcmUgb2JqZWN0LCBqdXN0IGEgc2luZ2xlXG4gICAgICogdmFsdWUpIGFuZCByZXR1cm5zIGEgdmFsdWUgdGhhdCBpcyBzYWZlIHRvIHVzZSBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FuaXRpemVTdHlsZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSkudHJpbSgpOyAvLyBNYWtlIHN1cmUgaXQncyBhY3R1YWxseSBhIHN0cmluZy5cbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gU2luZ2xlIHVybCguLi4pIHZhbHVlcyBhcmUgc3VwcG9ydGVkLCBidXQgb25seSBmb3IgVVJMcyB0aGF0IHNhbml0aXplIGNsZWFubHkuIFNlZSBhYm92ZSBmb3JcbiAgICAgICAgLy8gcmVhc29uaW5nIGJlaGluZCB0aGlzLlxuICAgICAgICB2YXIgdXJsTWF0Y2ggPSB2YWx1ZS5tYXRjaChVUkxfUkUpO1xuICAgICAgICBpZiAoKHVybE1hdGNoICYmIHNhbml0aXplVXJsKHVybE1hdGNoWzFdKSA9PT0gdXJsTWF0Y2hbMV0pIHx8XG4gICAgICAgICAgICB2YWx1ZS5tYXRjaChTQUZFX1NUWUxFX1ZBTFVFKSAmJiBoYXNCYWxhbmNlZFF1b3Rlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsgLy8gU2FmZSBzdHlsZSB2YWx1ZXMuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9hbmd1bGFyX2NvcmUuaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIGdldERPTSgpLmxvZyhcIldBUk5JTkc6IHNhbml0aXppbmcgdW5zYWZlIHN0eWxlIHZhbHVlIFwiICsgdmFsdWUgKyBcIiAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcykuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAndW5zYWZlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ5ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRG9tU2FuaXRpemVyIGhlbHBzIHByZXZlbnRpbmcgQ3Jvc3MgU2l0ZSBTY3JpcHRpbmcgU2VjdXJpdHkgYnVncyAoWFNTKSBieSBzYW5pdGl6aW5nXG4gICAgICogdmFsdWVzIHRvIGJlIHNhZmUgdG8gdXNlIGluIHRoZSBkaWZmZXJlbnQgRE9NIGNvbnRleHRzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gYmluZGluZyBhIFVSTCBpbiBhbiBgPGEgW2hyZWZdPVwic29tZVZhbHVlXCI+YCBoeXBlcmxpbmssIGBzb21lVmFsdWVgIHdpbGwgYmVcbiAgICAgKiBzYW5pdGl6ZWQgc28gdGhhdCBhbiBhdHRhY2tlciBjYW5ub3QgaW5qZWN0IGUuZy4gYSBgamF2YXNjcmlwdDpgIFVSTCB0aGF0IHdvdWxkIGV4ZWN1dGUgY29kZSBvblxuICAgICAqIHRoZSB3ZWJzaXRlLlxuICAgICAqXG4gICAgICogSW4gc3BlY2lmaWMgc2l0dWF0aW9ucywgaXQgbWlnaHQgYmUgbmVjZXNzYXJ5IHRvIGRpc2FibGUgc2FuaXRpemF0aW9uLCBmb3IgZXhhbXBsZSBpZiB0aGVcbiAgICAgKiBhcHBsaWNhdGlvbiBnZW51aW5lbHkgbmVlZHMgdG8gcHJvZHVjZSBhIGBqYXZhc2NyaXB0OmAgc3R5bGUgbGluayB3aXRoIGEgZHluYW1pYyB2YWx1ZSBpbiBpdC5cbiAgICAgKiBVc2VycyBjYW4gYnlwYXNzIHNlY3VyaXR5IGJ5IGNvbnN0cnVjdGluZyBhIHZhbHVlIHdpdGggb25lIG9mIHRoZSBgYnlwYXNzU2VjdXJpdHlUcnVzdC4uLmBcbiAgICAgKiBtZXRob2RzLCBhbmQgdGhlbiBiaW5kaW5nIHRvIHRoYXQgdmFsdWUgZnJvbSB0aGUgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBUaGVzZSBzaXR1YXRpb25zIHNob3VsZCBiZSB2ZXJ5IHJhcmUsIGFuZCBleHRyYW9yZGluYXJ5IGNhcmUgbXVzdCBiZSB0YWtlbiB0byBhdm9pZCBjcmVhdGluZyBhXG4gICAgICogQ3Jvc3MgU2l0ZSBTY3JpcHRpbmcgKFhTUykgc2VjdXJpdHkgYnVnIVxuICAgICAqXG4gICAgICogV2hlbiB1c2luZyBgYnlwYXNzU2VjdXJpdHlUcnVzdC4uLmAsIG1ha2Ugc3VyZSB0byBjYWxsIHRoZSBtZXRob2QgYXMgZWFybHkgYXMgcG9zc2libGUgYW5kIGFzXG4gICAgICogY2xvc2UgYXMgcG9zc2libGUgdG8gdGhlIHNvdXJjZSBvZiB0aGUgdmFsdWUsIHRvIG1ha2UgaXQgZWFzeSB0byB2ZXJpZnkgbm8gc2VjdXJpdHkgYnVnIGlzXG4gICAgICogY3JlYXRlZCBieSBpdHMgdXNlLlxuICAgICAqXG4gICAgICogSXQgaXMgbm90IHJlcXVpcmVkIChhbmQgbm90IHJlY29tbWVuZGVkKSB0byBieXBhc3Mgc2VjdXJpdHkgaWYgdGhlIHZhbHVlIGlzIHNhZmUsIGUuZy4gYSBVUkwgdGhhdFxuICAgICAqIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdXNwaWNpb3VzIHByb3RvY29sLCBvciBhbiBIVE1MIHNuaXBwZXQgdGhhdCBkb2VzIG5vdCBjb250YWluIGRhbmdlcm91c1xuICAgICAqIGNvZGUuIFRoZSBzYW5pdGl6ZXIgbGVhdmVzIHNhZmUgdmFsdWVzIGludGFjdC5cbiAgICAgKlxuICAgICAqIEBzZWN1cml0eSBDYWxsaW5nIGFueSBvZiB0aGUgYGJ5cGFzc1NlY3VyaXR5VHJ1c3QuLi5gIEFQSXMgZGlzYWJsZXMgQW5ndWxhcidzIGJ1aWx0LWluXG4gICAgICogc2FuaXRpemF0aW9uIGZvciB0aGUgdmFsdWUgcGFzc2VkIGluLiBDYXJlZnVsbHkgY2hlY2sgYW5kIGF1ZGl0IGFsbCB2YWx1ZXMgYW5kIGNvZGUgcGF0aHMgZ29pbmdcbiAgICAgKiBpbnRvIHRoaXMgY2FsbC4gTWFrZSBzdXJlIGFueSB1c2VyIGRhdGEgaXMgYXBwcm9wcmlhdGVseSBlc2NhcGVkIGZvciB0aGlzIHNlY3VyaXR5IGNvbnRleHQuXG4gICAgICogRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBEb21TYW5pdGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBEb21TYW5pdGl6ZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERvbVNhbml0aXplcjtcbiAgICB9KCkpO1xuICAgIHZhciBEb21TYW5pdGl6ZXJJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoRG9tU2FuaXRpemVySW1wbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRG9tU2FuaXRpemVySW1wbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIERvbVNhbml0aXplckltcGwucHJvdG90eXBlLnNhbml0aXplID0gZnVuY3Rpb24gKGN0eCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgc3dpdGNoIChjdHgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0Lk5PTkU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LkhUTUw6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVIdG1sSW1wbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrTm90U2FmZVZhbHVlKHZhbHVlLCAnSFRNTCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FuaXRpemVIdG1sKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgX2FuZ3VsYXJfY29yZS5TZWN1cml0eUNvbnRleHQuU1RZTEU6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVTdHlsZUltcGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1N0eWxlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzYW5pdGl6ZVN0eWxlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlNDUklQVDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZVNjcmlwdEltcGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1NjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZSB2YWx1ZSB1c2VkIGluIGEgc2NyaXB0IGNvbnRleHQnKTtcbiAgICAgICAgICAgICAgICBjYXNlIF9hbmd1bGFyX2NvcmUuU2VjdXJpdHlDb250ZXh0LlVSTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2FmZVJlc291cmNlVXJsSW1wbCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNhZmVVcmxJbXBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyByZXNvdXJjZSBVUkxzIGluIFVSTCBjb250ZXh0cywgdGhleSBhcmUgc3RyaWN0bHkgbW9yZSB0cnVzdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vdFNhZmVWYWx1ZSh2YWx1ZSwgJ1VSTCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2FuaXRpemVVcmwoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBfYW5ndWxhcl9jb3JlLlNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkw6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVSZXNvdXJjZVVybEltcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tOb3RTYWZlVmFsdWUodmFsdWUsICdSZXNvdXJjZVVSTCcpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZSB2YWx1ZSB1c2VkIGluIGEgcmVzb3VyY2UgVVJMIGNvbnRleHQgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpJyk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBTZWN1cml0eUNvbnRleHQgXCIgKyBjdHggKyBcIiAoc2VlIGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5I3hzcylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIERvbVNhbml0aXplckltcGwucHJvdG90eXBlLmNoZWNrTm90U2FmZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNhZmVWYWx1ZUltcGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiUmVxdWlyZWQgYSBzYWZlIFwiICsgZXhwZWN0ZWRUeXBlICsgXCIsIGdvdCBhIFwiICsgdmFsdWUuZ2V0VHlwZU5hbWUoKSArIFwiIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0SHRtbCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVIdG1sSW1wbCh2YWx1ZSk7IH07XG4gICAgICAgIERvbVNhbml0aXplckltcGwucHJvdG90eXBlLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IFNhZmVTdHlsZUltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0U2NyaXB0ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgU2FmZVNjcmlwdEltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0VXJsID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgU2FmZVVybEltcGwodmFsdWUpOyB9O1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLnByb3RvdHlwZS5ieXBhc3NTZWN1cml0eVRydXN0UmVzb3VyY2VVcmwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZVJlc291cmNlVXJsSW1wbCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERvbVNhbml0aXplckltcGwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEb21TYW5pdGl6ZXJJbXBsLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBEb21TYW5pdGl6ZXJJbXBsO1xuICAgIH0oRG9tU2FuaXRpemVyKSk7XG4gICAgdmFyIFNhZmVWYWx1ZUltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTYWZlVmFsdWVJbXBsKGNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdpbmdUaGlzQnJlYWtzQXBwbGljYXRpb25TZWN1cml0eSA9IGNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHk7XG4gICAgICAgICAgICAvLyBlbXB0eVxuICAgICAgICB9XG4gICAgICAgIFNhZmVWYWx1ZUltcGwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChcIlNhZmVWYWx1ZSBtdXN0IHVzZSBbcHJvcGVydHldPWJpbmRpbmc6IFwiICsgdGhpcy5jaGFuZ2luZ1RoaXNCcmVha3NBcHBsaWNhdGlvblNlY3VyaXR5KSArXG4gICAgICAgICAgICAgICAgXCIgKHNlZSBodHRwOi8vZy5jby9uZy9zZWN1cml0eSN4c3MpXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTYWZlVmFsdWVJbXBsO1xuICAgIH0oKSk7XG4gICAgdmFyIFNhZmVIdG1sSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVIdG1sSW1wbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gU2FmZUh0bWxJbXBsKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgU2FmZUh0bWxJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdIVE1MJzsgfTtcbiAgICAgICAgcmV0dXJuIFNhZmVIdG1sSW1wbDtcbiAgICB9KFNhZmVWYWx1ZUltcGwpKTtcbiAgICB2YXIgU2FmZVN0eWxlSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVTdHlsZUltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVTdHlsZUltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBTYWZlU3R5bGVJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTdHlsZSc7IH07XG4gICAgICAgIHJldHVybiBTYWZlU3R5bGVJbXBsO1xuICAgIH0oU2FmZVZhbHVlSW1wbCkpO1xuICAgIHZhciBTYWZlU2NyaXB0SW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVTY3JpcHRJbXBsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBTYWZlU2NyaXB0SW1wbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFNhZmVTY3JpcHRJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdTY3JpcHQnOyB9O1xuICAgICAgICByZXR1cm4gU2FmZVNjcmlwdEltcGw7XG4gICAgfShTYWZlVmFsdWVJbXBsKSk7XG4gICAgdmFyIFNhZmVVcmxJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoU2FmZVVybEltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVVcmxJbXBsKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgU2FmZVVybEltcGwucHJvdG90eXBlLmdldFR5cGVOYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1VSTCc7IH07XG4gICAgICAgIHJldHVybiBTYWZlVXJsSW1wbDtcbiAgICB9KFNhZmVWYWx1ZUltcGwpKTtcbiAgICB2YXIgU2FmZVJlc291cmNlVXJsSW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ5KFNhZmVSZXNvdXJjZVVybEltcGwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNhZmVSZXNvdXJjZVVybEltcGwoKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBTYWZlUmVzb3VyY2VVcmxJbXBsLnByb3RvdHlwZS5nZXRUeXBlTmFtZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdSZXNvdXJjZVVSTCc7IH07XG4gICAgICAgIHJldHVybiBTYWZlUmVzb3VyY2VVcmxJbXBsO1xuICAgIH0oU2FmZVZhbHVlSW1wbCkpO1xuXG4gICAgdmFyIElOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTID0gW1xuICAgICAgICB7IHByb3ZpZGU6IF9hbmd1bGFyX2NvcmUuUExBVEZPUk1fSU5JVElBTElaRVIsIHVzZVZhbHVlOiBpbml0RG9tQWRhcHRlciwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb21tb24uUGxhdGZvcm1Mb2NhdGlvbiwgdXNlQ2xhc3M6IEJyb3dzZXJQbGF0Zm9ybUxvY2F0aW9uIH1cbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBzZWN1cml0eSBSZXBsYWNpbmcgYnVpbHQtaW4gc2FuaXRpemF0aW9uIHByb3ZpZGVycyBleHBvc2VzIHRoZSBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuXG4gICAgICogQXR0YWNrZXItY29udHJvbGxlZCBkYXRhIGludHJvZHVjZWQgYnkgYW4gdW5zYW5pdGl6ZWQgcHJvdmlkZXIgY291bGQgZXhwb3NlIHlvdXJcbiAgICAgKiBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuIEZvciBtb3JlIGRldGFpbCwgc2VlIHRoZSBbU2VjdXJpdHkgR3VpZGVdKGh0dHA6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUyA9IFtcbiAgICAgICAgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLlNhbml0aXplciwgdXNlRXhpc3Rpbmc6IERvbVNhbml0aXplciB9LFxuICAgICAgICB7IHByb3ZpZGU6IERvbVNhbml0aXplciwgdXNlQ2xhc3M6IERvbVNhbml0aXplckltcGwgfSxcbiAgICBdO1xuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgcGxhdGZvcm1Ccm93c2VyID0gX2FuZ3VsYXJfY29yZS5jcmVhdGVQbGF0Zm9ybUZhY3RvcnkoX2FuZ3VsYXJfY29yZS5wbGF0Zm9ybUNvcmUsICdicm93c2VyJywgSU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMpO1xuICAgIGZ1bmN0aW9uIGluaXREb21BZGFwdGVyKCkge1xuICAgICAgICBCcm93c2VyRG9tQWRhcHRlci5tYWtlQ3VycmVudCgpO1xuICAgICAgICBCcm93c2VyR2V0VGVzdGFiaWxpdHkuaW5pdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX2FuZ3VsYXJfY29yZS5FcnJvckhhbmRsZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2RvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gZ2V0RE9NKCkuZGVmYXVsdERvYygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcmVzb2x2ZURlZmF1bHRBbmltYXRpb25Ecml2ZXIoKSB7XG4gICAgICAgIGlmIChnZXRET00oKS5zdXBwb3J0c1dlYkFuaW1hdGlvbigpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkFuaW1hdGlvbnNEcml2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uRHJpdmVyLk5PT1A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBuZyBtb2R1bGUgZm9yIHRoZSBicm93c2VyLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBCcm93c2VyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQnJvd3Nlck1vZHVsZShwYXJlbnRNb2R1bGUpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTW9kdWxlIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkLiBJZiB5b3UgbmVlZCBhY2Nlc3MgdG8gY29tbW9uIGRpcmVjdGl2ZXMgc3VjaCBhcyBOZ0lmIGFuZCBOZ0ZvciBmcm9tIGEgbGF6eSBsb2FkZWQgbW9kdWxlLCBpbXBvcnQgQ29tbW9uTW9kdWxlIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEJyb3dzZXJNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJST1dTRVJfU0FOSVRJWkFUSU9OX1BST1ZJREVSUywgeyBwcm92aWRlOiBfYW5ndWxhcl9jb3JlLkVycm9ySGFuZGxlciwgdXNlRmFjdG9yeTogZXJyb3JIYW5kbGVyLCBkZXBzOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogRE9DVU1FTlQsIHVzZUZhY3Rvcnk6IF9kb2N1bWVudCwgZGVwczogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IERvbUV2ZW50c1BsdWdpbiwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IEtleUV2ZW50c1BsdWdpbiwgbXVsdGk6IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUywgdXNlQ2xhc3M6IEhhbW1lckdlc3R1cmVzUGx1Z2luLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSEFNTUVSX0dFU1RVUkVfQ09ORklHLCB1c2VDbGFzczogSGFtbWVyR2VzdHVyZUNvbmZpZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogRG9tUm9vdFJlbmRlcmVyLCB1c2VDbGFzczogRG9tUm9vdFJlbmRlcmVyXyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfY29yZS5Sb290UmVuZGVyZXIsIHVzZUV4aXN0aW5nOiBEb21Sb290UmVuZGVyZXIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFNoYXJlZFN0eWxlc0hvc3QsIHVzZUV4aXN0aW5nOiBEb21TaGFyZWRTdHlsZXNIb3N0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBBbmltYXRpb25Ecml2ZXIsIHVzZUZhY3Rvcnk6IF9yZXNvbHZlRGVmYXVsdEFuaW1hdGlvbkRyaXZlciB9LCBEb21TaGFyZWRTdHlsZXNIb3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyX2NvcmUuVGVzdGFiaWxpdHksIEV2ZW50TWFuYWdlciwgRUxFTUVOVF9QUk9CRV9QUk9WSURFUlMsIFRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIF9hbmd1bGFyX2NvcmUuQXBwbGljYXRpb25Nb2R1bGVdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQnJvd3Nlck1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQnJvd3Nlck1vZHVsZSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBCcm93c2VyTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogSlMgdmVyc2lvbiBvZiBicm93c2VyIEFQSXMuIFRoaXMgbGlicmFyeSBjYW4gb25seSBydW4gaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgdmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyB8fCB7fTtcblxuICAgIHZhciBDaGFuZ2VEZXRlY3Rpb25QZXJmUmVjb3JkID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hhbmdlRGV0ZWN0aW9uUGVyZlJlY29yZChtc1BlclRpY2ssIG51bVRpY2tzKSB7XG4gICAgICAgICAgICB0aGlzLm1zUGVyVGljayA9IG1zUGVyVGljaztcbiAgICAgICAgICAgIHRoaXMubnVtVGlja3MgPSBudW1UaWNrcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uUGVyZlJlY29yZDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciBhbGwgQW5ndWxhciBkZWJ1ZyB0b29scy4gVGhpcyBvYmplY3QgY29ycmVzcG9uZHMgdG8gdGhlIGBuZ2BcbiAgICAgKiBnbG9iYWwgdmFyaWFibGUgYWNjZXNzaWJsZSBpbiB0aGUgZGV2IGNvbnNvbGUuXG4gICAgICovXG4gICAgdmFyIEFuZ3VsYXJUb29scyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuZ3VsYXJUb29scyhyZWYpIHtcbiAgICAgICAgICAgIHRoaXMucHJvZmlsZXIgPSBuZXcgQW5ndWxhclByb2ZpbGVyKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFuZ3VsYXJUb29scztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciBhbGwgQW5ndWxhciBwcm9maWxpbmctcmVsYXRlZCBkZWJ1ZyB0b29scy4gVGhpcyBvYmplY3RcbiAgICAgKiBjb3JyZXNwb25kcyB0byB0aGUgYG5nLnByb2ZpbGVyYCBpbiB0aGUgZGV2IGNvbnNvbGUuXG4gICAgICovXG4gICAgdmFyIEFuZ3VsYXJQcm9maWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFuZ3VsYXJQcm9maWxlcihyZWYpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwUmVmID0gcmVmLmluamVjdG9yLmdldChfYW5ndWxhcl9jb3JlLkFwcGxpY2F0aW9uUmVmKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlcmNpc2VzIGNoYW5nZSBkZXRlY3Rpb24gaW4gYSBsb29wIGFuZCB0aGVuIHByaW50cyB0aGUgYXZlcmFnZSBhbW91bnQgb2ZcbiAgICAgICAgICogdGltZSBpbiBtaWxsaXNlY29uZHMgaG93IGxvbmcgYSBzaW5nbGUgcm91bmQgb2YgY2hhbmdlIGRldGVjdGlvbiB0YWtlcyBmb3JcbiAgICAgICAgICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIFVJLiBJdCBydW5zIGEgbWluaW11bSBvZiA1IHJvdW5kcyBmb3IgYSBtaW5pbXVtXG4gICAgICAgICAqIG9mIDUwMCBtaWxsaXNlY29uZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9wdGlvbmFsbHksIGEgdXNlciBtYXkgcGFzcyBhIGBjb25maWdgIHBhcmFtZXRlciBjb250YWluaW5nIGEgbWFwIG9mXG4gICAgICAgICAqIG9wdGlvbnMuIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAgICAgICAgICpcbiAgICAgICAgICogYHJlY29yZGAgKGJvb2xlYW4pIC0gY2F1c2VzIHRoZSBwcm9maWxlciB0byByZWNvcmQgYSBDUFUgcHJvZmlsZSB3aGlsZVxuICAgICAgICAgKiBpdCBleGVyY2lzZXMgdGhlIGNoYW5nZSBkZXRlY3Rvci4gRXhhbXBsZTpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIG5nLnByb2ZpbGVyLnRpbWVDaGFuZ2VEZXRlY3Rpb24oe3JlY29yZDogdHJ1ZX0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgQW5ndWxhclByb2ZpbGVyLnByb3RvdHlwZS50aW1lQ2hhbmdlRGV0ZWN0aW9uID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIHJlY29yZCA9IGlzUHJlc2VudChjb25maWcpICYmIGNvbmZpZ1sncmVjb3JkJ107XG4gICAgICAgICAgICB2YXIgcHJvZmlsZU5hbWUgPSAnQ2hhbmdlIERldGVjdGlvbic7XG4gICAgICAgICAgICAvLyBQcm9maWxlciBpcyBub3QgYXZhaWxhYmxlIGluIEFuZHJvaWQgYnJvd3NlcnMsIG5vciBpbiBJRSA5IHdpdGhvdXQgZGV2IHRvb2xzIG9wZW5lZFxuICAgICAgICAgICAgdmFyIGlzUHJvZmlsZXJBdmFpbGFibGUgPSBpc1ByZXNlbnQod2luLmNvbnNvbGUucHJvZmlsZSk7XG4gICAgICAgICAgICBpZiAocmVjb3JkICYmIGlzUHJvZmlsZXJBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICB3aW4uY29uc29sZS5wcm9maWxlKHByb2ZpbGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydCA9IGdldERPTSgpLnBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgICB2YXIgbnVtVGlja3MgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG51bVRpY2tzIDwgNSB8fCAoZ2V0RE9NKCkucGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0KSA8IDUwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwUmVmLnRpY2soKTtcbiAgICAgICAgICAgICAgICBudW1UaWNrcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVuZCA9IGdldERPTSgpLnBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgICBpZiAocmVjb3JkICYmIGlzUHJvZmlsZXJBdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNhc3QgdG8gPGFueT4gYmVjYXVzZSB0eXBlIGNoZWNrZXIgdGhpbmtzIHRoZXJlJ3Mgbm8gYXJndW1lbnRcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSBpbiBmYWN0IHRoZXJlIGlzOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NvbnNvbGUvcHJvZmlsZUVuZFxuICAgICAgICAgICAgICAgIHdpbi5jb25zb2xlLnByb2ZpbGVFbmQocHJvZmlsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1zUGVyVGljayA9IChlbmQgLSBzdGFydCkgLyBudW1UaWNrcztcbiAgICAgICAgICAgIHdpbi5jb25zb2xlLmxvZyhcInJhbiBcIiArIG51bVRpY2tzICsgXCIgY2hhbmdlIGRldGVjdGlvbiBjeWNsZXNcIik7XG4gICAgICAgICAgICB3aW4uY29uc29sZS5sb2coTnVtYmVyV3JhcHBlci50b0ZpeGVkKG1zUGVyVGljaywgMikgKyBcIiBtcyBwZXIgY2hlY2tcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYW5nZURldGVjdGlvblBlcmZSZWNvcmQobXNQZXJUaWNrLCBudW1UaWNrcyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBbmd1bGFyUHJvZmlsZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBjb250ZXh0ID0gZ2xvYmFsJDE7XG4gICAgLyoqXG4gICAgICogRW5hYmxlZCBBbmd1bGFyIDIgZGVidWcgdG9vbHMgdGhhdCBhcmUgYWNjZXNzaWJsZSB2aWEgeW91ciBicm93c2VyJ3NcbiAgICAgKiBkZXZlbG9wZXIgY29uc29sZS5cbiAgICAgKlxuICAgICAqIFVzYWdlOlxuICAgICAqXG4gICAgICogMS4gT3BlbiBkZXZlbG9wZXIgY29uc29sZSAoZS5nLiBpbiBDaHJvbWUgQ3RybCArIFNoaWZ0ICsgailcbiAgICAgKiAxLiBUeXBlIGBuZy5gICh1c3VhbGx5IHRoZSBjb25zb2xlIHdpbGwgc2hvdyBhdXRvLWNvbXBsZXRlIHN1Z2dlc3Rpb24pXG4gICAgICogMS4gVHJ5IHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIHByb2ZpbGVyIGBuZy5wcm9maWxlci50aW1lQ2hhbmdlRGV0ZWN0aW9uKClgXG4gICAgICogICAgdGhlbiBoaXQgRW50ZXIuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFsbCBkZWJ1Z2dpbmcgYXBpcyBhcmUgY3VycmVudGx5IGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmFibGVEZWJ1Z1Rvb2xzKHJlZikge1xuICAgICAgICBjb250ZXh0Lm5nID0gbmV3IEFuZ3VsYXJUb29scyhyZWYpO1xuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBBbmd1bGFyIDIgdG9vbHMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFsbCBkZWJ1Z2dpbmcgYXBpcyBhcmUgY3VycmVudGx5IGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkaXNhYmxlRGVidWdUb29scygpIHtcbiAgICAgICAgZGVsZXRlIGNvbnRleHQubmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlZGljYXRlcyBmb3IgdXNlIHdpdGgge0BsaW5rIERlYnVnRWxlbWVudH0ncyBxdWVyeSBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIEFsbCBkZWJ1Z2dpbmcgYXBpcyBhcmUgY3VycmVudGx5IGV4cGVyaW1lbnRhbC5cbiAgICAgKi9cbiAgICB2YXIgQnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCeSgpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTWF0Y2ggYWxsIGVsZW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIHtAZXhhbXBsZSBwbGF0Zm9ybS1icm93c2VyL2RvbS9kZWJ1Zy90cy9ieS9ieS50cyByZWdpb249J2J5X2FsbCd9XG4gICAgICAgICAqL1xuICAgICAgICBCeS5hbGwgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoZGVidWdFbGVtZW50KSB7IHJldHVybiB0cnVlOyB9OyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWF0Y2ggZWxlbWVudHMgYnkgdGhlIGdpdmVuIENTUyBzZWxlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiB7QGV4YW1wbGUgcGxhdGZvcm0tYnJvd3Nlci9kb20vZGVidWcvdHMvYnkvYnkudHMgcmVnaW9uPSdieV9jc3MnfVxuICAgICAgICAgKi9cbiAgICAgICAgQnkuY3NzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQoZGVidWdFbGVtZW50Lm5hdGl2ZUVsZW1lbnQpID9cbiAgICAgICAgICAgICAgICAgICAgZ2V0RE9NKCkuZWxlbWVudE1hdGNoZXMoZGVidWdFbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hdGNoIGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgZ2l2ZW4gZGlyZWN0aXZlIHByZXNlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICoge0BleGFtcGxlIHBsYXRmb3JtLWJyb3dzZXIvZG9tL2RlYnVnL3RzL2J5L2J5LnRzIHJlZ2lvbj0nYnlfZGlyZWN0aXZlJ31cbiAgICAgICAgICovXG4gICAgICAgIEJ5LmRpcmVjdGl2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlYnVnRWxlbWVudCkgeyByZXR1cm4gZGVidWdFbGVtZW50LnByb3ZpZGVyVG9rZW5zLmluZGV4T2YodHlwZSkgIT09IC0xOyB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQnk7XG4gICAgfSgpKTtcblxuICAgIHZhciBfX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fID0ge1xuICAgICAgICBCcm93c2VyUGxhdGZvcm1Mb2NhdGlvbjogQnJvd3NlclBsYXRmb3JtTG9jYXRpb24sXG4gICAgICAgIERvbUFkYXB0ZXI6IERvbUFkYXB0ZXIsXG4gICAgICAgIEJyb3dzZXJEb21BZGFwdGVyOiBCcm93c2VyRG9tQWRhcHRlcixcbiAgICAgICAgQnJvd3NlckdldFRlc3RhYmlsaXR5OiBCcm93c2VyR2V0VGVzdGFiaWxpdHksXG4gICAgICAgIGdldERPTTogZ2V0RE9NLFxuICAgICAgICBzZXRSb290RG9tQWRhcHRlcjogc2V0Um9vdERvbUFkYXB0ZXIsXG4gICAgICAgIERvbVJvb3RSZW5kZXJlcl86IERvbVJvb3RSZW5kZXJlcl8sXG4gICAgICAgIERvbVJvb3RSZW5kZXJlcjogRG9tUm9vdFJlbmRlcmVyLFxuICAgICAgICBEb21TaGFyZWRTdHlsZXNIb3N0OiBEb21TaGFyZWRTdHlsZXNIb3N0LFxuICAgICAgICBTaGFyZWRTdHlsZXNIb3N0OiBTaGFyZWRTdHlsZXNIb3N0LFxuICAgICAgICBFTEVNRU5UX1BST0JFX1BST1ZJREVSUzogRUxFTUVOVF9QUk9CRV9QUk9WSURFUlMsXG4gICAgICAgIERvbUV2ZW50c1BsdWdpbjogRG9tRXZlbnRzUGx1Z2luLFxuICAgICAgICBLZXlFdmVudHNQbHVnaW46IEtleUV2ZW50c1BsdWdpbixcbiAgICAgICAgSGFtbWVyR2VzdHVyZXNQbHVnaW46IEhhbW1lckdlc3R1cmVzUGx1Z2luLFxuICAgICAgICBpbml0RG9tQWRhcHRlcjogaW5pdERvbUFkYXB0ZXIsXG4gICAgICAgIElOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTOiBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyxcbiAgICAgICAgQlJPV1NFUl9TQU5JVElaQVRJT05fUFJPVklERVJTOiBCUk9XU0VSX1NBTklUSVpBVElPTl9QUk9WSURFUlNcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5Ccm93c2VyTW9kdWxlID0gQnJvd3Nlck1vZHVsZTtcbiAgICBleHBvcnRzLnBsYXRmb3JtQnJvd3NlciA9IHBsYXRmb3JtQnJvd3NlcjtcbiAgICBleHBvcnRzLlRpdGxlID0gVGl0bGU7XG4gICAgZXhwb3J0cy5kaXNhYmxlRGVidWdUb29scyA9IGRpc2FibGVEZWJ1Z1Rvb2xzO1xuICAgIGV4cG9ydHMuZW5hYmxlRGVidWdUb29scyA9IGVuYWJsZURlYnVnVG9vbHM7XG4gICAgZXhwb3J0cy5BbmltYXRpb25Ecml2ZXIgPSBBbmltYXRpb25Ecml2ZXI7XG4gICAgZXhwb3J0cy5CeSA9IEJ5O1xuICAgIGV4cG9ydHMuTmdQcm9iZVRva2VuID0gTmdQcm9iZVRva2VuO1xuICAgIGV4cG9ydHMuRE9DVU1FTlQgPSBET0NVTUVOVDtcbiAgICBleHBvcnRzLkVWRU5UX01BTkFHRVJfUExVR0lOUyA9IEVWRU5UX01BTkFHRVJfUExVR0lOUztcbiAgICBleHBvcnRzLkV2ZW50TWFuYWdlciA9IEV2ZW50TWFuYWdlcjtcbiAgICBleHBvcnRzLkhBTU1FUl9HRVNUVVJFX0NPTkZJRyA9IEhBTU1FUl9HRVNUVVJFX0NPTkZJRztcbiAgICBleHBvcnRzLkhhbW1lckdlc3R1cmVDb25maWcgPSBIYW1tZXJHZXN0dXJlQ29uZmlnO1xuICAgIGV4cG9ydHMuRG9tU2FuaXRpemVyID0gRG9tU2FuaXRpemVyO1xuICAgIGV4cG9ydHMuX19wbGF0Zm9ybV9icm93c2VyX3ByaXZhdGVfXyA9IF9fcGxhdGZvcm1fYnJvd3Nlcl9wcml2YXRlX187XG5cbn0pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9yb290Jyk7XG52YXIgdG9TdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3V0aWwvdG9TdWJzY3JpYmVyJyk7XG52YXIgb2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9zeW1ib2wvb2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFueSBzZXQgb2YgdmFsdWVzIG92ZXIgYW55IGFtb3VudCBvZiB0aW1lLiBUaGlzIHRoZSBtb3N0IGJhc2ljIGJ1aWxkaW5nIGJsb2NrXG4gKiBvZiBSeEpTLlxuICpcbiAqIEBjbGFzcyBPYnNlcnZhYmxlPFQ+XG4gKi9cbnZhciBPYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmUgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgIGNhbGxlZCB3aGVuIHRoZSBPYnNlcnZhYmxlIGlzXG4gICAgICogaW5pdGlhbGx5IHN1YnNjcmliZWQgdG8uIFRoaXMgZnVuY3Rpb24gaXMgZ2l2ZW4gYSBTdWJzY3JpYmVyLCB0byB3aGljaCBuZXcgdmFsdWVzXG4gICAgICogY2FuIGJlIGBuZXh0YGVkLCBvciBhbiBgZXJyb3JgIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHJhaXNlIGFuIGVycm9yLCBvclxuICAgICAqIGBjb21wbGV0ZWAgY2FuIGJlIGNhbGxlZCB0byBub3RpZnkgb2YgYSBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT2JzZXJ2YWJsZSwgd2l0aCB0aGlzIE9ic2VydmFibGUgYXMgdGhlIHNvdXJjZSwgYW5kIHRoZSBwYXNzZWRcbiAgICAgKiBvcGVyYXRvciBkZWZpbmVkIGFzIHRoZSBuZXcgb2JzZXJ2YWJsZSdzIG9wZXJhdG9yLlxuICAgICAqIEBtZXRob2QgbGlmdFxuICAgICAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wZXJhdG9yIHRoZSBvcGVyYXRvciBkZWZpbmluZyB0aGUgb3BlcmF0aW9uIHRvIHRha2Ugb24gdGhlIG9ic2VydmFibGVcbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhIG5ldyBvYnNlcnZhYmxlIHdpdGggdGhlIE9wZXJhdG9yIGFwcGxpZWRcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGhhbmRsZXJzIGZvciBoYW5kbGluZyBlbWl0dGVkIHZhbHVlcywgZXJyb3IgYW5kIGNvbXBsZXRpb25zIGZyb20gdGhlIG9ic2VydmFibGUsIGFuZFxuICAgICAqICBleGVjdXRlcyB0aGUgb2JzZXJ2YWJsZSdzIHN1YnNjcmliZXIgZnVuY3Rpb24sIHdoaWNoIHdpbGwgdGFrZSBhY3Rpb24gdG8gc2V0IHVwIHRoZSB1bmRlcmx5aW5nIGRhdGEgc3RyZWFtXG4gICAgICogQG1ldGhvZCBzdWJzY3JpYmVcbiAgICAgKiBAcGFyYW0ge1BhcnRpYWxPYnNlcnZlcnxGdW5jdGlvbn0gb2JzZXJ2ZXJPck5leHQgKG9wdGlvbmFsKSBlaXRoZXIgYW4gb2JzZXJ2ZXIgZGVmaW5pbmcgYWxsIGZ1bmN0aW9ucyB0byBiZSBjYWxsZWQsXG4gICAgICogIG9yIHRoZSBmaXJzdCBvZiB0aHJlZSBwb3NzaWJsZSBoYW5kbGVycywgd2hpY2ggaXMgdGhlIGhhbmRsZXIgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycm9yIChvcHRpb25hbCkgYSBoYW5kbGVyIGZvciBhIHRlcm1pbmFsIGV2ZW50IHJlc3VsdGluZyBmcm9tIGFuIGVycm9yLiBJZiBubyBlcnJvciBoYW5kbGVyIGlzIHByb3ZpZGVkLFxuICAgICAqICB0aGUgZXJyb3Igd2lsbCBiZSB0aHJvd24gYXMgdW5oYW5kbGVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGxldGUgKG9wdGlvbmFsKSBhIGhhbmRsZXIgZm9yIGEgdGVybWluYWwgZXZlbnQgcmVzdWx0aW5nIGZyb20gc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgICAqIEByZXR1cm4ge0lTdWJzY3JpcHRpb259IGEgc3Vic2NyaXB0aW9uIHJlZmVyZW5jZSB0byB0aGUgcmVnaXN0ZXJlZCBoYW5kbGVyc1xuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IHRoaXMub3BlcmF0b3I7XG4gICAgICAgIHZhciBzaW5rID0gdG9TdWJzY3JpYmVyXzEudG9TdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIG9wZXJhdG9yLmNhbGwoc2luaywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaW5rLmFkZCh0aGlzLl9zdWJzY3JpYmUoc2luaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaW5rLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgICAgIHRocm93IHNpbmsuc3luY0Vycm9yVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbms7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGZvckVhY2hcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0IGEgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHBhcmFtIHtQcm9taXNlQ29uc3RydWN0b3J9IFtQcm9taXNlQ3Rvcl0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBQcm9taXNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9uIG9ic2VydmFibGUgY29tcGxldGlvbiBvclxuICAgICAqICByZWplY3RzIHdpdGggdGhlIGhhbmRsZWQgZXJyb3JcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKG5leHQsIFByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIGlmIChyb290XzEucm9vdC5SeCAmJiByb290XzEucm9vdC5SeC5jb25maWcgJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2NyaXB0aW9uLCB0aGVuIHdlIGNhbiBzdXJtaXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IGhhbmRsaW5nIGlzIGFzeW5jaHJvbm91cy4gQW55IGVycm9ycyB0aHJvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZSByZWplY3RlZCBleHBsaWNpdGx5IGFuZCB1bnN1YnNjcmliZSBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgTk8gc3Vic2NyaXB0aW9uLCB0aGVuIHdlJ3JlIGdldHRpbmcgYSBuZXh0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgc3luY2hyb25vdXNseSBkdXJpbmcgc3Vic2NyaXB0aW9uLiBXZSBjYW4ganVzdCBjYWxsIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBlcnJvcnMsIE9ic2VydmFibGUncyBgc3Vic2NyaWJlYCB3aWxsIGVuc3VyZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5zdWJzY3JpcHRpb24gbG9naWMgaXMgY2FsbGVkLCB0aGVuIHN5bmNocm9ub3VzbHkgcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIHRoYXQsIFByb21pc2Ugd2lsbCB0cmFwIHRoZSBlcnJvciBhbmQgc2VuZCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRoZSByZWplY3Rpb24gcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIGludGVyb3AgcG9pbnQgZGVmaW5lZCBieSB0aGUgZXM3LW9ic2VydmFibGUgc3BlYyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBTeW1ib2wub2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtvYnNlcnZhYmxlXzEuJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBIQUNLOiBTaW5jZSBUeXBlU2NyaXB0IGluaGVyaXRzIHN0YXRpYyBwcm9wZXJ0aWVzIHRvbywgd2UgaGF2ZSB0b1xuICAgIC8vIGZpZ2h0IGFnYWluc3QgVHlwZVNjcmlwdCBoZXJlIHNvIFN1YmplY3QgY2FuIGhhdmUgYSBkaWZmZXJlbnQgc3RhdGljIGNyZWF0ZSBzaWduYXR1cmVcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGQgT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZT8gdGhlIHN1YnNjcmliZXIgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgY29sZCBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVtcHR5ID0ge1xuICAgIGNsb3NlZDogdHJ1ZSxcbiAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmliZXIgPSBTdWJqZWN0U3Vic2NyaWJlcjtcbi8qKlxuICogQGNsYXNzIFN1YmplY3Q8VD5cbiAqL1xudmFyIFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBTdWJqZWN0LnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmliZXIodGhpcyk7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IEFub255bW91c1N1YmplY3QodGhpcywgdGhpcyk7XG4gICAgICAgIHN1YmplY3Qub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29weVtpXS5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IGVycjtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMudGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpcHRpb25fMS5TdWJqZWN0U3Vic2NyaXB0aW9uKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5hc09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0O1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TdWJqZWN0ID0gU3ViamVjdDtcbi8qKlxuICogQGNsYXNzIEFub255bW91c1N1YmplY3Q8VD5cbiAqL1xudmFyIEFub255bW91c1N1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbm9ueW1vdXNTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24ubmV4dCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpKTtcbmV4cG9ydHMuQW5vbnltb3VzU3ViamVjdCA9IEFub255bW91c1N1YmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaXB0aW9uKHN1YmplY3QsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgIGlmICghb2JzZXJ2ZXJzIHx8IG9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgc3ViamVjdC5pc1N0b3BwZWQgfHwgc3ViamVjdC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaWJlckluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5zdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uoc3Vic2NyaWJlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaXB0aW9uID0gU3ViamVjdFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RTdWJzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi9PYnNlcnZlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBPYnNlcnZlcn0gaW50ZXJmYWNlIGFuZCBleHRlbmRzIHRoZVxuICoge0BsaW5rIFN1YnNjcmlwdGlvbn0gY2xhc3MuIFdoaWxlIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGlzIHRoZSBwdWJsaWMgQVBJIGZvclxuICogY29uc3VtaW5nIHRoZSB2YWx1ZXMgb2YgYW4ge0BsaW5rIE9ic2VydmFibGV9LCBhbGwgT2JzZXJ2ZXJzIGdldCBjb252ZXJ0ZWQgdG9cbiAqIGEgU3Vic2NyaWJlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBTdWJzY3JpcHRpb24tbGlrZSBjYXBhYmlsaXRpZXMgc3VjaCBhc1xuICogYHVuc3Vic2NyaWJlYC4gU3Vic2NyaWJlciBpcyBhIGNvbW1vbiB0eXBlIGluIFJ4SlMsIGFuZCBjcnVjaWFsIGZvclxuICogaW1wbGVtZW50aW5nIG9wZXJhdG9ycywgYnV0IGl0IGlzIHJhcmVseSB1c2VkIGFzIGEgcHVibGljIEFQSS5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IFtkZXN0aW5hdGlvbk9yTmV4dF0gQSBwYXJ0aWFsbHlcbiAgICAgKiBkZWZpbmVkIE9ic2VydmVyIG9yIGEgYG5leHRgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JOZXh0IGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uT3JOZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgZmFjdG9yeSBmb3IgYSBTdWJzY3JpYmVyLCBnaXZlbiBhIChwb3RlbnRpYWxseSBwYXJ0aWFsKSBkZWZpbml0aW9uXG4gICAgICogb2YgYW4gT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih4OiA/VCk6IHZvaWR9IFtuZXh0XSBUaGUgYG5leHRgIGNhbGxiYWNrIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpYmVyPFQ+fSBBIFN1YnNjcmliZXIgd3JhcHBpbmcgdGhlIChwYXJ0aWFsbHkgZGVmaW5lZClcbiAgICAgKiBPYnNlcnZlciByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAgICAqL1xuICAgIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHR5cGUgYG5leHRgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhIHZhbHVlLiBUaGUgT2JzZXJ2YWJsZSBtYXkgY2FsbCB0aGlzIG1ldGhvZCAwIG9yIG1vcmVcbiAgICAgKiB0aW1lcy5cbiAgICAgKiBAcGFyYW0ge1R9IFt2YWx1ZV0gVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBlcnJvcmAgZnJvbVxuICAgICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGFuIGF0dGFjaGVkIHtAbGluayBFcnJvcn0uIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0XG4gICAgICogdGhlIE9ic2VydmFibGUgaGFzIGV4cGVyaWVuY2VkIGFuIGVycm9yIGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycl0gVGhlIGBlcnJvcmAgZXhjZXB0aW9uLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgYSB2YWx1ZWxlc3Mgbm90aWZpY2F0aW9uIG9mIHR5cGVcbiAgICAgKiBgY29tcGxldGVgIGZyb20gdGhlIE9ic2VydmFibGUuIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0IHRoZSBPYnNlcnZhYmxlXG4gICAgICogaGFzIGZpbmlzaGVkIHNlbmRpbmcgcHVzaC1iYXNlZCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudCwgb2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgICAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgICAgaWYgKCFfcGFyZW50LnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnQsIHRoaXMuX25leHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnQsIHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9wYXJlbnQuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgX3BhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudC5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50LCB0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICBfcGFyZW50LnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi91dGlsL2lzQXJyYXknKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZSgnLi91dGlsL2lzT2JqZWN0Jyk7XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBkaXNwb3NhYmxlIHJlc291cmNlLCBzdWNoIGFzIHRoZSBleGVjdXRpb24gb2YgYW4gT2JzZXJ2YWJsZS4gQVxuICogU3Vic2NyaXB0aW9uIGhhcyBvbmUgaW1wb3J0YW50IG1ldGhvZCwgYHVuc3Vic2NyaWJlYCwgdGhhdCB0YWtlcyBubyBhcmd1bWVudFxuICogYW5kIGp1c3QgZGlzcG9zZXMgdGhlIHJlc291cmNlIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHN1YnNjcmlwdGlvbnMgbWF5IGJlIGdyb3VwZWQgdG9nZXRoZXIgdGhyb3VnaCB0aGUgYGFkZCgpYFxuICogbWV0aG9kLCB3aGljaCB3aWxsIGF0dGFjaCBhIGNoaWxkIFN1YnNjcmlwdGlvbiB0byB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24uXG4gKiBXaGVuIGEgU3Vic2NyaXB0aW9uIGlzIHVuc3Vic2NyaWJlZCwgYWxsIGl0cyBjaGlsZHJlbiAoYW5kIGl0cyBncmFuZGNoaWxkcmVuKVxuICogd2lsbCBiZSB1bnN1YnNjcmliZWQgYXMgd2VsbC5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaXB0aW9uXG4gKi9cbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW3Vuc3Vic2NyaWJlXSBBIGZ1bmN0aW9uIGRlc2NyaWJpbmcgaG93IHRvXG4gICAgICogcGVyZm9ybSB0aGUgZGlzcG9zYWwgb2YgcmVzb3VyY2VzIHdoZW4gdGhlIGB1bnN1YnNjcmliZWAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgU3Vic2NyaXB0aW9uIGhhcyBhbHJlYWR5IGJlZW4gdW5zdWJzY3JpYmVkLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF91bnN1YnNjcmliZSA9IF9hLl91bnN1YnNjcmliZSwgX3N1YnNjcmlwdGlvbnMgPSBfYS5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgKGVycm9ycyA9IGVycm9ycyB8fCBbXSkucHVzaChlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5XzEuaXNBcnJheShfc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIGxlbiA9IF9zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3RfMS5pc09iamVjdChzdWIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc3ViLnVuc3Vic2NyaWJlKS5jYWxsKHN1Yik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGVyci5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRlYXIgZG93biB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZSB1bnN1YnNjcmliZSgpIG9mIHRoaXNcbiAgICAgKiBTdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGVhciBkb3duIGJlaW5nIGFkZGVkIGlzIGEgc3Vic2NyaXB0aW9uIHRoYXQgaXMgYWxyZWFkeVxuICAgICAqIHVuc3Vic2NyaWJlZCwgaXMgdGhlIHNhbWUgcmVmZXJlbmNlIGBhZGRgIGlzIGJlaW5nIGNhbGxlZCBvbiwgb3IgaXNcbiAgICAgKiBgU3Vic2NyaXB0aW9uLkVNUFRZYCwgaXQgd2lsbCBub3QgYmUgYWRkZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHN1YnNjcmlwdGlvbiBpcyBhbHJlYWR5IGluIGFuIGBjbG9zZWRgIHN0YXRlLCB0aGUgcGFzc2VkXG4gICAgICogdGVhciBkb3duIGxvZ2ljIHdpbGwgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RlYXJkb3duTG9naWN9IHRlYXJkb3duIFRoZSBhZGRpdGlvbmFsIGxvZ2ljIHRvIGV4ZWN1dGUgb25cbiAgICAgKiB0ZWFyZG93bi5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259IFJldHVybnMgdGhlIFN1YnNjcmlwdGlvbiB1c2VkIG9yIGNyZWF0ZWQgdG8gYmVcbiAgICAgKiBhZGRlZCB0byB0aGUgaW5uZXIgc3Vic2NyaXB0aW9ucyBsaXN0LiBUaGlzIFN1YnNjcmlwdGlvbiBjYW4gYmUgdXNlZCB3aXRoXG4gICAgICogYHJlbW92ZSgpYCB0byByZW1vdmUgdGhlIHBhc3NlZCB0ZWFyZG93biBsb2dpYyBmcm9tIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zXG4gICAgICogbGlzdC5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xuICAgICAgICBpZiAoIXRlYXJkb3duIHx8ICh0ZWFyZG93biA9PT0gU3Vic2NyaXB0aW9uLkVNUFRZKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVhcmRvd24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWIgPSB0ZWFyZG93bjtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdGVhcmRvd24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uKHRlYXJkb3duKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHN1Yi5jbG9zZWQgfHwgdHlwZW9mIHN1Yi51bnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5fc3Vic2NyaXB0aW9ucyB8fCAodGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdKSkucHVzaChzdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBTdWJzY3JpcHRpb24gZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBzdWJzY3JpcHRpb25zIHRoYXQgd2lsbFxuICAgICAqIHVuc3Vic2NyaWJlIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUgcHJvY2VzcyBvZiB0aGlzIFN1YnNjcmlwdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uIFRoZSBzdWJzY3JpcHRpb24gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIEhBQ0s6IFRoaXMgbWlnaHQgYmUgcmVkdW5kYW50IGJlY2F1c2Ugb2YgdGhlIGxvZ2ljIGluIGBhZGQoKWBcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PSBudWxsIHx8IChzdWJzY3JpcHRpb24gPT09IHRoaXMpIHx8IChzdWJzY3JpcHRpb24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIGdldFN5bWJvbE9ic2VydmFibGUoY29udGV4dCkge1xuICAgIHZhciAkJG9ic2VydmFibGU7XG4gICAgdmFyIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sLm9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcbiAgICAgICAgICAgIFN5bWJvbC5vYnNlcnZhYmxlID0gJCRvYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAkJG9ic2VydmFibGUgPSAnQEBvYnNlcnZhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuICQkb2JzZXJ2YWJsZTtcbn1cbmV4cG9ydHMuZ2V0U3ltYm9sT2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGU7XG5leHBvcnRzLiQkb2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGUocm9vdF8xLnJvb3QpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBTeW1ib2wgPSByb290XzEucm9vdC5TeW1ib2w7XG5leHBvcnRzLiQkcnhTdWJzY3JpYmVyID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpID9cbiAgICBTeW1ib2wuZm9yKCdyeFN1YnNjcmliZXInKSA6ICdAQHJ4U3Vic2NyaWJlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yeFN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gYWN0aW9uIGlzIGludmFsaWQgYmVjYXVzZSB0aGUgb2JqZWN0IGhhcyBiZWVuXG4gKiB1bnN1YnNjcmliZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgU3ViamVjdH1cbiAqIEBzZWUge0BsaW5rIEJlaGF2aW9yU3ViamVjdH1cbiAqXG4gKiBAY2xhc3MgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JcbiAqL1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBlcnIgPSBfc3VwZXIuY2FsbCh0aGlzLCAnb2JqZWN0IHVuc3Vic2NyaWJlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdPYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBvbmUgb3IgbW9yZSBlcnJvcnMgaGF2ZSBvY2N1cnJlZCBkdXJpbmcgdGhlXG4gKiBgdW5zdWJzY3JpYmVgIG9mIGEge0BsaW5rIFN1YnNjcmlwdGlvbn0uXG4gKi9cbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5zdWJzY3JpcHRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHZhciBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIGVycm9ycyA/XG4gICAgICAgICAgICBlcnJvcnMubGVuZ3RoICsgXCIgZXJyb3JzIG9jY3VycmVkIGR1cmluZyB1bnN1YnNjcmlwdGlvbjpcXG4gIFwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7IHJldHVybiAoKGkgKyAxKSArIFwiKSBcIiArIGVyci50b1N0cmluZygpKTsgfSkuam9pbignXFxuICAnKSA6ICcnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gVW5zdWJzY3JpcHRpb25FcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuVW5zdWJzY3JpcHRpb25FcnJvciA9IFVuc3Vic2NyaXB0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbnN1YnNjcmlwdGlvbkVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gdHlwZW9mIGFueSBzbyB0aGF0IGl0IHdlIGRvbid0IGhhdmUgdG8gY2FzdCB3aGVuIGNvbXBhcmluZyBhIHJlc3VsdCB0byB0aGUgZXJyb3Igb2JqZWN0XG5leHBvcnRzLmVycm9yT2JqZWN0ID0geyBlOiB7fSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JPYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInOyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQXJyYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNGdW5jdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG9iamVjdFR5cGVzID0ge1xuICAgICdib29sZWFuJzogZmFsc2UsXG4gICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcbiAgICAnb2JqZWN0JzogdHJ1ZSxcbiAgICAnbnVtYmVyJzogZmFsc2UsXG4gICAgJ3N0cmluZyc6IGZhbHNlLFxuICAgICd1bmRlZmluZWQnOiBmYWxzZVxufTtcbmV4cG9ydHMucm9vdCA9IChvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZikgfHwgKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyk7XG52YXIgZnJlZUdsb2JhbCA9IG9iamVjdFR5cGVzW3R5cGVvZiBnbG9iYWxdICYmIGdsb2JhbDtcbmlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICBleHBvcnRzLnJvb3QgPSBmcmVlR2xvYmFsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm9vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG5mdW5jdGlvbiB0b1N1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIGlmIChuZXh0T3JPYnNlcnZlcikge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgaW5zdGFuY2VvZiBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5leHRPck9ic2VydmVyICYmICFlcnJvciAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xufVxuZXhwb3J0cy50b1N1YnNjcmliZXIgPSB0b1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1N1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vZXJyb3JPYmplY3QnKTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRyeUNhdGNoVGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cbmV4cG9ydHMudHJ5Q2F0Y2ggPSB0cnlDYXRjaDtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyeUNhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgY29yZV8xID0gcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpO1xyXG52YXIgQXBwQ29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFwcENvbXBvbmVudCgpIHtcclxuICAgICAgICB0aGlzLnRpdGxlID0gJ0NsZWFyV2F0ZXIgUmVsb2FkZWQhISc7XHJcbiAgICB9XHJcbiAgICBBcHBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlXzEuQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxoMT57e3RpdGxlfX08L2gxPicsXHJcbiAgICAgICAgfSlcclxuICAgIF0sIEFwcENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gQXBwQ29tcG9uZW50O1xyXG59KCkpO1xyXG5leHBvcnRzLkFwcENvbXBvbmVudCA9IEFwcENvbXBvbmVudDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBjb3JlXzEgPSByZXF1aXJlKCdAYW5ndWxhci9jb3JlJyk7XHJcbnZhciBwbGF0Zm9ybV9icm93c2VyXzEgPSByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJyk7XHJcbnZhciBhcHBfY29tcG9uZW50XzEgPSByZXF1aXJlKCcuL2FwcC5jb21wb25lbnQnKTtcclxudmFyIEFwcE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcHBNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBBcHBNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBjb3JlXzEuTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbcGxhdGZvcm1fYnJvd3Nlcl8xLkJyb3dzZXJNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFthcHBfY29tcG9uZW50XzEuQXBwQ29tcG9uZW50XSxcclxuICAgICAgICAgICAgYm9vdHN0cmFwOiBbYXBwX2NvbXBvbmVudF8xLkFwcENvbXBvbmVudF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgQXBwTW9kdWxlKTtcclxuICAgIHJldHVybiBBcHBNb2R1bGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQXBwTW9kdWxlID0gQXBwTW9kdWxlO1xyXG4iLCLvu78vLy88cmVmZXJlbmNlIHBhdGg9XCIuLi90eXBpbmdzL2luZGV4LmQudHNcIi8+XHJcblxyXG5pbXBvcnQge2NhbGxXaGVuUmVhZHl9IGZyb20gJy4vbWFpbic7XHJcblxyXG4vLyBGb3IgYW4gaW50cm9kdWN0aW9uIHRvIHRoZSBCbGFuayB0ZW1wbGF0ZSwgc2VlIHRoZSBmb2xsb3dpbmcgZG9jdW1lbnRhdGlvbjpcclxuLy8gaHR0cDovL2dvLm1pY3Jvc29mdC5jb20vZndsaW5rLz9MaW5rSUQ9Mzk3NzA1XHJcbi8vIFRvIGRlYnVnIGNvZGUgb24gcGFnZSBsb2FkIGluIFJpcHBsZSBvciBvbiBBbmRyb2lkIGRldmljZXMvZW11bGF0b3JzOiBsYXVuY2ggeW91ciBhcHAsIHNldCBicmVha3BvaW50cywgXHJcbi8vIGFuZCB0aGVuIHJ1biBcIndpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVwiIGluIHRoZSBKYXZhU2NyaXB0IENvbnNvbGUuXHJcbm1vZHVsZSBDV3YyIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIGV4cG9ydCBtb2R1bGUgQXBwbGljYXRpb24ge1xyXG4gICAgICAgIGV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uRGV2aWNlUmVhZHksIGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9uRGV2aWNlUmVhZHkoKSB7XHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgQ29yZG92YSBwYXVzZSBhbmQgcmVzdW1lIGV2ZW50c1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIG9uUGF1c2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgb25SZXN1bWUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IENvcmRvdmEgaGFzIGJlZW4gbG9hZGVkLiBQZXJmb3JtIGFueSBpbml0aWFsaXphdGlvbiB0aGF0IHJlcXVpcmVzIENvcmRvdmEgaGVyZS5cclxuICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV2aWNlcmVhZHknKTtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmluZ0VsZW1lbnQgPSBwYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5saXN0ZW5pbmcnKTtcclxuICAgICAgICAgICAgdmFyIHJlY2VpdmVkRWxlbWVudCA9IHBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLnJlY2VpdmVkJyk7XHJcbiAgICAgICAgICAgIGxpc3RlbmluZ0VsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5Om5vbmU7Jyk7XHJcbiAgICAgICAgICAgIHJlY2VpdmVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6YmxvY2s7Jyk7XHJcbiAgICAgICAgICAgIGNhbGxXaGVuUmVhZHkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9uUGF1c2UoKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgYXBwbGljYXRpb24gaGFzIGJlZW4gc3VzcGVuZGVkLiBTYXZlIGFwcGxpY2F0aW9uIHN0YXRlIGhlcmUuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBvblJlc3VtZSgpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBhcHBsaWNhdGlvbiBoYXMgYmVlbiByZWFjdGl2YXRlZC4gUmVzdG9yZSBhcHBsaWNhdGlvbiBzdGF0ZSBoZXJlLlxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBBcHBsaWNhdGlvbi5pbml0aWFsaXplKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy9keW5hbWljIGJvb3RzdHJhcHBpbmdcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGggYSBjb21waWxlclxyXG52YXIgcGxhdGZvcm1fYnJvd3Nlcl9keW5hbWljXzEgPSByZXF1aXJlKCdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMnKTtcclxuLy8gVGhlIGFwcCBtb2R1bGVcclxudmFyIGFwcF9tb2R1bGVfMSA9IHJlcXVpcmUoJy4vYXBwLm1vZHVsZScpO1xyXG5mdW5jdGlvbiBjYWxsV2hlblJlYWR5KCkge1xyXG4gICAgLy8gQ29tcGlsZSBhbmQgbGF1bmNoIHRoZSBtb2R1bGVcclxuICAgIHBsYXRmb3JtX2Jyb3dzZXJfZHluYW1pY18xLnBsYXRmb3JtQnJvd3NlckR5bmFtaWMoKS5ib290c3RyYXBNb2R1bGUoYXBwX21vZHVsZV8xLkFwcE1vZHVsZSk7XHJcbn1cclxuZXhwb3J0cy5jYWxsV2hlblJlYWR5ID0gY2FsbFdoZW5SZWFkeTtcclxuLy9zdGF0aWMgYm9vdHN0cmFwcGluZ1xyXG4vLy8vIFRoZSBicm93c2VyIHBsYXRmb3JtIHdpdGhvdXQgYSBjb21waWxlclxyXG4vL2ltcG9ydCB7IHBsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xyXG4vLy8vIFRoZSBhcHAgbW9kdWxlIGZhY3RvcnkgcHJvZHVjZWQgYnkgdGhlIHN0YXRpYyBvZmZsaW5lIGNvbXBpbGVyXHJcbi8vaW1wb3J0IHsgQXBwTW9kdWxlTmdGYWN0b3J5IH0gZnJvbSAnLi9hcHAubW9kdWxlLm5nZmFjdG9yeSc7XHJcbi8vLy8gTGF1bmNoIHdpdGggdGhlIGFwcCBtb2R1bGUgZmFjdG9yeS5cclxuLy9wbGF0Zm9ybUJyb3dzZXIoKS5ib290c3RyYXBNb2R1bGVGYWN0b3J5KEFwcE1vZHVsZU5nRmFjdG9yeSk7XHJcbiJdfQ==
